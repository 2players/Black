{"version":3,"sources":["MathEx.js","Helpers.js","Vector.js","Matrix.js","Rectangle.js","Circle.js","Line.js","Polygon.js","Curve.js","Debug.js","MessageDispatcher.js","Time.js","System.js","Viewport.js","Component.js","GameObject.js","Texture.js","AtlasTexture.js","Asset.js","TextureAsset.js","JSONAsset.js","AtlasTextureAsset.js","AssetManager.js","BlendMode.js","VideoNullDriver.js","CanvasDriver.js","DOMDriver.js","DisplayObject.js","TextInfo.js","Sprite.js","TextField.js","Device.js","Scatter.js","FloatScatter.js","VectorScatter.js","CurveScatter.js","Action.js","Acceleration.js","AlphaOverLife.js","ScaleOverLife.js","RotationOverLife.js","TextureOverLife.js","Initializer.js","Life.js","Mass.js","Scale.js","Velocity.js","Position.js","Rotation.js","RandomTexture.js","EmitterState.js","Particle.js","Emitter.js","Key.js","KeyInfo.js","Input.js","InputComponent.js","FPSComponent.js","MRComponent.js","Ease.js","Interpolation.js","Tween.js","Animation.js","AnimationController.js","Black.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACjHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACxCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACzUA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACxdA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC/cA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC3PA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AClTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACxgBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC9OA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC9BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACveA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AChCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACpFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACxDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AClFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC1zCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AChOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC/HA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACzHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACnDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACzBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AClDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACnKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACzBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACjLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC1MA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC1SA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AChFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACjEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC9GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACpZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACvFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACrBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACrCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACxCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACvDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACnCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC3BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACxBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACxBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACxBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACxBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC1BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC3BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC1BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC7BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC9BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC1BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC1BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACnFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACzdA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACxGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACnBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC7cA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACjBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACpFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACraA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC9HA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACrcA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC/MA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AChIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"black-es6.js","sourcesContent":["/**\n * randomBetween\n *\n * @param {number} a\n * @param {number} b\n *\n * @return {number}\n */\nMath.randomBetween = function (a, b) {\n  return Math.floor(Math.random() * (b - a + 1) + a);\n};\n\n\n/**\n * clamp\n *\n * @param {number} value\n * @param {number} min\n * @param {number} max\n *\n * @return {number}\n */\nMath.clamp = function (value, min, max) {\n  return (value < min) ? min : (value > max) ? max : value;\n};\n\n\n/**\n * lerp\n *\n * @param {number} a\n * @param {number} b\n * @param {number} t\n *\n * @return {number}\n */\nMath.lerp = function (a, b, t) {\n  return a + t * (b - a);\n};\n\n\n/**\n * lerpp\n *\n * @param {number} a\n * @param {number} b\n * @param {number} t\n *\n * @return {number}\n */\nMath.lerpp = function (a, b, t) {\n  return (1 - t) * a + t * b;\n};\n\n/** @const\n *  @type {number}\n */\nMath.PI_Q = Math.PI / 4;\n\n/** @const\n *  @type {number}\n */\nMath.PI2 = Math.PI * 2;\n\n/** @const\n *  @type {number}\n */\nMath.DEG2RAD = 0.01745329251994329576923690768489;\n\n/** @const\n *  @type {number}\n */\nMath.RAD2DEG = 57.295779513082320876798154814105;\n// \n//\n//\n// /**\n//  * fsin - Fast sin\n//  *\n//  * @param {number} x\n//  *\n//  * @return {number}\n//  */\n// Math.fsin = function(x) {\n//   if (x === 0)\n//     return 0;\n//\n//   // modulo to range of -PI..PI\n//   const width = 3.14159265 - -3.14159265;\n//   const offsetValue = x - -3.14159265;\n//   x = (offsetValue - (Math.floor(offsetValue / width) * width)) + -3.14159265;\n//\n//   return x < 0 ? 1.27323954 * x + 0.405284735 * x * x : 1.27323954 * x - 0.405284735 * x * x;\n// }\n//\n//\n// /**\n//  * fcos - Fast cos\n//  *\n//  * @param {number} x\n//  *\n//  * @return {number}\n//  */\n// Math.fcos = function(x) {\n//   x += 1.57079632;\n//\n//   // modulo to range of -PI..PI\n//   const width = 3.14159265 - -3.14159265;\n//   const offsetValue = x - -3.14159265;\n//   x = (offsetValue - (Math.floor(offsetValue / width) * width)) + -3.14159265;\n//\n//   return x < 0 ? 1.27323954 * x + 0.405284735 * x * x : 1.27323954 * x - 0.405284735 * x * x;\n// }\n","// function assert(title, condition) {\n//   if (condition)\n//     console.log('%s %c[  OK  ]', title + ' ' + '.'.repeat(88 - title.length), 'color:green;')\n//   else\n//     console.log('%s %c[FAILED]', title + ' ' + '.'.repeat(88 - title.length), 'color:red;')\n// }\n//\n// function perfTest(testName, fn, ctx, count = 1000) {\n//   let startTime = new Date().getTime();\n//\n//   for (var i = 0; i < count; i++)\n//     fn.apply(ctx);\n//     //fn();\n//\n//   return (new Date().getTime() - startTime);\n// }\n//\n// function perfCompare(testsName, fn1, fn2, ctx, count = 1000) {\n//   let t1 = perfTest(testsName, fn1, ctx, count);\n//   let t2 = perfTest(testsName, fn2, ctx, count);\n//\n//   let c1 = 'color:green;'\n//   let c2 = 'color:red;'\n//\n//   if (t1 > t2) {\n//     c1 = c2;\n//     c2 = 'color:green;'\n//   }\n//\n//   console.log('%s:%c %dms %cvs%c %dms', testsName, c1, t1, 'color:black;', c2, t2);\n// }\n//\n// function assertf(title, func) {\n//   const r = func();\n//\n//   const statuses = ['[  OK  ]', '[FAILED]'];\n//   const colors = ['color:green;', 'color:red;'];\n//\n//   console.log('%s %c%s', title + ' ' + '.'.repeat(88 - title.length), r ? colors[0] : colors[1], r ? statuses[0] : statuses[1]);\n// }\n","\nclass Vector {\n  /**\n   * @param  {number=} x = 0 description\n   * @param  {number=} y = 0 description\n   */\n  constructor(x = 0, y = 0) {\n    /** @type {number} */\n    this.x = x;\n\n    /** @type {number} */\n    this.y = y;\n  }\n\n  /**\n   * set - Description\n   *\n   * @param {number=} [x=0] Description\n   * @param {number=} [y=0] Description\n   *\n   * @return {Vector} Description\n   */\n  set(x = 0, y = 0) {\n    this.x = x;\n    this.y = y;\n\n    return this;\n  }\n\n  /**\n   * add - Description\n   *\n   * @param {Vector} vector Description\n   *\n   * @return {Vector} Description\n   */\n  add(vector) {\n    this.x += vector.x;\n    this.y += vector.y;\n\n    return this;\n  }\n\n  /**\n   * subtract - Description\n   *\n   * @param {Vector} vector Description\n   *\n   * @return {Vector} Description\n   */\n  subtract(vector) {\n    this.x -= vector.x;\n    this.y -= vector.y;\n\n    return this;\n  }\n\n  /**\n   * distance - Description\n   *\n   * @param {Vector} vector Description\n   *\n   * @return {number} Description\n   */\n  distance(vector) {\n    let x = this.x - vector.x;\n    let y = this.y - vector.y;\n\n    return Math.sqrt((x * x) + (y * y));\n  }\n\n  /**\n   * multiply - Description\n   *\n   * @param {Vector} vector Description\n   *\n   * @return {Vector} Description\n   */\n  multiply(vector) {\n    this.x *= vector.x;\n    this.y *= vector.y;\n\n    return this;\n  }\n\n  /**\n   * multiplyScalar - Description\n   *\n   * @param {number} scalar Description\n   *\n   * @return {Vector} Description\n   */\n  multiplyScalar(scalar) {\n    this.x *= scalar;\n    this.y *= scalar;\n\n    return this;\n  }\n\n  /**\n   * dot - Description\n   *\n   * @param {Vector} vector Description\n   *\n   * @return {number} Description\n   */\n  dot(vector) {\n    return this.x * vector.x + this.y * vector.y;\n  }\n\n  /**\n   * length - Description\n   *\n   * @return {number} Description\n   */\n  length() {\n    let x = this.x;\n    let y = this.y;\n\n    return Math.sqrt(x * x + y * y);\n  }\n\n  /**\n   * lengthSqr - Description\n   *\n   * @return {number} Description\n   */\n  lengthSqr() {\n    let x = this.x;\n    let y = this.y;\n\n    return x * x + y * y;\n  }\n\n  normalize() {\n    let sum = this.lengthSqr();\n\n    if (sum > 0) {\n      sum = Math.sqrt(sum);\n      this.x /= sum;\n      this.y /= sum;\n    } else {\n      this.x = 0;\n      this.y = 0;\n    }\n\n    return this;\n  }\n\n  /**\n   * clamp - Description\n   *\n   * @param {number} min Description\n   * @param {number} max Description\n   *\n   * @return {Vector} Description\n   */\n  clamp(min, max) {\n    this.x = Math.clamp(this.x, min, max);\n    this.y = Math.clamp(this.y, min, max);\n\n    return this;\n  }\n\n  /**\n   * lerp - Description\n   *\n   * @param {Vector} vector Description\n   * @param {number} t      Description\n   *\n   * @return {Vector} Description\n   */\n  lerp(vector, t) {\n    this.x = Math.lerp(this.x, vector.x, t);\n    this.y = Math.lerp(this.y, vector.y, t);\n\n    return this;\n  }\n\n  /**\n   * copyTo - Description\n   *\n   * @param {Vector} vector Description\n   *\n   * @return {Vector} Description\n   */\n  copyTo(vector) {\n    vector.x = this.x;\n    vector.y = this.y;\n\n    return vector;\n  }\n\n  /**\n   * copyFrom - Description\n   *\n   * @param {Vector} vector Description\n   *\n   * @return {Vector} Description\n   */\n  copyFrom(vector) {\n    this.x = vector.x;\n    this.y = vector.y;\n\n    return this;\n  }\n\n  /**\n   * clone - Description\n   *\n   * @return {Vector} Description\n   */\n  clone() {\n    return new Vector(this.x, this.y);\n  }\n\n  /**\n   * equals - Description\n   *\n   * @param {Vector} vector Description\n   * @param {number=} epsilon Description\n   *\n   * @return {boolean}\n   */\n  equals(vector, epsilon = Number.EPSILON) {\n    return vector !== null && (Math.abs(vector.x - this.x) < epsilon) && (Math.abs(vector.y - this.y) < epsilon);\n  }\n\n  /**\n   * isEmpty - Description\n   *\n   * @return {boolean} Description\n   */\n  isEmpty() {\n    return this.x === 0 && this.y === 0;\n  }\n\n  /**\n   * setRotationFrom - Rotates this vector around specified point.\n   *\n   * @param {Vector} vector Center vector.\n   * @param {number} rotation Angle in radians.\n   *\n   * @return {Vector} This rotated vector.\n   */\n  setRotationFrom(vector, rotation) {\n    return this\n      .subtract(vector)\n      .setRotation(rotation)\n      .add(vector);\n  }\n\n  /**\n   * setRotation - Rotates this vector around zero vector\n   *\n   * @param {number} rotation Angle in radians\n   *\n   * @return {Vector} This rotated vector.\n   */\n  setRotation(rotation) {\n    let cos = Math.cos(rotation).toFixed(15);\n    let sin = Math.sin(rotation).toFixed(15);\n\n    return this.set(this.x * cos - this.y * sin, this.x * sin + this.y * cos);\n  }\n\n  /**\n   * theta - Calculates angle in radians within this and specified vectors.\n   *\n   * @return {number} Angle in radians.\n   */\n  theta(vector) {\n    return Math.acos(this.dot(vector) / this.length() / vector.length());\n  }\n\n  /**\n   * perp - Rotates this vector to normal.\n   *\n   * @return {Vector} This vector.\n   */\n  perp() {\n    return this.set(this.y, -this.x);\n  }\n\n  /**\n   * fromAngle - Description\n   *\n   * @param {number=} [angle=0] Description\n   *\n   * @return {Vector} Description\n   */\n  static fromAngle(angle = 0) {\n    return new Vector(Math.cos(angle), Math.sin(angle));\n  }\n\n  /**\n   * randomRange\n   *\n   * @param {Vector} vectorMin\n   * @param {Vector} vectorMax\n   * @param {Vector=} outVector\n   *\n   * @return {Vector}\n   */\n  static randomRange(vectorMin, vectorMax, outVector = undefined) {\n    outVector = outVector || new Vector();\n\n    outVector.x = Math.random() * (vectorMax.x - vectorMin.x) + vectorMin.x;\n    outVector.y = Math.random() * (vectorMax.y - vectorMin.y) + vectorMin.y;\n\n    return outVector;\n  }\n\n  /**\n   * toString - Description\n   *\n   * @param {number=} [digits=2] Description\n   *\n   * @return {string} Description\n   */\n  toString(digits = 2) {\n    return `Vector: { x: ${this.x.toFixed(digits)}, y: ${this.y.toFixed(digits)} }`;\n  }\n}\n\n/** @type {Vector}\n * @nocollapse\n */\nVector.__cache = new Vector();\n","\nclass Matrix {\n  /**\n   * @param  {number} a = 1  description\n   * @param  {number} b = 0  description\n   * @param  {number} c = 0  description\n   * @param  {number} d = 1  description\n   * @param  {number} tx = 0 description\n   * @param  {number} ty = 0 description\n   * @return {number}        description\n   */\n  constructor(a = 1, b = 0, c = 0, d = 1, tx = 0, ty = 0) {\n    /** @type {Float32Array} */\n    this._matrix = new Float32Array(6);\n\n    this.set(a, b, c, d, tx, ty);\n  }\n\n  /**\n\n   * @param  {number} a  description\n   * @param  {number} b  description\n   * @param  {number} c  description\n   * @param  {number} d  description\n   * @param  {number} tx description\n   * @param  {number} ty description\n   * @return {Matrix}    description\n   */\n  set(a = 1, b = 0, c = 0, d = 1, tx = 0, ty = 0) {\n    let m = this._matrix;\n\n    m[0] = a;\n    m[1] = b;\n    m[2] = c;\n    m[3] = d;\n    m[4] = tx;\n    m[5] = ty;\n\n    return this;\n  }\n\n  /**\n   * translate - Description\n   *\n   * @param {number} dx Description\n   * @param {number} dy Description\n   *\n   * @return {Matrix} Description\n   */\n  translate(dx, dy) {\n    let a = this._matrix;\n\n    let /** @type {number} */ a0 = a[0]; // a\n    let /** @type {number} */ a1 = a[1]; // b\n    let /** @type {number} */ a2 = a[2]; // c\n    let /** @type {number} */ a3 = a[3]; // d\n    let /** @type {number} */ a4 = a[4]; // tx\n    let /** @type {number} */ a5 = a[5]; // ty\n\n    this._matrix[4] += dx;\n    this._matrix[5] += dy;\n\n    return this;\n  }\n\n  /**\n   * setTranslation - Description\n   *\n   * @param {number} x Description\n   * @param {number} y Description\n   *\n   * @return {Matrix} Description\n   */\n  setTranslation(x, y) {\n    this._matrix[4] = x;\n    this._matrix[5] = y;\n\n    return this;\n  }\n\n  /**\n   * @param  {number} theta     description\n   * @param  {number} scale = 1 description\n   */\n  setRotation(theta, scale = 1) {\n    let m = this._matrix;\n    m[0] = Math.cos(theta) * scale;\n    m[2] = Math.sin(theta) * scale;\n    m[1] = -m[2];\n    m[3] = m[0];\n\n    return this;\n  }\n\n  /**\n   * rotate - angle\n   *\n   * @param  {number} angle description\n   * @return {Matrix}       description\n   */\n  rotate(angle) {\n    let a = this._matrix;\n    let cos = Math.cos(angle);\n    let sin = Math.sin(angle);\n    let a0 = a[0];\n    let a2 = a[2];\n    let a4 = a[4];\n\n    a[0] = a0 * cos - a[1] * sin;\n    a[1] = a0 * sin + a[1] * cos;\n    a[2] = a2 * cos - a[3] * sin;\n    a[3] = a2 * sin + a[3] * cos;\n    a[4] = a4 * cos - a[5] * sin;\n    a[5] = a4 * sin + a[5] * cos;\n\n    return this;\n  }\n\n  /**\n   * scale - Description\n   *\n   * @param {number} sx Description\n   * @param {number} sy Description\n   *\n   * @return {Matrix} Description\n   */\n  scale(sx, sy) {\n    let a = this._matrix;\n    let /** @type {number} */ a0 = a[0]; // a\n    let /** @type {number} */ a1 = a[1]; // b\n    let /** @type {number} */ a2 = a[2]; // c\n    let /** @type {number} */ a3 = a[3]; // d\n    let /** @type {number} */ a4 = a[4]; // tx\n    let /** @type {number} */ a5 = a[5]; // ty\n\n    this._matrix[0] = a0 * sx;\n    this._matrix[1] = a1 * sx;\n    this._matrix[2] = a2 * sy;\n    this._matrix[3] = a3 * sy;\n\n    return this;\n  }\n\n  /**\n   * identity - Description\n   *\n   * @return {Matrix} Description\n   */\n  identity() {\n    return this.set(1, 0, 0, 1, 0, 0);\n  }\n\n  /**\n   * Same as concat in flash\n   * @param  {Matrix} b description\n   * @return {Matrix}   description\n   */\n  prepend(b) {\n    let a = this._matrix;\n    let bv = b._matrix;\n\n    let /** @type {number} */ a0 = a[0]; // a\n    let /** @type {number} */ a1 = a[1]; // b\n    let /** @type {number} */ a2 = a[2]; // c\n    let /** @type {number} */ a3 = a[3]; // d\n    let /** @type {number} */ a4 = a[4]; // tx\n    let /** @type {number} */ a5 = a[5]; // ty\n\n    let /** @type {number} */ b0 = bv[0]; // a\n    let /** @type {number} */ b1 = bv[1]; // b\n    let /** @type {number} */ b2 = bv[2]; // c\n    let /** @type {number} */ b3 = bv[3]; // d\n    let /** @type {number} */ b4 = bv[4]; // tx\n    let /** @type {number} */ b5 = bv[5]; // ty\n\n    let a11 = (a0 * b0 + a1 * b2);\n    a[1] = a0 * b1 + a1 * b3;\n    a[0] = a11;\n\n    let c11 = (a2 * b0 + a3 * b2);\n    a[3] = a2 * b1 + a3 * b3;\n    a[2] = c11;\n\n    let tx11 = (a4 * b0 + a5 * b2 + b4);\n    a[5] = a4 * b1 + a5 * b3 + b5;\n    a[4] = tx11;\n    return this;\n  }\n\n  /**\n   * @param  {Matrix} b description\n   * @return {Matrix}   description\n   */\n  append(b) {\n    let a = this._matrix;\n    let bv = b._matrix;\n\n    let /** @type {number} */ a0 = a[0];\n    let /** @type {number} */ a1 = a[1];\n    let /** @type {number} */ a2 = a[2];\n    let /** @type {number} */ a3 = a[3];\n    let /** @type {number} */ a4 = a[4];\n    let /** @type {number} */ a5 = a[5];\n    let /** @type {number} */ b0 = bv[0];\n    let /** @type {number} */ b1 = bv[1];\n    let /** @type {number} */ b2 = bv[2];\n    let /** @type {number} */ b3 = bv[3];\n    let /** @type {number} */ b4 = bv[4];\n    let /** @type {number} */ b5 = bv[5];\n\n    a[0] = a0 * b0 + a2 * b1;\n    a[1] = a1 * b0 + a3 * b1;\n    a[2] = a0 * b2 + a2 * b3;\n    a[3] = a1 * b2 + a3 * b3;\n    a[4] = a0 * b4 + a2 * b5 + a4;\n    a[5] = a1 * b4 + a3 * b5 + a5;\n    return this;\n  }\n\n  /**\n   * @param  {number} x         description\n   * @param  {number} y         description\n   * @param  {Vector=} outVector description\n   * @return {Vector}           description\n   */\n  transformXY(x, y, outVector) {\n    outVector = outVector || new Vector();\n    let m = this._matrix;\n\n    outVector.x = m[0] * x + m[2] * y + m[4];\n    outVector.y = m[1] * x + m[3] * y + m[5];\n\n    return outVector;\n  }\n\n  /**\n   * @param  {number} x         description\n   * @param  {number} y         description\n   * @param  {Vector=} outVector description\n   * @return {Vector}           description\n   */\n  transformDirectionXY(x, y, outVector) {\n    let m = this._matrix;\n    outVector = outVector || new Vector();\n\n    outVector.x = m[0] * x + m[2] * y;\n    outVector.y = m[1] * x + m[3] * y;\n\n    return outVector;\n  }\n\n  /**\n   * transformVector - transforms vector by current matrix object.\n   *\n   * @param  {Vector} vector    description\n   * @param  {Vector=} outVector description\n   * @return {Vector}           description\n   */\n  transformVector(vector, outVector) {\n    outVector = outVector || new Vector();\n    let m = this._matrix;\n\n    outVector.x = m[0] * vector.x + m[2] * vector.y + m[4];\n    outVector.y = m[1] * vector.x + m[3] * vector.y + m[5];\n\n    return outVector;\n  }\n\n  /**\n   * transformRect - transforms rectangle by current matrix object.\n   *\n   * @param  {Rectangle} rect    description\n   * @param  {Rectangle|null} outRect description\n   * @return {Rectangle}         description\n   */\n  transformRect(rect, outRect) {\n    outRect = outRect || new Rectangle();\n\n    let minX = Number.MAX_VALUE;\n    let maxX = -Number.MAX_VALUE;\n    let minY = Number.MAX_VALUE;\n    let maxY = -Number.MAX_VALUE;\n    let xx = 0;\n    let yy = 0;\n    let tmpVector = new Vector();\n\n    // TODO: fix dirty hack. rewrite to use rect\n    //let points = [rect.x, rect.y, rect.x + rect.width, rect.y + rect.height];\n\n    /** @type {Array<number>} */\n    let points = [rect.x, rect.y, rect.x + rect.width, rect.y, rect.x, rect.y + rect.height, rect.x + rect.width, rect.y + rect.height];\n\n    for (var i = 0; i < points.length; i += 2) {\n      xx = points[i];\n      yy = points[i + 1];\n\n      this.transformXY(xx, yy, tmpVector);\n\n      if (minX > tmpVector.x)\n        minX = tmpVector.x;\n      if (maxX < tmpVector.x)\n        maxX = tmpVector.x;\n      if (minY > tmpVector.y)\n        minY = tmpVector.y;\n      if (maxY < tmpVector.y)\n        maxY = tmpVector.y;\n    }\n\n    outRect.set(minX, minY, maxX - minX, maxY - minY);\n    return outRect;\n  }\n\n  /**\n   * invert - inverts current matrix.\n   *\n   * @return {Matrix}  description\n   */\n  invert() {\n    let a = this._matrix;\n\n    let aa = a[0];\n    let ab = a[1];\n    let ac = a[2];\n    let ad = a[3];\n    let atx = a[4];\n    let aty = a[5];\n\n    let det = aa * ad - ab * ac;\n    if (det === 0) {\n      a[0] = a[1] = a[2] = a[3] = 0;\n      a[4] = -atx;\n      a[5] = -aty;\n      return this;\n    }\n    det = 1.0 / det;\n\n    a[0] = ad * det;\n    a[1] = -ab * det;\n    a[2] = -ac * det;\n    a[3] = aa * det;\n    a[4] = (ac * aty - ad * atx) * det;\n    a[5] = (ab * atx - aa * aty) * det;\n\n    return this;\n  }\n\n  // NOTE: remove or finish\n  __decompose() {\n    let m = this._matrix;\n    let a = m[0];\n    let b = m[1];\n    let c = m[2];\n    let d = m[3];\n    let tx = m[4];\n    let ty = m[5];\n\n    let skewX = -Math.atan2(-c, d);\n    let skewY = Math.atan2(b, a);\n\n    let delta = Math.abs(skewX + skewY);\n\n    let r_rotation = 0\n    let r_skewX = 0;\n    let r_skewY = 0;\n    let r_scaleX = 0;\n    let r_scaleY = 0;\n    let r_x = 0;\n    let r_y = 0;\n\n    if (delta < 0.00001) {\n      r_rotation = skewY;\n\n      if (a < 0 && d >= 0)\n        r_rotation += (r_rotation <= 0) ? Math.PI : -Math.PI;\n    } else {\n      r_skewX = skewX;\n      r_skewY = skewY;\n    }\n\n    r_scaleX = Math.sqrt((a * a) + (b * b));\n    r_scaleY = Math.sqrt((c * c) + (d * d));\n\n    r_x = tx;\n    r_y = ty;\n\n    return [r_x, r_y, r_rotation, r_scaleX, r_scaleY, r_skewX, r_skewY];\n  }\n\n  /**\n   * clone - clones the current matrix and returns new cloned object.\n   *\n   * @return {Matrix}  description\n   */\n  clone() {\n    let m = new Matrix();\n    let v = this._matrix;\n    m.set(v[0], v[1], v[2], v[3], v[4], v[5]);\n    return m;\n  }\n\n  /**\n   * copyTo - copies\n   *\n   * @param  {Matrix} matrix description\n   * @return {Matrix}        description\n   */\n  copyTo(matrix) {\n    let a = this._matrix;\n    let b = matrix._matrix;\n\n    b[0] = a[0];\n    b[1] = a[1];\n    b[2] = a[2];\n    b[3] = a[3];\n    b[4] = a[4];\n    b[5] = a[5];\n\n    return matrix;\n  }\n\n  /**\n   * copyFrom - description\n   *\n   * @param  {Matrix} matrix description\n   * @return {Matrix}        description\n   */\n  copyFrom(matrix) {\n    return matrix.copyTo(this);\n  }\n\n  /**\n   * equals - description\n   *\n   * @param  {Matrix} matrix                   description\n   * @param  {number} epsilon = Number.EPSILON description\n   * @return {boolean}                          description\n   */\n  equals(matrix, epsilon = Number.EPSILON) {\n    let a = this._matrix;\n    let b = matrix._matrix;\n    if (!matrix)\n      return false;\n\n    return (Math.abs(a[0] - b[0]) < epsilon) && (Math.abs(a[1] - b[1]) < epsilon) && (Math.abs(a[2] - b[2]) < epsilon) &&\n      (Math.abs(a[3] - b[3]) < epsilon) && (Math.abs(a[4] - b[4]) < epsilon) && (Math.abs(a[5] - b[5]) < epsilon);\n  }\n\n  /**\n   * get - description\n   *\n   * @return {Float32Array}  description\n   */\n  get value() {\n    return this._matrix;\n  }\n\n  /**\n   * @param  {number=} digits = 2\n   * @return {string}\n   */\n  toString(digits = 2) {\n    return `        | ${this.value[0].toFixed(digits)} | ${this.value[1].toFixed(digits)} | ${this.value[4].toFixed(digits)} |\nMatrix: | ${this.value[2].toFixed(digits)} | ${this.value[3].toFixed(digits)} | ${this.value[5].toFixed(digits)} |\n        | ${(0).toFixed(digits)} | ${(0).toFixed(digits)} | ${(1).toFixed(digits)} |`;\n  }\n}\n\n/**\n * @type {Matrix}\n * @nocollapse\n */\nMatrix.__cache = new Matrix();\n","\nclass Rectangle {\n  /**\n   * @param  {number=} y = 0 description\n   * @param  {number=} x = 0 description\n   * @param  {number=} w = 0 description\n   * @param  {number=} h = 0 description\n   */\n  constructor(x = 0, y = 0, w = 0, h = 0) {\n    /** @type {number} */\n    this.x = x;\n\n    /** @type {number} */\n    this.y = y;\n\n    /** @type {number} */\n    this.width = w;\n\n    /** @type {number} */\n    this.height = h;\n  }\n\n  /**\n   * set - Description\n   *\n   * @param {number} x Description\n   * @param {number} y Description\n   * @param {number} w Description\n   * @param {number} h Description\n   *\n   * @return {Rectangle} Description\n   */\n  set(x, y, w, h) {\n    this.x = x;\n    this.y = y;\n    this.width = w;\n    this.height = h;\n\n    return this;\n  }\n\n  /**\n   * copyFrom - Description\n   *\n   * @param {Rectangle} rect Description\n   *\n   * @return {Rectangle} Description\n   */\n  copyFrom(rect) {\n    this.x = rect.x;\n    this.y = rect.y;\n    this.width = rect.width;\n    this.height = rect.height;\n\n    return this;\n  }\n\n  /**\n   * copyTo - Description\n   *\n   * @param {Rectangle} rect Description\n   *\n   * @return {Rectangle} Description\n   */\n  copyTo(rect) {\n    rect.x = this.x;\n    rect.y = this.y;\n    rect.width = this.width;\n    rect.height = this.height;\n\n    return rect;\n  }\n\n\n  /**\n   * left - Description\n   *\n   * @return {number} Description\n   */\n  get left() {\n    return this.x;\n  }\n\n  /**\n   * left - Description\n   *\n   * @param {number} left Left x position.\n   */\n  set left(left) {\n    this.x = left;\n  }\n\n  /**\n   * right - Description\n   *\n   * @return {number} Description\n   */\n  get right() {\n    return this.x + this.width;\n  }\n\n  /**\n   * right - Description\n   *\n   * @param {number} right Right x position.\n   */\n  set right(right) {\n    this.x = right - this.width;\n  }\n\n  /**\n   * top - Description\n   *\n   * @return {number} Description\n   */\n  get top() {\n    return this.y;\n  }\n\n  /**\n   * top - Description\n   *\n   * @param {number} top Top y position.\n   */\n  set top(top) {\n    this.y = top;\n  }\n\n  /**\n   * bottom - Description\n   *\n   * @return {number} Description\n   */\n  get bottom() {\n    return this.y + this.height;\n  }\n\n  /**\n   * bottom - Description\n   *\n   * @param {number} bottom Bottom y position.\n   */\n  set bottom(bottom) {\n    this.y = bottom - this.height;\n  }\n\n  /**\n   * topLeft - Description\n   *\n   * @return {Vector} Description\n   */\n  get topLeft() {\n    return new Vector(this.x, this.y);\n  }\n\n  /**\n   * topLeft - Description\n   *\n   * @param {Vector} vector Top left position.\n   */\n  set topLeft(vector) {\n    this.left = vector.x;\n    this.top = vector.y;\n  }\n\n  /**\n   * topRight - Description\n   *\n   * @return {Vector} Description\n   */\n  get topRight() {\n    return new Vector(this.right, this.y);\n  }\n\n  /**\n   * topRight - Description\n   *\n   * @param {Vector} vector Top right position.\n   */\n  set topRight(vector) {\n    this.right = vector.x;\n    this.top = vector.y;\n  }\n\n  /**\n   * bottomRight - Description\n   *\n   * @return {Vector} Description\n   */\n  get bottomRight() {\n    return new Vector(this.right, this.bottom);\n  }\n\n  /**\n   * bottomRight - Description\n   *\n   * @param {Vector} vector Right bottom position.\n   */\n  set bottomRight(vector) {\n    this.right = vector.x;\n    this.bottom = vector.y;\n  }\n\n  /**\n   * bottomLeft - Description\n   *\n   * @return {Vector} Description\n   */\n  get bottomLeft() {\n    return new Vector(this.right, this.bottom);\n  }\n\n  /**\n   * bottomLeft - Description\n   *\n   * @param {Vector} vector Left bottom position.\n   */\n  set bottomLeft(vector) {\n    this.left = vector.x;\n    this.bottom = vector.y;\n  }\n\n  /**\n   * size - Description\n   *\n   * @param {Vector=} outVector Description\n   *\n   * @return {Vector} Description\n   */\n  size(outVector = undefined) {\n    outVector = outVector || new Vector();\n    return outVector.set(this.width, this.height);\n  }\n\n  /**\n   * zero - Description\n   *\n   * @return {Rectangle} Description\n   */\n  zero() {\n    return this.set(0, 0, 0, 0);\n  }\n\n\n  /**\n   * equals - Description\n   *\n   * @param {Rectangle} rect Description\n   * @param {number=} epsilon Description\n   *\n   * @return {boolean}\n   */\n  equals(rect, epsilon = Number.EPSILON) {\n    return rect !== null && (Math.abs(this.x - rect.x) < epsilon) && (Math.abs(this.y - rect.y) < epsilon) &&\n           (Math.abs(this.width - rect.width) < epsilon) && (Math.abs(this.height - rect.height) < epsilon);\n  }\n\n\n  /**\n   * containsXY - Description\n   *\n   * @param {number} x Description\n   * @param {number} y Description\n   *\n   * @return {boolean} Description\n   */\n  containsXY(x, y) {\n    return x >= this.x && x <= this.right && y >= this.y && y <= this.bottom;\n  }\n\n\n  /**\n   * contains - Description\n   *\n   * @param {Rectangle} rect Description\n   *\n   * @return {boolean} Description\n   */\n  contains(rect) {\n    return rect.x >= this.x && rect.y >= this.y && rect.right <= this.right && rect.bottom <= this.bottom;\n  }\n\n  /**\n   * intersects - Description\n   *\n   * @param {Rectangle} rect Description\n   *\n   * @return {boolean} Description\n   */\n  intersects(rect) {\n    return rect.right > this.x && rect.bottom > this.y &&\n           rect.x < this.right && rect.y < this.bottom;\n  }\n\n\n  /**\n   * union - Description\n   *\n   * @param {Rectangle} toUnion Description\n   *\n   * @return {Rectangle} Description\n   */\n  union(toUnion) {\n    if (this.width === 0 || this.height === 0)\n      return toUnion.clone();\n    else if (toUnion.width === 0 || toUnion.height === 0)\n      return this.clone();\n\n    let x0 = this.x > toUnion.x ? toUnion.x : this.x;\n    let x1 = this.right < toUnion.right ? toUnion.right : this.right;\n    let y0 = this.y > toUnion.y ? toUnion.y : this.y;\n    let y1 = this.bottom < toUnion.bottom ? toUnion.bottom : this.bottom;\n\n    return new Rectangle(x0, y0, x1 - x0, y1 - y0);\n  }\n\n\n  /**\n   * volume - Description\n   *\n   * @return {number} Description\n   */\n  get volume() {\n    return this.width * this.height;\n  }\n\n\n  /**\n   * expand - Description\n   *\n   * @param {number} x      Description\n   * @param {number} y      Description\n   * @param {number} width  Description\n   * @param {number} height Description\n   *\n   * @return {Rectangle} Description\n   */\n  expand(x, y, width, height) {\n    if (this.volume === 0)\n      return this.set(x, y, width, height);\n\n    let cacheRight = this.right;\n\t\tlet cacheBottom = this.bottom;\n\n    if (this.x > x) {\n      this.x = x;\n      this.width = cacheRight - x;\n    }\n\n    if (this.y > y) {\n      this.y = y;\n      this.height = cacheBottom - y;\n    }\n\n    if (cacheRight < x + width)\n      this.width = x + width - this.x;\n\n\t\tif (cacheBottom < y + height)\n      this.height = y + height - this.y;\n\n    return this;\n  }\n\n\n  /**\n   * inflate - Description\n   *\n   * @param {number=} [x=0] Description\n   * @param {number=} [y=0] Description\n   *\n   * @return {Rectangle} Description\n   */\n  inflate(x = 0, y = 0) {\n    this.x -= x;\n    this.y -= y;\n    this.width += 2 * x;\n    this.height += 2 * y;\n\n    return this;\n  }\n\n\n  /**\n   * clone - Description\n   *\n   * @return {Rectangle} Description\n   */\n  clone() {\n    return new Rectangle(this.x, this.y, this.width, this.height);\n  }\n\n  /**\n   * perimeter - Description\n   *\n   * @return {number} Description\n   */\n  get perimeter() {\n    return 2 * (this.width + this.height);\n  }\n\n\n  /**\n   * center - Description\n   *\n   * @param {Vector=} outVector Description\n   *\n   * @return {Vector} Description\n   */\n  center(outVector = undefined) {\n    outVector = outVector || new Vector();\n    return outVector.set(this.x + this.width * 0.5, this.y + this.height * 0.5);\n  }\n\n  /**\n   * scale - Scales this rectangle.\n   *\n   * @param {number} x Width multiplier.\n   * @param {number} y Height multiplier.\n   *\n   * @return {Rectangle} This rectangle.\n   */\n  scale(x, y) {\n    this.width *= x;\n    this.height *= y;\n\n    return this;\n  }\n\n  /**\n   * isEmpty - Checks rectangle has area.\n   *\n   * @return {boolean} True if has.\n   */\n  isEmpty() {\n    return this.width === 0 && this.height === 0;\n  }\n\n  get lines() { // todo\n    return [\n      new Line(this.topLeft, this.topRight),\n      new Line(this.topRight, this.bottomRight),\n      new Line(this.bottomRight, this.bottomLeft),\n      new Line(this.bottomLeft, this.topLeft)\n    ];\n  }\n\n\n  /**\n   * toString - Description\n   *\n   * @param {number=} [digits=2] Description\n   *\n   * @return {string} Description\n   */\n  toString(digits = 2) {\n    return `Rectangle { x: ${this.x.toFixed(digits)}, y: ${this.y.toFixed(digits)}, width: ${this.width.toFixed(digits)}, height: ${this.height.toFixed(digits)} }`;\n  }\n}\n\n/** @type {Rectangle}\n  * @nocollapse\n  */\nRectangle.__cache = new Rectangle();\n","\nclass Circle {\n  /**\n   * @param  {number=} x = 0 Position x.\n   * @param  {number=} y = 0 Position y.\n   * @param  {number=} r = 1 Radius.\n   */\n  constructor(x = 0, y = 0, r = 1) {\n    /** @type {number} */\n    this.x = x;\n\n    /** @type {number} */\n    this.y = y;\n\n    /** @type {number} */\n    this.r = r;\n  }\n\n  /**\n   * set - Sets new circle properties\n   *\n   * @param {number} x Position x.\n   * @param {number} y Position y.\n   * @param {number} r Radius.\n   *\n   * @return {Circle} This circle.\n   */\n  set(x, y, r) {\n    this.x = x;\n    this.y = y;\n    this.r = r;\n\n    return this;\n  }\n\n  /**\n   * clone - Clones this circle.\n   *\n   * @return {Circle} Created circle.\n   */\n  clone() {\n    return new Circle(this.x, this.y, this.r);\n  }\n\n  /**\n   * copyTo - Copy this properties to another circle.\n   *\n   * @param {Circle} circle Object to copy to.\n   *\n   * @return {Circle} Passed circle.\n   */\n  copyTo(circle) {\n    return circle.set(this.x, this.y, this.r);\n  }\n\n  /**\n   * copyFrom - Copy another circle properties to this.\n   *\n   * @param {Circle} circle Object to copy from.\n   *\n   * @return {Circle} This circle.\n   */\n  copyFrom(circle) {\n    return this.set(circle.x, circle.y, circle.r);\n  }\n\n  /**\n   * equals - Shows whether circles are identical.\n   *\n   * @param {Circle} circle Object to comparison.\n   * @param {number=} epsilon Compare precision.\n   *\n   * @return {boolean} True if circles are identical.\n   */\n  equals(circle, epsilon = Number.EPSILON) {\n    return circle !== null && (Math.abs(this.x - circle.x) < epsilon) && (Math.abs(this.y - circle.y) < epsilon) &&\n      (Math.abs(this.r - circle.r) < epsilon);\n  }\n\n  /**\n   * containsXY - Shows whether point is in circle.\n   *\n   * @param {number} x Point position x.\n   * @param {number} y Point position y.\n   *\n   * @return {boolean} True if circle contains point.\n   */\n  containsXY(x, y) {\n    return this.contains(new Vector(x, y));\n  }\n\n  /**\n   * contains - Shows whether point is in circle.\n   *\n   * @param {Vector} vector Point to check.\n   *\n   * @return {boolean} True if circle contains point.\n   */\n  contains(vector) {\n    return new Vector(this.x, this.y).subtract(vector).length() <= this.r;\n  }\n\n  /**\n   * left - Finds left X position.\n   *\n   * @return {number} Left X position.\n   */\n  get left() {\n    return this.x - this.r;\n  }\n\n  /**\n   * right - Finds right X position.\n   *\n   * @return {number} Right X position.\n   */\n  get right() {\n    return this.x + this.r;\n  }\n\n  /**\n   * top - Finds top Y position.\n   *\n   * @return {number} Top Y position.\n   */\n  get top() {\n    return this.y - this.r;\n  }\n\n  /**\n   * bottom - Finds bottom Y position.\n   *\n   * @return {number} Bottom Y position.\n   */\n  get bottom() {\n    return this.y + this.r;\n  }\n\n  /**\n   * topPoint - Description\n   *\n   * @return {Vector} Description\n   */\n  get topPoint() {\n    return new Vector(this.x, this.top);\n  }\n\n  /**\n   * bottomPoint - Description\n   *\n   * @return {Vector} Description\n   */\n  get bottomPoint() {\n    return new Vector(this.x, this.bottom);\n  }\n\n  /**\n   * zero - Description\n   *\n   * @return {Circle} Description\n   */\n  zero() {\n    return this.set(0, 0, 0);\n  }\n\n  /**\n   * intersects - Shows whether this circle intersects another.\n   *\n   * @param {Circle} circle Circle to check.\n   *\n   * @return {boolean} True if intersects.\n   */\n  intersects(circle) {\n    let d = new Vector(this.x, this.y).distance(new Vector(circle.x, circle.y));\n    return d <= this.r + circle.r && d >= this.r - circle.r;\n  }\n\n  /**\n   * collide - Shows whether this circle collide with another.\n   *\n   * @param {Circle} circle Circle to check.\n   *\n   * @return {boolean} True if collide.\n   */\n  collide(circle) {\n    let d = new Vector(this.x, this.y).distance(new Vector(circle.x, circle.y));\n    return d <= this.r + circle.r;\n  }\n\n  /**\n   * overlap - Shows whether this circle overlap another.\n   *\n   * @param {Circle} circle Circle to check.\n   *\n   * @return {boolean} True if overlap.\n   */\n  overlap(circle) {\n    if (this.r < circle.r) {\n      return false;\n    }\n\n    let d = new Vector(this.x, this.y).distance(new Vector(circle.x, circle.y));\n    return d <= this.r - circle.r;\n  }\n\n  /**\n   * volume - Area of this circle.\n   *\n   * @return {number} area.\n   */\n  get volume() {\n    return Math.PI * this.r * this.r;\n  }\n\n  /**\n   * perimeter - Perimeter of this circle.\n   *\n   * @return {number} perimeter.\n   */\n  get perimeter() {\n    return 2 * Math.PI * this.r;\n  }\n\n  /**\n   * center - Represents center as vector.\n   *\n   * @param {Vector=} outVector Object for result.\n   *\n   * @return {Vector} Center point.\n   */\n  center(outVector = undefined) {\n    outVector = outVector || new Vector();\n    return outVector.set(this.x, this.y);\n  }\n\n  /**\n   * toString - String representation of this circle.\n   *\n   * @param {number=} [digits=2] Number of digits after float point.\n   *\n   * @return {string} Description.\n   */\n  toString(digits = 2) {\n    return `Circle { x: ${this.x.toFixed(digits)}, y: ${this.y.toFixed(digits)}, r: ${this.r.toFixed(digits)} }`;\n  }\n}\n\n/** @type {Circle}\n * @nocollapse\n */\nCircle.__cache = new Circle();\n","\nclass Line {\n  /**\n   * @param  {Vector} start Start point.\n   * @param  {Vector} end End point.\n   */\n  constructor(start, end) {\n    /** @type {Vector} */\n    this.start = start;\n\n    /** @type {Vector} */\n    this.end = end;\n  }\n\n  /**\n   * set - Sets new line properties\n   *\n   * @param  {Vector} start Start point.\n   * @param  {Vector} end End point.\n   *\n   * @return {Line} This circle.\n   */\n  set(start, end) {\n    this.start = start;\n    this.end = end;\n\n    return this;\n  }\n\n  /**\n   * clone - Clones this line.\n   *\n   * @return {Line} Created line.\n   */\n  clone() {\n    return new Line(this.start.clone(), this.end.clone());\n  }\n\n  /**\n   * copyTo - Copy this properties to another line.\n   *\n   * @param {Line} line Object to copy to.\n   *\n   * @return {Line} Passed line.\n   */\n  copyTo(line) {\n    return line.set(this.start.clone(), this.end.clone());\n  }\n\n  /**\n   * copyFrom - Copy another line properties to this.\n   *\n   * @param {Line} line Object to copy from.\n   *\n   * @return {Line} This circle.\n   */\n  copyFrom(line) {\n    return this.set(line.start.clone(), line.end.clone());\n  }\n\n  /**\n   * equals - Shows whether lines are identical.\n   *\n   * @param {Line} line Object to comparison.\n   * @param {number=} epsilon Compare precision.\n   *\n   * @return {boolean} True if lines are identical.\n   */\n  equals(line, epsilon = Number.EPSILON) {\n    return (this.start.equals(line.start, epsilon) && this.end.equals(line.end, epsilon)) ||\n      (this.start.equals(line.end, epsilon) && this.end.equals(line.start, epsilon));\n  }\n\n  /**\n   * left - Finds left X position.\n   *\n   * @return {number} Left X position.\n   */\n  get left() {\n    return Math.min(this.start.x, this.end.x);\n  }\n\n\n  /**\n   * right - Finds right X position.\n   *\n   * @return {number} Right X position.\n   */\n  get right() {\n    return Math.max(this.start.x, this.end.x);\n  }\n\n  /**\n   * top - Finds top Y position.\n   *\n   * @return {number} Top Y position.\n   */\n  get top() {\n    return Math.min(this.start.y, this.end.y);\n  }\n\n  /**\n   * bottom - Finds bottom Y position.\n   *\n   * @return {number} Bottom Y position.\n   */\n  get bottom() {\n    return Math.max(this.start.y, this.end.y);\n  }\n\n  /**\n   * reverse - Replace line start and end points.\n   *\n   * @return {Line} This line.\n   */\n  reverse() {\n    let start = this.start;\n    this.start = this.end;\n    this.end = start;\n\n    return this;\n  }\n\n  /**\n   * normalize - Change line's length to one. Moves end point.\n   *\n   * @return {Line} This line.\n   */\n  normalize() {\n    this.end\n      .subtract(this.start)\n      .normalize()\n      .add(this.start);\n\n    return this;\n  }\n\n  /**\n   * scale - Change line's length to scaled. Moves end point.\n   *\n   * @return {Line} This line.\n   */\n  scale(multyplier) {\n    this.end\n      .subtract(this.start)\n      .multiplyScalar(multyplier)\n      .add(this.start);\n\n    return this;\n  }\n\n  /**\n   * zero - Description\n   *\n   * @return {Line} Description\n   */\n  zero() {\n    return this.set(new Vector(), new Vector());\n  }\n\n  /**\n   * length - Length of this line.\n   *\n   * @return {number} length.\n   */\n  length() {\n    return this.start.distance(this.end);\n  }\n\n  /**\n   * center - Represents center as vector.\n   *\n   * @param {Vector=} outVector Object for result.\n   *\n   * @return {Vector} Center point.\n   */\n  center(outVector = undefined) {\n    outVector = outVector || new Vector();\n    return outVector.set((this.start.x + this.end.x) / 2, (this.start.y + this.end.y) / 2);\n  }\n\n\n  /**\n   * type - Description\n   *\n   * @return {string} Description\n   */\n  get type() {\n    return 'Line';\n  }\n\n  /**\n   * containsXY - Shows whether point is on line.\n   *\n   * @param {number} x Point position x.\n   * @param {number} y Point position y.\n   *\n   * @return {boolean} True if line contains point.\n   */\n  containsXY(x, y) {\n    return this.contains(new Vector(x, y));\n  }\n\n  /**\n   * contains - Shows whether point is on line.\n   *\n   * @param {Vector} vector Point to check.\n   *\n   * @return {boolean} True if line contains point.\n   */\n  contains(vector) {\n    return this.start.distance(vector) + this.end.distance(vector) === this.length();\n  }\n\n  /**\n   * intersects - Shows whether this line intersects another.\n   *\n   * @param {Line} line Line to check.\n   *\n   * @return {boolean} True if intersects.\n   */\n  intersects(line) {\n    let start1 = this.start;\n    let end1 = this.end;\n    let start2 = line.start;\n    let end2 = line.end;\n\n    let denominator = ((end2.y - start2.y) * (end1.x - start1.x)) - ((end2.x - start2.x) * (end1.y - start1.y));\n\n    if (denominator === 0) {\n      return false;\n    }\n\n    let a = start1.y - start2.y;\n    let b = start1.x - start2.x;\n    let numerator1 = ((end2.x - start2.x) * a) - ((end2.y - start2.y) * b);\n    let numerator2 = ((end1.x - start1.x) * a) - ((end1.y - start1.y) * b);\n    a = numerator1 / denominator;\n    b = numerator2 / denominator;\n\n    return a >= 0 && a <= 1 && b > 0 && b < 1;\n  }\n\n  /**\n   * intersects - Shows whether this line intersects circle.\n   *\n   * @param {Circle} circle Circle to check.\n   *\n   * @return {boolean} True if intersects.\n   */\n  intersectsCircle(circle) {\n    let start = this.start;\n    let end = this.end;\n\n    if (circle.contains(start) || circle.contains(end)) {\n      return true;\n    }\n\n    let distance = start.distance(end);\n    let directionX = (end.x - start.x) / distance;\n    let directionY = (end.y - start.y) / distance;\n\n    let t = directionX * (circle.x - start.x) + directionY * (circle.y - start.y);\n\n    let nearest = new Vector((t * directionX) + start.x, (t * directionY) + start.y);\n    let nearestDistance = nearest.distance(new Vector(circle.x, circle.y));\n\n    if (nearestDistance < circle.r) {\n      let dt = Math.sqrt(Math.pow(circle.r, 2) - Math.pow(nearestDistance, 2));\n\n      let x1 = ((t - dt) * directionX + start.x).toFixed(15);\n      let y1 = ((t - dt) * directionY + start.y).toFixed(15);\n      let x2 = ((t + dt) * directionX + start.x).toFixed(15);\n      let y2 = ((t + dt) * directionY + start.y).toFixed(15);\n\n      return this.__isInBoundsXY(x1, y1) || this.__isInBoundsXY(x2, y2);\n    }\n\n    return false;\n  }\n\n  __isInBoundsXY(x, y) {\n    let x1 = this.start.x;\n    let y1 = this.start.y;\n    let x2 = this.end.x;\n    let y2 = this.end.y;\n    \n    return x > Math.min(x1, x2) && x < Math.max(x1, x2) && y > Math.min(y1, y2) && y < Math.max(y1, y2);\n  }\n\n  /**\n   * toString - String representation of this line.\n   *\n   * @param {number=} [digits=2] Number of digits after float point.\n   *\n   * @return {string} Description.\n   */\n  toString(digits = 2) {\n    return `Line { start: ${this.start.toString(digits)}, end: ${this.end.toString(digits)} }`;\n  }\n}\n\n/** @type {Line}\n * @nocollapse\n */\nLine.__cache = new Line(new Vector(), new Vector());\n","\nclass Polygon {\n\n  /**\n   * @param  {Array<Vector>} vertices = [] Array of vertex points;\n   */\n  constructor(vertices = []) {\n\n    /** @type {Array<Vector>} */\n    this.vertices = vertices;\n\n    /** @type {Array<Line>} */\n    this.lines = [];\n\n    /** @type {Rectangle} */\n    this.bounds = new Rectangle();\n\n    /** @type {Vector} */\n    this.center = new Vector();\n\n    this.refresh();\n  }\n\n  /**\n   * set - Sets new vertices.\n   *\n   * @param {Array<Vector>} vertices New points.\n   *\n   * @return {Polygon} This polygon.\n   */\n  set(vertices) {\n    this.vertices = vertices;\n    this.refresh();\n    return this;\n  }\n\n  /**\n   * copyTo - Copy this properties to another polygon.\n   *\n   * @param {Polygon} polygon Object to copy to.\n   *\n   * @return {Polygon} Passed polygon.\n   */\n  copyTo(polygon) {\n    let len = this.vertices.length;\n    let vertices = [];\n\n    for (let i = 0; i < len; i++) {\n      vertices.push(this.vertices[i].clone());\n    }\n\n    return polygon.set(vertices);\n  }\n\n  /**\n   * copyFrom - Copy another polygon properties to this.\n   *\n   * @param {Polygon} polygon Object to copy from.\n   *\n   * @return {Polygon} This polygon.\n   */\n  copyFrom(polygon) {\n    let polygonVertices = polygon.vertices;\n    let len = polygonVertices.length;\n    let vertices = [];\n\n    for (let i = 0; i < len; i++) {\n      vertices.push(polygonVertices[i].clone());\n    }\n\n    return this.set(vertices);\n  }\n\n  /**\n   * clone - Clones this polygon.\n   *\n   * @return {Polygon} Created polygon.\n   */\n  clone() {\n    let thisVertices = this.vertices;\n    let len = thisVertices.length;\n    let vertices = [];\n\n    for (let i = 0; i < len; i++) {\n      vertices.push(thisVertices[i].clone());\n    }\n\n    return new Polygon(vertices);\n  }\n\n  get width() {\n    return this.bounds.width;\n  }\n\n  get height() {\n    return this.bounds.height;\n  }\n\n  /**\n   * containsXY - Shows whether point is in polygon.\n   *\n   * @param {number} x Point position x.\n   * @param {number} y Point position y.\n   *\n   * @return {boolean} True if polygon contains point.\n   */\n  containsXY(x, y) {\n    return this.contains(new Vector(x, y));\n  }\n\n  /**\n   * contains - Shows whether point is in polygon.\n   *\n   * @param {Vector} vector Point to check.\n   *\n   * @return {boolean} True if polygon contains point.\n   */\n  contains(vector) {\n    let center = this.center;\n    let lines = this.lines;\n    let len = lines.length;\n\n    if (center.equals(vector)) {\n      return true;\n    }\n\n    let intersectionLine = new Line(vector, center.clone());\n    let intersects = 0;\n    intersectionLine.scale((this.width + this.height) / intersectionLine.length());\n\n    for (let i = 0; i < len; i++) {\n      intersects += lines[i].intersects(intersectionLine) ? 1 : 0;\n    }\n\n    return intersects % 2 !== 0;\n  }\n\n  /**\n   * perimeter - Perimeter of this polygon.\n   *\n   * @return {number} perimeter.\n   */\n  get perimeter() {\n    let thisLines = this.lines;\n    let len = thisLines.length;\n    let perimeter = 0;\n\n    for (let i = 0; i < len; i++) {\n      perimeter += thisLines[i].length();\n    }\n\n    return perimeter;\n  }\n\n  /**\n   * collide - Checks collides between two polygons.\n   *\n   * @param {Polygon} polygon Object to check.\n   *\n   * @return {boolean} True if polygon collides with another polygon.\n   */\n  collide(polygon) {\n    if (!this.bounds.intersects(polygon.bounds)) {\n      return false;\n    }\n\n    let thisLines = this.lines;\n    let thisLen = thisLines.length;\n    let polygonLines = polygon.lines;\n    let polygonLen = polygonLines.length;\n\n    for (let i = 0; i < thisLen; i++) {\n      for (let j = 0; j < polygonLen; j++) {\n        if (thisLines[i].intersects(polygonLines[j])) {\n          return true;\n        }\n      }\n    }\n\n    return false;\n  }\n\n  /**\n   * collideCircle - Checks collides between this polygon and circle.\n   *\n   * @param {Circle} circle Object to check.\n   *\n   * @return {boolean} True if polygon collides with circle.\n   */\n  collideCircle(circle) {\n    let bounds = this.bounds;\n    let lines = this.lines;\n\n    if (bounds.left > circle.right || bounds.right < circle.left || bounds.top > circle.bottom || bounds.bottom < circle.top) {\n      return false;\n    }\n\n    let len = lines.length;\n    for (let i = 0; i < len; i++) {\n      if (lines[i].intersectsCircle(circle)) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  /**\n   * collideRectangle - Checks collides between this polygon and rectangle.\n   *\n   * @param {Rectangle} rectangle Object to check.\n   *\n   * @return {boolean} True if polygon collides with rectangle.\n   */\n  collideRectangle(rectangle) {\n    if (!this.bounds.intersects(rectangle)) {\n      return false;\n    }\n\n    let thisLines = this.lines;\n    let thisLen = thisLines.length;\n    let rectangleLines = rectangle.lines;\n    let rectangleLen = rectangleLines.length;\n\n    for (let i = 0; i < thisLen; i++) {\n      for (let j = 0; j < rectangleLen; j++) {\n        if (thisLines[i].intersects(rectangleLines[j])) {\n          return true;\n        }\n      }\n    }\n\n    return false;\n  }\n\n  /**\n   * overlap - Checks overlaps between this polygon and another.\n   *\n   * @param {Polygon} polygon Object to check.\n   *\n   * @return {boolean} True if polygon overlaps second.\n   */\n  overlap(polygon) {\n    if (this.bounds.width < polygon.bounds.width || this.bounds.height < polygon.bounds.height) {\n      return false;\n    }\n\n    if (!this.contains(polygon.center)) {\n      return false;\n    }\n\n    let thisLines = this.lines;\n    let thisLen = thisLines.length;\n    let polygonLines = polygon.lines;\n    let polygonLen = polygonLines.length;\n\n    for (let i = 0; i < thisLen; i++) {\n      for (let j = 0; j < polygonLen; j++) {\n        if (thisLines[i].intersects(polygonLines[j])) {\n          return false;\n        }\n      }\n    }\n\n    return true;\n  }\n\n  /**\n   * overlapCircle - Checks overlaps between this polygon and circle.\n   *\n   * @param {Circle} circle Object to check.\n   *\n   * @return {boolean} True if polygon overlaps circle.\n   */\n  overlapCircle(circle) {\n    if (!this.containsXY(circle.x, circle.y)) {\n      return false;\n    }\n\n    let thisLines = this.lines;\n    let len = thisLines.length;\n\n    for (let i = 0; i < len; i++) {\n      if (thisLines[i].intersectsCircle(circle)) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  /**\n   * overlapRectangle - Checks overlaps between this polygon and rectangle.\n   *\n   * @param {Rectangle} rectangle Object to check.\n   *\n   * @return {boolean} True if polygon overlaps rectangle.\n   */\n  overlapRectangle(rectangle) {\n    if (!this.contains(rectangle.center())) {\n      return false;\n    }\n\n    let thisLines = this.lines;\n    let thisLen = thisLines.length;\n    let rectangleLines = rectangle.lines;\n    let rectangleLen = rectangleLines.length;\n\n    for (let i = 0; i < thisLen; i++) {\n      for (let j = 0; j < rectangleLen; j++) {\n        if (thisLines[i].intersects(rectangleLines[j])) {\n          return false;\n        }\n      }\n    }\n\n    return true;\n  }\n\n  /**\n   * refresh - ReCalc center, bounds, and edges of this polygon.\n   *\n   * @return {Polygon} This polygon.\n   */\n  refresh() {\n    let center = this.center;\n    let bounds = this.bounds;\n    let vertices = this.vertices;\n    let lines = this.lines = [];\n    center.set(0, 0);\n\n    // bounds\n    let maxX = -Number.MAX_VALUE;\n    let maxY = -Number.MAX_VALUE;\n    let minX = Number.MAX_VALUE;\n    let minY = Number.MAX_VALUE;\n\n    for (let i = 0; i < vertices.length; i++) {\n      let vector = vertices[i];\n      center.add(vector);\n\n      // bounds\n      let {\n        x,\n        y\n      } = vector;\n      maxX = x > maxX ? x : maxX;\n      maxY = y > maxY ? y : maxY;\n      minX = x < minX ? x : minX;\n      minY = y < minY ? y : minY;\n\n      lines.push(new Line(vector, vertices[i + 1] || vertices[0]));\n    }\n\n    center.multiplyScalar(1 / vertices.length);\n    bounds.set(minX, minY, maxX - minX, maxY - minY);\n\n    return this;\n  }\n\n  /**\n   * refreshCenter - ReCalc center of this polygon.\n   *\n   * @return {Polygon} This polygon.\n   */\n  refreshCenter() {\n    let center = this.center;\n    let vertices = this.vertices;\n    let len = vertices.length;\n    center.set(0, 0);\n\n    for (let i = 0; i < len; i++) {\n      center.add(vertices[i]);\n    }\n\n    center.multiplyScalar(1 / vertices.length);\n\n    return this;\n  }\n\n  /**\n   * refreshBounds - ReCalc bounds of this polygon.\n   *\n   * @return {Polygon} This polygon.\n   */\n  refreshBounds() {\n    let bounds = this.bounds;\n    let vertices = this.vertices;\n    let maxX = -Number.MAX_VALUE;\n    let maxY = -Number.MAX_VALUE;\n    let minX = Number.MAX_VALUE;\n    let minY = Number.MAX_VALUE;\n    let len = vertices.length;\n    let x;\n    let y;\n\n    for (let i = 0; i < len; i++) {\n      x = vertices[i].x;\n      y = vertices[i].y;\n      maxX = x > maxX ? x : maxX;\n      maxY = y > maxY ? y : maxY;\n      minX = x < minX ? x : minX;\n      minY = y < minY ? y : minY;\n    }\n\n    bounds.set(minX, minY, maxX - minX, maxY - minY);\n\n    return this;\n  }\n\n  /**\n   * refreshLines - ReCalc edges of this polygon.\n   *\n   * @return {Polygon} This polygon.\n   */\n  refreshLines() {\n    let vertices = this.vertices;\n    let lines = this.lines = [];\n\n    for (let i = 0; i < vertices.length; i += 2) {\n      lines.push(new Line(vertices[i], vertices[i + 1] || vertices[0]));\n    }\n\n    return this;\n  }\n\n  /**\n   * fromPath - Creates instance of Polygon.\n   *\n   * @param {string} path Numbers x y divided with space.\n   *\n   * @return {Polygon} Created polygon.\n   */\n  static fromPath(path) {\n    let vertices = [];\n    let path2 = path.split(' ');\n\n    for (let i = 0; i < path2.length; i += 2) {\n      vertices.push(new Vector(Number(path2[i]), Number(path2[i + 1])));\n    }\n\n    return new Polygon(vertices);\n  }\n\n  /**\n   * setRotation - Sets rotation. Rotate this polygon around it center.\n   *\n   * @param {number} rotation Angle in radians.\n   *\n   * @return {Polygon} This polygon.\n   */\n  setRotation(rotation) {\n    let center = this.center;\n    let vertices = this.vertices;\n    let cos = Math.cos(rotation).toFixed(15);\n    let sin = Math.sin(rotation).toFixed(15);\n\n    for (let i = 0, len = vertices.length; i < len; i++) {\n      let vector = vertices[i];\n      vector\n        .subtract(center)\n        .set(vector.x * cos - vector.y * sin, vector.x * sin + vector.y * cos)\n        .add(center);\n    }\n\n    return this.refresh();\n  }\n\n  /**\n   * setTranslation - Translates this polygon to specified position.\n   *\n   * @param {Vector} point Translation vector.\n   *\n   * @return {Polygon} This vertices.\n   */\n  setTranslation(point) {\n    let center = this.center;\n    let vertices = this.vertices;\n    let len = vertices.length;\n    point.subtract(center);\n\n    for (let i = 0; i < len; i++) {\n      vertices[i].add(point);\n    }\n\n    return this.refresh();\n  }\n\n  /**\n   * toString - String representation of this polygon.\n   *\n   * @param {number=} [digits=2] Number of digits after float point.\n   *\n   * @return {string} Description.\n   */\n  toString(digits = 2) {\n    let thisLines = this.lines;\n    let thisVertices = this.vertices;\n    let len = thisLines.length;\n    let vertices = '';\n    let lines = '';\n\n    for (let i = 0; i < len; i++) {\n      lines += thisLines[i].toString(digits);\n    }\n\n    len = thisVertices.length;\n    for (let i = 0; i < len; i++) {\n      vertices += thisVertices[i].toString(digits);\n    }\n\n    return `Polygon { vertices: ${vertices}, bounds: ${this.bounds.toString(digits)}, center: ${this.center.toString()}, lines: ${lines} }`;\n  }\n\n}\n\n/** @type {Polygon}\n * @nocollapse\n */\nPolygon.__cache = new Polygon();\n","\nclass Curve {\n  constructor() {\n\n    /** @private @type {Array<number>} */\n    this.mPoints = [];\n\n    /** @private @type {Array<Vector>} */\n    this.mLookup = null;\n\n    /** @private @type {boolean} */\n    this.mBaked = false;\n\n    /** @private @type {number} */\n    this.mStep = 1 / 60;\n\n    /** @private @type {Array<number>} */\n    this.mEachT = [];\n  }\n\n  /**\n   * set - Sets new points coordinates.\n   *\n   * @param  {...number} points Coordinates: startX, startY, cpStartX, cpStartY, cpEndX, cpEndY, endX/start2X, endY/start2Y, cp2StartX, cp2StartX... 8 or 14 or 20...\n   *\n   * @return {Curve} This curve.\n   */\n  set(...points) {\n    this.mPoints = this.__initPoints(points);\n    this.__refreshEachT();\n\n    if (this.mBaked)\n      this.__refreshCache();\n\n    return this;\n  }\n\n\n  /**\n   * baked - Returns true or false depending on baked is enabled or not.\n   *\n   * @return {boolean}\n   */\n  get baked() {\n    return this.mBaked;\n  }\n\n  /**\n   * baked - Enables or disables interpolation from cache (lookup).\n   *\n   * @param  {boolean} label\n   */\n  set baked(label) {\n    this.mBaked = label;\n\n    if (!this.mLookup && this.mPoints) {\n      this.__refreshCache();\n    }\n  }\n\n  /**\n   * __initPoints - Wides points array. Sets first point for next bezier same as last of previous.\n   *\n   * @param  {Array<number>} points Array of points coordinates.\n   *\n   * @return {Array<number>} Points coordinates array.\n   */\n  __initPoints(points) {\n    let res = [];\n\n    for (let i = 6; i < points.length; i += 6) {\n      res = res.concat(points.slice(i - 6, i + 2));\n    }\n\n    return res;\n  }\n\n  /**\n   * __refreshCache - Refresh cache (lookup) for fast interpolations.\n   *\n   * @return {Curve} This curve.\n   */\n  __refreshCache() {\n    let lookup = this.mLookup = [];\n    let getFullLength = this.getFullLength();\n    let points = this.mPoints;\n    let pointsLen = points.length;\n\n    for (let i = 0; i < pointsLen; i += 8) {\n      let length = Curve.getLength(...points.slice(i, i + 8));\n      let step = this.mStep * getFullLength / length;\n\n      for (let t = step; t < 1; t += step)\n        lookup.push(Curve.lerp(t, ...points.slice(i, i + 8)));\n    }\n\n    return this;\n  }\n\n\n  /**\n   * __refreshEachT - Refresh local interpolation kof for each bezier in curve.\n   *\n   * @return {Curve} This curve.\n   */\n  __refreshEachT() {\n    let points = this.mPoints;\n    let eachT = this.mEachT = [];\n    let pointsLen = points.length;\n    let eachLength = [];\n\n    for (let i = 0; i < pointsLen; i += 8)\n      eachLength.push(Curve.getLength(...points.slice(i, i + 8)));\n\n    let length = this.getFullLength();\n    let s = 0;\n    for (let i = 0; i < pointsLen; i += 8) {\n      s += eachLength[i / 8];\n      eachT.push(s / length);\n    }\n\n    return this;\n  }\n\n  /**\n   * lerp - Interpolates single bezier on t position.\n   *\n   * @param  {number} t Interpolation position (0...1).\n   * @param  {number} startX\n   * @param  {number} startY\n   * @param  {number} cpStartX\n   * @param  {number} cpStartY\n   * @param  {number} cpEndX\n   * @param  {number} cpEndY\n   * @param  {number} endX\n   * @param  {number} endY\n   * @param  {Vector=} outVector\n   *\n   * @return {Vector} Position on bezier.\n   */\n  static lerp(t, startX, startY, cpStartX, cpStartY, cpEndX, cpEndY, endX, endY, outVector) {\n    let u = 1 - t;\n    let tt = t * t;\n    let uu = u * u;\n    let uuu = uu * u;\n    let ttt = tt * t;\n\n    let p = outVector || new Vector();\n    p.set(startX, startY);\n    p.x *= uuu;\n    p.y *= uuu;\n\n    // first\n    p.x += 3 * uu * t * cpStartX;\n    p.y += 3 * uu * t * cpStartY;\n\n    // second\n    p.x += 3 * u * tt * cpEndX;\n    p.y += 3 * u * tt * cpEndY;\n\n    // third\n    p.x += ttt * endX;\n    p.y += ttt * endY;\n\n    return p;\n  }\n\n  /**\n   * interpolate - Interpolates across whole curve.\n   *\n   * @param  {number} t Interpolation position (0...1).\n   * @param  {Vector=} outVector\n   *\n   * @return {Vector} Position on curve.\n   */\n  interpolate(t, outVector) {\n    let res = outVector || new Vector();\n    let lookup = this.mLookup;\n\n    if (this.mBaked) {\n      let i = Math.ceil((lookup.length - 1) * t);\n      let p = lookup[i];\n      res.copyFrom(p);\n\n      return res;\n    }\n\n    // not backed\n    let { mEachT, mPoints } = this;\n    let i = 0;\n\n    while (mEachT[i] < t)\n      i++;\n\n    let minT = mEachT[i - 1] || 0;\n    let maxT = mEachT[i];\n    let bezier = mPoints.slice(i * 8, i * 8 + 8);\n\n    return Curve.lerp((t - minT) / (maxT - minT), ...bezier, res);\n  }\n\n  /**\n   * length - Returns single bezier length.\n   *\n   * @param  {...number} points Coordinates: startX, startY, cpStartX, cpStartY, cpEndX, cpEndY, endX, endY\n   *\n   * @return {number} Length.\n   */\n  static getLength(...points) {\n    let p0 = new Vector(points[0], points[1]);\n    let p1 = new Vector(points[2], points[3]);\n    let p2 = new Vector(points[4], points[5]);\n    let p3 = new Vector(points[6], points[7]);\n\n    return (p3.distance(p0) + p0.distance(p1) + p1.distance(p2) + p2.distance(p3)) / 2;\n  }\n\n  /**\n   * getFullLength - Returns this curve length.\n   *\n   * @return {number} Length.\n   */\n  getFullLength() {\n    let points = this.mPoints;\n    let mPointsLen = points.length;\n    let res = 0;\n\n    for (let i = 0; i < mPointsLen; i += 8)\n      res += Curve.getLength(...points.slice(i, i + 8));\n\n    return res;\n  }\n}\n\n/** @type {Curve}\n * @nocollapse\n */\nCurve.__cache = new Curve();\n","\nclass Debug {\n  constructor() {\n    Debug.assert(false, 'Static class.');\n  }\n\n  static assert(value, message) {\n    if (value === true)\n      return;\n\n    message = message == null ? 'Assertation failed.' : message;\n\n    if (Debug.logOnFail)\n      console.error('[ASSERT]', message);\n\n    if (Debug.throwOnFail)\n      throw new Error(message);\n  }\n\n  static info(...message) {\n    console.info(...message);\n  }\n\n  static warn(...message) {\n    console.warn(...message);\n  }\n}\n\nDebug.throwOnFail = false;\nDebug.logOnFail = true;\n","/**\n * MessageDispatcher - Description\n * @unrestricted\n */\n\nclass MessageDispatcher {\n  constructor() {\n    // object of arrays\n\n    /** @type {Object<string, Array>} */\n    this.mListeners = null;\n  }\n\n  /**\n   * on - Listens to message by given name\n   *\n   * @param {string} name           Name of a message to listen\n   * @param {Function} callback       The callback function\n   * @param {Object=} [context=null] The context for callback function\n   *\n   * @return {void}\n   */\n  on(name, callback, context = null) {\n    Debug.assert(name !== null, 'name cannot be null.');\n    Debug.assert(callback !== null, 'callback cannot be null.');\n\n    // TODO: refactor, expore dispatching provider\n    let filterIx = name.indexOf('@') ;\n    if (filterIx !== -1) {\n      // global handler\n\n      let pureName = name.substring(0, filterIx);\n      let pathMask = name.substring(filterIx + 1);\n\n      //console.log(pureName, pathMask);\n\n      if (MessageDispatcher.mGlobalHandlers.hasOwnProperty(pureName) === false)\n        MessageDispatcher.mGlobalHandlers[pureName] = [];\n\n      let dispatchers = (MessageDispatcher.mGlobalHandlers[pureName]);\n      for (let i = 0; i < dispatchers.length; i++)\n        if (dispatchers[i].callback === callback)\n          return;\n\n      dispatchers.push({\n        callback: callback,\n        context: context,\n        pathMask: pathMask\n      });\n\n      return;\n    }\n\n    if (this.mListeners === null)\n      this.mListeners = {};\n\n    if (this.mListeners.hasOwnProperty(name) === false)\n      this.mListeners[name] = [];\n\n    let dispatchers = /** @type {Array<{callback: Function, context}>} */ (this.mListeners[name]);\n\n    for (let i = 0; i < dispatchers.length; i++)\n      if (dispatchers[i].callback === callback)\n        return;\n\n    dispatchers.push({\n      callback: callback,\n      context: context\n    });\n  }\n\n  /**\n   * removeOn - Description\n   *\n   * @param {string} name            Description\n   * @param {Function=} [callback=null] Description\n   *\n   * @return {void} Description\n   */\n  removeOn(name, callback = null) {\n    if (name === null || name.length === 0)\n      throw new Error('Name cannot be null.');\n\n    if (this.mListeners === null)\n      return;\n\n    let dispatchers = /** @type {Array<{callback: Function, context}>} */ (this.mListeners[name]);\n\n    if (dispatchers === undefined)\n      return;\n\n    if (callback === null) {\n      dispatchers.splice(0, dispatchers.length);\n      return;\n    }\n\n    for (let i = dispatchers.length; i--;) {\n      if (dispatchers[i].callback === callback) {\n        dispatchers.splice(i, 1);\n        return;\n      }\n    }\n  }\n\n  /**\n   * post - Sends message with given pattern and params\n   *\n   * @param {string}  name   The name of a message\n   * @param {...*} params A list of params to send\n   *\n   * @return {void}\n   */\n  post(name, ...params) {\n    // TODO: add wildcard support and name mask annotation support\n    Debug.assert(name !== null, 'name cannot be null.');\n    // if (name === null || name.length === 0)\n    //   throw new Error('Name cannot be null.');\n\n    let message = this.__parseMessage(this, name);\n\n    // TODO: o'really 62?\n    let isGameObject = this instanceof GameObject;\n    if (message.mDirection !== 'none' && isGameObject === false)\n      throw new Error('Dispatching not direct messages are not allowed on non Game Objects.');\n\n    if (message.mDirection === 'none') {\n      this.__invoke(this, message, ...params);\n      this.__invokeGlobal(this, message, ...params);\n    } else if (message.mDirection === 'down') {\n      message.mOrigin = ( /** @type {GameObject} */ (this)).root;\n\n      if (message.mSibblings === true) {\n        this.__sendGlobal(this, message, null, ...params);\n        message.mOrigin.__invokeGlobal(this, message, ...params);\n      }\n      else\n        this.__sendBubbles(this, message, false, ...params);\n    } else if (message.mDirection === 'up') {\n      this.__sendBubbles(this, message, true, ...params);\n    } else {\n      throw new Error('Unknown message type.');\n    }\n  }\n\n  /**\n   * __sendBubbles - Description\n   *\n   * @param {*}  sender  Description\n   * @param {string}  message Description\n   * @param {boolean}  toTop   Description\n   * @param {...*} params  Description\n   *\n   * @return {void} Description\n   */\n  __sendBubbles(sender, message, toTop, ...params) {\n    message.mOrigin = toTop === true ? this : ( /** @type {GameObject} */ (this)).root;\n\n    let list = [this];\n\n    let current = /** @type {GameObject} */ (this);\n    while (current.parent !== null) {\n      list.push(current.parent);\n      current = current.parent;\n    }\n\n    if (toTop) {\n      for (let i = 0; i < list.length; i++) {\n        let dispatcher = /** @type {GameObject} */ (list[i]);\n        dispatcher.__invoke(sender, message, ...params);\n      }\n    } else {\n      for (let i = list.length - 1; i >= 0; i--) {\n        let dispatcher = /** @type {GameObject} */ (list[i]);\n        dispatcher.__invoke(sender, message, ...params);\n      }\n    }\n\n    message.sender.__invokeGlobal(message.sender, message, ...params);\n  }\n\n  /**\n   * __sendGlobal - Description\n   *\n   * @param {*}  sender  Description\n   * @param {Message}  message Description\n   * @param {GameObject=}  origin  Description\n   * @param {...*} params  Description\n   *\n   * @return {void} Description\n   */\n  __sendGlobal(sender, message, origin, ...params) {\n    if (origin === null)\n      origin = /** @type {GameObject} */ (message.mOrigin);\n\n    origin.__invoke(sender, message, ...params);\n\n    for (let i = 0; i < origin.numChildren; i++) {\n      let child = origin.getChildAt(i);\n      child.__sendGlobal(sender, message, child, ...params);\n    }\n  }\n\n  /**\n   * @param {*}  sender\n   * @param {Message}  message\n   * @param {...*} params\n   *\n   * @return {void}\n   */\n  __invoke(sender, message, ...params) {\n    if (this.mListeners === null)\n      return;\n\n    let dispatchers = /** @type {Array<{callback: Function, context}>} */ (this.mListeners[message.mName]);\n\n    if (dispatchers === undefined || dispatchers.length === 0)\n      return;\n\n    if (message.mPathMask !== null) {\n      let inPath = this.__checkPath(this.path, message.mPathMask);\n      if (!inPath)\n        return;\n    }\n\n    // no path filter found - just invoke it\n    let clone = dispatchers.slice(0);\n\n    for (let i = 0; i < clone.length; i++) {\n      let dispatcher = /** @type {{callback: Function, context: *}} */ (clone[i]);\n      message.mTarget = this;\n      dispatcher.callback.call(dispatcher.context, message, ...params);\n    }\n  }\n\n  /**\n   * @param {*}  sender\n   * @param {Message}  message\n   * @param {...*} params\n   *\n   * @return {void}\n   */\n  __invokeGlobal(sender, message, ...params) {\n    let dispatchers = MessageDispatcher.mGlobalHandlers[message.mName];\n\n    if (dispatchers === undefined || dispatchers.length === 0)\n      return;\n\n    let clone = dispatchers.slice(0);\n\n    for (let i = 0; i < clone.length; i++) {\n      let dispatcher = /** @type {{callback: Function, context: *}} */ (clone[i]);\n\n      if (!this.__checkPath(sender.path, dispatcher.pathMask))\n        continue;\n\n      message.mTarget = this;\n      dispatcher.callback.call(dispatcher.context, message, ...params);\n    }\n  }\n\n  /**\n   * @param {string} path\n   * @param {string} pattern\n   *\n   * @return {boolean}\n   */\n  __checkPath(path, pathMask) {\n    if (path == null || pathMask == null)\n      return false;\n\n    if (path === pathMask)\n      return true;\n\n    if (pathMask.indexOf('*') === -1)\n      return path === pathMask;\n    else\n      return new RegExp(\"^\" + pathMask.split(\"*\").join(\".*\") + \"$\").test(path);\n  }\n\n  // TODO: parse exception path'ses like: ~tatata@@@omg####imnotidiout###@@~~\n  /**\n   * __parseMessage - Description\n   *\n   * @param {*} sender Description\n   * @param {string} info   Description\n   *\n   * @return {Message} Description\n   */\n  __parseMessage(sender, info) {\n    // TODO: make message pool... this type of objects shall not be\n    // but dont forget to take care about cancel property\n\n    // EXAMPLES:\n    //  this.post('clicked', data); // Sends to all listeners of this\n    //  this.post('~clicked', data); // Sends to all listeners of this and to each parent of this object\n    //  this.post('clicked@mySprite'); // From top to bottom looking for mySprite\n    //  this.post('~clicked@mySprite'); // From this to top over each parent looks for mySprite\n    //  this.post('clicked@mySprite#ColliderComponent'); // message to a component with type of ColliderComponent\n    //  this.post('~clicked@mySprite#ColliderComponent');\n\n    // DIRECTIONS\n    // clicked - none, direct\n    // ~clicked - up, bubbling\n    // clicked@ - down starting from root, with no filter to everyone\n    // clicked@mySpriter - down with 'mySprite' filter\n    // ~clicked@ - inversed bubbling starting from the root, ending at this\n\n    let result = new Message();\n    result.mSender = sender;\n    result.mDirection = 'none';\n    result.mSibblings = true;\n    result.mPathMask = null;\n    result.mComponentMask = null;\n\n    if (info.charAt(0) === '~') {\n      result.mSibblings = false;\n      result.mDirection = 'up';\n    }\n\n    let ixAt = info.indexOf('@');\n    let ixHash = info.indexOf('#');\n\n    if (ixAt === -1 && ixHash === -1) {\n      result.mSibblings = false;\n      result.mName = info.substr(result.mDirection === 'up' ? 1 : 0);\n      return result;\n    }\n\n    result.mDirection = 'down';\n\n    if (ixHash === -1) { // we got no hash but we have a dog\n      result.mName = info.substring(result.mSibblings ? 0 : 1, ixAt);\n\n      if (info.length === ixAt + 1)\n        result.mPathMask = null;\n      else\n        result.mPathMask = info.substring(ixAt + 1);\n\n      return result;\n    } else {\n      if (ixAt !== -1) {\n        result.mPathMask = info.substring(ixAt + 1, ixHash);\n        result.mName = info.substring(result.mSibblings ? 0 : 1, ixAt);\n      } else {\n        result.mName = info.substring(result.mSibblings ? 0 : 1, ixHash);\n      }\n\n      if (info.length === ixHash + 1)\n        result.mComponentMask = null;\n      else\n        result.mComponentMask = info.substring(ixHash + 1);\n\n      return result;\n    }\n  }\n}\n\nMessageDispatcher.mGlobalHandlers = {};\n\n\nclass Message {\n  constructor() {\n    /** @private @type {*} */\n    this.mSender = null;\n\n    /** @private @type {string} */\n    this.mName;\n\n    /** @private @type {string|null} */\n    this.mPathMask = null;\n\n    /** @private @type {string|null} */\n    this.mComponentMask = null;\n\n    /** @private @type {string} */\n    this.mDirection = 'none';\n\n    /** @private @type {boolean} */\n    this.mSibblings = false;\n\n    /** @private @type {Object} */\n    this.mOrigin = null;\n\n    /** @private @type {Object} */\n    this.mTarget = null;\n\n    /** @private @type {boolean} */\n    this.mCanceled = false;\n  }\n\n  /**\n   * sender - Who send the message\n   *\n   * @return {*} Description\n   */\n  get sender() {\n    return this.mSender;\n  }\n\n  /**\n   * name - The name of the message\n   *\n   * @return {string}\n   */\n  get name() {\n    return this.mName;\n  }\n\n  /**\n   * direction - direction in what message was sent. Can be 'none', 'up' and 'down'.\n   *\n   * @return {string}\n   */\n  get direction() {\n    return this.mDirection;\n  }\n\n  /**\n   * sibblings - Indicates if sibblings should be included into dispatching process.\n   *\n   * @return {boolean} Description\n   */\n  get sibblings() {\n    return this.mSibblings;\n  }\n\n  /**\n   * pathMask - The GameObject.name mask string if was used.\n   *\n   * @return {string|null} Description\n   */\n  get pathMask() {\n    return this.mPathMask;\n  }\n\n  /**\n   * componentMask - Component mask string if was used.\n   *\n   * @return {string|null}\n   */\n  get componentMask() {\n    return this.mComponentMask;\n  }\n\n  /**\n   * origin - The original sender of a message.\n   *\n   * @return {*|null}\n   */\n  get origin() {\n    return this.mOrigin;\n  }\n\n  /**\n   * target - The destination object for this message.\n   *\n   * @return {*|null}\n   */\n  get target() {\n    return this.mTarget;\n  }\n\n  /**\n   * cancel - Stops propagation of the message.\n   *\n   * @return {void}\n   */\n  cancel() {\n    this.mCanceled = true;\n  }\n\n  /**\n   * canceled - True/False if\n   *\n   * @return {boolean}\n   */\n  get canceled() {\n    return this.mCanceled;\n  }\n\n  static get PROGRESS() {\n    return 'progress';\n  }\n  static get COMPLETE() {\n    return 'complete';\n  }\n}\n","\nclass Time {\n  constructor() {\n  }\n\n  static get time(){\n    return Time.mTime;\n  }\n\n  static get dt() {\n    return Time.mDeltaTime;\n  }\n\n  static get scale() {\n    return Time.mScale;\n  }\n\n  static set scale(value) {\n    Debug.assert(value >= 0, 'Time.scale must be >= 0.');\n\n    Time.mScale = value;\n  }\n}\n\n/** @type {number} */\nTime.mTime = 0;\n\n/** @type {number} */\nTime.mDeltaTime = 0;\n\n/** @type {number} */\nTime.mScale = 1;\n","\nclass System extends MessageDispatcher {\n  constructor(){\n    super();\n  }\n\n\n  /**\n   * onFixedUpdate - Description\n   *\n   * @param {number} dt Description\n   *\n   * @return {void} Description\n   */\n  onFixedUpdate(dt){\n  }\n\n\n  /**\n   * onUpdate - Description\n   *\n   * @param {number} dt Description\n   *\n   * @return {void} Description\n   */\n  onUpdate(dt, t){\n  }\n\n  /**\n   * onPostUpdate - Description\n   *\n   * @param {number} dt Description\n   *\n   * @return {void} Description\n   */\n  onPostUpdate(dt, t){\n  }\n\n\n  /**\n   * onChildrenAdded - Description\n   *\n   * @param {GameObject} child Description\n   *\n   * @return {void} Description\n   */\n  onChildrenAdded(child){\n  }\n\n\n  /**\n   * onChildrenRemoved - Description\n   *\n   * @param {GameObject} child Description\n   *\n   * @return {void} Description\n   */\n  onChildrenRemoved(child){\n  }\n\n\n  /**\n   * onComponentAdded - Description\n   *\n   * @param {GameObject} child     Description\n   * @param {Component} component Description\n   *\n   * @return {void} Description\n   */\n  onComponentAdded(child, component)\n  {}\n\n\n  /**\n   * onComponentRemoved - Description\n   *\n   * @param {GameObject} child     Description\n   * @param {Component} component Description\n   *\n   * @return {void} Description\n   */\n  onComponentRemoved(child, component)\n  {}\n}\n","\nclass Viewport extends MessageDispatcher {\n  /**\n   * constructor - Description\n   *\n   * @param {HTMLElement} containerElement Description\n   *\n   * @return {void} Description\n   */\n  constructor(containerElement) {\n    super();\n\n    /** @type {HTMLElement} */\n    this.mContainerElement = containerElement;\n\n    this.mContainerElement.style.userSelect = 'none';\n    this.mContainerElement.style.touchAction = 'none';\n    this.mContainerElement.style.overflow = 'hidden';\n    this.mContainerElement.style.cursor = 'auto';\n    this.mContainerElement.style.WebkitTapHighlightColor = 'rgba(0, 0, 0, 0)';\n\n    let size = this.mContainerElement.getBoundingClientRect();\n\n    /** @type {Rectangle} */\n    this.mSize = new Rectangle(size.left, size.top, size.width, size.height);\n\n    window.addEventListener('resize', x=> this.__onResize());\n  }\n\n  __onResize() {\n    let size = this.mContainerElement.getBoundingClientRect();\n    this.mSize = new Rectangle(size.left, size.top, size.width, size.height);\n\n    this.post('resize', this.mSize);\n  }\n\n  /**\n   * size - Description\n   *\n   * @return {Rectangle} Description\n   */\n  get size(){\n    return this.mSize;\n  }\n\n  /**\n   * nativeDOM - Description\n   *\n   * @return {Element} Description\n   */\n  get nativeDOM(){\n    return this.mContainerElement;\n  }\n\n  // TODO: dispose, remove resize event\n}\n","/**\n * Component - Description\n * @unrestricted\n * @extends MessageDispatcher\n */\n\nclass Component extends MessageDispatcher {\n  /**\n   * constructor - description\n   *\n   * @return {void}          description\n   */\n  constructor() {\n    super();\n\n    /** @type {number} */\n    this.mId = ++GameObject.ID;\n\n    /** @type {GameObject|null} */\n    this.gameObject = null;\n\n    /** @type {boolean} */\n    this.mAdded = false;\n  }\n\n  /**\n   * onAdded - description\n   *\n   * @param  {GameObject} gameObject description\n   * @return {void}            description\n   */\n  onAdded(gameObject) {}\n\n  /**\n   * onRemoved - description\n   *\n   * @param  {GameObject} gameObject description\n   * @return {void}            description\n   */\n  onRemoved(gameObject) {}\n\n  /**\n   * onFixedUpdate - description\n   *\n   * @param  {number} dt description\n   * @return {void}    description\n   */\n  onFixedUpdate(dt) {}\n\n  /**\n   * onUpdate - description\n   *\n   * @param  {number} dt description\n   * @return {void}    description\n   */\n  onUpdate(dt) {}\n\n  /**\n   * onUpdate - description\n   *\n   * @param  {number} dt description\n   * @return {void}    description\n   */\n  onPostUpdate(dt) {}\n\n  // TODO: finish\n  dispose() {}\n\n  // TODO: finish\n  removeFromParent() {\n    if (this.gameObject === null)\n      return;\n\n    this.gameObject.removeComponent(this);\n  }\n}\n\n\n/** @type {number}\n * @nocollapse\n */\nComponent.ID = 0;\n","/**\n * GameObject - Base class for all black game objects.\n * @unrestricted\n * @extends MessageDispatcher\n */\n\nclass GameObject extends MessageDispatcher {\n  constructor() {\n    super();\n\n    /** @type {number} */\n    this.mId = ++GameObject.ID;\n\n    /** @type {string|null} */\n    this.mName = null;\n\n    /** @type {Array<Component>} */\n    this.mComponents = [];\n\n    /** @type {Array<GameObject>} */\n    this.mChildren = [];\n\n    /** @type {number} */\n    this.mX = 0;\n\n    /** @type {number} */\n    this.mY = 0;\n\n    /** @type {number} */\n    this.mScaleX = 1;\n\n    /** @type {number} */\n    this.mScaleY = 1;\n\n    /** @type {number} */\n    this.mPivotX = 0;\n\n    /** @type {number} */\n    this.mPivotY = 0;\n\n    /** @type {number} */\n    this.mRotation = 0;\n\n    /** @type {Rectangle} */\n    this.mBounds = null;\n\n    /** @type {Matrix} */\n    this.mLocalTransform = new Matrix();\n\n    /** @type {Matrix} */\n    this.mWorldTransform = new Matrix();\n\n    /** @type {DirtyFlag} */\n    this.mDirty = DirtyFlag.DIRTY;\n\n    /** @type {GameObject} */\n    this.mParent = null;\n\n    /** @type {string|null} */\n    this.mTag = null;\n\n    /** @type {number} */\n    this.mIndex = 0;\n\n    /** @type {boolean} */\n    this.mAdded = false;\n  }\n\n  /**\n   * id - Unique object id.\n   *\n   * @returns {number} Unique object id.\n   */\n  get id() {\n    return this.mId;\n  }\n\n  /**\n   * onAdded - This method called each time object added to stage.\n   *\n   * @return {void}\n   */\n  onAdded() { }\n\n  /**\n   * onRemoved - Called when object is removed from stage.\n   *\n   * @return {void}\n   */\n  onRemoved() {}\n\n\n  /**\n   * add - Sugar method for adding child GameObjects or Components.\n   *\n   * @param {...GameObject|...Component} gameObjectsAndOrComponents A GameObject or Component to add.\n   *\n   * @return {Array<GameObject|Component>} The passed GameObject or Component.\n   */\n  add(...gameObjectsAndOrComponents) {\n    for (let i = 0; i < gameObjectsAndOrComponents.length; i++) {\n      let gooc = gameObjectsAndOrComponents[i];\n\n      if (gooc instanceof GameObject)\n        this.addChild(/* @type {!GameObject} */ (gooc));\n      else\n        this.addComponent(/* @type {!Component} */ (gooc));\n    }\n\n    return gameObjectsAndOrComponents;\n  }\n\n  /**\n   * Adds a child GameObject instance to this GameObject instance. The child is added to the top of all other children in this GameObject instance.\n   *\n   * @param  {GameObject} child The GameObject instance to add as a child of this GameObject instance.\n   * @return {GameObject}\n   */\n  addChild(child) {\n    return this.addChildAt(child, this.mChildren.length);\n  }\n\n  /**\n   * Adds a child GameObject instance to this GameObject instance. The child is added to the top of all other children in this GameObject instance.\n   *\n   * @param  {GameObject} child The GameObject instance to add as a child of this GameObject instance.\n   * @param  {number=} index = 0 The index position to which the child is added.\n   * @return {GameObject} The GameObject instance that you pass in the child parameter.\n   */\n  addChildAt(child, index = 0) {\n    let numChildren = this.mChildren.length;\n\n    if (index < 0 || index > numChildren)\n      throw new Error('Child index is out of bounds.');\n\n    if (child.mParent === this)\n      return this.setChildIndex(child, index);\n\n    // this operation should be atomic. since __setParent can throw exception.\n    this.mChildren.splice(index, 1, child);\n\n    child.removeFromParent();\n    child.__setParent(this);\n\n    if (this.root !== null)\n      Black.instance.onChildrenAdded(child);\n\n    return child;\n  }\n\n  /**\n   * @protected\n   * @param {GameObject} value Description\n   *\n   * @return {boolean} Description\n   */\n  __setParent(value) {\n    let p = value;\n\n    while (p !== null && p !== this)\n      p = p.mParent;\n\n    if (p === this)\n      throw new Error('Object cannot be a child to itself.');\n\n    this.mParent = value;\n    this.setTransformDirty();\n    return true;\n  }\n\n  /**\n   * setChildIndex - Sets the index (layer) of the specified GameObject to the specified index (layer).\n   *\n   * @param {GameObject} child The GameObject instance to change index for.\n   * @param {number} index Desired index.\n   *\n   * @returns {GameObject} The GameObject instance that you pass in the child parameter.\n   */\n  setChildIndex(child, index) {\n    let ix = this.mChildren.indexOf(child);\n\n    if (ix < 0)\n      throw new Error('Child is not a child of this object.');\n\n    if (ix === index)\n      return child;\n\n    this.mChildren.splice(ix, 1);\n    this.mChildren.splice(index, 1, child);\n    this.setTransformDirty();\n\n    return child;\n  }\n\n  /**\n   * removeFromParent - Removes this GameObject instance from its parent.\n   *\n   * @param {boolean} [dispose=false]\n   *\n   * @return {void} Description\n   */\n  removeFromParent(dispose = false) {\n    if (this.mParent)\n      this.mParent.removeChild(this);\n\n    if (dispose)\n      this.dispose();\n\n    this.setTransformDirty();\n  }\n\n  /**\n   * removeChild - Removes specified GameObjects instance.\n   *\n   * @param {GameObject} child GameObject instance to remove.\n   * @param {boolean} [dispose=false]\n   *\n   * @return {GameObject} The GameObject instance that you pass in the child parameter.\n   */\n  removeChild(child, dispose) {\n    let ix = this.mChildren.indexOf(child);\n\n    if (ix < 0)\n      return null;\n\n    return this.removeChildAt(ix);\n  }\n\n\n  /**\n   * getChildByName\n   *\n   * @param {string} name\n   *\n   * @return {GameObject|null}\n   */\n  getChildByName(name) {\n    for (var i = 0; i < this.mChildren.length; i++) {\n      if (this.mChildren[i].name === name)\n        return this.mChildren[i];\n    }\n\n    return null;\n  }\n\n  /**\n   * removeChildAt - Removes GameObjects instance from specified index.\n   *\n   * @param {number} index Description\n   * @param {boolean} [dispose=false]\n   *\n   * @return {GameObject} The removed GameObject instance.\n   */\n  removeChildAt(index, dispose) {\n    if (index < 0 || index > this.numChildren)\n      throw new Error('Child index is out of bounds.');\n\n    let hadRoot = this.root !== null;\n\n    let child = this.mChildren[index];\n    child.__setParent(null);\n\n    this.mChildren.splice(index, 1);\n\n    if (hadRoot)\n      Black.instance.onChildrenRemoved(child);\n\n    if (dispose)\n      child.dispose();\n\n    this.setTransformDirty();\n\n    return child;\n  }\n\n  /**\n   * getChildAt - Returns GameObject at specified index.\n   *\n   * @param {number} index The index of child GameObject.\n   *\n   * @return {GameObject} The GameObject at specified index.\n   */\n  getChildAt(index) {\n    return this.mChildren[index];\n  }\n\n  /**\n   * addComponent - Adds Component instance to the end of the list,\n   *\n   * @param  {Component} instances Component instance or instances.\n   * @return {Component} The Component instance you pass in the instances parameter.\n   */\n  addComponent(component) {\n    let instance = component;\n\n    if (instance.gameObject)\n      throw new Error('Component cannot be added to two game objects at the same time.');\n\n    this.mComponents.push(instance);\n    instance.gameObject = this;\n\n    if (this.root !== null)\n      Black.instance.onComponentAdded(this, instance);\n\n    instance.onAdded(this);\n\n    return instance;\n  }\n\n  /**\n   * removeComponent - Description\n   *\n   * @param {Component} instance Description\n   *\n   * @return {Component|null} Description\n   */\n  removeComponent(instance) {\n    if (!instance)\n      return null;\n\n    let index = this.mComponents.indexOf(instance);\n    if (index > -1)\n      this.mComponents.splice(index, 1);\n\n    // detach game object after or before?\n    instance.gameObject = null;\n    instance.onRemoved(this);\n\n    if (this.root !== null)\n      Black.instance.onComponentRemoved(this, instance);\n\n    return instance;\n  }\n\n  /**\n   * getComponent\n   *\n   * @param {*} typeName\n   *\n   * @return {Component|null}\n   */\n  getComponent(typeName) {\n    for (let i = 0; i < this.mComponents.length; i++) {\n      let c = this.mComponents[i];\n      if (c instanceof typeName)\n        return c;\n    }\n\n    return null;\n  }\n\n\n  /**\n   * numComponenets - Returns number of component's\n   *\n   * @return {number}\n   */\n  get numComponenets() {\n    return this.mComponents.length;\n  }\n\n\n  /**\n   * getComponentAt - Retrives Component at given index.\n   *\n   * @param {number} index\n   *\n   * @return {Component|null}\n   */\n  getComponentAt(index) {\n    if (index >= 0 && index < this.mComponents.length)\n      return this.mComponents[index];\n\n    return null;\n  }\n\n  /**\n   * localTransformation - Description\n   *\n   * @return {Matrix} Description\n   */\n  get localTransformation() {\n    if (this.mDirty & DirtyFlag.LOCAL) {\n      this.mDirty ^= DirtyFlag.LOCAL;\n\n      if (this.mRotation === 0) {\n        let tx = this.mX - this.mPivotX * this.mScaleX;\n        let ty = this.mY - this.mPivotY * this.mScaleY;\n        return this.mLocalTransform.set(this.mScaleX, 0, 0, this.mScaleY, tx, ty);\n      } else {\n        let cos = Math.cos(this.mRotation);\n        let sin = Math.sin(this.mRotation);\n        let a = this.mScaleX * cos;\n        let b = this.mScaleX * sin;\n        let c = this.mScaleY * -sin;\n        let d = this.mScaleY * cos;\n        let tx = this.mX - this.mPivotX * a - this.mPivotY * c;\n        let ty = this.mY - this.mPivotX * b - this.mPivotY * d;\n        return this.mLocalTransform.set(a, b, c, d, tx, ty);\n      }\n    }\n\n    return this.mLocalTransform;\n  }\n\n  /**\n   * worldTransformation - returns cloned Matrix object which represents object orientation in world space.\n   *\n   * @return {Matrix}\n   */\n  get worldTransformation() {\n    if (this.mDirty & DirtyFlag.WORLD) {\n      this.mDirty ^= DirtyFlag.WORLD;\n\n      if (this.mParent)\n        this.mParent.worldTransformation.copyTo(this.mWorldTransform).append(this.localTransformation);\n      else\n        this.localTransformation.copyTo(this.mWorldTransform);\n    }\n\n    return this.mWorldTransform.clone();\n  }\n\n  /**\n   * worldTransformationInversed - Description\n   *\n   * @return {Matrix} Description\n   */\n  get worldTransformationInversed() {\n    // TODO: optimize, cache\n    return this.worldTransformation.clone().invert();\n  }\n\n  /**\n   * __fixedUpdate - Description\n   *\n   * @param {number} dt Description\n   *\n   * @return {void} Description\n   */\n  __fixedUpdate(dt) {\n    this.onFixedUpdate(dt);\n\n    for (let k = 0; k < this.mComponents.length; k++) {\n      let c = this.mComponents[k];\n      c.gameObject = this;\n      c.onFixedUpdate(dt);\n    }\n\n    for (let i = 0; i < this.mChildren.length; i++)\n      this.mChildren[i].__fixedUpdate(dt);\n  }\n\n  /**\n   * __update - Description\n   *\n   * @param {number} dt Description\n   *\n   * @return {void} Description\n   */\n  __update(dt) {\n    this.onUpdate(dt);\n\n    for (let k = 0; k < this.mComponents.length; k++) {\n      let c = this.mComponents[k];\n      c.gameObject = this;\n      c.onUpdate(dt);\n    }\n\n    for (let i = 0; i < this.mChildren.length; i++)\n      this.mChildren[i].__update(dt);\n  }\n\n  /**\n   * __update - Description\n   *\n   * @param {number} dt Description\n   *\n   * @return {void} Description\n   */\n  __postUpdate(dt) {\n    this.onPostUpdate(dt);\n\n    for (let k = 0; k < this.mComponents.length; k++) {\n      let c = this.mComponents[k];\n      c.gameObject = this;\n      c.onPostUpdate(dt);\n    }\n\n    for (let i = 0; i < this.mChildren.length; i++) {\n      this.mChildren[i].__postUpdate(dt);\n    }\n  }\n\n  /**\n   * onFixedUpdate - Description\n   *\n   * @param {number} dt Description\n   *\n   * @return {void} Description\n   */\n  onFixedUpdate(dt) {}\n\n  /**\n   * onUpdate - Description\n   *\n   * @param {number} dt Description\n   *\n   * @return {void} Description\n   */\n  onUpdate(dt) {}\n\n  /**\n   * onUpdate - Description\n   *\n   * @param {number} dt Description\n   *\n   * @return {void} Description\n   */\n  onPostUpdate(dt) {}\n\n  /**\n   * __render - Description\n   *\n   * @param {VideoNullDriver} video           Description\n   * @param {number} time            Description\n   * @param {number} parentAlpha     Description\n   * @param {string} parentBlendMode Description\n   *\n   * @return {void} Description\n   */\n  __render(video, time, parentAlpha, parentBlendMode) {\n    this.onRender(video, time);\n\n    let child = null;\n    for (let i = 0; i < this.mChildren.length; i++) {\n      child = this.mChildren[i];\n      child.__render(video, time, parentAlpha, parentBlendMode);\n    }\n  }\n\n  /**\n   * onRender - Description\n   *\n   * @param {VideoNullDriver} video Description\n   * @param {number} time  Description\n   *\n   * @return {void} Description\n   */\n  onRender(video, time) {}\n\n  /**\n   * onGetLocalBounds - Override this method if you need to specify GameObject size. Should be always be a local coordinates.\n   *\n   * @protected\n   * @param {Rectangle=} outRect Description\n   *\n   * @return {Rectangle} bounds in local space withoout taking care about transformation matrix\n   */\n  onGetLocalBounds(outRect = undefined) {\n    outRect = outRect || new Rectangle();\n    return outRect.set(0, 0, 0, 0);\n  }\n\n  /**\n   * getBounds - Returns world bounds of this object and all children if specified (true by default).\n   * object.getBounds() - relative to world.\n   * object.getBounds(object) - local bounds.\n   * object.getBounds(object.parent) - relative to parent.\n   * object.getBounds(objectB) - relative to objectB space.\n   *\n   * @param {GameObject} [space=undefined]\n   * @param {boolean} [includeChildren=true]\n   * @param {Rectangle=} [outRect=null]\n   *\n   * @return {Rectangle} returns bounds of the object and all childrens\n   */\n  getBounds(space = undefined, includeChildren = true, outRect = undefined) {\n    outRect = outRect || new Rectangle();\n\n    let matrix = this.worldTransformation;\n\n    // TODO: optimize, check if space == null, space == this, space == parent\n    // TODO: use wtInversed instead\n    if (space != null) {\n      matrix = this.worldTransformation.clone();\n      matrix.prepend(space.worldTransformation.clone().invert());\n    }\n\n    let bounds = new Rectangle();\n    this.onGetLocalBounds(bounds);\n\n    matrix.transformRect(bounds, bounds);\n    outRect.expand(bounds.x, bounds.y, bounds.width, bounds.height);\n\n    if (includeChildren)\n      for (let i = 0; i < this.numChildren; i++)\n        this.getChildAt(i).getBounds(space, includeChildren, outRect);\n\n    return outRect;\n  }\n\n  /**\n   * setTransform -\n   *\n   * @param {number} [x=0]      x-cord\n   * @param {number} [y=0]      y-cord\n   * @param {number} [r=0]      rotation\n   * @param {number} [scaleX=1] scale-x\n   * @param {number} [scaleY=1] scale-y\n   * @param {number} [anchorX=0] anchor-x\n   * @param {number} [anchorY=0] anchor-y\n   * @param {number} [includeChildren=true] include children when adjusting pivot?\n   *\n   * @return {GameObject}\n   */\n  setTransform(x = 0, y = 0, r = 0, scaleX = 1, scaleY = 1, anchorX = 0, anchorY = 0, includeChildren = true) {\n    this.mX = x;\n    this.mY = y;\n    this.mRotation = r;\n    this.mScaleX = scaleX;\n    this.mScaleY = scaleY;\n\n    this.getBounds(this, includeChildren, Rectangle.__cache.zero());\n    this.mPivotX = Rectangle.__cache.width * anchorX;\n    this.mPivotY = Rectangle.__cache.height * anchorY;\n\n    this.setTransformDirty();\n    return this;\n  }\n\n  /**\n   * localToGlobal - Description\n   *\n   * @param {Vector} localPoint       Description\n   * @param {Vector|null} [outVector=null] Description\n   *\n   * @return {Vector} Description\n   */\n  localToGlobal(localPoint, outVector = null) {\n    return this.worldTransformation.transformVector(localPoint, outVector);\n  }\n\n  /**\n   * globalToLocal - Description\n   *\n   * @param {Vector} localPoint       Description\n   * @param {Vector|null} [outVector=null] Description\n   *\n   * @return {Vector} Description\n   */\n  globalToLocal(globalPoint, outVector = null) {\n    return this.worldTransformationInversed.transformVector(globalPoint, outVector);\n  }\n\n  /*:--- PROPERTIES ---:*/\n\n  /**\n   * numChildren - Description\n   *\n   * @return {number} Description\n   */\n  get numChildren() {\n    return this.mChildren.length;\n  }\n\n  /**\n   * name - Description\n   *\n   * @return {string|null} Description\n   */\n  get name() {\n    return this.mName;\n  }\n\n  /**\n   * name - Description\n   *\n   * @param {string|null} value Description\n   *\n   * @return {void} Description\n   */\n  set name(value) {\n    this.mName = value;\n  }\n\n  /**\n   * x - Gets the x coordinate of the GameoObject instance relative to the local coordinates of the parent GameoObject.\n   *\n   * @return {number} Description\n   */\n  get x() {\n    return this.mX;\n  }\n\n  /**\n   * x - Sets the x coordinate of the GameoObject instance relative to the local coordinates of the parent GameoObject.\n   *\n   * @param {number} value Description\n   *\n   * @return {void} Description\n   */\n  set x(value) {\n    if (this.mX == value)\n      return;\n\n    this.mX = value;\n    this.setTransformDirty();\n  }\n\n  /**\n   * y - Gets the y coordinate of the GameoObject instance relative to the local coordinates of the parent GameoObject.\n   *\n   * @return {number} Description\n   */\n  get y() {\n    return this.mY;\n  }\n\n  /**\n   * y - Sets the y coordinate of the GameoObject instance relative to the local coordinates of the parent GameoObject.\n   *\n   * @param {number} value Description\n   *\n   * @return {void} Description\n   */\n  set y(value) {\n    if (this.mY == value)\n      return;\n\n    this.mY = value;\n    this.setTransformDirty();\n  }\n\n  /**\n   * pivotX - Description\n   * @export\n   * @return {number} Description\n   */\n  get pivotX() {\n    return this.mPivotX;\n  }\n\n  /**\n   * pivotX - Description\n   *\n   * @export\n   * @param {number} value Description\n   *\n   * @return {void} Description\n   */\n  set pivotX(value) {\n    if (this.mPivotX == value)\n      return;\n\n    this.mPivotX = value;\n    this.setTransformDirty();\n  }\n\n  /**\n   * pivotY - Description\n   *\n   * @return {number} Description\n   */\n  get pivotY() {\n    return this.mPivotY;\n  }\n\n  /**\n   * pivotY - Description\n   *\n   * @param {number} value Description\n   *\n   * @return {void} Description\n   */\n  set pivotY(value) {\n    if (this.mPivotY == value)\n      return;\n\n    this.mPivotY = value;\n    this.setTransformDirty();\n  }\n\n  /**\n   * alignPivot\n   *\n   * @param {number}  [px=0.5]\n   * @param {number}  [py=0.5]\n   * @param {boolean} [includeChildren=true]\n   *\n   * @return {GameObject}\n   */\n  alignPivot(ax = 0.5, ay = 0.5, includeChildren = true) {\n    this.getBounds(this, includeChildren, Rectangle.__cache.zero());\n\n    this.mPivotX = Rectangle.__cache.width * ax;\n    this.mPivotY = Rectangle.__cache.height * ay;\n    this.setTransformDirty();\n\n    return this;\n  }\n\n  /**\n   * scaleX - Description\n   *\n   * @return {number} Description\n   */\n  get scaleX() {\n    return this.mScaleX;\n  }\n\n  /**\n   * scaleX - Description\n   *\n   * @param {number} value Description\n   *\n   * @return {void} Description\n   */\n  set scaleX(value) {\n    if (this.mScaleX == value)\n      return;\n\n    this.mScaleX = value;\n    this.setTransformDirty();\n  }\n\n  /**\n   * scaleY - Description\n   *\n   * @return {number} Description\n   */\n  get scaleY() {\n    return this.mScaleY;\n  }\n\n  /**\n   * scaleY - Description\n   *\n   * @param {number} value Description\n   *\n   * @return {void} Description\n   */\n  set scaleY(value) {\n    if (this.mScaleY == value)\n      return;\n\n    this.mScaleY = value;\n    this.setTransformDirty();\n  }\n\n  /**\n   * rotation - returns current rotation\n   *\n   * @return {number} Description\n   */\n  get rotation() {\n    return this.mRotation;\n  }\n\n  /**\n   * rotation - Description\n   *\n   * @param {number} value Description\n   *\n   * @return {void} Description\n   */\n  set rotation(value) {\n    if (this.mRotation == value)\n      return;\n\n    this.mRotation = value;\n    this.setTransformDirty();\n  }\n\n  /**\n   * parent - Description\n   *\n   * @return {GameObject} Description\n   */\n  get parent() {\n    return this.mParent;\n  }\n\n  /**\n   * root - Description\n   *\n   * @return {GameObject|null} Description\n   */\n  get root() {\n    let current = this;\n\n    if (current === Black.instance.root)\n      return current;\n\n    while (current.mParent) {\n      if (current === Black.instance.root)\n        return current;\n      else if (current.mParent === Black.instance.root)\n        return Black.instance.root;\n      else\n        current = current.mParent;\n    }\n\n    return null;\n  }\n\n  /**\n   * depth - Description\n   *\n   * @return {number} Description\n   */\n  get depth() {\n    if (this.mParent)\n      return this.mParent.depth + 1;\n    else\n      return 0;\n  }\n\n  /**\n   * index - Description\n   *\n   * @return {number} Description\n   */\n  get index() {\n    return this.mIndex;\n  }\n\n  /**\n   * width - Description\n   *\n   * @return {number} Description\n   */\n  get width() {\n    return this.getBounds(this.mParent).width;\n  }\n\n  /**\n   * width - Description\n   *\n   * @param {number} value Description\n   *\n   * @return {void} Description\n   */\n  set width(value) {\n    this.scaleX = 1;\n    const currentWidth = this.width;\n\n    if (currentWidth != 0.0)\n      this.scaleX = value / currentWidth;\n  }\n\n  /**\n   * height - Description\n   *\n   * @return {number} Description\n   */\n  get height() {\n    return this.getBounds(this.mParent).height;\n  }\n\n  /**\n   * height - Description\n   *\n   * @param {number} value Description\n   *\n   * @return {void} Description\n   */\n  set height(value) {\n    this.scaleY = 1;\n    const currentHeight = this.height;\n\n    if (currentHeight != 0)\n      this.scaleY = value / currentHeight;\n  }\n\n\n  /**\n   * localWidth - returns height in local space without children.\n   *\n   * @return {number}\n   */\n  get localWidth() {\n    return this.getBounds(this, false).width;\n  }\n\n\n  /**\n   * localHeight - returns height in local space without children.\n   *\n   * @return {number}\n   */\n  get localHeight() {\n    return this.getBounds(this, false).height;\n  }\n\n  // TODO: precache\n  /**\n   * path - Description\n   *\n   * @return {string} Description\n   */\n  get path() {\n    if (this.mParent !== null)\n      return this.mParent.path + '/' + this.mName;\n\n    return this.mName;\n  }\n\n  /**\n   * tag - Description\n   *\n   * @return {string|null} Description\n   */\n  get tag() {\n    return this.mTag;\n  }\n\n  /**\n   * tag - Description\n   *\n   * @param {string|null} value Description\n   *\n   * @return {void} Description\n   */\n  set tag(value) {\n    if (this.mTag === value)\n      return;\n\n    /** @type {string|null} */\n    let old = this.mTag;\n    this.mTag = value;\n\n    if (this.mAdded)\n      Black.instance.onTagUpdated(this, old, value);\n  }\n\n\n  /**\n   * co - Starts coroutine.\n   *\n   * @param {Function} gen\n   * @param {*=} [ctx=null]\n   *\n   * @return {Generator}\n   */\n  spawn(gen, ctx = null) {\n    var iter = gen.apply(ctx == null ? this : ctx);\n\n    function step(it) {\n      if (it.done)\n        return;\n\n      if (typeof it.value === 'function')\n        it.value(x => step(iter.next(x)));\n      else\n        step(iter.next(it.value));\n    }\n\n    step(iter.next());\n    return iter;\n  }\n\n\n  /**\n   * @param {number} [seconds=1]\n   *\n   * @return {function(*):*}\n   */\n  wait(seconds = 1) {\n    return cb => setTimeout(cb.bind(this, seconds * 1000), seconds * 1000);\n  }\n\n\n  /**\n   * waitMessage - Waits for a speceific message\n   *\n   * @param {string} message The name of the message to wait for\n   *\n   * @return {function(?):?} Description\n   */\n  waitMessage(message) {\n    return cb => this.on(message, cb.bind(this));\n  }\n\n\n  /**\n   * setDirty\n   *\n   * @param {DirtyFlag} flag\n   * @param {boolean} [includeChildren=true] Description\n   *\n   * @return {void}\n   */\n  setDirty(flag, includeChildren = true) {\n    if (includeChildren) {\n      GameObject.forEach(this, x=> {\n        x.mDirty |= flag;\n      });\n    } else {\n      this.mDirty |= flag;\n    }\n  }\n\n  setTransformDirty() {\n    this.setDirty(DirtyFlag.LOCAL, false);\n    this.setDirty(DirtyFlag.WORLD, true);\n  }\n\n  /**\n   * dispose\n   *\n   * @return {void}\n   */\n  dispose() {\n  }\n\n  // TODO: rename method\n  /**\n   * getBoundsWithPoints - Description\n   *\n   * @param {Array<number>} points              Description\n   * @param {Matrix} worldTransformation Description\n   * @param {Rectangle=} outRect             Description\n   *\n   * @return {Rectangle} Description\n   */\n  static getBoundsWithPoints(points, worldTransformation, outRect) {\n    outRect = outRect || new Rectangle();\n\n    let minX = Number.MAX_VALUE;\n    let maxX = -Number.MAX_VALUE;\n    let minY = Number.MAX_VALUE;\n    let maxY = -Number.MAX_VALUE;\n    let xx = 0;\n    let yy = 0;\n    let tmpVector = new Vector();\n\n    for (let i = 0; i < points.length; i += 2) {\n      worldTransformation.transformXY(points[i], points[i + 1], tmpVector);\n\n      if (minX > tmpVector.x)\n        minX = tmpVector.x;\n\n      if (maxX < tmpVector.x)\n        maxX = tmpVector.x;\n\n      if (minY > tmpVector.y)\n        minY = tmpVector.y;\n\n      if (maxY < tmpVector.y)\n        maxY = tmpVector.y;\n    }\n\n    outRect.set(minX, minY, maxX - minX, maxY - minY);\n    return outRect;\n  }\n\n  /**\n   * intersects - Description\n   *\n   * @param {GameObject} gameObject Description\n   * @param {Vector} point      Description\n   *\n   * @return {boolean} Description\n   */\n  static intersects(gameObject, point) {\n    let tmpVector = new Vector();\n    let inv = gameObject.worldTransformation.invert();\n\n    inv.transformVector(point, tmpVector);\n\n    let rect = gameObject.getBounds(gameObject, false);\n    return rect.containsXY(tmpVector.x, tmpVector.y);\n  }\n\n  /**\n   * intersectsAt - Description\n   *\n   * @param {GameObject} gameObject Description\n   * @param {Vector} point      Description\n   * @param {Vector=} outVector  Description\n   *\n   * @return {boolean} Description\n   */\n  static intersectsAt(gameObject, point, outVector = undefined) {\n    outVector = outVector || new Vector();\n\n    let tmpVector = Vector.__cache;\n    let inv = gameObject.worldTransformationInversed;\n\n    inv.transformVector(point, tmpVector);\n\n    let rect = gameObject.getBounds(gameObject, false);\n    let contains = rect.containsXY(tmpVector.x, tmpVector.y);\n\n    if (!contains)\n      return false;\n\n    outVector.x = tmpVector.x - rect.x;\n    outVector.y = tmpVector.y - rect.y;\n    return true;\n  }\n\n  /**\n   * intersectsWith - Description\n   *\n   * @param {GameObject} gameObject Description\n   * @param {Vector} point      Description\n   *\n   * @return {GameObject|null} returns object or null\n   */\n  static intersectsWith(gameObject, point) {\n    let obj = null;\n    for (let i = gameObject.numChildren - 1; i >= 0; --i) {\n      let child = gameObject.mChildren[i];\n\n      obj = GameObject.intersectsWith(child, point);\n      if (obj != null)\n        return obj;\n\n      let inside = GameObject.intersects(child, point);\n      if (inside) {\n        obj = child;\n        break;\n      }\n    }\n\n    if (obj === null && GameObject.intersects(gameObject, point)) {\n      return gameObject;\n    }\n\n    return null;\n  }\n\n  /**\n   * findWithTag - Description\n   *\n   * @param {string} tag Description\n   *\n   * @return {Array<GameObject>|null} Description\n   */\n  static findWithTag(tag) {\n    if (Black.instance.mTagCache.hasOwnProperty(tag) === false)\n      return null;\n\n    return Black.instance.mTagCache[tag];\n  }\n\n  /**\n   * findComponents - Returns a list of Components\n   *\n   * @param {GameObject} gameObject\n   * @param {function (new:Component)} type\n   *\n   * @return {Array<Component>}\n   */\n  static findComponents(gameObject, type) {\n    Debug.assert(gameObject !== null, 'gameObject cannot be null.');\n    Debug.assert(type !== null, 'type cannot be null.');\n\n    /** @type {Array<Component>} */\n    let list = [];\n\n    /** @type {function(GameObject, function(new:Component)):void} */\n    let f = function(gameObject, type) {\n      for (let i = 0; i < gameObject.mComponents.length; i++) {\n        let c = gameObject.mComponents[i];\n        if (c instanceof type)\n          list.push(c);\n      }\n\n      for (let i = 0; i < gameObject.mChildren.length; i++)\n        f(gameObject.mChildren[i], type);\n    };\n\n    f(gameObject, type);\n\n    return list;\n  }\n\n  /**\n   * forEach - Runs action accross all object mathing the name.\n   *\n   * @param {GameObject} node   Description\n   * @param {function(GameObject)} action Description\n   *\n   * @return {void} Description\n   */\n  static forEach(node, action) {\n    if (node == null)\n      node = Black.instance.root;\n\n    action(node);\n\n    for (let i = 0; i < node.numChildren; i++)\n      GameObject.forEach(node.getChildAt(i), action);\n  }\n\n\n  /**\n   * find - Finds object by its name.\n   *\n   * @param {string} name Description\n   * @param {GameObject} node Description\n   *\n   * @return {GameObject} Description\n   */\n  static find(name, node) {\n    if (node == null)\n      node = Black.instance.root;\n\n    if (node.name === name)\n      return node;\n\n    for (let i = 0; i < node.numChildren; i++) {\n      let r = GameObject.find(name, node.getChildAt(i));\n      if (r != null)\n        return r;\n    }\n\n    return null;\n  }\n}\n\n/** @type {number}\n * @nocollapse\n */\nGameObject.ID = 0;\n\n/**\n * @enum {number}\n */\n\nvar DirtyFlag = {\n  LOCAL: 1,\n  WORLD: 2,\n  DIRTY: 0xffffff\n};\n","// TODO:\n// [_] Do not handle is loaded or not.\n// Texture shall not be responsible for loading itself.\n// We have TextureAsset for it.\n// native size - always the size of physical texture\n// source size - the original size of a texture to\n//\n\n\nclass Texture {\n  /**\n   * @param  {Image} nativeTexture description\n   * @param  {Rectangle=} region = undefined description\n   * @param  {Rectangle=} untrimmedRect = undefined description\n   */\n  constructor(nativeTexture, region, untrimmedRect) {\n    /** @type {Image} */\n    this.mTexture = nativeTexture;\n\n    /** @type {Rectangle} */\n    this.mRegion;\n\n    /** @type {boolean} */\n    this.mIsSubtexture = false;\n\n    /** @type {number} */\n    this.mId = ++Texture.__ID;\n\n    if (region === undefined) {\n      this.mRegion = new Rectangle(0, 0, nativeTexture.naturalWidth, nativeTexture.naturalHeight);\n    } else {\n      this.mRegion = /** @type {Rectangle} */ (region);\n      this.mIsSubtexture = true;\n    }\n\n    /** @type {boolean} */\n    this.mTrimmed = untrimmedRect !== undefined;\n\n    if (this.mTrimmed === false)\n      untrimmedRect = new Rectangle(0, 0, this.mRegion.width, this.mRegion.height);\n\n    /** @type {Rectangle} */\n    this.mUntrimmedRect = /** @type {Rectangle} */ (untrimmedRect);\n\n    /** @type {boolean} */\n    this.mIsLoaded = true;\n  }\n\n  /**\n   * id - Description\n   *\n   * @return {number} Description\n   */\n  get id() {\n    return this.mId;\n  }\n\n  /**\n   * isTrimmed - Description\n   *\n   * @return {boolean} Description\n   */\n  get isTrimmed() {\n    return this.mTrimmed;\n  }\n\n  /**\n   * isSubTexture - Description\n   *\n   * @return {boolean} Description\n   */\n  get isSubTexture() {\n    return this.mIsSubtexture;\n  }\n\n  // TODO: if we update texture we have to nofity everything, send signal\n  // update(nativeTexture = null, region = null, source = null, crop = null){\n  // }\n\n  // render width\n  // render height\n  // croppedWidth, croppedHeight\n  // width, height\n  //\n\n  /**\n   * untrimmedRect - Description\n   *\n   * @return {Rectangle} Description\n   */\n  get untrimmedRect() {\n    return this.mUntrimmedRect;\n  }\n\n  /**\n   * width - Description\n   *\n   * @return {number} Description\n   */\n  get width() {\n    if (this.mRegion)\n      return this.mRegion.width;\n\n    return this.mTexture.naturalWidth;\n  }\n\n  /**\n   * height - Description\n   *\n   * @return {number} Description\n   */\n  get height() {\n    if (this.mRegion)\n      return this.mRegion.height;\n\n    return this.mTexture.naturalHeight;\n  }\n\n  /**\n   * region - Description\n   *\n   * @return {Rectangle} Description\n   */\n  get region() {\n    return this.mRegion;\n  }\n\n  /**\n   * native - Description\n   *\n   * @return {Image} Description\n   */\n  get native() {\n    return this.mTexture;\n  }\n\n  /**\n   * isLoaded - Description\n   *\n   * @return {boolean} Description\n   */\n  get isLoaded() {\n    return this.mIsLoaded;\n  }\n\n  /**\n   * type - Description\n   *\n   * @return {string} Description\n   */\n  get type() {\n    return 'Texture';\n  }\n\n  /**\n   * baseType - Description\n   *\n   * @return {string} Description\n   */\n  get baseType() {\n    return 'Texture';\n  }\n\n  /**\n   * dispose - Description\n   *\n   * @return {void} Description\n   */\n  dispose() {\n    this.mTexture = null;\n  }\n\n  /**\n   * fromBase64String - Description\n   *\n   * @param {string} string Description\n   *\n   * @return {Texture} Description\n   */\n  static fromBase64String(string) {\n    let imgElement = new Image();\n    imgElement.src = string;\n    return new Texture(imgElement);\n  }\n\n\n  /**\n   * fromCanvasAsImage - Description\n   *\n   * @param {HTMLElement}   canvas           Description\n   * @param {string} [type=image/png] Description\n   * @param {number} [quality=1]      Description\n   *\n   * @return {Texture} Description\n   */\n  static fromCanvasAsImage(canvas, type = 'image/png', quality = 1) {\n    let imgElement = new Image();\n    imgElement.src = canvas.toDataURL(type, quality);\n\n    return new Texture(imgElement);\n  }\n\n\n  /**\n   * fromCanvas - Description\n   *\n   * @param {HTMLElement} canvas Description\n   *\n   * @return {Texture} Description\n   */\n  static fromCanvas(canvas) {\n    return Black.instance.video.getTextureFromCanvas(canvas);\n  }\n}\n\n/** @type {number}\n * @nocollapse\n */\nTexture.__ID = 0;\n\n/** @type {Image|null}\n * @nocollapse\n */\nTexture.MISSING_IMAGE_CACHE = null;\n","\nclass AtlasTexture extends Texture {\n  /**\n   * constructor - Creates an Texture Atlas\n   *\n   * @param {Texture} texture A base texture object.\n   * @param {{meta: *, frames: *}} jsonObject\n   *\n   * @return {void}\n   */\n  constructor(texture, jsonObject) {\n    super(texture.native);\n\n    /** @type {Object} */\n    this.mMeta = {};\n\n    /** @dict */\n    this.mSubTextures = {}; // dictionary\n\n    this.__parseJson(jsonObject);\n  }\n\n  /**\n   * __parseJson\n   *\n   * @param  {{meta: *, frames: *}} o\n   * @return {void}\n   */\n  __parseJson(o) {\n    const NEGATIVE_HALF_PI = -(Math.PI / 2);\n\n    // if (o.meta.format)\n    //   this.mMeta.format = o.meta.format;\n    //\n    // if (o.meta.scale)\n    //   this.mMeta.scale = parseFloat(o.meta.scale);\n\n    for (let key in o.frames) {\n      let data = /** @type {Array<number>} */ (o.frames[key]);\n\n      let region = new Rectangle(data[0], data[1], data[2], data[3]);\n      let untrimmedRect = new Rectangle(data[4], data[5], data[6], data[7]);\n\n      this.mSubTextures[key] = new Texture(this.native, region, untrimmedRect);\n    }\n  }\n\n  // addRegion(name, region, frame) {}\n  //\n  // removeRegion() {}\n\n  /**\n   * getTexture - Returns the textures by a given name.\n   *\n   * @param {string} name\n   *\n   * @return {Texture} The Texture or null;\n   */\n  getTexture(name) {\n    /** @type {Texture} */\n    let t = this.mSubTextures[name];\n    if (t === undefined)\n      console.warn('Texture \\'%s\\' was not found in cache.', name);\n\n    return /** @type {Texture} */ (t);\n  }\n\n  /**\n   * getTextures - Returns list of Textures.\n   *\n   * @param {string|null} [nameMask=null] The mask to filter by.\n   * @param {Array<Texture>|null} outTextures\n   *\n   * @return {Array<Texture>} The list of found textures.\n   */\n  getTextures(nameMask = null, outTextures = null) {\n    let out = outTextures || [];\n    if (nameMask === null) {\n      for (let key in this.mSubTextures)\n        out.push(this.mSubTextures[key]);\n\n      return /** @type {Array<Texture>} */ (out);\n    }\n\n    let names = [];\n\n    // TODO: make helper wild function\n    let re = new RegExp(\"^\" + nameMask.split(\"*\").join(\".*\") + \"$\");\n    for (let key in this.mSubTextures)\n      if (re.test(key))\n        names.push(key);\n\n    names.sort(this.__naturalComparer);\n\n    for (let i = 0; i < names.length; i++)\n      out.push(this.mSubTextures[names[i]]);\n\n    return out;\n  }\n\n  /**\n   * @param {*} a\n   * @param {*} b\n   *\n   * @return {number}\n   */\n  __naturalComparer(a, b) {\n    const NUMBER_GROUPS = /(-?\\d*\\.?\\d+)/g;\n    let aa = String(a).split(NUMBER_GROUPS);\n    let bb = String(b).split(NUMBER_GROUPS);\n    let min = Math.min(aa.length, bb.length);\n\n    for (let i = 0; i < min; i++) {\n      let x = parseFloat(aa[i]) || aa[i].toLowerCase();\n      let y = parseFloat(bb[i]) || bb[i].toLowerCase();\n\n      if (x < y)\n        return -1;\n      else if (x > y)\n        return 1;\n    }\n\n    return 0;\n  };\n\n  //dispose() {}\n}\n","// TODO: handle errors\n// TODO: v2: parallel loading?\n//\n//\n\nclass Asset extends MessageDispatcher {\n  /**\n   * @param  {string} name description\n   * @param  {string} url  description\n   */\n  constructor(name, url) {\n    super();\n\n    /** @type {string} */\n    this.mName = name;\n\n    /** @type {string} */\n    this.mUrl = url;\n\n    /** @type {*|null} */\n    this.mData = null;\n\n    /** @type {boolean} */\n    this.mIsLoaded = false;\n\n    /** @type {string|undefined} */\n    this.mMimeType = undefined;\n\n    /** @type {string} */\n    this.mResponseType = '';\n\n    /** @type {string} */\n    this.mExtension = this.getExtension(url);\n\n    /** @type {XMLHttpRequest|null} */\n    this.mRequest = null;\n  }\n\n  /**\n   * load\n   *\n   * @return {void}\n   */\n  load() {\n    //console.log('Asset: loading asset \\'%s\\' from \\'%s\\'', this.mName, this.mUrl);\n\n    this.mRequest = new XMLHttpRequest();\n    //this.mRequest.onprogress = (pe) => this.onProgressChanged(pe);\n\n    if (this.mRequest.overrideMimeType && this.mMimeType)\n      this.mRequest.overrideMimeType(this.mMimeType);\n\n    this.mRequest.responseType = this.mResponseType;\n    this.mRequest.open(\"GET\", this.mUrl, true);\n    this.mRequest.onreadystatechange = () => {\n      if (this.mRequest.readyState === 4) {\n        if ((this.mRequest.status === 200) || ((this.mRequest.status === 0) && this.mRequest.responseText))\n          this.onLoaded();\n        else\n          throw new Error('Error loading ' + this.mUrl + \" (\" + this.mRequest.status + \":\"+ this.mRequest.responseText + \")\"); //TODO handle errors\n      }\n    };\n\n    this.mRequest.send(null);\n  }\n\n\n  /**\n   * onLoaded\n   *\n   * @return {void}\n   */\n  onLoaded() {\n    this.mIsLoaded = true;\n    this.post('complete');\n  }\n\n  /**\n   * name\n   *\n   * @return {string}\n   */\n  get name() {\n    return this.mName;\n  }\n\n  /**\n   * data\n   *\n   * @return {*}\n   */\n  get data() {\n    return this.mData;\n  }\n\n  /**\n   * isLoaded\n   *\n   * @return {boolean}\n   */\n  get isLoaded() {\n    return this.mIsLoaded;\n  }\n\n  // TODO: finish\n  dispose() {}\n\n  /**\n   * getExtension\n   *\n   * @param {string} url\n   *\n   * @return {string}\n   */\n  getExtension(url) {\n    if (url.indexOf(\".\") === -1)\n      return '';\n\n    return url.substring(url.indexOf(\".\")).toLowerCase();\n  }\n}\n","\nclass TextureAsset extends Asset {\n  /**\n   * constructor - Description\n   *\n   * @param {string} name Description\n   * @param {string} url  Description\n   *\n   * @return {void} Description\n   */\n  constructor(name, url) {\n    super(name, url);\n\n    /** @type {Image} */\n    this.mImageElement = new Image();\n  }\n\n  /**\n   * onLoaded - Description\n   *\n   * @return {void} Description\n   */\n  onLoaded() {\n    //console.log('TextureAsset: \\'%s\\' loaded', this.mName);\n\n    this.mData = new Texture(this.mImageElement);\n\n    super.onLoaded();\n  }\n\n  /**\n   * load - Description\n   *\n   * @return {void} Description\n   */\n  load() {\n    this.mImageElement.src = this.mUrl;\n    this.mImageElement.onload = () => {\n      this.onLoaded();\n    }\n  }\n\n  /**\n   * type - Description\n   *\n   * @return {string} Description\n   */\n  get type() {\n    return \"TextureAsset\";\n  }\n}\n","\nclass JSONAsset extends Asset {\n  /**\n   * constructor\n   *\n   * @param {string} name\n   * @param {string} url\n   *\n   * @return {void}\n   */\n  constructor(name, url) {\n    super(name, url);\n    this.mimeType = \"application/json\";\n  }\n\n  /**\n   * onLoaded\n   *\n   * @return {void}\n   */\n  onLoaded(){\n    this.mData = JSON.parse(/** @type {string} */ (this.mRequest.responseText) );\n    super.onLoaded();\n  }\n}\n","\nclass AtlasTextureAsset extends Asset {\n  /**\n   * constructor\n   *\n   * @param {string} name\n   * @param {string} imageUrl\n   * @param {string} dataUrl\n   *\n   * @return {void}\n   */\n  constructor(name, imageUrl, dataUrl) {\n    super(name, imageUrl);\n\n    /** @type {Image} */\n    this.mImageElement = new Image();\n\n    /** @type {JSONAsset} */\n    this.dataAsset = new JSONAsset(name, dataUrl);\n    this.dataAsset.on('complete', this.onJsonLoaded, this);\n  }\n\n  onJsonLoaded() {\n    this.mImageElement.src = this.mUrl;\n    this.mImageElement.onload = () => {\n      this.onLoaded();\n    }\n  }\n\n  /**\n   * onLoaded\n   *\n   * @return {void}\n   */\n  onLoaded() {\n    this.mData = new AtlasTexture(new Texture(this.mImageElement), /** @type {{meta: *, frames: *}} */ (this.dataAsset.data));\n\n    super.onLoaded();\n  }\n\n  /**\n   * load\n   * @override\n   *\n   * @return {void}\n   */\n  load() {\n    this.dataAsset.load();\n  }\n}\n","/*\nTODO:\n  1. propper error handling\n  2. max parallel downloads\n  3. check for name dublicates\n  4. load progress\n*/\n\n\nclass AssetManager extends MessageDispatcher {\n  constructor() {\n    super();\n\n    /** @type {string} */\n    this.mDefaultPath = '';\n\n    /** @type {number} */\n    this.mTotalLoaded = 0;\n\n    /** @type {boolean} */\n    this.mIsAllLoaded = false;\n\n    /** @type {number} */\n    this.mLoadingProgress = 0;\n\n    /** @type {Array<Asset>} */\n    this.mQueue = [];\n\n    /** @dict */\n    this.mTextures = {};\n\n    /** @dict */\n    this.mAtlases = {};\n\n    /** @dict */\n    this.mJsons = {};\n  }\n\n  enqueueImage(name, url) {\n    this.mQueue.push(new TextureAsset(name, this.mDefaultPath + url));\n  }\n\n  enqueueAtlas(name, imageUrl, dataUrl) {\n    this.mQueue.push(new AtlasTextureAsset(name, this.mDefaultPath + imageUrl, this.mDefaultPath + dataUrl));\n  }\n\n  enqueueJson(name, url) {\n    this.mQueue.push(new JSONAsset(name, this.mDefaultPath + url));\n  }\n\n  /**\n   * loadQueue\n   *\n   * @return {void}\n   */\n  loadQueue() {\n    for (let i = 0; i < this.mQueue.length; i++) {\n      let item = this.mQueue[i];\n\n      item.on(Message.COMPLETE, this.onAssetLoaded, this);\n      item.load();\n    }\n  }\n\n  /**\n   * onAssetLoaded\n   *\n   * @param {Message} msg\n   *\n   * @return {void}\n   */\n  onAssetLoaded(msg) {\n    this.mTotalLoaded++;\n    this.mLoadingProgress = this.mTotalLoaded / this.mQueue.length;\n\n    let item = msg.sender;\n\n    // TODO: rework this\n    // TODO: check for dups\n    if (item.constructor === TextureAsset)\n      this.mTextures[item.name] = item.data;\n    else if (item.constructor === AtlasTextureAsset)\n      this.mAtlases[item.name] = item.data;\n    else if (item.constructor === JSONAsset)\n      this.mJsons[item.name] = item.data;\n    else\n      console.error('Unable to handle asset type.', item);\n\n    this.post(Message.PROGRESS, this.mLoadingProgress);\n\n    if (this.mTotalLoaded === this.mQueue.length) {\n      this.mQueue.splice(0, this.mQueue.length);\n\n      this.mIsAllLoaded = true;\n      this.post(Message.COMPLETE);\n    }\n  }\n\n  /**\n   * getTexture\n   *\n   * @param {string} name\n   *\n   * @return {Texture|null}\n   */\n  getTexture(name) {\n    /** @type {Texture} */\n    let t = this.mTextures[name];\n\n    if (t != null)\n      return t;\n\n    for (let key in this.mAtlases) {\n      t = this.mAtlases[key].getTexture(name);\n      if (t != null)\n        return t;\n    }\n\n    return null;\n  }\n\n\n  /**\n   * @param {string} name\n   *\n   * @return {AtlasTexture}\n   */\n  getAtlas(name) {\n    return this.mAtlases[name];\n  }\n\n  /**\n   * defaultPath\n   *\n   * @return {string}\n   */\n  get defaultPath() {\n    return this.mDefaultPath;\n  }\n\n  /**\n   * defaultPath\n   *\n   * @param {string} value\n   *\n   * @return {void}\n   */\n  set defaultPath(value) {\n    this.mDefaultPath = value;\n  }\n\n  /**\n   * isAllLoaded\n   *\n   * @return {boolean}\n   */\n  get isAllLoaded() {\n    return this.mIsAllLoaded;\n  }\n}\n\n/** @type {AssetManager} */\nAssetManager.default = new AssetManager();\n","/**\n * A blend mode enum.\n * @enum {string}\n */\n\nvar BlendMode = {\n  AUTO: 'auto',\n  NORMAL: 'source-over',\n  ADD: 'lighter',\n  MULTIPLY: 'multiply',\n  SCREEN: 'screen',\n  OVERLAY: 'overlay',\n  DARKEN: 'darken',\n  LIGHTEN: 'lighten',\n  COLOR_DODGE: 'color-dodge',\n  COLOR_BURN: 'color-burn',\n  HARD_LIGHT: 'hard-light',\n  SOFT_LIGHT: 'soft-light',\n  DIFFERENCE: 'difference',\n  EXCLUSION: 'exclusion',\n  HUE: 'hue',\n  SATURATE: 'saturate',\n  COLOR: 'color',\n  LUMINOSITY: 'luminosity'\n};\n","\nclass VideoNullDriver {\n  /**\n   * @param  {HTMLElement} containerElement description\n   * @param  {number} width            description\n   * @param  {number} height           description\n   */\n  constructor(containerElement, width, height) {\n    /** @type {string} */\n    this.mGlobalBlendMode = 'auto';\n\n    /** @type {HTMLElement} */\n    this.mContainerElement = /** @type {HTMLElement} */ (containerElement);\n\n    /** @type {number} */\n    this.mClientWidth = width;\n\n    /** @type {number} */\n    this.mClientHeight = height;\n\n    /** @type {Matrix} */\n    this.mTransform = new Matrix();\n\n    /** @type {number} */\n    this.mGlobalAlpha = 1;\n\n    /** @type {HTMLElement} */\n    this.mMeasureElement = /** @type {HTMLElement} */ (document.createElement('span'));\n    this.mMeasureElement.style.position = 'absolute';\n    this.mContainerElement.appendChild(this.mMeasureElement);\n\n    Black.instance.viewport.on('resize', this.__onResize, this);\n  }\n\n  __onResize(msg, rect) {\n    let w = this.mContainerElement.clientWidth;\n    let h = this.mContainerElement.clientHeight;\n\n    this.mClientWidth = w;\n    this.mClientHeight = h;\n  }\n\n  /**\n   * start - Description\n   *\n   * @return {void} Description\n   */\n  start() {}\n\n  beginFrame() {}\n\n  endFrame() {}\n\n\n  /**\n   * getTextureFromCanvas - Description\n   *\n   * @param {HTMLElement} canvas Description\n   *\n   * @return {Texture|null} Description\n   */\n  getTextureFromCanvas(canvas){\n    return null;\n  }\n\n  /**\n   * setTransform - Description\n   *\n   * @param {Matrix} m Description\n   *\n   * @return {void} Description\n   */\n  setTransform(m) {\n    this.mTransform = m;\n  }\n\n  /**\n   * globalAlpha - Description\n   *\n   * @return {number} Description\n   */\n  get globalAlpha() {\n    return this.mGlobalAlpha;\n  }\n\n  /**\n   * globalAlpha - Description\n   *\n   * @param {number} value Description\n   *\n   * @return {void} Description\n   */\n  set globalAlpha(value) {\n    this.mGlobalAlpha = value;\n  }\n\n  /**\n   * mGlobalBlendMode - Description\n   *\n   * @return {string} Description\n   */\n  get globalBlendMode() {\n    return this.mGlobalBlendMode;\n  }\n\n  /**\n   * globalBlendMode - Description\n   *\n   * @param {string} value Description\n   *\n   * @return {void} Description\n   */\n  set globalBlendMode(value) {\n    this.mGlobalBlendMode = value;\n  }\n\n  /**\n   * drawImage - description\n   *\n   * @param  {Texture} texture description\n   */\n  drawImage(texture) {}\n\n  /**\n   * drawText\n   *\n   * @param {string} text\n   * @param {TextInfo} style\n   * @param {Rectangle} bounds\n   * @param {number} textWidth\n   * @param {number} textHeight\n   *\n   * @return {void}\n   */\n  drawText(text, style, bounds, textWidth, textHeight) {}\n\n  clear() {}\n\n  /**\n   * save - Description\n   *\n   * @param {GameObject|null} gameObject Used for internal binding.\n   *\n   * @return {void} Description\n   */\n  save(gameObject) {}\n\n  restore() {}\n\n  hexColorToString(color) {\n    let parsedColor = color.toString(16);\n    return '#000000'.substring(0, 7 - parsedColor.length) + parsedColor;\n  }\n\n  /**\n   * measureText - Description\n   *\n   * @param {string} text  Description\n   * @param {TextInfo} style Description\n   *\n   * @return {Vector} Description\n   */\n  measureText(text, style) {\n    let el = this.mMeasureElement;\n    el.innerHTML = text;\n    el.style.whiteSpace = 'pre';\n    el.style.fontSize = style.size + 'px';\n    el.style.fontFamily = style.name;\n    el.style.fontStyle = style.style;\n    el.style.fontWeight = style.weight;\n\n    let v = new Vector(el.offsetWidth + style.strokeThickness, el.offsetHeight + style.strokeThickness);\n    el.innerHTML = '';\n\n    return v;\n  }\n}\n","\nclass CanvasDriver extends VideoNullDriver {\n  /**\n   * @param  {HTMLElement} containerElement description\n   * @param  {number} width            description\n   * @param  {number} height           description\n   */\n  constructor(containerElement, width, height) {\n    super(containerElement, width, height);\n\n    /** @type {CanvasRenderingContext2D|null} */\n    this.mCtx = null;\n\n    this.mGlobalAlpha = 1;\n    this.mGlobalBlendMode = BlendMode.NORMAL;\n\n    this.__createCanvas();\n  }\n\n  /**\n   * __createCanvas\n   *\n   * @return {void}\n   */\n  __createCanvas() {\n    let cvs = /** @type {HTMLCanvasElement} */ (document.createElement('canvas'));\n    cvs.id = 'canvas';\n    this.mContainerElement.appendChild(cvs);\n\n    this.mCtx = /** @type {CanvasRenderingContext2D} */ (cvs.getContext('2d'));\n    this.mCtx.canvas.width = this.mClientWidth;\n    this.mCtx.canvas.height = this.mClientHeight;\n  }\n\n  __onResize(msg, rect) {\n    super.__onResize(msg, rect);\n\n    this.mCtx.canvas.width = this.mClientWidth;\n    this.mCtx.canvas.height = this.mClientHeight;\n  }\n\n  /**\n   * setTransform\n   *\n   * @param {Matrix} m\n   *\n   * @return {void}\n   */\n  setTransform(m) {\n    super.setTransform(m);\n\n    let v = m.value;\n    this.mCtx.setTransform(v[0], v[1], v[2], v[3], v[4], v[5]);\n  }\n\n\n  /**\n   * globalAlpha\n   *\n   * @param {number} value\n   *\n   * @return {void}\n   */\n  set globalAlpha(value) {\n    this.mGlobalAlpha = value;\n    this.mCtx.globalAlpha = value;\n  }\n\n\n  /**\n   * globalBlendMode\n   *\n   * @param {string} blendMode\n   *\n   * @return {void}\n   */\n  set globalBlendMode(blendMode) {\n    if (blendMode === BlendMode.AUTO)\n      return;\n\n    this.mGlobalBlendMode = blendMode;\n    this.mCtx.globalCompositeOperation = blendMode;\n  }\n\n  /**\n   * drawImage\n   *\n   * @param {Texture} texture\n   *\n   * @return {void}\n   */\n  drawImage(texture) {\n    let w = texture.width;\n    let h = texture.height;\n    let ox = texture.untrimmedRect.x;\n    let oy = texture.untrimmedRect.y;\n\n    this.mCtx.drawImage(texture.native, texture.region.x, texture.region.y, w, h, ox, oy, w, h);\n  }\n\n  /**\n   * drawText\n   *\n   * @override\n   * @param {string} text\n   * @param {TextInfo} style\n   * @param {Rectangle} bounds\n   * @param {number} textWidth\n   * @param {number} textHeight\n   *\n   * @return {void}\n   */\n  drawText(text, style, bounds, textWidth, textHeight) {\n    this.mCtx.beginPath();\n    this.mCtx.rect(bounds.x, bounds.y, bounds.width, bounds.height);\n    this.mCtx.clip();\n\n    this.mCtx.font = `${style.style} ${style.weight} ${style.size}px \"${style.name}\"`;\n    this.mCtx.fillStyle = this.hexColorToString(style.color);\n\n    let x = 0;\n    if (style.align === 'center')\n      x = (bounds.width * 0.5) - textWidth * 0.5;\n\n    else if (style.align === 'right')\n      x = bounds.width - textWidth;\n\n    this.mCtx.textBaseline = 'top';\n    this.mCtx.fillText(text, x, 0);\n\n    if (style.strokeThickness > 0) {\n      this.mCtx.lineWidth = style.strokeThickness;\n      this.mCtx.strokeStyle = this.hexColorToString(style.strokeColor);\n      this.mCtx.strokeText(text, x, 0);\n    }\n    this.mCtx.closePath();\n  }\n\n  /**\n   * clear\n   *\n   * @return {void}\n   */\n  clear() {\n    this.mCtx.clearRect(0, 0, this.mCtx.canvas.width, this.mCtx.canvas.height);\n  }\n\n  /**\n   * beginFrame\n   *\n   * @return {void}\n   */\n  beginFrame() {\n    super.beginFrame();\n\n    this.clear();\n    this.mCtx.save();\n  }\n\n  /**\n   * endFrame\n   *\n   * @return {void}\n   */\n  endFrame() {\n    super.endFrame();\n\n    this.mCtx.restore();\n  }\n\n  /**\n   * getTextureFromCanvas - Description\n   *\n   * @param {HTMLElement} canvas Description\n   *\n   * @return {Texture|null} Description\n   */\n  getTextureFromCanvas(canvas) {\n    return new Texture(canvas, new Rectangle(0, 0, canvas.width, canvas.height));\n  }\n\n  /**\n   * save\n   *\n   * @override\n   * @param {GameObject|null} gameObject Used for internal binding.\n   *\n   * @return {void}\n   */\n  save(gameObject) {\n    this.mCtx.save();\n  }\n\n  /**\n   * restore\n   *\n   * @return {void}\n   */\n  restore() {\n    this.mCtx.restore();\n  }\n}\n","\nclass DOMDriver extends VideoNullDriver {\n  /**\n   * @param  {HTMLElement} containerElement description\n   * @param  {number} width            description\n   * @param  {number} height           description\n   */\n  constructor(containerElement, width, height) {\n    super(containerElement, width, height);\n\n    /** @type {number} */\n    this.mGlobalAlpha = 1;\n\n    /** @type {Array<Element>} */\n    this.mCache = [];\n\n    /** @type {number} */\n    this.mCounter = 0;\n\n    /** @type {boolean} */\n    this.mPixelated = true;\n\n    /** @type {GameObject|null} */\n    this.mCurrentObject = null;\n    this.__initCSS();\n  }\n\n  /**\n   * save - Description\n   *\n   * @override\n   * @param {GameObject|null} gameObject Used for internal binding.\n   *\n   * @return {void} Description\n   */\n  save(gameObject) {\n    this.mCurrentObject = gameObject;\n  }\n\n  /**\n   * __initCSS - description\n   *\n   * @return {void}  description\n   */\n  __initCSS() {\n    let imgRendering = 'image-rendering:optimizeSpeed; image-rendering:optimize-contrast; image-rendering:crisp-edges; image-rendering:pixelated';\n\n    let sSprite = document.createElement('style');\n    sSprite.type = 'text/css';\n    sSprite.innerHTML = '.sprite { position: absolute; background-repeat: no-repeat; cursor: default !important; -webkit-transform-origin: 0px 0px;}';\n    document.getElementsByTagName('head')[0].appendChild(sSprite);\n\n    let sSpritePixelated = document.createElement('style');\n    sSpritePixelated.type = 'text/css';\n    sSpritePixelated.innerHTML = '.sprite-p { position: absolute; background-repeat: no-repeat; cursor: default !important; -webkit-transform-origin: 0px 0px; ' + imgRendering + '}';\n    document.getElementsByTagName('head')[0].appendChild(sSpritePixelated);\n\n    let sText = document.createElement('style');\n    sText.type = 'text/css';\n    sText.innerHTML = '.text { position: absolute; white-space: pre; overflow: hidden; cursor: default !important; -webkit-transform-origin: 0px 0px;}';\n    document.getElementsByTagName('head')[0].appendChild(sText);\n\n    let sViewport = document.createElement('style');\n    sViewport.type = 'text/css';\n    sViewport.innerHTML = '.viewport { width: 100%; height: 100%; position: relative; overflow: hidden; cursor: default; }';\n    document.getElementsByTagName('head')[0].appendChild(sViewport);\n\n    this.mContainerElement.className = 'viewport';\n  }\n\n  /**\n   * beginFrame - description\n   *\n   * @return {void}  description\n   */\n  beginFrame() {\n    this.mCounter = 0;\n  }\n\n  /**\n   * endFrame - description\n   *\n   * @return {void}  description\n   */\n  endFrame() {\n    if (this.mCounter === this.mCache.length)\n      return;\n\n    //TODO: cleanup unused divs\n    //TODO: remove them instead of hiding\n    for (let i = this.mCounter; i < this.mCache.length; i++) {\n      let el = this.mCache[i];\n\n      el.parentNode.removeChild(el);\n    }\n\n    this.mCache.splice(this.mCounter);\n  }\n\n  /**\n   * getTextureFromCanvas - Description\n   *\n   * @param {HTMLElement} canvas Description\n   *\n   * @return {Texture|null} Description\n   */\n  getTextureFromCanvas(canvas) {\n    return Texture.fromCanvasAsImage(canvas);\n  }\n\n  /**\n   * drawImage - description\n   *\n   * @param  {Texture} texture description\n   * @return {void}         description\n   */\n  drawImage(texture) {\n    /** @type {Matrix|null} */\n    let oldTransform = this.mTransform;\n\n    if (texture.untrimmedRect.x !== 0 || texture.untrimmedRect.y !== 0) {\n      Matrix.__cache.set(1, 0, 0, 1, texture.untrimmedRect.x, texture.untrimmedRect.y);\n      this.mTransform.append(Matrix.__cache);\n    }\n\n    let el = this.__popElement(this.mPixelated ? 'sprite-p' : 'sprite');\n    this.__updateElementCommon(el);\n    this.__updateImageElement(el, texture);\n\n    this.mTransform = oldTransform;\n  }\n\n  /**\n   * drawText - description\n   *\n   * @override\n   * @param {string} text\n   * @param {TextInfo} style\n   * @param {Rectangle} bounds\n   * @param {number} textWidth\n   * @param {number} textHeight\n   *\n   * @return {void}                      description\n   */\n  drawText(text, style, bounds, textWidth, textHeight) {\n    let el = this.__popElement('text');\n    this.__updateElementCommon(el);\n\n    // TODO: check this type. review the code.\n    this.__updateTextElement( /** @type {HTMLElement} */ (el), text, style, bounds);\n  }\n\n  /**\n   * __popElement - Description\n   *\n   * @param {string} className Description\n   *\n   * @return {Element} Description\n   */\n  __popElement(className) {\n    this.mCounter++;\n\n    if (this.mCounter <= this.mCache.length)\n      return this.mCache[this.mCounter - 1];\n\n    let el = document.createElement('div');\n    el.className = className;\n    this.mContainerElement.appendChild(el);\n\n    this.mCache.push(el);\n    return (el);\n  }\n\n  /**\n   * __updateElementCommon - Description\n   *\n   * @param {Element} el Description\n   *\n   * @return {void} Description\n   */\n  __updateElementCommon(el) {\n    let v = this.mTransform.value;\n\n    // TODO: slow, rework\n    // NOTE: toFixed(0) is faster then toFixed(6)\n    let transform = `matrix(${v[0].toFixed(6)}, ${v[1].toFixed(6)}, ${v[2].toFixed(6)}, ${v[3].toFixed(6)}, ${v[4].toFixed(6)}, ${v[5].toFixed(6)})`;\n    //let transform = `matrix(${v[0]}, ${v[1]}, ${v[2]}, ${v[3]}, ${v[4]}, ${v[5]})`;\n\n    //console.log(el.style.transform, transform);\n    if (el.style.webkitTransform !== transform)\n      el.style.webkitTransform = transform;\n\n    //el.style.transform = transform;\n\n    //if (el.style.opacity != this.mGlobalAlpha)\n    el.style.opacity = this.mGlobalAlpha; // would be faster to not compare string and int\n\n    //if (el.style.backgroundImage !== '') {\n    //el.style.backgroundImage = '';\n    //console.log('reset img');\n    //}\n\n    // if (el.style.width !== null)\n    //   el.style.width = null;\n    //\n    // if (el.style.height !== null)\n    //   el.style.height = null;\n\n    // if (el.style.display === 'none')\n    //   el.style.display = 'block';\n  }\n\n  /**\n   * __updateImageElement - description\n   *\n   * @param  {Element} el      description\n   * @param  {Texture} texture description\n   * @return {void}         description\n   */\n  __updateImageElement(el, texture) {\n    if (texture) {\n      let url = 'url(' + texture.native.src + ')';\n\n      if (el.style.backgroundImage !== url)\n        el.style.backgroundImage = url;\n\n      if (texture.isSubTexture) {\n        let vBackgroundPosition = `${-texture.region.x}px ${-texture.region.y}px`;\n\n        if (el.style.backgroundPosition !== vBackgroundPosition)\n          el.style.backgroundPosition = vBackgroundPosition;\n      }\n    } else {\n      el.style.backgroundImage = 'none';\n    }\n\n    if (el.style.width != texture.width + 'px')\n      el.style.width = texture.width + 'px';\n\n    if (el.style.height != texture.height + 'px')\n      el.style.height = texture.height + 'px';\n\n    if (el.innerHTML !== '')\n      el.innerHTML = '';\n  }\n\n  /**\n   * __updateTextElement - Description\n   *\n   * @param {HTMLElement} el     Description\n   * @param {string} text   Description\n   * @param {TextInfo} style  Description\n   * @param {Rectangle} bounds Description\n   *\n   * @return {void} Description\n   */\n  __updateTextElement(el, text, style, bounds) {\n    el.innerHTML = text;\n    el.style.fontSize = style.size + 'px';\n\n    if (el.style.width !== bounds.width + 'px')\n      el.style.width = bounds.width + 'px';\n\n    if (el.style.height !== bounds.height + 'px')\n      el.style.height = bounds.height + 'px';\n\n    if (el.style.fontFamily !== style.name)\n      el.style.fontFamily = style.name;\n\n    let color = this.hexColorToString(style.color);\n\n    if (el.style.color != color)\n      el.style.color = color;\n\n    if (el.style.fontStyle !== style.style)\n      el.style.fontStyle = style.style;\n\n    if (el.style.fontWeight != style.weight)\n      el.style.fontWeight = style.weight;\n\n    if (el.style.textAlign !== style.align)\n      el.style.textAlign = style.align;\n\n    if (style.strokeThickness > 0) {\n      let strokeColor = this.hexColorToString(style.strokeColor);\n\n      if (el.style.webkitTextStrokeColor != strokeColor)\n        el.style.webkitTextStrokeColor = strokeColor;\n\n      if (el.style.webkitTextStrokeWidth != style.strokeThickness + 'px') {\n        el.style.webkitTextStrokeWidth = style.strokeThickness + 'px';\n      }\n    }\n\n    if (el.style.backgroundImage !== 'none')\n      el.style.backgroundImage = 'none';\n  }\n}\n","\nclass DisplayObject extends GameObject {\n  constructor() {\n    super();\n\n    /** @type {number} */\n    this.mAlpha = 1;\n\n    /** @type {string} */\n    this.blendMode = BlendMode.AUTO;\n\n    /** @type {boolean} */\n    this.mVisible = true;\n  }\n\n  /**\n   * __render - Description\n   *\n   * @param {VideoNullDriver} video           Description\n   * @param {number} time            Description\n   * @param {number} parentAlpha     Description\n   * @param {string} parentBlendMode Description\n   *\n   * @return {void} Description\n   */\n  __render(video, time, parentAlpha, parentBlendMode) {\n    if (this.mVisible === false)\n      return;\n\n    this.onRender(video, time);\n\n    let child = null;\n    for (var i = 0; i < this.mChildren.length; i++) {\n      child = this.mChildren[i];\n      child.__render(video, time, parentAlpha, parentBlendMode);\n    }\n  }\n\n  /**\n   * alpha - Description\n   *\n   * @return {number} Description\n   */\n  get alpha() {\n    return this.mAlpha;\n  }\n\n  /**\n   * alpha - Description\n   *\n   * @param {number} value Description\n   *\n   * @return {void} Description\n   */\n  set alpha(value) {\n    this.mAlpha = Math.clamp(value, 0, 1);\n  }\n\n\n  /**\n   * visible - Description\n   *\n   * @return {boolean} Description\n   */\n  get visible() {\n    return this.mVisible;\n  }\n\n\n  /**\n   * visible - Description\n   *\n   * @param {boolean} value Description\n   *\n   * @return {void} Description\n   */\n  set visible(value) {\n    this.mVisible = value;\n  }\n}\n","\nclass TextInfo {\n  /**\n   * @param  {string=} name = 'sans-serif' description\n   * @param  {number=} color = '0x000000' description\n   * @param  {number=} size = '14' description\n   * @param  {TextInfo.FontStyle=} style = 'normal' description\n   * @param  {TextInfo.FontWeight=} weight = '400' description\n   * @param  {TextInfo.FontAlign=} align = 'left' description\n   * @param  {number=} strokeThickness = '0' description\n   * @param  {number=} strokeColor = '0xffffff' description\n   */\n  constructor(name = 'sans-serif', color = 0x000000, size = 14, style = TextInfo.FontStyle.NORMAL, weight = TextInfo.FontWeight.NORMAL, align = TextInfo.FontAlign.LEFT, strokeThickness = 0, strokeColor = 0xffffff) {\n\n    /** @type {string} */\n    this.name = name;\n\n    /** @type {number} */\n    this.size = size;\n\n    /** @type {number} */\n    this.color = color;\n\n    /** @type {TextInfo.FontStyle} */\n    this.style = style;\n\n    /** @type {TextInfo.FontWeight} */\n    this.weight = weight;\n\n    /** @type {TextInfo.FontAlign} */\n    this.align = align;\n\n    /** @type {number} */\n    this.strokeThickness = strokeThickness;\n\n    /** @type {number} */\n    this.strokeColor = strokeColor;\n  }\n}\n\n/**\n * @enum {string}\n */\nTextInfo.FontStyle = {\n  NORMAL: 'normal',\n  ITALIC: 'italic'\n};\n\n/**\n * @enum {string}\n */\nTextInfo.FontWeight = {\n  NORMAL: '400',\n  BOLD: '700',\n  SUPERBOLD: '800'\n};\n\n/**\n * @enum {string}\n */\nTextInfo.FontAlign = {\n  LEFT: 'left',\n  RIGHT: 'right',\n  CENTER: 'center'\n};\n","\nclass Sprite extends DisplayObject {\n\n  /**\n   * constructor - Creates a new Sprite object instance.\n   *\n   * @param {Texture|string|null} texture The Texture instance or null.\n   */\n  constructor(texture = null) {\n    super();\n\n    /**\n     * @private\n     * @type {Texture|null} */\n    this.mTexture = null;\n\n    if (texture !== null && texture.constructor === String)\n      this.mTexture = AssetManager.default.getTexture(/** @type {string} */ (texture));\n    else\n      this.mTexture = /** @type {Texture} */ (texture);\n  }\n\n  /**\n   * @override\n   * @private\n   * @param {VideoNullDriver} video\n   * @param {number} time\n   * @param {number} parentAlpha\n   * @param {string} parentBlendMode\n   *\n   * @return {void}\n   */\n  __render(video, time, parentAlpha, parentBlendMode) {\n    if (this.mAlpha <= 0 || this.mVisible === false)\n      return;\n\n    let tmpBlendMode = BlendMode.AUTO;\n\n    if (this.mTexture !== null) {\n      video.save(this);\n      video.setTransform(this.worldTransformation);\n      video.globalAlpha = parentAlpha * this.mAlpha;\n      video.globalBlendMode = tmpBlendMode = this.blendMode === BlendMode.AUTO ? parentBlendMode : this.blendMode;\n      video.drawImage(this.mTexture);\n      video.restore();\n    }\n\n    super.__render(video, time, parentAlpha * this.mAlpha, tmpBlendMode);\n  }\n\n  /**\n   * onGetLocalBounds - Returns a rectangle that completely encloses the object in local coordinate system.\n   *\n   * @override\n   * @protected\n   * @param {Rectangle=} outRect Description\n   *\n   * @return {Rectangle} The new Rectangle or outRect with .\n   */\n  onGetLocalBounds(outRect = undefined) {\n    outRect = outRect || new Rectangle();\n\n    if (!this.mTexture)\n      return outRect;\n\n    return outRect.set(0, 0, this.mTexture.untrimmedRect.width, this.mTexture.untrimmedRect.height);\n  }\n\n  /**\n   * texture - Returns the current Texture on this sprite.\n   *\n   * @return {Texture|null} The current texture set on this Sprite or null.\n   */\n  get texture() {\n    return this.mTexture;\n  }\n\n  /**\n   * texture - Sets the Texture on this sprite.\n   *\n   * @param {Texture|null} texture Texture to apply on.\n   *\n   * @return {void}\n   */\n  set texture(texture) {\n    if (this.mTexture === texture)\n      return;\n\n    this.mTexture = texture;\n  }\n\n  set touchable(value) {\n    let c = this.getComponent(InputComponent);\n\n    if (value === true) {\n      if (c === null)\n        this.addComponent(new InputComponent());\n      else\n        c.touchable = true;\n    } else {\n      if (c !== null)\n        this.removeComponent(c);\n    }\n  }\n\n  get touchable() {\n    let c = this.getComponent(InputComponent);\n    return c !== null && c.touchable === true;\n  }\n}\n","\nclass TextField extends DisplayObject {\n  /**\n   * @param  {string=} text = ''            description\n   * @param  {number=} size = 14        description\n   * @param  {string=} name = \"sans-serif\" description\n   * @param {TextInfo=} style\n   */\n  constructor(text = '', size = 14, name = 'sans-serif', style = undefined) {\n    super();\n\n    /** @private @type {string} */\n    this.mText = text;\n\n    /** @private @type {boolean} */\n    this.mNeedInvalidate = true;\n\n    /** @private @type {Rectangle} */\n    this.mCacheBounds = new Rectangle();\n\n    /** @private @type {number} */\n    this.mFieldWidth = 0;\n\n    /** @private @type {number} */\n    this.mFieldHeight = 0;\n\n    /** @private @type {number} */\n    this.mTextWidth = 0;\n\n    /** @private @type {number} */\n    this.mTextHeight = 0;\n\n    /** @private @type {TextInfo} */\n    this.mStyle = style || new TextInfo();\n\n    /** @private @type {string} */\n    this.mStyle.name = name || style.name;\n\n    /** @private @type {number} */\n    this.mStyle.size = size || style.size;\n\n    /** @public @type {boolean} */\n    this.mAutoSize = true;\n\n    this.__validate(this.mCacheBounds);\n  }\n\n  /**\n   * __render - Description\n   * @private @override\n   * @param {VideoNullDriver} video           Description\n   * @param {number} time            Description\n   * @param {number} parentAlpha     Description\n   * @param {string} parentBlendMode Description\n   *\n   * @return {void} Description\n   */\n  __render(video, time, parentAlpha, parentBlendMode) {\n    if (this.mAlpha <= 0 || this.mVisible === false)\n      return;\n\n    this.__validate(this.mCacheBounds);\n\n    let tmpBlendMode = BlendMode.AUTO;\n\n    video.save(this);\n    video.setTransform(this.worldTransformation);\n    video.globalAlpha = parentAlpha * this.mAlpha;\n    video.globalBlendMode = tmpBlendMode = this.blendMode === BlendMode.AUTO ? parentBlendMode : this.blendMode;\n    video.drawText(this.mText, this.mStyle, this.mCacheBounds, this.mTextWidth, this.mTextHeight);\n    video.restore();\n\n    super.__render(video, time, parentAlpha * this.mAlpha, tmpBlendMode);\n  }\n\n  /**\n   * onGetLocalBounds - Description\n   *\n   * @protected @override\n   * @param {Rectangle=} outRect Description\n   *\n   * @return {Rectangle} bounds in local space withoout taking care about transformation matrix\n   */\n  onGetLocalBounds(outRect = undefined) {\n    outRect = outRect || new Rectangle();\n    return this.__validate(outRect);\n  }\n\n\n  /**\n   * __validate - Description\n   *\n   * @private\n   * @param {Rectangle} outRect Description\n   *\n   * @return {Rectangle} bounds in local space withoout taking care about transformation matrix\n   */\n  __validate(outRect) {\n    let strokeCorrection = 0 - this.mStyle.strokeThickness * 0.5;\n    if (this.mNeedInvalidate === false)\n      return outRect.set(strokeCorrection, strokeCorrection, this.mFieldWidth, this.mFieldHeight);\n\n    let driver = Black.instance.video;\n    let vSize = driver.measureText(this.mText, this.mStyle);\n    this.mTextWidth = vSize.x;\n    this.mTextHeight = vSize.y;\n\n    if (this.mAutoSize) {\n      this.mFieldWidth = this.mTextWidth;\n      this.mFieldHeight = this.mTextHeight;\n    }\n\n    this.mNeedInvalidate = false;\n    return outRect.set(strokeCorrection, strokeCorrection, this.mFieldWidth, this.mFieldHeight);\n  }\n\n\n  /**\n   * size - Description\n   *\n   * @public\n   * @return {number} Description\n   */\n  get size() {\n    return this.mStyle.size;\n  }\n\n  /**\n   * size - Description\n   *\n   * @param {number} value Description\n   * @public\n   *\n   * @return {void} Description\n   */\n  set size(value) {\n    this.mStyle.size = value;\n    this.mNeedInvalidate = true;\n  }\n\n  /**\n   * font - Description\n   *\n   * @public\n   * @return {string} Description\n   */\n  get font() {\n      return this.mStyle.name;\n    }\n    /**\n     * font - Description\n     *\n     * @param {string} value Description\n     * @public\n     *\n     * @return {void} Description\n     */\n\n  set font(value) {\n    this.mStyle.name = value;\n    this.mNeedInvalidate = true;\n  }\n\n  /**\n   * color - Description\n   *\n   * @public\n   * @return {number} Description\n   */\n  get color() {\n    return this.mStyle.color;\n  }\n\n  /**\n   * color - Description\n   *\n   * @param {number} value Description\n   * @public\n   *\n   * @return {void} Description\n   */\n  set color(value) {\n    this.mStyle.color = value;\n  }\n\n  /**\n   * style - Description\n   *\n   * @public\n   * @return {TextInfo.FontStyle} Description\n   */\n  get style() {\n    return this.mStyle.style;\n  }\n\n  /**\n   * style - Description\n   *\n   * @param {TextInfo.FontStyle} value Description\n   * @public\n   *\n   * @return {void} Description\n   */\n  set style(value) {\n    this.mStyle.style = value;\n    this.mNeedInvalidate = true;\n  }\n\n  /**\n   * weight - Description\n   *\n   * @public\n   * @return {TextInfo.FontWeight} Description\n   */\n  get weight() {\n    return this.mStyle.weight;\n  }\n\n  /**\n   * weight - Description\n   *\n   * @param {TextInfo.FontWeight} value Description\n   * @public\n   *\n   * @return {void} Description\n   */\n  set weight(value) {\n    this.mStyle.weight = value;\n    this.mNeedInvalidate = true;\n  }\n\n  /**\n   * align - Description\n   *\n   * @public\n   * @return {TextInfo.FontAlign} Description\n   */\n  get align() {\n    return this.mStyle.align;\n  }\n\n  /**\n   * align - Description\n   *\n   * @param {TextInfo.FontAlign} value Description\n   * @public\n   *\n   * @return {void} Description\n   */\n  set align(value) {\n    this.mStyle.align = value;\n  }\n\n  /**\n   * strokeColor - Description\n   *\n   * @public\n   * @return {number} Description\n   */\n  get strokeColor() {\n    return this.mStyle.strokeColor;\n  }\n\n  /**\n   * strokeColor - Description\n   *\n   * @param {number} value Description\n   * @public\n   *\n   * @return {void} Description\n   */\n  set strokeColor(value) {\n    this.mStyle.strokeColor = value;\n  }\n\n  /**\n   * strokeThickness - Description\n   *\n   * @public\n   * @return {number} Description\n   */\n  get strokeThickness() {\n    return this.mStyle.strokeThickness;\n  }\n\n  //noinspection JSAnnotator\n  /**\n   * strokeThickness - Description\n   * @public\n   *\n   * @param {number} value Description\n   *\n   * @return {void} Description\n   */\n  set strokeThickness(value) {\n    if (value === this.mStyle.strokeThickness)\n      return;\n\n    this.mStyle.strokeThickness = value;\n    this.mNeedInvalidate = true;\n  }\n\n  /**\n   * fieldWidth - Description\n   *\n   * @public\n   * @return {number} Description\n   */\n  get fieldWidth() {\n    return this.mFieldWidth;\n  }\n\n  /**\n   * fieldWidth - Description\n   *\n   * @param {number} value Description\n   * @public\n   *\n   * @return {void} Description\n   */\n  set fieldWidth(value) {\n    if (this.mAutoSize || value === this.mFieldWidth)\n      return;\n\n    this.mFieldWidth = value;\n    this.mNeedInvalidate = true;\n  }\n\n  /**\n   * fieldHeight - Description\n   *\n   * @public\n   * @return {number} Description\n   */\n  get fieldHeight() {\n    return this.mFieldHeight;\n  }\n\n\n  /**\n   * fieldHeight - Description\n   *\n   * @param {number} value Description\n   * @public\n   *\n   * @return {void} Description\n   */\n  set fieldHeight(value) {\n    if (this.mAutoSize || value === this.mFieldHeight)\n      return;\n\n    this.mFieldHeight = value;\n    this.mNeedInvalidate = true;\n  }\n\n  /**\n   * @public text - Description\n   *\n   * @return {string} Description\n   */\n  get text() {\n    return this.mText;\n  }\n\n  /**\n   * text - Description\n   *\n   * @param {string} value Description\n   * @public\n   *\n   * @return {void} Description\n   */\n  set text(value) {\n    if (this.mText === value)\n      return;\n\n    this.mText = value;\n    this.mNeedInvalidate = true;\n  }\n\n  /**\n   * autoSize - Description\n   *\n   * @return {boolean} Description\n   */\n  get autoSize() {\n    return this.mAutoSize;\n  }\n\n  /**\n   * autoSize - Description\n   *\n   * @param {boolean} value Description\n   *\n   * @return {void} Description\n   */\n  set autoSize(value) {\n    if (this.mAutoSize === value)\n      return;\n\n    this.mAutoSize = value;\n    this.mNeedInvalidate = true;\n  }\n}\n","\nclass Device {\n  constructor() {\n    /** @type {Device} */\n    this.constructor.mInstance = this;\n\n    /** @type {number} */\n    this.mPixelRatio = 0;\n\n    /** @type {number} */\n    Device.mInstance.mPixelRatio = Device.getDevicePixelRatio();\n  }\n\n  /**\n   * @return {string}\n   */\n  static get os() {\n    var userAgent = navigator.userAgent || navigator.vendor || window.opera;\n\n    if (/windows phone/i.test(userAgent))\n      return 'Windows Phone';\n\n    if (/android/i.test(userAgent))\n      return 'Android';\n\n    if (/iPad|iPhone|iPod/.test(userAgent)/* && !window.MSStream*/)\n      return 'iOS';\n\n    return 'unknown';\n  }\n\n  /**\n   * isTouch - Description\n   *\n   * @return {boolean} Description\n   */\n  static get isTouch() {\n    let hasEvent = 'ontouchstart' in window;\n    if (hasEvent)\n      return true;\n\n    if (navigator.maxTouchPoints > 0)\n      return true;\n\n    return false;\n  }\n\n  /**\n   * isMobile - Description\n   *\n   * @return {boolean} Description\n   */\n  static get isMobile() {\n    return /Mobi/.test(navigator.userAgent);\n  }\n\n  /**\n   * pixelRatio - Description\n   *\n   * @return {number} Description\n   */\n  static get pixelRatio() {\n    return Device.mInstance.mPixelRatio;\n  }\n\n  /**\n   * getDevicePixelRatio - Description\n   *\n   * @suppress {missingProperties}\n   *\n   * @return {number} Description\n   */\n  static getDevicePixelRatio() {\n    if (window.screen.systemXDPI !== undefined && window.screen.logicalXDPI !== undefined && window.screen.systemXDPI > window.screen.logicalXDPI)\n      return window.screen.systemXDPI / window.screen.logicalXDPI;\n    else if (window.devicePixelRatio !== undefined)\n      return window.devicePixelRatio;\n\n    return 1;\n  }\n\n}\n\n/** @type {Device}\n * @nocollapse\n */\nDevice.mInstance = null;\n","\nclass Scatter {\n  constructor() {}\n\n  /**\n   * getValue\n   *\n   * @return {*}\n   */\n  getValue() {}\n\n\n  /**\n   * getValueAt\n   *\n   * @param {number} t\n   *\n   * @return {*}\n   */\n  getValueAt(t) {}\n}\n","\nclass FloatScatter extends Scatter {\n  constructor(min, max = undefined, ease = null) {\n    super();\n\n    // NOTE: dont make us @private @member\n    this.min = min;\n    this.max = max == null ? min : max;\n    \n    this.ease = ease;\n  }\n\n\n  /**\n   * getValue\n   *\n   * @return {number}\n   */\n  getValue() {\n    return Math.random() * (this.max - this.min) + this.min;\n  }\n\n\n  /**\n   * getValueAt\n   *\n   * @param {number} t\n   *\n   * @return {number}\n   */\n  getValueAt(t) {\n    if (this.ease !== null)\n      t = this.ease(t);\n\n    return this.min + t * (this.max - this.min);\n  }\n}\n","\nclass VectorScatter extends Scatter {\n  constructor(minX, minY, maxX, maxY) {\n    super();\n\n    // NOTE: dont make us @private @member\n    this.minX = minX;\n    this.minY = minY;\n    this.maxX = maxX;\n    this.maxY = maxY;\n  }\n\n\n  /**\n   * getValue\n   *\n   * @return {Vector}\n   */\n  getValue() {\n    let outVector = new Vector();\n    outVector.x = Math.random() * (this.maxX - this.minX) + this.minX;\n    outVector.y = Math.random() * (this.maxY - this.minY) + this.minY;\n    return outVector;\n  }\n\n\n  /**\n   * getValueAt\n   *\n   * @param {number} t\n   *\n   * @return {Vector}\n   */\n  getValueAt(t) {\n    let outVector = new Vector();\n    outVector.x = this.minX + t * (this.maxX - this.minX);\n    outVector.y = this.minY + t * (this.maxY - this.minY);\n    return outVector;\n  }\n}\n","\nclass FloatCurveScatter extends Scatter {\n  /**\n   * @param {...number} points Coordinates: startX, startY, cpStartX, cpStartY, cpEndX, cpEndY, endX/start2X, endY/start2Y, cp2StartX, cp2StartX... 8 or 14 or 20...\n   */\n  constructor(...points) {\n    super();\n\n    this.mCurve = new Curve();\n    this.mCurve.baked = true;\n    this.mCurve.set(...points);\n\n    this.mCache = new Vector();\n  }\n\n  getValue() {\n    let t = Math.random();\n    this.mCurve.interpolate(t, this.mCache);\n    return this.mCache.y;\n  }\n\n  getValueAt(t) {\n    this.mCurve.interpolate(t, this.mCache);\n    return this.mCache.y;\n  }\n}\n\n\nclass VectorCurveScatter extends Scatter {\n  /**\n   * @param {...number} points Coordinates: startX, startY, cpStartX, cpStartY, cpEndX, cpEndY, endX/start2X, endY/start2Y, cp2StartX, cp2StartX... 8 or 14 or 20...\n   */\n  constructor(...points) {\n    super();\n\n    this.mCurve = new Curve();\n    this.mCurve.baked = true;\n    this.mCurve.set(...points);\n\n    this.mCache = new Vector();\n  }\n\n\n  getValue() {\n    let t = Math.random();\n    this.mCurve.interpolate(t, this.mCache);\n    return this.mCache;\n  }\n\n\n  getValueAt(t) {\n    this.mCurve.interpolate(t, this.mCache);\n    return this.mCache;\n  }\n}\n","\nclass Action {\n\n  /**\n   * preUpdate - Description\n   *\n   * @param {number} dt Description\n   * @param {number} t  Description\n   *\n   * @return {void} Description\n   */\n  preUpdate(dt, t) {}\n\n\n  /**\n   * @param {Emitter} emmiter\n   * @param {Particle} particle\n   * @param {number} dt\n   * @param {number} t\n   *\n   * @return {void}\n   */\n  update(emmiter, particle, dt, t) {}\n\n\n  /**\n   * postUpdate\n   *\n   * @param {number} dt\n   * @param {number} t\n   *\n   * @return {void}\n   */\n  postUpdate(dt, t) {}\n}\n","/**\n * @extends Action\n */\n\nclass Acceleration extends Action {\n  constructor(vectorScatter) {\n    super();\n\n    this.scatter = vectorScatter;\n  }\n\n  /**\n   * @override\n   * @param {Emitter} emmiter\n   * @param {Particle} particle\n   * @param {number} dt\n   * @param {number} t\n   *\n   * @return {void}\n   */\n  update(emmiter, particle, dt, t) {\n    let v = this.scatter.getValue();\n\n    particle.ax += v.x;\n    particle.ay += v.y;\n  }\n}\n","/**\n * @extends Action\n */\n\nclass AlphaOverLife extends Action {\n  constructor(floatScatter) {\n    super();\n\n    this.scatter = floatScatter;\n  }\n\n  /**\n   * @override\n   * @param {Emitter} emmiter\n   * @param {Particle} particle\n   * @param {number} dt\n   * @param {number} t\n   *\n   * @return {void}\n   */\n  update(emmiter, particle, dt, t) {\n    particle.alpha = this.scatter.getValueAt(particle.energy);\n  }\n}\n","/**\n * @extends Action\n */\n\nclass ScaleOverLife extends Action {\n  constructor(floatScatter) {\n    super();\n\n    this.scatter = floatScatter;\n  }\n\n  /**\n   * @override\n   * @param {Emitter} emmiter\n   * @param {Particle} particle\n   * @param {number} dt\n   * @param {number} t\n   *\n   * @return {void}\n   */\n  update(emmiter, particle, dt, t) {\n    particle.scale = this.scatter.getValueAt(particle.energy);\n  }\n}\n","/**\n * @extends Action\n */\n\nclass RotationOverLife extends Action {\n  constructor(floatScatter) {\n    super();\n\n    this.scatter = floatScatter;\n  }\n\n  /**\n   * @override\n   * @param {Emitter} emmiter\n   * @param {Particle} particle\n   * @param {number} dt\n   * @param {number} t\n   *\n   * @return {void}\n   */\n  update(emmiter, particle, dt, t) {\n    particle.r = this.scatter.getValueAt(particle.energy);\n  }\n}\n","/**\n * @extends Action\n */\n\nclass TextureOverLife extends Action {\n  constructor(floatScatter) {\n    super();\n\n    this.scatter = floatScatter;\n  }\n\n  /**\n   * @override\n   * @param {Emitter} emmiter\n   * @param {Particle} particle\n   * @param {number} dt\n   * @param {number} t\n   *\n   * @return {void}\n   */\n  update(emmiter, particle, dt, t) {\n    particle.textureIndex = ~~this.scatter.getValueAt(particle.energy);\n  }\n}\n","\nclass Initializer {\n  /**\n   * @param {Particle} particle\n   *\n   * @return {void}\n   */  \n  initialize(particle) {}\n}\n","\nclass Life extends Initializer {\n  /**\n   * constructor - Description\n   *\n   * @param {FloatScatter} floatScatter Description\n   *\n   * @return {void} Description\n   */\n  constructor(floatScatter) {\n    super();\n\n    /** @type {FloatScatter} */\n    this.scatter = floatScatter;\n  }\n\n  /**\n   * @override\n   * @param {Particle} particle\n   *\n   * @return {void}\n   */\n  initialize(particle) {\n    particle.life = this.scatter.getValue();\n  }\n}\n","\nclass Mass extends Initializer {\n\n  /**\n   * constructor - Description\n   *\n   * @param {number} mass Description\n   *\n   * @return {void} Description\n   */\n  constructor(mass) {\n    super();\n\n    /** @type {number} */\n    this.mass = mass;\n  }\n\n  /**\n   * @override\n   * @param {Particle} particle\n   *\n   * @return {void}\n   */\n  initialize(particle) {\n    particle.mass = this.mass;\n  }\n}\n","\nclass Scale extends Initializer {\n  /**\n   * constructor - Description\n   *\n   * @param {FloatScatter} floatScatter Description\n   *\n   * @return {void} Description\n   */\n  constructor(floatScatter) {\n    super();\n\n    /** @type {FloatScatter} */\n    this.scatter = floatScatter;\n  }\n\n  /**\n   * @override\n   * @param {Particle} particle\n   *\n   * @return {void}\n   */\n  initialize(particle) {\n    particle.scale = this.scatter.getValue();\n  }\n}\n","\nclass Velocity extends Initializer {\n  /**\n   * constructor - Description\n   *\n   * @param {VectorScatter} vectorScatter Description\n   *\n   * @return {void} Description\n   */\n  constructor(vectorScatter) {\n    super();\n\n    /** @type {VectorScatter} */\n    this.scatter = vectorScatter;\n  }\n\n  /**\n   * @override\n   * @param {Particle} particle\n   *\n   * @return {void}\n   */\n  initialize(particle) {\n    // TODO: optimize!\n    let v = this.scatter.getValue();\n    particle.vx = v.x;\n    particle.vy = v.y;\n  }\n}\n","\nclass Position extends Initializer {\n\n  /**\n   * constructor - Description\n   *\n   * @param {VectorScatter} vectorScatter Description\n   *\n   * @return {void} Description\n   */\n  constructor(vectorScatter) {\n    super();\n\n    /** @type {VectorScatter} */\n    this.scatter = vectorScatter;\n  }\n\n  /**\n   * @override\n   * @param {Particle} particle\n   *\n   * @return {void}\n   */\n  initialize(particle) {\n    // TODO: optimize!\n    let v = this.scatter.getValue();\n    particle.x = v.x;\n    particle.y = v.y;\n  }\n}\n","\nclass Rotation extends Initializer {\n  /**\n   * constructor - Description\n   *\n   * @param {FloatScatter} floatScatter Description\n   *\n   * @return {void} Description\n   */\n  constructor(floatScatter) {\n    super();\n\n    /** @type {FloatScatter} */\n    this.scatter = floatScatter;\n  }\n\n  /**\n   * @override\n   * @param {Particle} particle\n   *\n   * @return {void}\n   */\n  initialize(particle) {\n    particle.r = this.scatter.getValue();\n  }\n}\n","\nclass RandomTexture extends Initializer {\n  /**\n   * constructor - Description\n   *\n   * @param {FloatScatter} floatScatter Description\n   *\n   * @return {void} Description\n   */\n  constructor(floatScatter) {\n    super();\n\n    /** @type {FloatScatter} */\n    this.scatter = floatScatter;\n  }\n\n  /**\n   * @override\n   * @param {Particle} particle\n   *\n   * @return {void}\n   */\n  initialize(particle) {\n    particle.textureIndex = ~~this.scatter.getValue();\n  }\n}\n","/**\n * @enum {number}\n */\nvar EmitterState = {\n  PENDING: 0,\n  EMITTING: 1,\n  FINISHED: 2\n};\n","\nclass Particle {\n  constructor() {\n    this.reset();\n  }\n\n  reset() {\n    /** @type {number} */\n    this.textureIndex = 0;\n\n    /** @type {number} */\n    this.scale = 1;\n\n    /** @type {number} */\n    this.alpha = 1;\n\n    /** @type {number} */\n    this.life = 1;\n\n    /** @type {number} */\n    this.age = 0;\n\n    /** @type {number} */\n    this.energy = this.age / this.life;\n\n    /** @type {number} */\n    this.mass = 0;\n\n    /** @type {number} */\n    this.x = 0;\n\n    /** @type {number} */\n    this.y = 0;\n\n    /** @type {number} */\n    this.r = 0\n\n    /** @type {number} */\n    this.vx = 0;\n\n    /** @type {number} */\n    this.vy = 0;\n\n    /** @type {number} */\n    this.ax = 0;\n\n    /** @type {number} */\n    this.ay = 0;\n  }\n\n  /**\n   * update\n   *\n   * @param {number} dt\n   *\n   * @return {void}\n   */\n  update(dt) {\n    if (this.life <= 0) {\n      this.life = 0;\n      return;\n    }\n\n    this.x += this.vx * dt;\n    this.y += this.vy * dt;\n\n    if (this.mass > 0) {\n      this.ax *= 1 / this.mass;\n      this.ay *= 1 / this.mass;\n    }\n\n    this.vx += this.ax * dt;\n    this.vy += this.ay * dt;\n\n    this.ax = 0;\n    this.ay = 0;\n\n    this.life -= dt;\n    this.age += dt;\n\n    this.energy = this.age / (this.age + this.life);\n  }\n}\n","\nclass Emitter extends DisplayObject {\n  constructor() {\n    super();\n\n    /** @type {Array<Texture>} */\n    this.mTextures = null;\n\n    /** @type {Array<Particle>} */\n    this.mParticles = [];\n\n    /** @type {Array<Particle>} */\n    this.mRecycled = [];\n\n    /** @type {Array<Initializer>} */\n    this.mInitializers = [];\n\n    /** @type {Array<Action>} */\n    this.mActions = [];\n\n    /** @type {GameObject} */\n    this.mSpace = null;\n\n    /** @type {boolean} */\n    this.mIsLocal = true;\n\n    /** @type {number} */\n    this.mMaxParticles = 10000;\n\n    /** @type {FloatScatter} */\n    this.mEmitCount = new FloatScatter(10);\n\n    /** @type {FloatScatter} */\n    this.mEmitNumRepeats = new FloatScatter(Infinity);\n\n    /** @type {number} */\n    this.mEmitNumRepeatsLeft = this.mEmitNumRepeats.getValue();\n\n    /** @type {FloatScatter} */\n    this.mEmitDuration = new FloatScatter(1);\n\n    /** @type {number} */\n    this.mEmitDurationLeft = this.mEmitDuration.getValue();\n\n    /** @type {FloatScatter} */\n    this.mEmitInterval = new FloatScatter(0.1);\n\n    /** @type {number} */\n    this.mEmitIntervalLeft = this.mEmitInterval.getValue();\n\n    /** @type {FloatScatter} */\n    this.mEmitDelay = new FloatScatter(1);\n\n    /** @type {number} */\n    this.mEmitDelayLeft = this.mEmitDelay.getValue();\n\n    /** @type {number} */\n    this.mNextUpdateAt = 0;\n\n    /** @type {EmitterState} */\n    this.mState = EmitterState.PENDING;\n\n    // /** @type {function(a:Particle, b:Particle):number} */\n    // this.mComparer = null;\n\n    /** @type {Matrix} */\n    this.__tmpLocal = new Matrix();\n\n    /** @type {Matrix} */\n    this.__tmpWorld = new Matrix();\n  }\n\n  // reset() {\n  //   this.mState = 0;\n  //\n  //   // todo: reset simulation\n  //   // todo: clear all particles\n  //   this.updateNextTick(0);\n  // }\n\n  resetState() {\n    this.mState = EmitterState.PENDING;\n  }\n\n  /**\n   * updateNextTick - Updates delay, duration, interval. Use this function each time you change one of those values.\n   *\n   * @param {number} [dt=0]\n   *\n   * @return {void}\n   */\n  updateNextTick(dt = 0) {\n    let t = Black.instance.uptime;\n    let firstEmit = false;\n\n    if (this.mState === EmitterState.PENDING) {\n      this.mNextUpdateAt = t + this.mEmitDelayLeft;\n      this.mEmitDelayLeft -= dt;\n\n      if (this.mEmitDelayLeft <= 0) {\n        this.mEmitDelayLeft = this.mEmitDelay.getValue();\n        this.mState = EmitterState.EMITTING;\n        firstEmit = true;\n      }\n    }\n\n    if (this.mState === EmitterState.EMITTING) {\n      if (this.mEmitDurationLeft <= 0) {\n        this.mEmitDurationLeft = this.mEmitDuration.getValue();\n\n        this.mEmitNumRepeatsLeft--;\n\n        if (this.mEmitNumRepeatsLeft <= 0) {\n          this.mState = EmitterState.FINISHED;\n\n          this.post('complete');\n          return;\n        } else {\n          this.mState = EmitterState.PENDING;\n          return;\n        }\n      } else {\n        // we are getting value here each update to make sure we are up to date!\n        if (firstEmit) {\n          // for a first emit we do not want to add an extra delay. emit now!\n          this.mNextUpdateAt = t\n          this.mEmitIntervalLeft = this.mEmitInterval.getValue();\n        }\n        else {\n          this.mEmitIntervalLeft -= dt;\n          this.mNextUpdateAt = t + this.mEmitIntervalLeft;\n          //console.log(this.mEmitIntervalLeft);\n\n          // reset interval\n          if (this.mEmitIntervalLeft <= 0)\n            this.mEmitIntervalLeft = this.mEmitInterval.getValue();\n        }\n      }\n\n      this.mEmitDurationLeft -= dt;\n    }\n  }\n\n\n  /**\n   * addInitializer - Adds Initializer to the end of the list.\n   *\n   * @param {Initializer} initializer\n   *\n   * @return {Initializer}\n   */\n  addInitializer(initializer) {\n    this.mInitializers.push(initializer);\n    return initializer;\n  }\n\n\n  /**\n   * addAction - Adds action to the end of the list.\n   *\n   * @param {Action} action\n   *\n   * @return {Action}\n   */\n  addAction(action) {\n    this.mActions.push(action);\n    return action;\n  }\n\n  __render(video, time, parentAlpha, parentBlendMode) {\n    video.save(this);\n\n    // set blend mode\n    let tmpBlendMode = BlendMode.AUTO;\n    video.globalBlendMode = tmpBlendMode = this.blendMode === BlendMode.AUTO ? parentBlendMode : this.blendMode;\n\n    // tmp matrices\n    let localTransform = this.__tmpLocal;\n    let worldTransform = this.__tmpWorld;\n    localTransform.identity();\n\n    let texture = null;\n\n    if (this.mTextures.length > 0) {\n      let plength = this.mParticles.length;\n      let particle;\n      for (let i = 0; i < plength; i++) {\n      //for (let i = plength - 1; i > 0; i--) {\n        particle = this.mParticles[i];\n        texture = this.mTextures[particle.textureIndex];\n\n        let tw = texture.width * 0.5;\n        let th = texture.height * 0.5;\n\n        if (particle.r === 0) {\n          let tx = particle.x - tw * particle.scale;\n          let ty = particle.y - th * particle.scale;\n          localTransform.set(particle.scale, 0, 0, particle.scale, tx, ty);\n        } else {\n          let cos = Math.cos(particle.r);\n          let sin = Math.sin(particle.r);\n          let a = particle.scale * cos;\n          let b = particle.scale * sin;\n          let c = particle.scale * -sin;\n          let d = particle.scale * cos;\n\n          let tx = particle.x - tw * a - th * c;\n          let ty = particle.y - tw * b - th * d;\n          localTransform.set(a, b, c, d, tx, ty);\n        }\n\n        if (this.mIsLocal === true) {\n          worldTransform.identity();\n          worldTransform.copyFrom(localTransform);\n          worldTransform.prepend(this.worldTransformation);\n        } else {\n          this.mSpace.worldTransformation.copyTo(worldTransform);\n          worldTransform.append(localTransform);\n        }\n\n        video.setTransform(worldTransform);\n        video.globalAlpha = parentAlpha * this.mAlpha * particle.alpha;\n        video.drawImage(texture);\n      }\n    }\n\n    video.restore();\n    super.__render(video, time, parentAlpha, parentBlendMode);\n  }\n\n  onUpdate(dt) {\n    // rate logic\n    this.updateNextTick(dt);\n\n    if (Black.instance.uptime >= this.mNextUpdateAt && this.mState === EmitterState.EMITTING)\n      this.__create(this.mEmitCount.getValue());\n\n    // main update login\n    let alength = this.mActions.length;\n    let plength = this.mParticles.length;\n\n    let t = Black.instance.uptime;\n\n    for (let i = 0; i < alength; i++)\n      this.mActions[i].preUpdate(dt, t);\n\n    let particle;\n\n    let i = this.mParticles.length;\n    while (i--) {\n      particle = this.mParticles[i];\n\n      for (let k = 0; k < alength; k++)\n        this.mActions[k].update(this, particle, dt, t);\n\n      particle.update(dt);\n\n      if (particle.life === 0) {\n        this.mRecycled.push(particle);\n        this.mParticles.splice(i, 1);\n      }\n    }\n\n    for (let j = 0; j < alength; j++)\n      this.mActions[j].postUpdate(dt, t);\n  }\n\n  __create(amount) {\n    let matrix = this.worldTransformation.clone();\n    let minv = null;\n\n    if (this.mIsLocal === false) {\n      minv = this.mSpace.worldTransformationInversed.clone();\n      matrix.prepend(minv);\n    }\n\n    for (let i = 0; i < amount; i++) {\n      let p = null;\n\n      if (this.mRecycled.length > 0) {\n        p = this.mRecycled.pop();\n      } else {\n        if (this.mParticles.length >= this.mMaxParticles)\n          return;\n\n        p = new Particle();\n      }\n\n      p.reset();\n\n      for (let k = 0; k < this.mInitializers.length; k++) {\n        let initer = this.mInitializers[k];\n        initer.initialize(p);\n      }\n\n      if (this.mIsLocal === false) {\n        matrix.transformDirectionXY(p.ax, p.ay, Vector.__cache);\n        p.ax = Vector.__cache.x;\n        p.ay = Vector.__cache.y;\n\n        matrix.transformDirectionXY(p.vx, p.vy, Vector.__cache);\n        p.vx = Vector.__cache.x;\n        p.vy = Vector.__cache.y;\n\n        matrix.transformXY(p.x, p.y, Vector.__cache);\n        p.x = Vector.__cache.x;\n        p.y = Vector.__cache.y;\n      }\n\n      this.mParticles.push(p);\n    }\n  }\n\n\n  /**\n   * maxParticles\n   *\n   * @return {number}\n   */\n  get maxParticles() {\n    return this.mMaxParticles;\n  }\n\n\n  /**\n   * maxParticles\n   *\n   * @param {number} value\n   *\n   * @return {void}\n   */\n  set maxParticles(value) {\n    if (value < 0)\n      throw new Error('Bad argument error.');\n\n    this.mMaxParticles = value;\n  }\n\n\n  /**\n   * emitCount\n   *\n   * @return {FloatScatter}\n   */\n  get emitCount() {\n    return this.mEmitCount;\n  }\n\n\n  /**\n   * emitCount\n   *\n   * @param {FloatScatter} value\n   *\n   * @return {void}\n   */\n  set emitCount(value) {\n    this.mEmitCount = value;\n  }\n\n\n  /**\n   * emitNumRepeats\n   *\n   * @return {FloatScatter}\n   */\n  get emitNumRepeats() { return this.mEmitNumRepeats; }\n\n  /**\n   * emitNumRepeats\n   *\n   * @param {FloatScatter} value\n   *\n   * @return {void}\n   */\n  set emitNumRepeats(value) { this.mEmitNumRepeats = value; this.mEmitNumRepeatsLeft = this.mEmitNumRepeats.getValue(); }\n\n\n  /**\n   * emitDuration\n   *\n   * @return {FloatScatter}\n   */\n  get emitDuration() { return this.mEmitDuration; }\n\n  /**\n   * emitDuration\n   *\n   * @param {FloatScatter} value\n   *\n   * @return {void}\n   */\n  set emitDuration(value) { this.mEmitDuration = value; this.mEmitDurationLeft = this.mEmitDuration.getValue(); }\n\n\n  /**\n   * emitInterval\n   *\n   * @return {FloatScatter}\n   */\n  get emitInterval() { return this.mEmitInterval; }\n\n  /**\n   * emitInterval\n   *\n   * @param {FloatScatter} value\n   *\n   * @return {void}\n   */\n  set emitInterval(value) { this.mEmitInterval = value; this.mEmitIntervalLeft = this.mEmitInterval.getValue(); }\n\n\n  /**\n   * emitDelay\n   *\n   * @return {FloatScatter}\n   */\n  get emitDelay() { return this.mEmitDelay; }\n\n  /**\n   * emitDelay\n   *\n   * @param {FloatScatter} value\n   *\n   * @return {void}\n   */\n  set emitDelay(value) { this.mEmitDelay = value; this.mEmitDelayLeft = this.mEmitDelay.getValue(); }\n\n\n  /**\n   * space\n   *\n   * @return {GameObject}\n   */\n  get space() { return this.mSpace; }\n\n  /**\n   * space\n   *\n   * @param {GameObject} gameObject\n   *\n   * @return {void}\n   */\n  set space(gameObject) {\n    this.mSpace = gameObject;\n    this.mIsLocal = this.mSpace === null || this.mSpace === this;\n  }\n\n\n  /**\n   * textures\n   *\n   * @return {Array<Texture>}\n   */\n  get textures() {\n    return this.mTextures;\n  }\n\n\n  /**\n   * textures\n   *\n   * @param {Array<Texture>} value\n   *\n   * @return {void}\n   */\n  set textures(value) {\n    if (value.length === 0)\n      throw new Error('At least one texture must be provided.');\n\n    this.mTextures = value;\n  }\n}\n","/**\n * @enum {number}\n */\n\nvar Key = {\n  A: 65,\n  B: 66,\n  C: 67,\n  D: 68,\n  E: 69,\n  F: 70,\n  G: 71,\n  H: 72,\n  I: 73,\n  J: 74,\n  K: 75,\n  L: 76,\n  M: 77,\n  N: 78,\n  O: 79,\n  P: 80,\n  Q: 81,\n  R: 82,\n  S: 83,\n  T: 84,\n  U: 85,\n  V: 86,\n  W: 87,\n  X: 88,\n  Y: 89,\n  Z: 90,\n  DIGIT_0: 48,\n  DIGIT_1: 49,\n  DIGIT_2: 50,\n  DIGIT_3: 51,\n  DIGIT_4: 52,\n  DIGIT_5: 53,\n  DIGIT_6: 54,\n  DIGIT_7: 55,\n  DIGIT_8: 56,\n  DIGIT_9: 57,\n  NUMPAD_0: 96,\n  NUMPAD_1: 97,\n  NUMPAD_2: 98,\n  NUMPAD_3: 99,\n  NUMPAD_4: 100,\n  NUMPAD_5: 101,\n  NUMPAD_6: 102,\n  NUMPAD_7: 103,\n  NUMPAD_8: 104,\n  NUMPAD_9: 105,\n  NUMPAD_MULTIPLY: 106,\n  NUMPAD_ADD: 107,\n  NUMPAD_SUBTRACT: 109,\n  NUMPAD_DECIMAL: 110,\n  NUMPAD_DIVIDE: 111,\n  LEFT_ARROW: 37,\n  UP_ARROW: 38,\n  RIGHT_ARROW: 39,\n  DOWN_ARROW: 40,\n  BACKSPACE: 8,\n  TAB: 9,\n  ENTER: 13,\n  SHIFT: 16,\n  CTRL: 17,\n  ALT: 18,\n  F1: 112,\n  F2: 113,\n  F3: 114,\n  F4: 115,\n  F5: 116,\n  F6: 117,\n  F7: 118,\n  F8: 119,\n  F9: 120,\n  F10: 121,\n  F11: 122,\n  F12: 123,\n  PAUSE_BREAK: 19,\n  CAPS_LOCK: 20,\n  ESCAPE: 27,\n  PAGE_UP: 33,\n  PAGE_DOWN: 34,\n  END: 35,\n  HOME: 36,\n  INSERT: 45,\n  DELETE: 46,\n  LEFT_WINDOW: 91,\n  RIGHT_WINDOW: 92,\n  CONTEXT_MENU: 93,\n  NUM_LOCK: 144,\n  SCROLL_LOCK: 145,\n  SEMI_COLON: 186,\n  EQUAL_SIGN: 187,\n  COMMA: 188,\n  DASH: 189,\n  PERIOD: 190,\n  FORWARD_SLASH: 191,\n  BACKQUOTE: 192,\n  BRAKET_LEFT: 219,\n  BACK_SLASH: 220,\n  BRAKET_RIGHT: 221,\n  SINGLE_QUOTE: 222,\n};\n","\nclass KeyInfo {\n\n  /**\n   * constructor - Description\n   *\n   * @param {Event} nativeEvent Description\n   *\n   * @return {void} Description\n   */\n  constructor(nativeEvent) {\n    this.keyCode = nativeEvent.keyCode;\n    this.code = nativeEvent.code;\n    this.char = nativeEvent.key;\n    this.shiftKey = nativeEvent.shiftKey;\n    this.altKey = nativeEvent.altKey;\n    this.ctrlKey = nativeEvent.ctrlKey;\n  }\n}\n","/*\nHas to be static class.\n\n+ before update store all events locally\n- check root object! add collider automatically? or do it on demand?\n*/\n\n\nclass Input extends System {\n  constructor() {\n    super();\n\n    /** @type {Input} */\n    this.constructor.instance = this;\n\n    /** @type {Vector} */\n    this.mPointerPosition = new Vector();\n\n    /** @type {Element} */\n    this.mDom = Black.instance.containerElement;\n\n    /** @type {Array<string>} */\n    this.mEventList = null;\n\n    /** @type {Array<string>} */\n    this.mKeyEventList = null;\n\n    this.__initListeners();\n\n    /** @type {Array<{e: Event, x: number, y:number}>} */\n    this.mPointerQueue = [];\n\n    /** @type {Array<Event>} */\n    this.mKeyQueue = [];\n\n    /** @type {Array<number>} */\n    this.mPressedKeys = [];\n\n    /** @type {boolean} */\n    this.mIsPointerDown = false;\n\n    this.mNeedUpEvent = false;\n\n    /** @type {Array<InputComponent>} */\n    this.mInputListeners = [];\n  }\n\n  __initListeners() {\n    this.mKeyEventList = Input.mKeyEventList;\n    //debugger;\n\n    if (window.PointerEvent)\n      this.mEventList = Input.mPointerEventList;\n    else if (Device.isTouch && Device.isMobile)\n      this.mEventList = Input.mTouchEventList;\n    else\n      this.mEventList = Input.mMouseEventList;\n\n    for (let i = 0; i < 6; i++)\n      this.mDom.addEventListener(this.mEventList[i], e => this.__onPointerEvent(e), false);\n\n    document.addEventListener(this.mEventList[Input.POINTER_UP], e => this.__onPointerEventDoc(e), false);\n\n    for (let i = 0; i < this.mKeyEventList.length; i++)\n      document.addEventListener(this.mKeyEventList[i], e => this.__onKeyEvent(e), false);\n  }\n\n  __sortListeners() {\n    // TODO: make it faster\n    // - try insert sort\n    this.mInputListeners.sort((x, y) => {\n      return y.gameObject.depth - x.gameObject.depth || y.gameObject.index - x.gameObject.index;\n    });\n  }\n\n\n  /**\n   * @param {Event} e\n   *\n   * @return {boolean}\n   */\n  __onKeyEvent(e) {\n    this.mKeyQueue.push(e);\n    return true;\n  }\n\n  __onPointerEventDoc(e) {\n    let over = e.target == this.mDom || e.target.parentElement == this.mDom;\n\n    if (over === false && this.mNeedUpEvent === true) {\n      this.mNeedUpEvent = false;\n      this.__pushEvent(e);\n    }\n  }\n\n\n  /**\n   * @param {Event} e Description\n   *\n   * @return {boolean} Description\n   */\n  __onPointerEvent(e) {\n    e.preventDefault();\n\n    this.__pushEvent(e);\n\n    return true;\n  }\n\n  __pushEvent(e) {\n    let /** @type {Vector|null} */ p = null;\n    if (e.type.indexOf('touch') === 0)\n      p = this.__getTouchPos(this.mDom, /** @type {TouchEvent} */ (e));\n    else\n      p = this.__getPointerPos(this.mDom, e);\n\n    this.mPointerPosition.x = p.x;\n    this.mPointerPosition.y = p.y;\n\n    this.mPointerQueue.push({\n      e: e,\n      x: p.x,\n      y: p.y\n    });\n  }\n\n\n  /**\n   * __getPointerPos - Description\n   *\n   * @param {Element} canvas Description\n   * @param {Event} evt    Description\n   *\n   * @return {Vector} Description\n   */\n  __getPointerPos(canvas, evt) {\n    let rect = canvas.getBoundingClientRect();\n    let scaleX = canvas.clientWidth / rect.width;\n    let scaleY = canvas.clientHeight / rect.height;\n    return new Vector((evt.clientX - rect.left) * scaleX, (evt.clientY - rect.top) * scaleY);\n  }\n\n  /**\n   * __getTouchPos - Description\n   *\n   * @param {Element} canvas Description\n   * @param {TouchEvent} evt    Description\n   *\n   * @return {Vector} Description\n   */\n  __getTouchPos(canvas, evt) {\n    let rect = canvas.getBoundingClientRect();\n\n    /** @type {Touch} */\n    let touch = evt.changedTouches[0]; // ios? what about android?\n    let x = touch.clientX;\n    let y = touch.clientY;\n\n    let scaleX = canvas.clientWidth / rect.width;\n    let scaleY = canvas.clientHeight / rect.height;\n    return new Vector((x - rect.left) * scaleX, (y - rect.top) * scaleY);\n  }\n\n\n  /**\n   * __addListener - Description\n   *\n   * @param {Array<InputComponent>} array Description\n   *\n   * @return {void} Description\n   */\n  __addListener(array) {\n    // check for duplicates\n    for (let i = 0; i < array.length; i++) {\n      let item = /** @type {InputComponent} */ (array[i]);\n\n      if (this.mInputListeners.indexOf(item) === -1)\n        this.mInputListeners.push(item);\n    }\n\n    this.__sortListeners();\n  }\n\n\n  /**\n   * onChildrenAdded - Description\n   *\n   * @param {GameObject} child Description\n   *\n   * @return {void} Description\n   */\n  onChildrenAdded(child) {\n    let cs = GameObject.findComponents(child, InputComponent);\n    if (!cs || cs.length === 0)\n      return;\n\n    this.__addListener(cs);\n  }\n\n\n  /**\n   * onChildrenRemoved - Description\n   *\n   * @param {GameObject} child Description\n   *\n   * @return {void} Description\n   */\n  onChildrenRemoved(child) {\n    let cs = GameObject.findComponents(child, InputComponent);\n    if (!cs || cs.length === 0)\n      return;\n\n    for (var i = cs.length - 1; i >= 0; i--) {\n      let component = cs[i];\n      let index = this.mInputListeners.indexOf( /** @type {InputComponent} */ (component));\n\n      if (index !== -1)\n        this.mInputListeners.splice(index, 1);\n    }\n\n    this.__sortListeners();\n  }\n\n\n  /**\n   * onComponentAdded - Description\n   *\n   * @param {GameObject} child     Description\n   * @param {Component} component Description\n   *\n   * @return {void} Description\n   */\n  onComponentAdded(child, component) {\n    if (component.constructor !== InputComponent)\n      return;\n\n    this.__addListener([component]);\n  }\n\n\n  /**\n   * onComponentRemoved - Description\n   *\n   * @param {GameObject} child     Description\n   * @param {Component} component Description\n   *\n   * @return {void} Description\n   */\n  onComponentRemoved(child, component) {\n    if (component.constructor !== InputComponent)\n      return;\n\n    let index = this.mInputListeners.indexOf( /** @type {InputComponent} */ (component));\n    if (index !== -1) {\n      this.mInputListeners.splice(index, 1);\n      this.__sortListeners();\n    }\n  }\n\n\n  /**\n   * onUpdate - Description\n   *\n   * @param {number} dt Description\n   *\n   * @return {void} Description\n   */\n  onUpdate(dt) {\n    let pointerPos = new Vector();\n\n    for (let i = 0; i < this.mPointerQueue.length; i++) {\n      let nativeEvent = this.mPointerQueue[i];\n\n      let ix = this.mEventList.indexOf(nativeEvent.e.type);\n      let fnName = Input.mInputEventsLookup[ix];\n\n      if (fnName === 'pointerDown')\n        this.mNeedUpEvent = true;\n\n      pointerPos.set(nativeEvent.x, nativeEvent.y);\n\n      /** @type {InputComponent|null} */\n      let currentComponent = null;\n      for (let k = 0; k < this.mInputListeners.length; k++) {\n        currentComponent = this.mInputListeners[k];\n\n        // if (currentComponent.gameObject === null)\n        //   console.log(currentComponent);\n\n        if (GameObject.intersects(currentComponent.gameObject, pointerPos) === false) {\n          // check for out events\n          if (currentComponent.mPointerInside === true) {\n            currentComponent.mPointerInside = false;\n            currentComponent.gameObject.post('~pointerOut');\n          }\n\n          continue;\n        }\n\n        // TODO: fix weird extra pointerMove bug on chrome, happens right after down and before up\n        if (ix === Input.POINTER_DOWN)\n          this.mIsPointerDown = true;\n        else if (ix === Input.POINTER_UP)\n          this.mIsPointerDown = false;\n\n        if (currentComponent.mPointerInside === false) {\n          currentComponent.mPointerInside = true;\n          currentComponent.gameObject.post('~pointerIn');\n        }\n\n        currentComponent.gameObject.post('~' + fnName);\n      }\n\n      this.post(fnName);\n    }\n\n    for (let i = 0; i < this.mKeyQueue.length; i++) {\n      let nativeEvent = this.mKeyQueue[i];\n\n      let ix = this.mKeyEventList.indexOf(nativeEvent.type);\n      let pIx = this.mPressedKeys.indexOf(nativeEvent.keyCode);\n      let fnName = Input.mKeyEventsLookup[ix];\n\n      if (fnName === 'keyUp' && pIx !== -1)\n        this.mPressedKeys.splice(pIx, 1);\n\n      else if (fnName === 'keyDown' && pIx === -1) {\n        this.mPressedKeys.push(nativeEvent.keyCode);\n        fnName = 'keyPress';\n      }\n\n      this.post(fnName, new KeyInfo(nativeEvent), nativeEvent);\n    }\n\n    this.mPointerQueue.splice(0, this.mPointerQueue.length);\n    this.mKeyQueue.splice(0, this.mKeyQueue.length);\n  }\n\n  /**\n   * on - Description\n   *\n   * @param {string} name           Description\n   * @param {Function} callback       Description\n   * @param {Object=} [context=null] Description\n   *\n   * @return {void} Description\n   */\n  static on(name, callback, context = null) {\n    Input.instance.on(name, callback, context);\n  }\n\n\n  /**\n   * isPointerDown - Description\n   *\n   * @return {boolean} Description\n   */\n  static get isPointerDown() {\n    return Input.instance.mIsPointerDown;\n  }\n\n\n  /**\n   * pointerX - Description\n   *\n   * @return {number} Description\n   */\n  static get pointerX() {\n    return Input.instance.mPointerPosition.x;\n  }\n\n\n  /**\n   * pointerY - Description\n   *\n   * @return {number} Description\n   */\n  static get pointerY() {\n    return Input.instance.mPointerPosition.y;\n  }\n\n\n  /**\n   * pointerPosition - Description\n   *\n   * @return {Vector} Description\n   */\n  static get pointerPosition() {\n    return Input.instance.mPointerPosition;\n  }\n\n  static get pressedKeys() {\n    return Input.instance.mPressedKeys;\n  }\n}\n\n/** @type {Input}\n * @nocollapse\n */\nInput.instance = null;\n\n\n/** @type {number}\n *  @const\n */\nInput.POINTER_MOVE = 0;\n\n/** @type {number}\n *  @const\n */\nInput.POINTER_DOWN = 1;\n\n/** @type {number}\n *  @const\n */\nInput.POINTER_UP = 2;\n\n/** @type {number}\n *  @const\n */\nInput.POINTER_CANCEL = 3;\n\n/** @type {number}\n *  @const\n */\nInput.POINTER_IN = 4;\n\n/** @type {number}\n *  @const\n */\nInput.POINTER_OUT = 5;\n\n/** @type {Array<string>}\n *  @const\n */\nInput.mKeyEventList = ['keydown', 'keyup'];\n\n/** @type {Array<string>}\n *  @const\n */\nInput.mKeyEventsLookup = ['keyDown', 'keyUp', 'keyPress'];\n\n/** @type {Array<string>}\n *  @const\n */\nInput.mInputEventsLookup = ['pointerMove', 'pointerDown', 'pointerUp', 'pointerIn', 'pointerOut'];\n\n/** @type {Array<string>}\n *  @const\n */\nInput.mPointerEventList = ['pointermove', 'pointerdown', 'pointerup', 'pointerenter', 'pointerleave'];\n\n/** @type {Array<string>}\n *  @const\n */\nInput.mMouseEventList = ['mousemove', 'mousedown', 'mouseup', 'mouseenter', 'mouseleave'];\n\n/** @type {Array<string>}\n *  @const\n */\nInput.mTouchEventList = ['touchmove', 'touchstart', 'touchend', 'touchenter', 'touchleave'];\n","\nclass InputComponent extends Component {\n  /**\n   * @return {void}\n   */\n  constructor() {\n    super();\n\n    /** @type {boolean} */\n    this.touchable = true;\n\n    /* INTERNAL */\n\n    /** @type {boolean} */\n    this.mPointerInside = false;\n  }\n}\n","\nclass FPSComponent extends Component  {\n  constructor() {\n    super();\n\n    /** @type {TextField} */\n    this.txtFPS = null;\n  }\n\n  onAdded(){\n    this.txtFPS = new TextField('FPS: 0');\n    this.txtFPS.x = 0;\n    this.txtFPS.y = 0;\n    this.gameObject.addChild(this.txtFPS);\n  }\n\n  onRemoved(){\n  }\n\n  onUpdate(){\n    this.txtFPS.text = 'FPS: ' + Black.instance.FPS;\n  }\n}\n","\nclass MRComponent extends Component {\n\n  /**\n   * constructor - Description\n   *\n   * @param {number} [width=960]  Description\n   * @param {number} [height=640] Description\n   */\n  constructor(width = 960, height = 640) {\n    super();\n\n    /** @type {number} */\n    this.mWidth = width;\n\n    /** @type {number} */\n    this.mHeight = height;\n\n    /** @type {number} */\n    this.mScale = 0;\n\n    /** @type {number} */\n    this.mInvScale = 0;\n\n    /** @type {number} */\n    this.mAspect = 0;\n\n    Black.instance.viewport.on('resize', this.__onResize, this);\n  }\n\n  __onResize(msg, rect) {\n    this.setSize(this.mWidth, this.mHeight);\n  }\n\n  /**\n   * setSize - description\n   *\n   * @param  {number} width = 960  description\n   * @param  {number} height = 640 description\n   * @return {void}              description\n   */\n  setSize(width = 960, height = 640){\n    this.mWidth = width;\n    this.mHeight = height;\n\n    this.updateLayout();\n  }\n\n  /**\n   * updateLayout - description\n   *\n   * @return {void}  description\n   */\n  updateLayout() {\n    if (!this.gameObject)\n      return;\n\n    /** @type {Rectangle} */\n    let size = Black.instance.viewport.size;\n\n    /** @type {number} */\n    let scaleX = size.width / this.mWidth;\n\n    /** @type {number} */\n    let scaleY = size.height / this.mHeight;\n\n    this.mScale = Math.min(scaleX, scaleY);\n    this.mInvScale = 1 / this.mScale;\n\n    this.gameObject.scaleX = this.gameObject.scaleY = this.mScale;\n    this.gameObject.x = (size.width / 2) - (this.mWidth / 2) * this.mScale;\n    this.gameObject.y = (size.height / 2) - (this.mHeight / 2) * this.mScale;\n  }\n\n  onAdded(){\n    this.updateLayout();\n  }\n\n  onRemoved(){\n  }\n\n  onUpdate(){\n  }\n}\n","\nclass Ease {\n  constructor() {}\n\n  /**\n   * linear - Description\n   *\n   * @param {number} k Description\n   *\n   * @return {number} Description\n   */\n  static linear(k) {\n    return k;\n  }\n\n  /**\n   * quadraticIn - Description\n   *\n   * @param {number} k Description\n   *\n   * @return {number} Description\n   */\n  static quadraticIn(k) {\n    return k * k;\n  }\n\n  /**\n   * quadraticOut - Description\n   *\n   * @param {number} k Description\n   *\n   * @return {number} Description\n   */\n  static quadraticOut(k) {\n    return k * (2 - k);\n  }\n\n  /**\n   * quadraticInOut - Description\n   *\n   * @param {number} k Description\n   *\n   * @return {number} Description\n   */\n  static quadraticInOut(k) {\n    if ((k *= 2) < 1)\n      return 0.5 * k * k;\n\n    return -0.5 * (--k * (k - 2) - 1);\n  }\n\n  /**\n   * cubicIn - Description\n   *\n   * @param {number} k Description\n   *\n   * @return {number} Description\n   */\n  static cubicIn(k) {\n    return k * k * k;\n  }\n\n  /**\n   * cubicOut - Description\n   *\n   * @param {number} k Description\n   *\n   * @return {number} Description\n   */\n  static cubicOut(k) {\n    return --k * k * k + 1;\n  }\n\n  /**\n   * cubicInOut - Description\n   *\n   * @param {number} k Description\n   *\n   * @return {number} Description\n   */\n  static cubicInOut(k) {\n    if ((k *= 2) < 1)\n      return 0.5 * k * k * k;\n\n    return 0.5 * ((k -= 2) * k * k + 2);\n  }\n\n  /**\n   * quarticIn - Description\n   *\n   * @param {number} k Description\n   *\n   * @return {number} Description\n   */\n  static quarticIn(k) {\n    return k * k * k * k;\n  }\n\n  /**\n   * quarticOut - Description\n   *\n   * @param {number} k Description\n   *\n   * @return {number} Description\n   */\n  static quarticOut(k) {\n    return 1 - (--k * k * k * k);\n  }\n\n  /**\n   * quarticInOut - Description\n   *\n   * @param {number} k Description\n   *\n   * @return {number} Description\n   */\n  static quarticInOut(k) {\n    if ((k *= 2) < 1)\n      return 0.5 * k * k * k * k;\n\n    return -0.5 * ((k -= 2) * k * k * k - 2);\n  }\n\n  /**\n   * quinticIn - Description\n   *\n   * @param {number} k Description\n   *\n   * @return {number} Description\n   */\n  static quinticIn(k) {\n    return k * k * k * k * k;\n  }\n\n  /**\n   * quinticOut - Description\n   *\n   * @param {number} k Description\n   *\n   * @return {number} Description\n   */\n  static quinticOut(k) {\n    return --k * k * k * k * k + 1;\n  }\n\n  /**\n   * quinticInOut - Description\n   *\n   * @param {number} k Description\n   *\n   * @return {number} Description\n   */\n  static quinticInOut(k) {\n    if ((k *= 2) < 1)\n      return 0.5 * k * k * k * k * k;\n\n    return 0.5 * ((k -= 2) * k * k * k * k + 2);\n  }\n\n  /**\n   * sinusoidalIn - Description\n   *\n   * @param {number} k Description\n   *\n   * @return {number} Description\n   */\n  static sinusoidalIn(k) {\n    return 1 - Math.cos(k * Math.PI / 2);\n  }\n\n  /**\n   * sinusoidalOut - Description\n   *\n   * @param {number} k Description\n   *\n   * @return {number} Description\n   */\n  static sinusoidalOut(k) {\n    return Math.sin(k * Math.PI / 2);\n  }\n\n  /**\n   * sinusoidalInOut - Description\n   *\n   * @param {number} k Description\n   *\n   * @return {number} Description\n   */\n  static sinusoidalInOut(k) {\n    return 0.5 * (1 - Math.cos(Math.PI * k));\n  }\n\n  /**\n   * exponentialIn - Description\n   *\n   * @param {number} k Description\n   *\n   * @return {number} Description\n   */\n  static exponentialIn(k) {\n    return k === 0 ? 0 : Math.pow(1024, k - 1);\n  }\n\n  /**\n   * exponentialOut - Description\n   *\n   * @param {number} k Description\n   *\n   * @return {number} Description\n   */\n  static exponentialOut(k) {\n    return k === 1 ? 1 : 1 - Math.pow(2, -10 * k);\n  }\n\n  /**\n   * exponentialInOut - Description\n   *\n   * @param {number} k Description\n   *\n   * @return {number} Description\n   */\n  static exponentialInOut(k) {\n    if (k === 0)\n      return 0;\n\n    if (k === 1)\n      return 1;\n\n    if ((k *= 2) < 1)\n      return 0.5 * Math.pow(1024, k - 1);\n\n    return 0.5 * (-Math.pow(2, -10 * (k - 1)) + 2);\n  }\n\n  /**\n   * circularIn - Description\n   *\n   * @param {number} k Description\n   *\n   * @return {number} Description\n   */\n  static circularIn(k) {\n    return 1 - Math.sqrt(1 - k * k);\n  }\n\n  /**\n   * circularOut - Description\n   *\n   * @param {number} k Description\n   *\n   * @return {number} Description\n   */\n  static circularOut(k) {\n    return Math.sqrt(1 - (--k * k));\n  }\n\n  /**\n   * circularInOut - Description\n   *\n   * @param {number} k Description\n   *\n   * @return {number} Description\n   */\n  static circularInOut(k) {\n    if ((k *= 2) < 1)\n      return -0.5 * (Math.sqrt(1 - k * k) - 1);\n\n    return 0.5 * (Math.sqrt(1 - (k -= 2) * k) + 1);\n  }\n\n  /**\n   * elasticIn - Description\n   *\n   * @param {number} k Description\n   *\n   * @return {number} Description\n   */\n  static elasticIn(k) {\n    if (k === 0)\n      return 0;\n\n    if (k === 1)\n      return 1;\n\n    return -Math.pow(2, 10 * (k - 1)) * Math.sin((k - 1.1) * 5 * Math.PI);\n  }\n\n  /**\n   * elasticOut - Description\n   *\n   * @param {number} k Description\n   *\n   * @return {number} Description\n   */\n  static elasticOut(k) {\n    if (k === 0)\n      return 0;\n\n    if (k === 1)\n      return 1;\n\n    return Math.pow(2, -10 * k) * Math.sin((k - 0.1) * 5 * Math.PI) + 1;\n  }\n\n  /**\n   * elasticInOut - Description\n   *\n   * @param {number} k Description\n   *\n   * @return {number} Description\n   */\n  static elasticInOut(k) {\n    if (k === 0)\n      return 0;\n\n    if (k === 1)\n      return 1;\n\n    k *= 2;\n\n    if (k < 1)\n      return -0.5 * Math.pow(2, 10 * (k - 1)) * Math.sin((k - 1.1) * 5 * Math.PI);\n\n    return 0.5 * Math.pow(2, -10 * (k - 1)) * Math.sin((k - 1.1) * 5 * Math.PI) + 1;\n\n  }\n\n  /**\n   * backIn - Description\n   *\n   * @param {number} k Description\n   *\n   * @return {number} Description\n   */\n  static backIn(k) {\n    const s = 1.70158;\n    return k * k * ((s + 1) * k - s);\n  }\n\n  /**\n   * backOut - Description\n   *\n   * @param {number} k Description\n   *\n   * @return {number} Description\n   */\n  static backOut(k) {\n    const s = 1.70158;\n    return --k * k * ((s + 1) * k + s) + 1;\n  }\n\n  /**\n   * backInOut - Description\n   *\n   * @param {number} k Description\n   *\n   * @return {number} Description\n   */\n  static backInOut(k) {\n    const s = 1.70158 * 1.525;\n\n    if ((k *= 2) < 1)\n      return 0.5 * (k * k * ((s + 1) * k - s));\n\n    return 0.5 * ((k -= 2) * k * ((s + 1) * k + s) + 2);\n  }\n\n  /**\n   * bounceIn - Description\n   *\n   * @param {number} k Description\n   *\n   * @return {number} Description\n   */\n  static bounceIn(k) {\n    return 1 - Ease.bounceOut(1 - k);\n  }\n\n  /**\n   * bounceOut - Description\n   *\n   * @param {number} k Description\n   *\n   * @return {number} Description\n   */\n  static bounceOut(k) {\n    if (k < (1 / 2.75))\n      return 7.5625 * k * k;\n    else if (k < (2 / 2.75))\n      return 7.5625 * (k -= (1.5 / 2.75)) * k + 0.75;\n    else if (k < (2.5 / 2.75))\n      return 7.5625 * (k -= (2.25 / 2.75)) * k + 0.9375;\n\n    return 7.5625 * (k -= (2.625 / 2.75)) * k + 0.984375;\n  }\n\n  /**\n   * bounceInOut - Description\n   *\n   * @param {number} k Description\n   *\n   * @return {number} Description\n   */\n  static bounceInOut(k) {\n    if (k < 0.5)\n      return Ease.bounceIn(k * 2) * 0.5;\n\n    return Ease.bounceOut(k * 2 - 1) * 0.5 + 0.5;\n  }\n\n  /**\n   * smoothstep - Description\n   *\n   * @param {number} k Description\n   *\n   * @return {number} Description\n   */\n  static smootherStep(k) {\n    return k * k * k * (k * (6.0 * k - 15.0) + 10.0);\n  }\n}\n","\nclass Interpolation {\n  constructor() {}\n\n  /**\n   * linear - Description\n   *\n   * @param {Array} v - The input array of values to interpolate between.\n   *\n   * @param {number} k - The percentage of interpolation, between 0 and 1.\n   *\n   * @return {number} The interpolated value\n   */\n  static linear(v, k) {\n    let m = v.length - 1;\n    let f = m * k;\n    let i = Math.floor(f);\n\n    let fn = (p0, p1, t) => {\n      return (p1 - p0) * t + p0;\n    };\n\n    if (k < 0) {\n      return fn(v[0], v[1], f);\n    }\n\n    if (k > 1) {\n      return fn(v[m], v[m - 1], m - f);\n    }\n\n    return fn(v[i], v[i + 1 > m ? m : i + 1], f - i);\n  }\n\n  /**\n   * bezier - Description\n   *\n   * @param {Array} v - The input array of values to interpolate between.\n   *\n   * @param {number} k - The percentage of interpolation, between 0 and 1.\n   *\n   * @return {number} The interpolated value\n   */\n  static bezier(v, k) {\n    let b = 0;\n    let n = v.length;\n    let pow = Math.pow;\n    // Bernstein basis polynomials\n    let bn = (n, i) => {\n      let fc = Interpolation.__factorial;\n      return fc(n) / fc(i) / fc(n - i);\n    };\n\n    for (let i = 0; i < n; i++) {\n      b += pow(1 - k, n - i) * pow(k, i) * v[i] * bn(n, i);\n    }\n\n    return b;\n  }\n\n  /**\n   * catmullRom - Description\n   *\n   * @param {Array} v - The input array of values to interpolate between.\n   *\n   * @param {number} k - The percentage of interpolation, between 0 and 1.\n   *\n   * @return {number} The interpolated value\n   */\n  static catmullRom(v, k) {\n    let m = v.length - 1;\n    let f = m * k;\n    let i = Math.floor(f);\n    let fn = (p0, p1, p2, p3, t) => {\n      let v0 = (p2 - p0) * 0.5;\n      let v1 = (p3 - p1) * 0.5;\n      let t2 = t * t;\n      let t3 = t * t2;\n\n      return ((p1 - p2) * 2 + v0 + v1) * t3 + ((p2 - p1) * 3 - 2 * v0 - v1) * t2 + v0 * t + p1;\n    };\n\n    if (v[0] === v[m]) {\n      if (k < 0) {\n        i = Math.floor(f = m * (1 + k));\n      }\n\n      return fn(v[(i - 1 + m) % m], v[i], v[(i + 1) % m], v[(i + 2) % m], f - i);\n    } else {\n      if (k < 0) {\n        return v[0] - (fn(v[0], v[0], v[1], v[1], -f) - v[0]);\n      }\n\n      if (k > 1) {\n        return v[m] - (fn(v[m], v[m], v[m - 1], v[m - 1], f - m) - v[m]);\n      }\n\n      return fn(v[i ? i - 1 : 0], v[i], v[m < i + 1 ? m : i + 1], v[m < i + 2 ? m : i + 2], f - i);\n    }\n  }\n}\n\n/**\n * __factorial\n *\n * @param {number} n\n *\n * @return {number}\n */\nInterpolation.__factorial = (function() {\n  let a = [1];\n\n  return function(n) {\n    if (a[n]) {\n      return a[n];\n    }\n\n    let s = n;\n\n    while (--n) {\n      s *= n;\n    }\n\n    a[n] = s;\n    return s;\n  };\n})();\n","/**\n * Tween\n * @unrestricted\n * @extends Component\n */\n\nclass Tween extends Component {\n  /**\n   * constructor - Description\n   * @param {Object}   values            Description\n   * @param {number} [duration=0.25]   Description\n   * @param {Object|null}   [properties=null] Description\n   */\n  constructor(values, duration = 0.250, properties = null) {\n    super();\n\n    /** @dict */\n    this.mValues = values;\n\n    /** @type {number} */\n    this.mDuration = duration;\n\n    /** @dict */\n    this.mProperties = properties;\n\n    /** @type {boolean} */\n    this.mIsPlaying = false;\n\n    /** @type {boolean} */\n    this.mIsPaused = false;\n\n    /** @type {number} */\n    this.mStartTime = 0;\n\n    /** @type {number} */\n    this.mPausedTime = 0;\n\n    /** @dict */\n    this.mValuesStart = {};\n\n    /** @type {number} */\n    this.mElapsed = 0;\n\n    /** @type {function ((Array|null), number):number} */\n    this.mInterpolation = Interpolation.linear;\n\n    /** @type {number} */\n    this.mDelay = 0;\n\n    /** @type {number} */\n    this.mRepeatTimes = 0;\n\n    /** @type {boolean} */\n    this.mInitiated = false;\n\n    /** @type {boolean} */\n    this.mStarted = false;\n\n    /** @type {boolean} */\n    this.mReverse = false;\n\n    /** @type {boolean} */\n    this.mRemoveOnComplete = true;\n\n    /** @type {boolean} */\n    this.mPlayOnAdded = true;\n\n   /** @type {function(number):number} */\n    this.mEase = Ease.smootherStep;\n\n    if (this.mProperties !== null) {\n      for (let f in this.mProperties) {\n        this[f] = /** @dict */ (this.mProperties[f]);\n      }\n    }\n  }\n\n  /**\n   * ease - Description\n   *\n   * @return {function(number):number} Description\n   */\n  get ease() {\n    return this.mEase;\n  }\n\n  /**\n   * ease - Description\n   *\n   * @param {function(number):number} value Description\n   *\n   * @return {void} Description\n   */\n  set ease(value) {\n    this.mEase = value;\n  }\n\n  /**\n   * interpolation - Description\n   *\n   * @return {function(Array, number):number} Description\n   */\n  get interpolation() {\n    return this.mInterpolation;\n  }\n\n  /**\n   * interpolation - Description\n   *\n   * @param {function(Array, number):number} value Description\n   *\n   * @return {void} Description\n   */\n  set interpolation(value) {\n    this.mInterpolation = value;\n  }\n\n  /**\n   * elapsed - Description\n   *\n   * @return {number} Description\n   */\n  get elapsed() {\n    return this.mElapsed;\n  }\n\n  /**\n   * delay - Description\n   *\n   * @return {number} Description\n   */\n  get delay() {\n    return this.mDelay;\n  }\n\n  /**\n   * delay - Description\n   *\n   * @param {number} value Description\n   *\n   * @return {void} Description\n   */\n  set delay(value) {\n    this.mDelay = value;\n  }\n\n  /**\n   * removeOnComplete - Description\n   *\n   * @return {boolean} Description\n   */\n  get removeOnComplete() {\n    return this.mRemoveOnComplete;\n  }\n\n  /**\n   * removeOnComplete - Description\n   *\n   * @param {boolean} value Description\n   *\n   * @return {void} Description\n   */\n  set removeOnComplete(value) {\n    this.mRemoveOnComplete = value;\n  }\n\n  /**\n   * playOnAdded - Description\n   *\n   * @return {boolean} Description\n   */\n  get playOnAdded() {\n    return this.mPlayOnAdded;\n  }\n\n  /**\n   * playOnAdded - Description\n   *\n   * @param {boolean} value Description\n   *\n   * @return {void} Description\n   */\n  set playOnAdded(value) {\n    this.mPlayOnAdded = value;\n  }\n\n\n  /**\n   * __start - Description\n   *\n   * @param {number} t Description\n   *\n   * @return {void} Description\n   */\n  __start(t) {\n    this.mIsPlaying = true;\n    this.mStartTime = t + this.mDelay;\n  }\n\n  /**\n   * play - Description\n   *\n   * @return {Tween} Description\n   */\n  play() {\n    if (!this.mIsPaused) {\n      this.__start(Black.instance.uptime);\n    } else {\n      this.__resume();\n    }\n\n    return this;\n  }\n\n  /**\n   * stop - Description\n   *\n   * @return {Tween} Description\n   */\n  stop() {\n    if (!this.mIsPlaying)\n      return this;\n\n    this.mIsPlaying = false;\n\n    return this;\n  }\n\n  /**\n   * to - Description\n   *\n   * @param {Object} values - Description\n   *\n   * @return {Tween} Description\n   */\n  to(values = {}, duration = 0.250) {\n    this.mValues = values;\n\n    this.mDuration = duration;\n\n    this.mInitiated = false;\n\n    return this;\n  }\n\n  /**\n   * pause - Description\n   *\n   * @return {Tween} Description\n   */\n  pause() {\n    if (!this.mIsPlaying)\n      return this;\n\n    this.mIsPaused = true;\n    this.mPausedTime = Black.instance.uptime;\n\n    return this;\n  }\n\n  /**\n   * __resume - Description\n   *\n   * @return {void} Description\n   */\n  __resume() {\n    if (!this.mIsPaused)\n      return;\n\n    this.mIsPaused = false;\n    this.mStartTime += Black.instance.uptime - this.mPausedTime;\n  }\n\n\n  /**\n   * @return {void}\n   */\n  remove() {\n    if (this.mIsPlaying)\n      this.stop();\n\n    this.gameObject.removeComponent(this);\n  }\n\n  /**\n   * dispose - Description\n   *\n   * @return {void} Description\n   */\n  dispose() {\n    this.remove();\n  }\n\n  /**\n   * repeat - Description\n   *\n   * @return {Tween} Description\n   */\n  repeat(times) {\n    this.mRepeatTimes = times;\n\n    return this;\n  }\n\n  /**\n   * loop - Description\n   *\n   * @return {Tween} Description\n   */\n  loop(value = true) {\n    this.mRepeatTimes = value ? Infinity : 0;\n\n    return this;\n  }\n\n   /**\n   * reverse - Description\n   *\n   * @return {Tween} Description\n   */\n  reverse(value = true) {\n    this.mReverse = value;\n\n    return this;\n  }\n\n  /**\n   * chain - Description\n   *\n   * @return {Tween} Description\n   */\n  chain(tween) {\n    if (!tween) {\n      return this;\n    }\n\n    this.mRemoveOnComplete = false;\n\n    this.on('complete', () => {\n      tween.play();\n    });\n\n    return this;\n  }\n\n  /**\n   * onAdded - description\n   *\n   * @override\n   * @param  {GameObject} gameObject description\n   * @return {void}            description\n   */\n  onAdded(gameObject) {\n    if (this.mPlayOnAdded) {\n      this.__start(Black.instance.uptime);\n    }\n  }\n\n  /**\n   * __update - Description\n   *\n   * @param {number} t Description\n   *\n   * @return {void} Description\n   */\n  __update(t) {\n    if (t < this.mStartTime || !this.mIsPlaying || this.mIsPaused)\n      return;\n\n    // copy values only when starting tween...\n    // since values may change\n    if (this.mStarted === false) {\n      this.mStarted = true;\n      this.post('start', this.gameObject);\n\n      for (let f in this.mValues) {\n        if (!this.mInitiated && Array.isArray(this.mValues[f])) {\n          this.mValues[f] = [this.gameObject[f]].concat(this.mValues[f]);\n        }\n        this.mValuesStart[f] = parseFloat(this.gameObject[f]);\n      }\n\n      this.mInitiated = true;\n    }\n\n    this.mElapsed = (t - this.mStartTime) / this.mDuration;\n\n    if (this.mElapsed > 1)\n      this.mElapsed = 1;\n\n    let value = this.mEase(this.mElapsed);\n\n    for (let f in this.mValues) {\n      let start = /** @type {number} */ (this.mValuesStart[f]);\n      let end = /** @type {number|Array} */ (this.mValues[f]);\n\n      if (Array.isArray(end)) {\n        this.gameObject[f] = this.mInterpolation(end, value);\n      } else {\n        this.gameObject[f] = /** @type {number} */ (start + (end - start) * value);\n      }\n    }\n\n    this.post('update', this.gameObject);\n\n    if (this.mElapsed === 1) {\n      if (this.mRepeatTimes-- > 0) {\n        if (this.mReverse) {\n          for (let f in this.mValues) {\n            [this.mValues[f], this.mValuesStart[f]] = [this.mValuesStart[f], this.mValues[f]];\n          }\n        }\n\n        this.mStartTime = t + this.mDelay;\n\n        this.post('loop', this.gameObject);\n      } else {\n        this.mIsPlaying = false;\n        this.post('complete', this.gameObject);\n\n        if (this.mRemoveOnComplete) {\n          this.dispose();\n        } else {\n          for (let f in this.mValues) {\n            this.mValuesStart[f] = this.mValues[f];\n          }\n\n          this.mStarted = false;\n        }\n      }\n    }\n  }\n\n\n  /**\n   * set - Description\n   *\n   * @param {Object} values Description\n   *\n   * @return {void} Description\n   */\n  set(values) {\n    this.mValues = values;\n\n    for (let f in this.mValues)\n      this.mValuesStart[f] = parseFloat(this.gameObject[f]);\n  }\n\n  onPostUpdate(dt){\n    let t = Black.instance.uptime;\n    this.__update(t);\n  }\n}\n","\nclass Animation {\n  /**\n   * constructor - Description\n   *\n   * @param {AnimationController}    controller  Description\n   * @param {string}    name        Description\n   * @param {Array<Texture>}    frames      Description\n   * @param {number}  [fps=14]    Description\n   * @param {boolean} [loop=true] Description\n   */\n  constructor(controller, name, frames, fps = 14, loop = true) {\n    Debug.assert(fps > 0, 'FPS must be greater than 0.');\n    assert(fps > 0, '');\n\n    this.mController = controller;\n\n    /** @type {string} */\n    this.mName = name;\n\n    /** @type {Array<Texture>} */\n    this.mFrames = frames;\n\n    /** @type {number} */\n    this.mCurrentFrame = 0;\n\n    /** @type {number} */\n    this.mNextFrameAt = 0;\n\n    /** @type {number} */\n    this.mFPS = fps;\n\n    /** @type {number} */\n    this.mFrameDuration = 1 / this.mFPS;\n\n    /** @type {boolean} */\n    this.mLoop = loop;\n\n    /** @type {boolean} */\n    this.mPaused = false;\n\n    /** @type {number} */\n    this.mElapsed = 0;\n\n    /** @type {boolean} */\n    this.mStopped = false;\n\n    /** @type {boolean} */\n    this.mCompleted = false;\n  }\n\n\n  /**\n   * play - Description\n   *\n   * @return {Texture} Description\n   */\n  play() {\n    if (this.mCompleted === true) {\n      this.mCurrentFrame = 0;\n      this.mElapsed = 0;\n    }\n\n    this.mPaused = false;\n    this.mStopped = false;\n    this.mCompleted = false;\n\n    this.mNextFrameAt = Black.instance.uptime + this.mFrameDuration - this.mElapsed;\n    this.mElapsed = 0;\n\n    return this.mFrames[this.mCurrentFrame];\n  }\n\n\n  /**\n   * stop - Description\n   *\n   * @return {void} Description\n   */\n  stop() {\n    this.mStopped = true;\n    this.mCurrentFrame = 0;\n  }\n\n\n  /**\n   * pause - Description\n   *\n   * @return {void} Description\n   */\n  pause() {\n    this.mPaused = true;\n    this.mElapsed = this.mNextFrameAt - Black.instance.uptime;\n  }\n\n\n  /**\n   * __update - Description\n   *\n   * @param {number} dt Description\n   * @param {number} t  Description\n   *\n   * @return {Texture|null} Description\n   */\n  __update(dt, t) {\n    if (t < this.mNextFrameAt || this.mPaused === true || this.mStopped === true || this.mCompleted === true)\n      return null;\n\n    this.mCurrentFrame++;\n\n    if (this.mCurrentFrame >= this.mFrames.length) {\n      if (this.mLoop === true) {\n        this.mCurrentFrame = 0;\n      }\n      else {\n        this.mCurrentFrame = this.mFrames.length - 1;\n        this.mController.post('complete', this);\n        this.mCompleted = true;\n        return null;\n      }\n    }\n\n    this.mNextFrameAt = Black.instance.uptime + this.mFrameDuration;\n    let texture = this.mFrames[this.mCurrentFrame];\n    return texture;\n  }\n\n  /**\n   * fps - Description\n   *\n   * @return {number} Description\n   */\n  get fps() {\n    return this.mFPS;\n  }\n\n  /**\n   * fps - Description\n   *\n   * @param {number} value Description\n   *\n   * @return {void} Description\n   */\n  set fps(value) {\n    Debug.assert(value > 0, 'FPS must be greater than 0.');\n\n    this.mFPS = value;\n    this.mFrameDuration = 1 / this.mFPS;\n\n    // update next frame start time\n    let diff = this.mNextFrameAt - Black.instance.uptime;\n    this.mNextFrameAt += diff;\n  }\n\n  /**\n   * loop - Description\n   *\n   * @return {boolean} Description\n   */\n  get loop() {\n    return this.mLoop;\n  }\n\n  /**\n   * loop - Description\n   *\n   * @param {boolean} value Description\n   *\n   * @return {void} Description\n   */\n  set loop(value) {\n    this.mLoop = value;\n  }\n\n\n  /**\n   * frames - Description\n   *\n   * @return {Array<Texture>} Description\n   */\n  get frames() {\n    return this.mFrames;\n  }\n\n\n  /**\n   * playing - Description\n   *\n   * @return {boolean} Description\n   */\n  get isPlaying(){\n    return this.mPaused === false && this.mStopped === false;\n  }\n\n  /**\n   * playing - Description\n   *\n   * @return {boolean} Description\n   */\n  get isComplete(){\n    return this.mCompleted;\n  }\n\n  get name() {\n    return this.mName;\n  }\n}\n","\nclass AnimationController extends Component {\n  constructor() {\n    super();\n\n    /** @type {Object<string, Animation>} */\n    this.mAnimations = {};\n\n    /** @type {Animation|null} */\n    this.mCurrentAnim = null;\n  }\n\n\n  /**\n   * get - Description\n   *\n   * @param {string} name Description\n   *\n   * @return {Animation} Description\n   */\n  get(name){\n    Debug.assert(this.mAnimations.hasOwnProperty(name), 'Animation must be set first.');\n\n    return this.mAnimations[name];\n  }\n\n\n  /**\n   * set - Description\n   *\n   * @param {string}    name        Description\n   * @param {Array<Texture>}    textures    Description\n   * @param {number}  [fps=14]    Description\n   * @param {boolean} [loop=true] Description\n   *\n   * @return {Animation} Description\n   */\n  set(name, textures, fps = 14, loop = true) {\n    Debug.assert(textures.length > 0, 'Animation cannot be empty.');\n    Debug.assert(fps > 0, 'FPS must be greater than 0.');\n\n    let anim = new Animation(this, name, textures, fps, loop);\n    this.mAnimations[name] = anim;\n\n    return anim;\n  }\n\n\n  /**\n   * play - Description\n   *\n   * @param {string} name Description\n   *\n   * @return {void} Description\n   */\n  play(name) {\n    Debug.assert(this.mAnimations.hasOwnProperty(name), 'Animation must be set first.');\n\n    this.mCurrentAnim = this.mAnimations[name];\n\n    let texture = this.mCurrentAnim.play();\n\n    let sprite = /** @type {Sprite} */ (this.gameObject);\n    if (sprite === null)\n      return;\n\n    if (texture !== null)\n      sprite.texture = texture;\n  }\n\n\n  /**\n   * stop - Description\n   *\n   * @return {void} Description\n   */\n  stop() {\n    if (this.mCurrentAnim === null)\n      return;\n\n    this.mCurrentAnim.stop();\n  }\n\n\n  /**\n   * pause - Description\n   *\n   * @return {void} Description\n   */\n  pause() {\n    if (this.mCurrentAnim === null)\n      return;\n\n    this.mCurrentAnim.pause();\n  }\n\n\n  /**\n   * onPostUpdate - Description\n   *\n   * @override\n   * @param {number} dt Description\n   *\n   * @return {void} Description\n   */\n  onPostUpdate(dt) {\n    if (this.mCurrentAnim === null)\n      return;\n\n    // TODO: replace with time.time\n    let newTexture = this.mCurrentAnim.__update(dt, Black.instance.uptime);\n    if (newTexture === null)\n      return;\n\n    let sprite = /** @type {Sprite} */ (this.gameObject);\n    sprite.texture = newTexture;\n  }\n\n\n  /**\n   * currentAnimation\n   *\n   * @return {Animation|null}\n   */\n  get currentAnimation() {\n    return this.mCurrentAnim;\n  }\n}\n","//.########::'##::::::::::'###:::::'######::'##:::'##:\n// ##.... ##: ##:::::::::'## ##:::'##... ##: ##::'##::\n// ##:::: ##: ##::::::::'##:. ##:: ##:::..:: ##:'##:::\n// ########:: ##:::::::'##:::. ##: ##::::::: #####::::\n// ##.... ##: ##::::::: #########: ##::::::: ##. ##:::\n// ##:::: ##: ##::::::: ##.... ##: ##::: ##: ##:. ##::\n// ########:: ########: ##:::: ##:. ######:: ##::. ##:\n//........:::........::..:::::..:::......:::..::::..::\n\n\nclass Black extends MessageDispatcher {\n\n  /**\n   * constructor\n   * @param {string}   containerElementId\n   * @param {function(new: GameObject)}   rootClass\n   * @param {function(new: VideoNullDriver)} [videoDriverClass]\n   */\n  constructor(containerElementId, rootClass, videoDriverClass) {\n    super();\n\n    // Dirty GCC workaround\n    window['Black'] = {};\n    window['Black']['instance'] = this;\n\n    var css = \"background: #000; color: #fff;\";\n    console.log('%c ~Black ', css);\n\n    /** @type {string} */\n    this.mContainerElementId = containerElementId;\n\n    /** @type {HTMLElement} */\n    this.mContainerElement = /** @type {!HTMLElement} */ (document.getElementById(this.mContainerElementId));\n\n    if (!this.mContainerElement)\n      throw new Error('Container element was not found');\n\n    /** @type {function(new: VideoNullDriver)} */\n    this.mVideoDriverClass = videoDriverClass;\n\n    /** @type {number} */\n    this.mStageWidth = this.mContainerElement.clientWidth;\n\n    /** @type {number} */\n    this.mStageHeight = this.mContainerElement.clientHeight;\n\n    /** @type {number} */\n    this.mSimulationTimestep = 1000 / 60;\n\n    /** @type {number} */\n    this.mUptime = 0;\n\n    /** @type {number} */\n    this.mFrameAccum = 0;\n\n    /** @type {number} */\n    this.mLastFrameTimeMs = 0;\n\n    /** @type {number} */\n    this.mCurrentTime = 0;\n\n    /** @type {number} */\n    this.mFPS = 60;\n\n    /** @type {number} */\n    this.mLastFpsUpdate = 0;\n\n    /** @type {number} */\n    this.mFramesThisSecond = 0;\n\n    /** @type {number} */\n    this.mNumUpdateSteps = 0;\n\n    /** @type {number} */\n    this.mMinFrameDelay = 0;\n\n    /** @type {Array<System>} */\n    this.mSystems = [];\n\n    /** @type {Rectangle} */\n    this.mBounds = new Rectangle();\n\n    /** @type {boolean} */\n    this.mIsRunning = false;\n\n    /** @type {boolean} */\n    this.mIsStarted = false;\n\n    /** @type {boolean} */\n    this.mIsPanic = false;\n\n    /** @type {number} */\n    this.mLastFrameUpdateTime = 0;\n\n    /** @type {number} */\n    this.mLastFrameRenderTime = 0;\n\n    /** @type {number} */\n    this.mRAFHandle = -1; // not sure\n\n    /** @type {Viewport} */\n    this.mViewport = null;\n\n    /** @type {VideoNullDriver} */\n    this.mVideo = null;\n\n    /** @type {boolean} */\n    this.mPaused = false;\n\n    /** @type {boolean} */\n    this.mUnpausing = false;\n\n    /** @type {boolean} */\n    this.mPauseOnHide = true;\n\n    /** @type {boolean} */\n    this.mPauseOnBlur = true;\n\n    /** @type {Object<string, Array>} */\n    this.mTagCache = {};\n\n    /** @type {function(new: GameObject)|null} */\n    this.mRootClass = rootClass;\n\n    /** @type {GameObject|null} */\n    this.mRoot = null;\n\n    /** @type {boolean} */\n    this.mEnableFixedTimeStep = false;\n  }\n\n  pause() {\n    this.mPaused = true;\n  }\n\n  resume() {\n    this.mUnpausing = true;\n  }\n\n  __bootViewport() {\n    this.mViewport = new Viewport(this.mContainerElement);\n  }\n\n  __bootSystems() {\n    this.addSystem(new Input());\n  }\n\n  __bootStage() {\n    window.onblur = event => this.__onVisbilityChange(event);\n    window.onfocus = event => this.__onVisbilityChange(event);\n    window.onpagehide = event => this.__onVisbilityChange(event);\n    window.onpageshow = event => this.__onVisbilityChange(event);\n\n    if (document.hidden && this.mPauseOnHide === true)\n      this.mPaused = true;\n  }\n\n  __onVisbilityChange(event) {\n    let type = event.type;\n\n    if (type === 'blur' && this.mPauseOnBlur === true)\n      this.mPaused = true;\n    else if (type === 'pagehide' && this.mPauseOnHide === true)\n      this.mPaused = true;\n    else if (type === 'focus' || type === 'pageshow') {\n      if (document.hidden === false)\n        this.mUnpausing = true;\n    }\n  }\n\n  /**\n   * addSystem - Adds a given system to the system list.\n   *\n   * @param  {System} system\n   * @return {System}\n   */\n  addSystem(system) {\n    this.mSystems.push(system);\n    return system;\n  }\n\n  /**\n   * removeSystem - Removes the given system to the system list.\n   *\n   * @param {System} system\n   *\n   * @return {System|null}\n   */\n  removeSystem(system) {\n    // TODO: remove system on next frame\n    var ix = this.mSystems.indexOf(system);\n    if (ix === -1)\n      return null;\n\n    this.mSystems.splice(ix, 1);\n    return system;\n  }\n\n  __bootVideo() {\n    this.mVideo = new this.mVideoDriverClass(this.mContainerElement, this.mStageWidth, this.mStageHeight);\n  }\n\n  start() {\n    this.constructor.instance = this;\n\n    if (this.mIsStarted)\n      return;\n\n    this.__bootViewport();\n    this.__bootSystems();\n    this.__bootVideo();\n    this.__bootStage();\n\n    this.mRoot = new this.mRootClass();\n    this.mRoot.name = 'root';\n    this.mRoot.mAdded = true; // why are not added actually?\n    this.mRoot.onAdded();\n\n    const self = this;\n\n    this.mIsStarted = true;\n    this.mVideo.start();\n\n    this.mRAFHandle = requestAnimationFrame(function(timestamp) {\n      // TODO: do first update here\n      self.mIsRunning = true;\n\n      self.mLastFrameTimeMs = timestamp;\n      self.mLastFpsUpdate = timestamp;\n      self.mFramesThisSecond = 0;\n\n      // Start the main loop.\n      self.mRAFHandle = requestAnimationFrame((x) => {\n        self.__update(x);\n      });\n    });\n\n    // TODO: show only when needed, eg required by any system\n    if (this.mEnableFixedTimeStep === false)\n      Debug.warn('Fixed time-step is disabled, some systems may not work.');\n  }\n\n  stop() {\n    this.mIsStarted = false;\n    this.mIsRunning = false;\n    cancelAnimationFrame(this.mRAFHandle);\n  }\n\n  /**\n   * __update - Description\n   *\n   * @param {number} timestamp Description\n   *\n   * @return {void} Description\n   */\n  __update(timestamp) {\n    // TODO: this method seems to be totaly broken. maxAllowedFPS is not working correctly\n    this.constructor.instance = this;\n\n    const self = this;\n\n    if (this.mPaused === true && this.mUnpausing === true) {\n      this.mUnpausing = this.mPaused = false;\n\n      this.mLastFrameTimeMs = 0;\n      this.mLastFpsUpdate = timestamp;\n      this.mLastFrameTimeMs = timestamp;\n      this.mCurrentTime = 0; // same as first update\n      this.mFrameAccum = 0;\n    }\n\n    if (timestamp < this.mLastFrameTimeMs + this.mMinFrameDelay) {\n      this.mRAFHandle = window.requestAnimationFrame(this.__update.bind(this));\n      return;\n    }\n\n    if (this.mPaused === false) {\n      this.mFrameAccum += (timestamp - this.mLastFrameTimeMs);\n      this.mLastFrameTimeMs = timestamp;\n\n      // BEGIN\n      if (timestamp > this.mLastFpsUpdate + 1000) {\n        this.mFPS = this.mFramesThisSecond;\n\n        this.mLastFpsUpdate = timestamp;\n        this.mFramesThisSecond = 0;\n      }\n      this.mFramesThisSecond++;\n\n      this.mNumUpdateSteps = 0;\n\n      // fix first update\n      if (this.mCurrentTime === 0)\n        this.mCurrentTime = timestamp - this.mMinFrameDelay;\n\n      const dt = Time.scale * ((timestamp - this.mCurrentTime) * 0.001);\n      this.mCurrentTime = timestamp;\n      Time.mDeltaTime = dt;\n\n      if (this.mEnableFixedTimeStep === true) {\n        while (this.mFrameAccum >= this.mSimulationTimestep) {\n          this.__internalFixedUpdate(this.mSimulationTimestep * 0.001);\n\n          this.mFrameAccum -= this.mSimulationTimestep;\n\n          if (++this.mNumUpdateSteps >= (60 * 3)) { // 3 seconds window\n            console.log('[BLACK]: Not enough time to calculate update logic.');\n            this.mIsPanic = true;\n            break;\n          }\n        }\n      }\n\n      this.__internalUpdate(dt);\n      this.__internalPostUpdate(dt);\n\n      this.mVideo.beginFrame();\n      this.mRoot.__render(this.mVideo, this.mUptime, 1, BlendMode.AUTO);\n      this.mVideo.endFrame();\n\n      // TODO: remove uptime\n      this.mUptime += dt;\n      Time.mTime = this.mUptime;\n\n      this.mIsPanic = false;\n    }\n\n    this.mRAFHandle = window.requestAnimationFrame(this.__update.bind(this));\n  }\n\n  /**\n   * __internalFixedUpdate - Description\n   *\n   * @param {number} dt Description\n   *\n   * @return {void} Description\n   */\n  __internalFixedUpdate(dt) {\n    for (let i = 0; i < this.mSystems.length; i++)\n      this.mSystems[i].onFixedUpdate(dt);\n\n    this.mRoot.__fixedUpdate(dt);\n  }\n\n  /**\n   * __internalUpdate - Description\n   *\n   * @param {number} dt Description\n   *\n   * @return {void} Description\n   */\n  __internalUpdate(dt) {\n    for (let i = 0; i < this.mSystems.length; i++)\n      this.mSystems[i].onUpdate(dt, this.mUptime);\n\n    this.mRoot.__update(dt);\n  }\n\n  /**\n   * __internalUpdate - Description\n   *\n   * @param {number} dt Description\n   *\n   * @return {void} Description\n   */\n  __internalPostUpdate(dt) {\n    for (let i = 0; i < this.mSystems.length; i++)\n      this.mSystems[i].onPostUpdate(dt, this.mUptime);\n\n    this.mRoot.__postUpdate(dt);\n  }\n\n  /**\n   * bounds - Description\n   *\n   * @return {Rectangle} Description\n   */\n  get bounds() {\n    return this.mBounds;\n  }\n\n  /**\n   * root - Description\n   *\n   * @return {GameObject} Description\n   */\n  get root() {\n    return this.mRoot;\n  }\n\n  /**\n   * video - Description\n   *\n   * @return {VideoNullDriver} Description\n   */\n  get video() {\n    return this.mVideo;\n  }\n\n  /**\n   * simulationTimestep - Description\n   *\n   * @return {number} Description\n   */\n  get simulationTimestep() {\n    return this.mSimulationTimestep;\n  }\n\n  /**\n   * simulationTimestep - Description\n   *\n   * @param {number} timestep Description\n   *\n   * @return {void} Description\n   */\n  set simulationTimestep(timestep) {\n    this.mSimulationTimestep = timestep;\n  }\n\n  /**\n   * FPS - Description\n   *\n   * @return {number} Description\n   */\n  get FPS() {\n    return this.mFPS;\n  }\n\n  /**\n   * maxFPS - Description\n   *\n   * @return {number} Description\n   */\n  get maxFPS() {\n    return 1000 / this.mMinFrameDelay;\n  }\n\n  /**\n   * maxAllowedFPS - Description\n   *\n   * @param {number} fps Description\n   *\n   * @return {void} Description\n   */\n  set maxAllowedFPS(fps) {\n    if (fps <= 0)\n      this.stop();\n    else\n      this.mMinFrameDelay = 1000 / fps;\n  }\n\n  /**\n   * viewport - Description\n   *\n   * @return {Viewport} Description\n   */\n  get viewport() {\n    return this.mViewport;\n  }\n\n  /**\n   * containerElement - Description\n   *\n   * @return {Element} Description\n   */\n  get containerElement() {\n    return this.mContainerElement;\n  }\n\n  /**\n   * uptime - Description\n   *\n   * @return {number} Description\n   */\n  get uptime() {\n    return this.mUptime;\n  }\n\n  /**\n   * onTagUpdated - Description\n   *\n   * @param {GameObject} child Description\n   * @param {string|null} oldTag   Description\n   * @param {string|null} newTag   Description\n   *\n   * @return {void} Description\n   */\n  onTagUpdated(child, oldTag, newTag) {\n    if (oldTag !== null) {\n      let arr = this.mTagCache[oldTag];\n      arr.splice(arr.indexOf(child), 1);\n\n      if (arr.length === 0)\n        delete this.mTagCache[oldTag];\n    }\n\n    if (newTag !== null) {\n      if (this.mTagCache.hasOwnProperty(newTag) === false)\n        this.mTagCache[newTag] = [];\n\n      this.mTagCache[newTag].push(child);\n    }\n  }\n\n  /**\n   * @param  {GameObject} child     description\n   * @return {void}           description\n   */\n  onChildrenAdded(child) {\n    for (let i = 0; i < this.mSystems.length; i++)\n      this.mSystems[i].onChildrenAdded(child);\n\n    GameObject.forEach(child, (x) => {\n      if (x.mAdded === true)\n        return;\n\n      this.onTagUpdated(x, null, x.mTag);\n\n      x.mAdded = true;\n      x.onAdded();\n\n      for (let i = 0; i < x.mComponents.length; i++) {\n        let c = x.mComponents[i];\n\n        if (c.mAdded === true)\n          continue;\n\n        c.mAdded = true;\n        c.onAdded(x);\n      }\n    });\n  }\n\n  /**\n   * @param  {GameObject} child     description\n   * @return {void}           description\n   */\n  onChildrenRemoved(child) {\n    for (let i = 0; i < this.mSystems.length; i++)\n      this.mSystems[i].onChildrenRemoved(child);\n\n    GameObject.forEach(child, (x) => {\n      if (x.mAdded === true) {\n        this.onTagUpdated(x, x.mTag, null);\n\n        x.mAdded = false;\n        x.onRemoved();\n\n        for (let i = 0; i < x.mComponents.length; i++) {\n          let c = x.mComponents[i];\n\n          if (c.mAdded === false)\n            continue;\n\n          c.mAdded = false;\n          c.onRemoved(x);\n        }\n      }\n    });\n  }\n\n  /**\n   * @param  {GameObject} child     description\n   * @param  {Component} component description\n   * @return {void}           description\n   */\n  onComponentAdded(child, component) {\n    for (let i = 0; i < this.mSystems.length; i++)\n      this.mSystems[i].onComponentAdded(child, component);\n\n    if (component.mAdded === true)\n      return;\n\n    component.mAdded = true;\n    component.onAdded(child);\n  }\n\n  /**\n   * @param  {GameObject} child     description\n   * @param  {Component} component description\n   * @return {void}           description\n   */\n  onComponentRemoved(child, component) {\n    //child.mBlack = null;\n    //console.log('onComponentRemoved', child, component);\n\n    for (let i = 0; i < this.mSystems.length; i++)\n      this.mSystems[i].onComponentRemoved(child, component);\n\n    if (component.mAdded === false)\n      return;\n\n    component.mAdded = false;\n    component.onRemoved(child);\n  }\n\n  /**\n   * pauseOnHide\n   *\n   * @return {boolean}\n   */\n  get pauseOnHide() {\n    return this.mPauseOnHide;\n  }\n\n  /**\n   * pauseOnHide\n   *\n   * @param {boolean} value\n   *\n   * @return {void}\n   */\n  set pauseOnHide(value) {\n    this.mPauseOnHide = value;\n  }\n\n  /**\n   * pauseOnBlur\n   *\n   * @return {boolean}\n   */\n  get pauseOnBlur() {\n    return this.mPauseOnBlur;\n  }\n\n  /**\n   * pauseOnBlur\n   *\n   * @param {boolean} value\n   *\n   * @return {void}\n   */\n  set pauseOnBlur(value) {\n    this.mPauseOnBlur = value;\n  }\n\n\n  /**\n   * When disabled the physics system and other systems may not work.\n   *\n   * @return {boolean}\n   */\n  get enableFixedTimeStep() {\n    return this.mEnableFixedTimeStep;\n  }\n\n  /**\n   * enableFixedTimeStep\n   *\n   * @param {boolean} value\n   *\n   * @return {void}\n   */\n  set enableFixedTimeStep(value) {\n    this.mEnableFixedTimeStep = value;\n  }\n}\n"]}