{"version":3,"sources":["MathEx.js","Helpers.js","Vector.js","Matrix.js","Rectangle.js","Circle.js","Line.js","Polygon.js","Curve.js","Debug.js","Message.js","MessageDispatcher.js","Time.js","System.js","Viewport.js","Component.js","GameObject.js","Texture.js","AtlasTexture.js","Asset.js","TextureAsset.js","JSONAsset.js","FontAsset.js","AtlasTextureAsset.js","SoundAsset.js","AssetManager.js","BlendMode.js","VideoNullDriver.js","CanvasDriver.js","DOMDriver.js","WebGLDriver.js","WebGLConstants.js","WebGLBlendMode.js","WebGLBasePlugin.js","WebGLTextures.js","WebGLTexPlugin.js","WebGLParticlesPlugin.js","DisplayObject.js","TextInfo.js","Sprite.js","TextField.js","Device.js","Scatter.js","FloatScatter.js","VectorScatter.js","CurveScatter.js","Action.js","Acceleration.js","AlphaOverLife.js","ScaleOverLife.js","RotationOverLife.js","TextureOverLife.js","Initializer.js","Life.js","Mass.js","Scale.js","Velocity.js","Position.js","Rotation.js","RandomTexture.js","EmitterState.js","Particle.js","Emitter.js","Key.js","KeyInfo.js","Input.js","InputComponent.js","FPSComponent.js","MRComponent.js","Ease.js","Interpolation.js","Tween.js","AnimationInfo.js","AnimationController.js","Black.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC/EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACxCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC9VA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC/eA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACjeA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC3QA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACxTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACxhBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACxQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC3CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AClLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC7aA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC5DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC5FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC3DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC/HA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACljDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACnRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC/IA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACtJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AClDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACjCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACtJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AClEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACxEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACzVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC1BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACpQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AChUA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACnYA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACvNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AChDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC3BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACzFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC7BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACnUA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC5VA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACrJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACtEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC1IA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC1dA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC3GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC3BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACxDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACxDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACvDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC/CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AClDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC9CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACzCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACzCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACzCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACjCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AClCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AClCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACrCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACrCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACjCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACrCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC1IA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC1lBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AClZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACxBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACplBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACtBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AChCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACnGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACvaA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AChIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACvfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AChPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACzJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"black-es6.js","sourcesContent":["\r\nclass MathEx {\r\n  /**\r\n   * randomBetween\r\n   *\r\n   * @param {number} a\r\n   * @param {number} b\r\n   *\r\n   * @return {number}\r\n   */\r\n  static randomBetween(a, b) {\r\n    return Math.floor(Math.random() * (b - a + 1) + a);\r\n  };\r\n\r\n\r\n  /**\r\n   * clamp\r\n   *\r\n   * @param {number} value\r\n   * @param {number} min\r\n   * @param {number} max\r\n   *\r\n   * @return {number}\r\n   */\r\n  static clamp(value, min, max) {\r\n    return (value < min) ? min : (value > max) ? max : value;\r\n  };\r\n\r\n\r\n  /**\r\n   * lerp\r\n   *\r\n   * @param {number} a\r\n   * @param {number} b\r\n   * @param {number} t\r\n   *\r\n   * @return {number}\r\n   */\r\n  static lerp(a, b, t) {\r\n    return a + t * (b - a);\r\n  };\r\n\r\n\r\n  /**\r\n   * lerpp\r\n   *\r\n   * @param {number} a\r\n   * @param {number} b\r\n   * @param {number} t\r\n   *\r\n   * @return {number}\r\n   */\r\n  static lerpp(a, b, t) {\r\n    return (1 - t) * a + t * b;\r\n  };\r\n\r\n  static equals(a, b, epsilon = Number.EPSILON) {\r\n    return (a - epsilon < b) && (a + epsilon > b);\r\n  }\r\n}\r\n\r\n/** @const\r\n *  @type {number}\r\n */\r\nMathEx.PI_Q = Math.PI / 4;\r\n\r\n/** @const\r\n *  @type {number}\r\n */\r\nMathEx.PI2 = Math.PI * 2;\r\n\r\n/** @const\r\n *  @type {number}\r\n */\r\nMathEx.DEG2RAD = 0.01745329251994329576923690768489;\r\n\r\n/** @const\r\n *  @type {number}\r\n */\r\nMathEx.RAD2DEG = 57.295779513082320876798154814105;","// function assert(title, condition) {\r\n//   if (condition)\r\n//     console.log('%s %c[  OK  ]', title + ' ' + '.'.repeat(88 - title.length), 'color:green;')\r\n//   else\r\n//     console.log('%s %c[FAILED]', title + ' ' + '.'.repeat(88 - title.length), 'color:red;')\r\n// }\r\n//\r\n// function perfTest(testName, fn, ctx, count = 1000) {\r\n//   let startTime = new Date().getTime();\r\n//\r\n//   for (var i = 0; i < count; i++)\r\n//     fn.apply(ctx);\r\n//     //fn();\r\n//\r\n//   return (new Date().getTime() - startTime);\r\n// }\r\n//\r\n// function perfCompare(testsName, fn1, fn2, ctx, count = 1000) {\r\n//   let t1 = perfTest(testsName, fn1, ctx, count);\r\n//   let t2 = perfTest(testsName, fn2, ctx, count);\r\n//\r\n//   let c1 = 'color:green;'\r\n//   let c2 = 'color:red;'\r\n//\r\n//   if (t1 > t2) {\r\n//     c1 = c2;\r\n//     c2 = 'color:green;'\r\n//   }\r\n//\r\n//   console.log('%s:%c %dms %cvs%c %dms', testsName, c1, t1, 'color:black;', c2, t2);\r\n// }\r\n//\r\n// function assertf(title, func) {\r\n//   const r = func();\r\n//\r\n//   const statuses = ['[  OK  ]', '[FAILED]'];\r\n//   const colors = ['color:green;', 'color:red;'];\r\n//\r\n//   console.log('%s %c%s', title + ' ' + '.'.repeat(88 - title.length), r ? colors[0] : colors[1], r ? statuses[0] : statuses[1]);\r\n// }\r\n","/**\r\n * Mathematical representation of a vector.\r\n *\r\n * @cat geom\r\n */\r\n\r\nclass Vector {\r\n  /**\r\n   * Creates new Vector instance.\r\n   *\r\n   * @param  {number=} x = 0 X-component.\r\n   * @param  {number=} y = 0 y-component.\r\n   */\r\n  constructor(x = 0, y = 0) {\r\n    /**\r\n     * X coordinate of a point in the space.\r\n     *\r\n     * @type {number}\r\n     */\r\n    this.x = x;\r\n\r\n    /**\r\n     * Y coordinate of a point in the space.\r\n     * @type {number}\r\n     */\r\n    this.y = y;\r\n  }\r\n\r\n  /**\r\n   * Updates values of this vector with a given.\r\n   *\r\n   * @param {number=} [x=0] X-component.\r\n   * @param {number=} [y=0] y-component\r\n   *\r\n   * @return {Vector} This.\r\n   */\r\n  set(x = 0, y = 0) {\r\n    this.x = x;\r\n    this.y = y;\r\n\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Adds two vectors.\r\n   *\r\n   * @param {Vector} vector The vector object to be added to this.\r\n   *\r\n   * @return {Vector} This.\r\n   */\r\n  add(vector) {\r\n    this.x += vector.x;\r\n    this.y += vector.y;\r\n\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Subtract two vectors.\r\n   *\r\n   * @param {Vector} vector The vector object to be subtracted.\r\n   *\r\n   * @return {Vector} This.\r\n   */\r\n  subtract(vector) {\r\n    this.x -= vector.x;\r\n    this.y -= vector.y;\r\n\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Returns distance between two vectors.\r\n   *\r\n   * @param {Vector} vector Second vector to check distance with.\r\n   *\r\n   * @return {number} The distance between two vectors.\r\n   */\r\n  distance(vector) {\r\n    let x = this.x - vector.x;\r\n    let y = this.y - vector.y;\r\n\r\n    return Math.sqrt((x * x) + (y * y));\r\n  }\r\n\r\n  /**\r\n   * Multiplies two vectors.\r\n   *\r\n   * @param {Vector} vector A second vector to multiply with.\r\n   *\r\n   * @return {Vector} This.\r\n   */\r\n  multiply(vector) {\r\n    this.x *= vector.x;\r\n    this.y *= vector.y;\r\n\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Multiplies this vector by scalar value.\r\n   *\r\n   * @param {number} scalar The values to mul by.\r\n   *\r\n   * @return {Vector} This.\r\n   */\r\n  multiplyScalar(scalar) {\r\n    this.x *= scalar;\r\n    this.y *= scalar;\r\n\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Find dot product between two vectors.\r\n   *\r\n   * @param {Vector} vector Second vector to find angle with.\r\n   *\r\n   * @return {number} A scalar value representing dot product.\r\n   */\r\n  dot(vector) {\r\n    return this.x * vector.x + this.y * vector.y;\r\n  }\r\n\r\n  /**\r\n   * Returns the length of this vector.\r\n   *\r\n   * @return {number} The length of the vector.\r\n   */\r\n  length() {\r\n    let x = this.x;\r\n    let y = this.y;\r\n\r\n    return Math.sqrt(x * x + y * y);\r\n  }\r\n\r\n  /**\r\n   * Returns the squared length of this vector.\r\n   *\r\n   * @return {number} Squared length.\r\n   */\r\n  lengthSqr() {\r\n    let x = this.x;\r\n    let y = this.y;\r\n\r\n    return x * x + y * y;\r\n  }\r\n\r\n  /**\r\n   * Creates unit vector out of this one.\r\n   *\r\n   * @returns {Vector} This.\r\n   */\r\n  normalize() {\r\n    let sum = this.lengthSqr();\r\n\r\n    if (sum > 0) {\r\n      sum = Math.sqrt(sum);\r\n      this.x /= sum;\r\n      this.y /= sum;\r\n    } else {\r\n      this.x = 0;\r\n      this.y = 0;\r\n    }\r\n\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Clamps values of this vector to given range.\r\n   *\r\n   * @param {number} min Min value.\r\n   * @param {number} max Max value.\r\n   *\r\n   * @return {Vector} This.\r\n   */\r\n  clamp(min, max) {\r\n    this.x = MathEx.clamp(this.x, min, max);\r\n    this.y = MathEx.clamp(this.y, min, max);\r\n\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Linearly interpolates between two vectors.\r\n   *\r\n   * @param {Vector} vector The second vector to interpolate values between.\r\n   * @param {number} t      Interpolant.\r\n   *\r\n   * @return {Vector} This.\r\n   */\r\n  lerp(vector, t) {\r\n    this.x = MathEx.lerp(this.x, vector.x, t);\r\n    this.y = MathEx.lerp(this.y, vector.y, t);\r\n\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Copies this vector values into given vector.\r\n   *\r\n   * @param {Vector} vector The vector to store values in.\r\n   *\r\n   * @return {Vector} Given vector.\r\n   */\r\n  copyTo(vector) {\r\n    vector.x = this.x;\r\n    vector.y = this.y;\r\n\r\n    return vector;\r\n  }\r\n\r\n  /**\r\n   * Copies values from given vector into this.\r\n   *\r\n   * @param {Vector} vector The vector to copy values from.\r\n   *\r\n   * @return {Vector} This.\r\n   */\r\n  copyFrom(vector) {\r\n    this.x = vector.x;\r\n    this.y = vector.y;\r\n\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Clones this vector object.\r\n   *\r\n   * @return {Vector} New Vector instance.\r\n   */\r\n  clone() {\r\n    return new Vector(this.x, this.y);\r\n  }\r\n\r\n  /**\r\n   * Compares two vectors for equality.\r\n   *\r\n   * @param {Vector} vector Second vector to compare with.\r\n   * @param {number=} epsilon Threshold.\r\n   *\r\n   * @return {boolean} True if equal.\r\n   */\r\n  equals(vector, epsilon = Number.EPSILON) {\r\n    return vector !== null && (Math.abs(vector.x - this.x) < epsilon) && (Math.abs(vector.y - this.y) < epsilon);\r\n  }\r\n\r\n  /**\r\n   * Checks if this vector is empty.\r\n   *\r\n   * @return {boolean} True if both components equal to zero,\r\n   */\r\n  isEmpty() {\r\n    return this.x === 0 && this.y === 0;\r\n  }\r\n\r\n  /**\r\n   * Rotates this vector around specified point.\r\n   *\r\n   * @param {Vector} vector Center vector.\r\n   * @param {number} rotation Angle in radians.\r\n   *\r\n   * @return {Vector} This rotated vector.\r\n   */\r\n  setRotationFrom(vector, rotation) {\r\n    return this\r\n      .subtract(vector)\r\n      .setRotation(rotation)\r\n      .add(vector);\r\n  }\r\n\r\n  /**\r\n   *  Rotates this vector around zero vector.\r\n   *\r\n   * @param {number} rotation Angle in radians\r\n   *\r\n   * @return {Vector} This rotated vector.\r\n   */\r\n  setRotation(rotation) {\r\n    let cos = Math.cos(rotation).toFixed(15);\r\n    let sin = Math.sin(rotation).toFixed(15);\r\n\r\n    return this.set(this.x * cos - this.y * sin, this.x * sin + this.y * cos);\r\n  }\r\n\r\n  /**\r\n   * Calculates angle in radians within this and specified vectors.\r\n   *\r\n   * @return {number} Angle in radians.\r\n   */\r\n  theta(vector) {\r\n    return Math.acos(this.dot(vector) / this.length() / vector.length());\r\n  }\r\n\r\n  /**\r\n   * Rotates this vector to normal.\r\n   *\r\n   * @return {Vector} This vector.\r\n   */\r\n  perp() {\r\n    return this.set(this.y, -this.x);\r\n  }\r\n\r\n  /**\r\n   * Creates new Vector from given angle in radians.\r\n   *\r\n   * @param {number=} [angle=0] Angle.\r\n   *\r\n   * @return {Vector} New Vector object.\r\n   */\r\n  static fromAngle(angle = 0) {\r\n    return new Vector(Math.cos(angle), Math.sin(angle));\r\n  }\r\n\r\n  /**\r\n   * @ignore\r\n   *\r\n   * @param {Vector} vectorMin\r\n   * @param {Vector} vectorMax\r\n   * @param {Vector=} outVector\r\n   *\r\n   * @return {Vector}\r\n   */\r\n  static randomRange(vectorMin, vectorMax, outVector = undefined) {\r\n    outVector = outVector || new Vector();\r\n\r\n    outVector.x = Math.random() * (vectorMax.x - vectorMin.x) + vectorMin.x;\r\n    outVector.y = Math.random() * (vectorMax.y - vectorMin.y) + vectorMin.y;\r\n\r\n    return outVector;\r\n  }\r\n\r\n  /**\r\n   * toString - Description\r\n   *\r\n   * @param {number=} [digits=2] Description\r\n   *\r\n   * @return {string} Description\r\n   */\r\n  toString(digits = 2) {\r\n    return `Vector: { x: ${this.x.toFixed(digits)}, y: ${this.y.toFixed(digits)} }`;\r\n  }\r\n}\r\n\r\n/**\r\n * @ignore\r\n * @type {Vector}\r\n * @nocollapse\r\n */\r\nVector.__cache = new Vector();\r\n","/**\r\n * A 2x3 matrix allows you to transform objects in space.\r\n *\r\n * @cat geom\r\n */\r\n\r\nclass Matrix {\r\n  /**\r\n   * Creates new Matrix instance.\r\n   *\r\n   * @param  {number} a = 1  A-component.\r\n   * @param  {number} b = 0  B-component.\r\n   * @param  {number} c = 0  C-component.\r\n   * @param  {number} d = 1  D-component.\r\n   * @param  {number} tx = 0 TX-component.\r\n   * @param  {number} ty = 0 TY-component.\r\n   */\r\n  constructor(a = 1, b = 0, c = 0, d = 1, tx = 0, ty = 0) {\r\n    /** @type {Float32Array} */\r\n    this._matrix = new Float32Array(6);\r\n\r\n    this.set(a, b, c, d, tx, ty);\r\n  }\r\n\r\n  /**\r\n   * Sets components of this matrix to the given values.\r\n   *\r\n   * @param  {number} a  A-component.\r\n   * @param  {number} b  B-component.\r\n   * @param  {number} c  C-component.\r\n   * @param  {number} d  D-component.\r\n   * @param  {number} tx TX-component.\r\n   * @param  {number} ty TY-component.\r\n   * @return {Matrix} This.\r\n   */\r\n  set(a = 1, b = 0, c = 0, d = 1, tx = 0, ty = 0) {\r\n    let m = this._matrix;\r\n\r\n    m[0] = a;\r\n    m[1] = b;\r\n    m[2] = c;\r\n    m[3] = d;\r\n    m[4] = tx;\r\n    m[5] = ty;\r\n\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Translates the matrix by x and y axes.\r\n   *\r\n   * @param {number} dx Amount along x-axis.\r\n   * @param {number} dy Amount along y-axis.\r\n   *\r\n   * @return {Matrix} This.\r\n   */\r\n  translate(dx, dy) {\r\n    let a = this._matrix;\r\n\r\n    let /** @type {number} */ a0 = a[0]; // a\r\n    let /** @type {number} */ a1 = a[1]; // b\r\n    let /** @type {number} */ a2 = a[2]; // c\r\n    let /** @type {number} */ a3 = a[3]; // d\r\n    let /** @type {number} */ a4 = a[4]; // tx\r\n    let /** @type {number} */ a5 = a[5]; // ty\r\n\r\n    this._matrix[4] = a0 * dx + a2 * dy + a4;\r\n    this._matrix[5] = a1 * dx + a3 * dy + a5;\r\n\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Sets tx and ty components to given values.\r\n   *\r\n   * @param {number} x The tx component to update.\r\n   * @param {number} y The ty component to update.\r\n   *\r\n   * @return {Matrix} This.\r\n   */\r\n  setTranslation(x, y) {\r\n    this._matrix[4] = x;\r\n    this._matrix[5] = y;\r\n\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Sets absolute rotation of this matrix to specified angle.\r\n   *\r\n   * @param  {number} theta     Theta value.\r\n   * @param  {number} scale = 1 Scale value.\r\n   */\r\n  setRotation(theta, scale = 1) {\r\n    let m = this._matrix;\r\n    m[0] = Math.cos(theta) * scale;\r\n    m[2] = Math.sin(theta) * scale;\r\n    m[1] = -m[2];\r\n    m[3] = m[0];\r\n\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Applies rotation to this matrix.\r\n   *\r\n   * @param  {number} angle Angle in radians.\r\n   * @return {Matrix} This.\r\n   */\r\n  rotate(angle) {\r\n    let a = this._matrix;\r\n    let cos = Math.cos(angle);\r\n    let sin = Math.sin(angle);\r\n    let a0 = a[0];\r\n    let a2 = a[2];\r\n    let a4 = a[4];\r\n\r\n    a[0] = a0 * cos - a[1] * sin;\r\n    a[1] = a0 * sin + a[1] * cos;\r\n    a[2] = a2 * cos - a[3] * sin;\r\n    a[3] = a2 * sin + a[3] * cos;\r\n    a[4] = a4 * cos - a[5] * sin;\r\n    a[5] = a4 * sin + a[5] * cos;\r\n\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Scales current matrix.\r\n   *\r\n   * @param {number} sx Abscissa of the scaling vector.\r\n   * @param {number} sy Ordinate of the scaling vector.\r\n   *\r\n   * @return {Matrix} This.\r\n   */\r\n  scale(sx, sy) {\r\n    let a = this._matrix;\r\n    let /** @type {number} */ a0 = a[0]; // a\r\n    let /** @type {number} */ a1 = a[1]; // b\r\n    let /** @type {number} */ a2 = a[2]; // c\r\n    let /** @type {number} */ a3 = a[3]; // d\r\n    let /** @type {number} */ a4 = a[4]; // tx\r\n    let /** @type {number} */ a5 = a[5]; // ty\r\n\r\n    this._matrix[0] = a0 * sx;\r\n    this._matrix[1] = a1 * sx;\r\n    this._matrix[2] = a2 * sy;\r\n    this._matrix[3] = a3 * sy;\r\n\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Resets current matrix to identity state.\r\n   *\r\n   * @return {Matrix} This.\r\n   */\r\n  identity() {\r\n    return this.set(1, 0, 0, 1, 0, 0);\r\n  }\r\n\r\n  /**\r\n   * Concatenates a given matrix with the current one.\r\n   *\r\n   * @param  {Matrix} b The matrix to be concatenated.\r\n   * @return {Matrix}   This.\r\n   */\r\n  prepend(b) {\r\n    let a = this._matrix;\r\n    let bv = b._matrix;\r\n\r\n    let /** @type {number} */ a0 = a[0]; // a\r\n    let /** @type {number} */ a1 = a[1]; // b\r\n    let /** @type {number} */ a2 = a[2]; // c\r\n    let /** @type {number} */ a3 = a[3]; // d\r\n    let /** @type {number} */ a4 = a[4]; // tx\r\n    let /** @type {number} */ a5 = a[5]; // ty\r\n\r\n    let /** @type {number} */ b0 = bv[0]; // a\r\n    let /** @type {number} */ b1 = bv[1]; // b\r\n    let /** @type {number} */ b2 = bv[2]; // c\r\n    let /** @type {number} */ b3 = bv[3]; // d\r\n    let /** @type {number} */ b4 = bv[4]; // tx\r\n    let /** @type {number} */ b5 = bv[5]; // ty\r\n\r\n    let a11 = (a0 * b0 + a1 * b2);\r\n    a[1] = a0 * b1 + a1 * b3;\r\n    a[0] = a11;\r\n\r\n    let c11 = (a2 * b0 + a3 * b2);\r\n    a[3] = a2 * b1 + a3 * b3;\r\n    a[2] = c11;\r\n\r\n    let tx11 = (a4 * b0 + a5 * b2 + b4);\r\n    a[5] = a4 * b1 + a5 * b3 + b5;\r\n    a[4] = tx11;\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Appends values to this matrix.\r\n   *\r\n   * @param  {Matrix} b The matrix to be appended.\r\n   * @return {Matrix} This.\r\n   */\r\n  append(b) {\r\n    let a = this._matrix;\r\n    let bv = b._matrix;\r\n\r\n    let /** @type {number} */ a0 = a[0];\r\n    let /** @type {number} */ a1 = a[1];\r\n    let /** @type {number} */ a2 = a[2];\r\n    let /** @type {number} */ a3 = a[3];\r\n    let /** @type {number} */ a4 = a[4];\r\n    let /** @type {number} */ a5 = a[5];\r\n    let /** @type {number} */ b0 = bv[0];\r\n    let /** @type {number} */ b1 = bv[1];\r\n    let /** @type {number} */ b2 = bv[2];\r\n    let /** @type {number} */ b3 = bv[3];\r\n    let /** @type {number} */ b4 = bv[4];\r\n    let /** @type {number} */ b5 = bv[5];\r\n\r\n    a[0] = a0 * b0 + a2 * b1;\r\n    a[1] = a1 * b0 + a3 * b1;\r\n    a[2] = a0 * b2 + a2 * b3;\r\n    a[3] = a1 * b2 + a3 * b3;\r\n    a[4] = a0 * b4 + a2 * b5 + a4;\r\n    a[5] = a1 * b4 + a3 * b5 + a5;\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Transforms given and x- and y- components of a point from a local space to\r\n   * world space.\r\n   *\r\n   * @param  {number} x          The x- component of a point.\r\n   * @param  {number} y          The y- component of a point.\r\n   * @param  {Vector=} outVector If given stores resulting values in it.\r\n   * @return {Vector} Transformed Vector object.\r\n   */\r\n  transformXY(x, y, outVector) {\r\n    outVector = outVector || new Vector();\r\n    let m = this._matrix;\r\n\r\n    outVector.x = m[0] * x + m[2] * y + m[4];\r\n    outVector.y = m[1] * x + m[3] * y + m[5];\r\n\r\n    return outVector;\r\n  }\r\n\r\n  /**\r\n   * Transforms given point from a local space to world space without applying\r\n   * scalling.\r\n   *\r\n   * @param  {number} x          The x- component.\r\n   * @param  {number} y          The y- component.\r\n   * @param  {Vector=} outVector If given stores results in it.\r\n   * @return {Vector} Just transformed Vector object.\r\n   */\r\n  transformDirectionXY(x, y, outVector) {\r\n    let m = this._matrix;\r\n    outVector = outVector || new Vector();\r\n\r\n    outVector.x = m[0] * x + m[2] * y;\r\n    outVector.y = m[1] * x + m[3] * y;\r\n\r\n    return outVector;\r\n  }\r\n\r\n  /**\r\n   * Transforms vector by current matrix object.\r\n   *\r\n   * @param  {Vector} vector     Vector to apply transformation on.\r\n   * @param  {Vector=} outVector Out Vector to store results in.\r\n   * @return {Vector} New transformed vector.\r\n   */\r\n  transformVector(vector, outVector) {\r\n    outVector = outVector || new Vector();\r\n    let m = this._matrix;\r\n\r\n    outVector.x = m[0] * vector.x + m[2] * vector.y + m[4];\r\n    outVector.y = m[1] * vector.x + m[3] * vector.y + m[5];\r\n\r\n    return outVector;\r\n  }\r\n\r\n  /**\r\n   * Transforms rectangle by current matrix object.\r\n   *\r\n   * @param  {Rectangle} rect         Rectangle to apply transformation on.\r\n   * @param  {Rectangle|null} outRect When given stores results in it.\r\n   * @return {Rectangle} Tranformed Rectangle object.\r\n   */\r\n  transformRect(rect, outRect) {\r\n    outRect = outRect || new Rectangle();\r\n\r\n    let minX = Number.MAX_VALUE;\r\n    let maxX = -Number.MAX_VALUE;\r\n    let minY = Number.MAX_VALUE;\r\n    let maxY = -Number.MAX_VALUE;\r\n    let xx = 0;\r\n    let yy = 0;\r\n    let tmpVector = new Vector();\r\n\r\n    // TODO: fix dirty hack. rewrite to use rect\r\n    //let points = [rect.x, rect.y, rect.x + rect.width, rect.y + rect.height];\r\n\r\n    /** @type {Array<number>} */\r\n    let points = [rect.x, rect.y, rect.x + rect.width, rect.y, rect.x, rect.y + rect.height, rect.x + rect.width, rect.y + rect.height];\r\n\r\n    for (var i = 0; i < points.length; i += 2) {\r\n      xx = points[i];\r\n      yy = points[i + 1];\r\n\r\n      this.transformXY(xx, yy, tmpVector);\r\n\r\n      if (minX > tmpVector.x)\r\n        minX = tmpVector.x;\r\n      if (maxX < tmpVector.x)\r\n        maxX = tmpVector.x;\r\n      if (minY > tmpVector.y)\r\n        minY = tmpVector.y;\r\n      if (maxY < tmpVector.y)\r\n        maxY = tmpVector.y;\r\n    }\r\n\r\n    outRect.set(minX, minY, maxX - minX, maxY - minY);\r\n    return outRect;\r\n  }\r\n\r\n  /**\r\n   * Inverts current matrix.\r\n   *\r\n   * @return {Matrix} This.\r\n   */\r\n  invert() {\r\n    let a = this._matrix;\r\n\r\n    let aa = a[0];\r\n    let ab = a[1];\r\n    let ac = a[2];\r\n    let ad = a[3];\r\n    let atx = a[4];\r\n    let aty = a[5];\r\n\r\n    let det = aa * ad - ab * ac;\r\n    if (det === 0) {\r\n      a[0] = a[1] = a[2] = a[3] = 0;\r\n      a[4] = -atx;\r\n      a[5] = -aty;\r\n      return this;\r\n    }\r\n    det = 1.0 / det;\r\n\r\n    a[0] = ad * det;\r\n    a[1] = -ab * det;\r\n    a[2] = -ac * det;\r\n    a[3] = aa * det;\r\n    a[4] = (ac * aty - ad * atx) * det;\r\n    a[5] = (ab * atx - aa * aty) * det;\r\n\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * TODO: remove or finish\r\n   * @ignore\r\n   *\r\n   * @returns {Array<number>} Description\r\n   */\r\n  __decompose() {\r\n    let m = this._matrix;\r\n    let a = m[0];\r\n    let b = m[1];\r\n    let c = m[2];\r\n    let d = m[3];\r\n    let tx = m[4];\r\n    let ty = m[5];\r\n\r\n    let skewX = -Math.atan2(-c, d);\r\n    let skewY = Math.atan2(b, a);\r\n\r\n    let delta = Math.abs(skewX + skewY);\r\n\r\n    let r_rotation = 0\r\n    let r_skewX = 0;\r\n    let r_skewY = 0;\r\n    let r_scaleX = 0;\r\n    let r_scaleY = 0;\r\n    let r_x = 0;\r\n    let r_y = 0;\r\n\r\n    if (delta < 0.00001) {\r\n      r_rotation = skewY;\r\n\r\n      if (a < 0 && d >= 0)\r\n        r_rotation += (r_rotation <= 0) ? Math.PI : -Math.PI;\r\n    } else {\r\n      r_skewX = skewX;\r\n      r_skewY = skewY;\r\n    }\r\n\r\n    r_scaleX = Math.sqrt((a * a) + (b * b));\r\n    r_scaleY = Math.sqrt((c * c) + (d * d));\r\n\r\n    r_x = tx;\r\n    r_y = ty;\r\n\r\n    return [r_x, r_y, r_rotation, r_scaleX, r_scaleY, r_skewX, r_skewY];\r\n  }\r\n\r\n  /**\r\n   * Clones the current matrix and returns new cloned object.\r\n   *\r\n   * @return {Matrix} New cloned object.\r\n   */\r\n  clone() {\r\n    let m = new Matrix();\r\n    let v = this._matrix;\r\n    m.set(v[0], v[1], v[2], v[3], v[4], v[5]);\r\n    return m;\r\n  }\r\n\r\n  /**\r\n   * Copies values to given matrix.\r\n   *\r\n   * @param  {Matrix} matrix The destination matrix.\r\n   * @return {Matrix} This.\r\n   */\r\n  copyTo(matrix) {\r\n    let a = this._matrix;\r\n    let b = matrix._matrix;\r\n\r\n    b[0] = a[0];\r\n    b[1] = a[1];\r\n    b[2] = a[2];\r\n    b[3] = a[3];\r\n    b[4] = a[4];\r\n    b[5] = a[5];\r\n\r\n    return matrix;\r\n  }\r\n\r\n  /**\r\n   * Copies values from given matrix into this.\r\n   *\r\n   * @param  {Matrix} matrix The matrix to copy values from.\r\n   * @return {Matrix} This.\r\n   */\r\n  copyFrom(matrix) {\r\n    return matrix.copyTo(this);\r\n  }\r\n\r\n  /**\r\n   * Compares this matrix values with given matrix and checks if they are the same.\r\n   *\r\n   * @param  {Matrix} matrix                   Matrix object to compare with.\r\n   * @param  {number} epsilon = Number.EPSILON Comparision threshold.\r\n   * @return {boolean} True if equal.\r\n   */\r\n  equals(matrix, epsilon = Number.EPSILON) {\r\n    let a = this._matrix;\r\n    let b = matrix._matrix;\r\n    if (!matrix)\r\n      return false;\r\n\r\n    return (Math.abs(a[0] - b[0]) < epsilon) && (Math.abs(a[1] - b[1]) < epsilon) && (Math.abs(a[2] - b[2]) < epsilon) &&\r\n      (Math.abs(a[3] - b[3]) < epsilon) && (Math.abs(a[4] - b[4]) < epsilon) && (Math.abs(a[5] - b[5]) < epsilon);\r\n  }\r\n\r\n  /**\r\n   * Returns array of values representing this matrix object.\r\n   *\r\n   * @return {Float32Array}\r\n   */\r\n  get value() {\r\n    return this._matrix;\r\n  }\r\n\r\n  /**\r\n   * @param  {number=} digits = 2\r\n   * @return {string}\r\n   */\r\n  toString(digits = 2) {\r\n    return `        | ${this.value[0].toFixed(digits)} | ${this.value[1].toFixed(digits)} | ${this.value[4].toFixed(digits)} |\r\nMatrix: | ${this.value[2].toFixed(digits)} | ${this.value[3].toFixed(digits)} | ${this.value[5].toFixed(digits)} |\r\n        | ${(0).toFixed(digits)} | ${(0).toFixed(digits)} | ${(1).toFixed(digits)} |`;\r\n  }\r\n}\r\n\r\n/**\r\n * @type {Matrix}\r\n * @nocollapse\r\n */\r\nMatrix.__cache = new Matrix();\r\n","/**\r\n * Mathematical representation of a rectangle.\r\n *\r\n * @cat geom\r\n */\r\n\r\nclass Rectangle {\r\n  /**\r\n   * Creates new instance of Rectangle.\r\n   *\r\n   * @param  {number=} y = 0 X-component.\r\n   * @param  {number=} x = 0 Y-component.\r\n   * @param  {number=} w = 0 The width.\r\n   * @param  {number=} h = 0 The height.\r\n   */\r\n  constructor(x = 0, y = 0, w = 0, h = 0) {\r\n    /**\r\n     * The x coordinate of the rectangle.\r\n     * @type {number}\r\n     */\r\n    this.x = x;\r\n\r\n    /**\r\n     * The y coordinate of the rectangle.\r\n     * @type {number}\r\n     */\r\n    this.y = y;\r\n\r\n    /**\r\n     * The width of the rectangle.\r\n     * @type {number}\r\n     */\r\n    this.width = w;\r\n\r\n    /**\r\n     * The height of the rectangle.\r\n     * @type {number}\r\n     */\r\n    this.height = h;\r\n  }\r\n\r\n  /**\r\n   * Update rectangle values with a given.\r\n   *\r\n   * @param {number} x X-component.\r\n   * @param {number} y Y-component.\r\n   * @param {number} w The width.\r\n   * @param {number} h The height.\r\n   *\r\n   * @return {Rectangle} This.\r\n   */\r\n  set(x, y, w, h) {\r\n    this.x = x;\r\n    this.y = y;\r\n    this.width = w;\r\n    this.height = h;\r\n\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Copies values from given rectangle into this one.\r\n   *\r\n   * @param {Rectangle} rect The Rectangle to copy values from.\r\n   *\r\n   * @return {Rectangle} This.\r\n   */\r\n  copyFrom(rect) {\r\n    this.x = rect.x;\r\n    this.y = rect.y;\r\n    this.width = rect.width;\r\n    this.height = rect.height;\r\n\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Copies values from this rectangle into given rectangle.\r\n   *\r\n   * @param {Rectangle} rect The destination rect.\r\n   *\r\n   * @return {Rectangle} Given rect object.\r\n   */\r\n  copyTo(rect) {\r\n    rect.x = this.x;\r\n    rect.y = this.y;\r\n    rect.width = this.width;\r\n    rect.height = this.height;\r\n\r\n    return rect;\r\n  }\r\n\r\n  /**\r\n   * Get/Sets the leftmost point of this rectangle.\r\n   *\r\n   * @return {number}\r\n   */\r\n  get left() {\r\n    return this.x;\r\n  }\r\n\r\n  /**\r\n   * @ignore\r\n   *\r\n   * @param {number} left\r\n   */\r\n  set left(left) {\r\n    this.x = left;\r\n  }\r\n\r\n  /**\r\n   * Get/Sets the rightmost point of this rectangle.\r\n   *\r\n   * @return {number}\r\n   */\r\n  get right() {\r\n    return this.x + this.width;\r\n  }\r\n\r\n  /**\r\n   * @ignore\r\n   *\r\n   * @param {number} right\r\n   */\r\n  set right(right) {\r\n    this.x = right - this.width;\r\n  }\r\n\r\n  /**\r\n   * Get/Sets the topmost point of this rectangle.\r\n   *\r\n   * @return {number}\r\n   */\r\n  get top() {\r\n    return this.y;\r\n  }\r\n\r\n  /**\r\n   * @ignore\r\n   *\r\n   * @param {number} top\r\n   */\r\n  set top(top) {\r\n    this.y = top;\r\n  }\r\n\r\n  /**\r\n   * Get/Sets the bottommost point of this rectangle.\r\n   *\r\n   * @return {number} Description\r\n   */\r\n  get bottom() {\r\n    return this.y + this.height;\r\n  }\r\n\r\n  /**\r\n   * @ignore\r\n   *\r\n   * @param {number} bottom\r\n   */\r\n  set bottom(bottom) {\r\n    this.y = bottom - this.height;\r\n  }\r\n\r\n  /**\r\n   * Get/Sets the top left point for this rectangle.\r\n   *\r\n   * @return {Vector}\r\n   */\r\n  get topLeft() {\r\n    return new Vector(this.x, this.y);\r\n  }\r\n\r\n  /**\r\n   * @ignore\r\n   *\r\n   * @param {Vector} vector\r\n   */\r\n  set topLeft(vector) {\r\n    this.left = vector.x;\r\n    this.top = vector.y;\r\n  }\r\n\r\n  /**\r\n   * Get/Sets the top right point for this rectangle.\r\n   *\r\n   * @return {Vector} Description\r\n   */\r\n  get topRight() {\r\n    return new Vector(this.right, this.y);\r\n  }\r\n\r\n  /**\r\n   * @ignore\r\n   *\r\n   * @param {Vector} vector\r\n   */\r\n  set topRight(vector) {\r\n    this.right = vector.x;\r\n    this.top = vector.y;\r\n  }\r\n\r\n  /**\r\n   * Get/Sets the top left point for this rectangle.\r\n   *\r\n   * @return {Vector} Description\r\n   */\r\n  get bottomRight() {\r\n    return new Vector(this.right, this.bottom);\r\n  }\r\n\r\n  /**\r\n   * @ignore\r\n   *\r\n   * @param {Vector} vector\r\n   */\r\n  set bottomRight(vector) {\r\n    this.right = vector.x;\r\n    this.bottom = vector.y;\r\n  }\r\n\r\n  /**\r\n   * Get/Sets the top left point for this rectangle.\r\n   *\r\n   * @return {Vector} Description\r\n   */\r\n  get bottomLeft() {\r\n    return new Vector(this.x, this.bottom);\r\n  }\r\n\r\n  /**\r\n   * @ignore\r\n   *\r\n   * @param {Vector} vector\r\n   */\r\n  set bottomLeft(vector) {\r\n    this.x = vector.x;\r\n    this.bottom = vector.y;\r\n  }\r\n\r\n  /**\r\n   * Creates a new Rectangle instance with width and height equal to current\r\n   * instance.\r\n   *\r\n   * @param {Vector=} outVector Resulting rect to save values in.\r\n   *\r\n   * @return {Vector} New Rectangle instance or `outVector` if passed.\r\n   */\r\n  size(outVector = undefined) {\r\n    outVector = outVector || new Vector();\r\n    return outVector.set(this.width, this.height);\r\n  }\r\n\r\n  /**\r\n   * Sets all components of this Rectangle to zero.\r\n   *\r\n   * @return {Rectangle} This.\r\n   */\r\n  zero() {\r\n    return this.set(0, 0, 0, 0);\r\n  }\r\n\r\n\r\n  /**\r\n   * Compares this Rectangle with a given one.\r\n   *\r\n   * @param {Rectangle} rect                  Rect to compare values with.\r\n   * @param {number} epsilon = Number.EPSILON\r\n   *\r\n   * @return {boolean} True if rects are equal.\r\n   */\r\n  equals(rect, epsilon = Number.EPSILON) {\r\n    return rect !== null && (Math.abs(this.x - rect.x) < epsilon) && (Math.abs(this.y - rect.y) < epsilon) &&\r\n           (Math.abs(this.width - rect.width) < epsilon) && (Math.abs(this.height - rect.height) < epsilon);\r\n  }\r\n\r\n\r\n  /**\r\n   * Checks if a given point is inside this rectangle.\r\n   *\r\n   * @param {number} x The x-component of a point.\r\n   * @param {number} y The y-component of a point.\r\n   *\r\n   * @return {boolean} True if point is inside.\r\n   */\r\n  containsXY(x, y) {\r\n    return x >= this.x && x <= this.right && y >= this.y && y <= this.bottom;\r\n  }\r\n\r\n\r\n  /**\r\n   * Checks if a given rectangle is inside this rect.\r\n   *\r\n   * @param {Rectangle} rect Rectangle to check with.\r\n   *\r\n   * @return {boolean} True if given rectangle is inside this one.\r\n   */\r\n  contains(rect) {\r\n    return rect.x >= this.x && rect.y >= this.y && rect.right <= this.right && rect.bottom <= this.bottom;\r\n  }\r\n\r\n  /**\r\n   * Checks if this rect intersects with a given rectangle.\r\n   *\r\n   * @param {Rectangle} rect The rect to check intersection with.\r\n   *\r\n   * @return {boolean} True if intersects.\r\n   */\r\n  intersects(rect) {\r\n    return rect.right > this.x && rect.bottom > this.y &&\r\n           rect.x < this.right && rect.y < this.bottom;\r\n  }\r\n\r\n\r\n  /**\r\n   * Adds given rectangle into this.\r\n   *\r\n   * @param {Rectangle} toUnion A rectangle object to add to this rect.\r\n   *\r\n   * @return {Rectangle} New rectangle object that is the union.\r\n   */\r\n  union(toUnion) {\r\n    if (this.width === 0 || this.height === 0)\r\n      return toUnion.clone();\r\n    else if (toUnion.width === 0 || toUnion.height === 0)\r\n      return this.clone();\r\n\r\n    let x0 = this.x > toUnion.x ? toUnion.x : this.x;\r\n    let x1 = this.right < toUnion.right ? toUnion.right : this.right;\r\n    let y0 = this.y > toUnion.y ? toUnion.y : this.y;\r\n    let y1 = this.bottom < toUnion.bottom ? toUnion.bottom : this.bottom;\r\n\r\n    return new Rectangle(x0, y0, x1 - x0, y1 - y0);\r\n  }\r\n\r\n\r\n  /**\r\n   * Returns volume of this Rectangle.\r\n   *\r\n   * @return {number}\r\n   */\r\n  get volume() {\r\n    return this.width * this.height;\r\n  }\r\n\r\n\r\n  /**\r\n   * Expands this rectangle object by given values.\r\n   *\r\n   * @param {number} x      X-component.\r\n   * @param {number} y      Y-component\r\n   * @param {number} width  The width.\r\n   * @param {number} height The height.\r\n   *\r\n   * @return {Rectangle} This.\r\n   */\r\n  expand(x, y, width, height) {\r\n    if (this.volume === 0)\r\n      return this.set(x, y, width, height);\r\n\r\n    let cacheRight = this.right;\r\n\t\tlet cacheBottom = this.bottom;\r\n\r\n    if (this.x > x) {\r\n      this.x = x;\r\n      this.width = cacheRight - x;\r\n    }\r\n\r\n    if (this.y > y) {\r\n      this.y = y;\r\n      this.height = cacheBottom - y;\r\n    }\r\n\r\n    if (cacheRight < x + width)\r\n      this.width = x + width - this.x;\r\n\r\n\t\tif (cacheBottom < y + height)\r\n      this.height = y + height - this.y;\r\n\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Increases the size of this rectangle by given x- and y- values.\r\n   *\r\n   * @param {number=} [x=0] X-component.\r\n   * @param {number=} [y=0] Y-component.\r\n   *\r\n   * @return {Rectangle} This.\r\n   */\r\n  inflate(x = 0, y = 0) {\r\n    this.x -= x;\r\n    this.y -= y;\r\n    this.width += 2 * x;\r\n    this.height += 2 * y;\r\n\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Clones this Rectangle object into new one.\r\n   *\r\n   * @return {Rectangle} New rectangle object.\r\n   */\r\n  clone() {\r\n    return new Rectangle(this.x, this.y, this.width, this.height);\r\n  }\r\n\r\n  /**\r\n   * perimeter - Description\r\n   *\r\n   * @return {number} Description\r\n   */\r\n  get perimeter() {\r\n    return 2 * (this.width + this.height);\r\n  }\r\n\r\n\r\n  /**\r\n   * Returns the center point of this rectangle.\r\n   *\r\n   * @param {Vector=} outVector The out-Vector to store values in.\r\n   *\r\n   * @return {Vector} New rectangle object.\r\n   */\r\n  center(outVector = undefined) {\r\n    outVector = outVector || new Vector();\r\n    return outVector.set(this.x + this.width * 0.5, this.y + this.height * 0.5);\r\n  }\r\n\r\n  /**\r\n   *  Scales this rectangle.\r\n   *\r\n   * @param {number} x Width multiplier.\r\n   * @param {number} y Height multiplier.\r\n   *\r\n   * @return {Rectangle} This rectangle.\r\n   */\r\n  scale(x, y) {\r\n    this.width *= x;\r\n    this.height *= y;\r\n\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Checks if rectangle has area.\r\n   *\r\n   * @return {boolean} True if has.\r\n   */\r\n  isEmpty() {\r\n    return this.width === 0 && this.height === 0;\r\n  }\r\n\r\n  get lines() { // todo\r\n    return [\r\n      new Line(this.topLeft, this.topRight),\r\n      new Line(this.topRight, this.bottomRight),\r\n      new Line(this.bottomRight, this.bottomLeft),\r\n      new Line(this.bottomLeft, this.topLeft)\r\n    ];\r\n  }\r\n\r\n  /**\r\n   * toString - Description\r\n   *\r\n   * @param {number=} [digits=2] Description\r\n   *\r\n   * @return {string} Description\r\n   */\r\n  toString(digits = 2) {\r\n    return `Rectangle { x: ${this.x.toFixed(digits)}, y: ${this.y.toFixed(digits)}, width: ${this.width.toFixed(digits)}, height: ${this.height.toFixed(digits)} }`;\r\n  }\r\n}\r\n\r\n/**\r\n * @ignore\r\n * @type {Rectangle}\r\n * @nocollapse\r\n */\r\nRectangle.__cache = new Rectangle();\r\n","/**\r\n * Mathematical representation of a circle.\r\n *\r\n * @cat geom\r\n */\r\n\r\nclass Circle {\r\n  /**\r\n   * Creates new Circle instance.\r\n   * \r\n   * @param  {number=} x = 0 Position x.\r\n   * @param  {number=} y = 0 Position y.\r\n   * @param  {number=} r = 1 Radius.\r\n   */\r\n  constructor(x = 0, y = 0, r = 1) {\r\n    /**\r\n     * @private\r\n     * @type {number}\r\n     */\r\n    this.x = x;\r\n\r\n    /**\r\n     * @private\r\n     * @type {number}\r\n     */\r\n    this.y = y;\r\n\r\n    /**\r\n     * @private\r\n     * @type {number}\r\n     */\r\n    this.r = r;\r\n  }\r\n\r\n  /**\r\n   * Sets new circle properties\r\n   *\r\n   * @param {number} x Position x.\r\n   * @param {number} y Position y.\r\n   * @param {number} r Radius.\r\n   *\r\n   * @return {Circle} This circle.\r\n   */\r\n  set(x, y, r) {\r\n    this.x = x;\r\n    this.y = y;\r\n    this.r = r;\r\n\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Clones this circle.\r\n   *\r\n   * @return {Circle} Created circle.\r\n   */\r\n  clone() {\r\n    return new Circle(this.x, this.y, this.r);\r\n  }\r\n\r\n  /**\r\n   * Copy this properties to another circle.\r\n   *\r\n   * @param {Circle} circle Object to copy to.\r\n   *\r\n   * @return {Circle} Passed circle.\r\n   */\r\n  copyTo(circle) {\r\n    return circle.set(this.x, this.y, this.r);\r\n  }\r\n\r\n  /**\r\n   * Copy another circle properties to this.\r\n   *\r\n   * @param {Circle} circle Object to copy from.\r\n   *\r\n   * @return {Circle} This circle.\r\n   */\r\n  copyFrom(circle) {\r\n    return this.set(circle.x, circle.y, circle.r);\r\n  }\r\n\r\n  /**\r\n   * Shows whether circles are identical.\r\n   *\r\n   * @param {Circle} circle Object to comparison.\r\n   * @param {number=} epsilon Compare precision.\r\n   *\r\n   * @return {boolean} True if circles are identical.\r\n   */\r\n  equals(circle, epsilon = Number.EPSILON) {\r\n    return circle !== null && (Math.abs(this.x - circle.x) < epsilon) && (Math.abs(this.y - circle.y) < epsilon) &&\r\n      (Math.abs(this.r - circle.r) < epsilon);\r\n  }\r\n\r\n  /**\r\n   * Shows whether point is in circle.\r\n   *\r\n   * @param {number} x Point position x.\r\n   * @param {number} y Point position y.\r\n   *\r\n   * @return {boolean} True if circle contains point.\r\n   */\r\n  containsXY(x, y) {\r\n    return this.contains(new Vector(x, y));\r\n  }\r\n\r\n  /**\r\n   * Shows whether point is in circle.\r\n   *\r\n   * @param {Vector} vector Point to check.\r\n   *\r\n   * @return {boolean} True if circle contains point.\r\n   */\r\n  contains(vector) {\r\n    return new Vector(this.x, this.y).subtract(vector).length() <= this.r;\r\n  }\r\n\r\n  /**\r\n   * Finds left X position.\r\n   *\r\n   * @return {number} Left X position.\r\n   */\r\n  get left() {\r\n    return this.x - this.r;\r\n  }\r\n\r\n  /**\r\n   * Finds right X position.\r\n   *\r\n   * @return {number} Right X position.\r\n   */\r\n  get right() {\r\n    return this.x + this.r;\r\n  }\r\n\r\n  /**\r\n   * Finds top Y position.\r\n   *\r\n   * @return {number} Top Y position.\r\n   */\r\n  get top() {\r\n    return this.y - this.r;\r\n  }\r\n\r\n  /**\r\n   * Finds bottom Y position.\r\n   *\r\n   * @return {number} Bottom Y position.\r\n   */\r\n  get bottom() {\r\n    return this.y + this.r;\r\n  }\r\n\r\n  /**\r\n   * Returns top point of this circle.\r\n   *\r\n   * @return {Vector}\r\n   */\r\n  get topPoint() {\r\n    return new Vector(this.x, this.top);\r\n  }\r\n\r\n  /**\r\n   * Returns bottom point of this circle.\r\n   *\r\n   * @return {Vector}\r\n   */\r\n  get bottomPoint() {\r\n    return new Vector(this.x, this.bottom);\r\n  }\r\n\r\n  /**\r\n   * Resets all values to zero.\r\n   *\r\n   * @return {Circle} Returns this.\r\n   */\r\n  zero() {\r\n    return this.set(0, 0, 0);\r\n  }\r\n\r\n  /**\r\n   * Shows whether this circle intersects another.\r\n   *\r\n   * @param {Circle} circle Circle to check.\r\n   *\r\n   * @return {boolean} True if intersects.\r\n   */\r\n  intersects(circle) {\r\n    let d = new Vector(this.x, this.y).distance(new Vector(circle.x, circle.y));\r\n    return d <= this.r + circle.r && d >= this.r - circle.r;\r\n  }\r\n\r\n  /**\r\n   * Shows whether this circle collide with another.\r\n   *\r\n   * @param {Circle} circle Circle to check.\r\n   *\r\n   * @return {boolean} True if collide.\r\n   */\r\n  collide(circle) {\r\n    let d = new Vector(this.x, this.y).distance(new Vector(circle.x, circle.y));\r\n    return d <= this.r + circle.r;\r\n  }\r\n\r\n  /**\r\n   * overlap - Shows whether this circle overlap another.\r\n   *\r\n   * @param {Circle} circle Circle to check.\r\n   *\r\n   * @return {boolean} True if overlap.\r\n   */\r\n  overlap(circle) {\r\n    if (this.r < circle.r) {\r\n      return false;\r\n    }\r\n\r\n    let d = new Vector(this.x, this.y).distance(new Vector(circle.x, circle.y));\r\n    return d <= this.r - circle.r;\r\n  }\r\n\r\n  /**\r\n   * Returns area of this circle.\r\n   *\r\n   * @return {number} area.\r\n   */\r\n  get volume() {\r\n    return Math.PI * this.r * this.r;\r\n  }\r\n\r\n  /**\r\n   * Returns perimeter of this circle.\r\n   *\r\n   * @return {number} perimeter.\r\n   */\r\n  get perimeter() {\r\n    return 2 * Math.PI * this.r;\r\n  }\r\n\r\n  /**\r\n   * Represents center as vector.\r\n   *\r\n   * @param {Vector=} outVector Object for result.\r\n   *\r\n   * @return {Vector} Center point.\r\n   */\r\n  center(outVector = undefined) {\r\n    outVector = outVector || new Vector();\r\n    return outVector.set(this.x, this.y);\r\n  }\r\n\r\n  /**\r\n   * String representation of this circle.\r\n   *\r\n   * @param {number=} [digits=2] Number of digits after float point.\r\n   *\r\n   * @return {string} Returns string representation of this circle.\r\n   */\r\n  toString(digits = 2) {\r\n    return `Circle { x: ${this.x.toFixed(digits)}, y: ${this.y.toFixed(digits)}, r: ${this.r.toFixed(digits)} }`;\r\n  }\r\n}\r\n\r\n/** @type {Circle}\r\n * @nocollapse\r\n */\r\nCircle.__cache = new Circle();\r\n","/**\r\n * Mathematical representation of a bezier curve.\r\n *\r\n * @cat geom\r\n */\r\n\r\nclass Line {\r\n  /**\r\n   * Creates new Line instance.\r\n   * @param  {Vector} start Start point.\r\n   * @param  {Vector} end End point.\r\n   */\r\n  constructor(start, end) {\r\n    /** @type {Vector} */\r\n    this.start = start;\r\n\r\n    /** @type {Vector} */\r\n    this.end = end;\r\n  }\r\n\r\n  /**\r\n   * set - Sets new line properties\r\n   *\r\n   * @param  {Vector} start Start point.\r\n   * @param  {Vector} end End point.\r\n   *\r\n   * @return {Line} This circle.\r\n   */\r\n  set(start, end) {\r\n    this.start = start;\r\n    this.end = end;\r\n\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * clone - Clones this line.\r\n   *\r\n   * @return {Line} Created line.\r\n   */\r\n  clone() {\r\n    return new Line(this.start.clone(), this.end.clone());\r\n  }\r\n\r\n  /**\r\n   * copyTo - Copy this properties to another line.\r\n   *\r\n   * @param {Line} line Object to copy to.\r\n   *\r\n   * @return {Line} Passed line.\r\n   */\r\n  copyTo(line) {\r\n    return line.set(this.start.clone(), this.end.clone());\r\n  }\r\n\r\n  /**\r\n   * copyFrom - Copy another line properties to this.\r\n   *\r\n   * @param {Line} line Object to copy from.\r\n   *\r\n   * @return {Line} This circle.\r\n   */\r\n  copyFrom(line) {\r\n    return this.set(line.start.clone(), line.end.clone());\r\n  }\r\n\r\n  /**\r\n   * equals - Shows whether lines are identical.\r\n   *\r\n   * @param {Line} line Object to comparison.\r\n   * @param {number=} epsilon Compare precision.\r\n   *\r\n   * @return {boolean} True if lines are identical.\r\n   */\r\n  equals(line, epsilon = Number.EPSILON) {\r\n    return (this.start.equals(line.start, epsilon) && this.end.equals(line.end, epsilon)) ||\r\n      (this.start.equals(line.end, epsilon) && this.end.equals(line.start, epsilon));\r\n  }\r\n\r\n  /**\r\n   * left - Finds left X position.\r\n   *\r\n   * @return {number} Left X position.\r\n   */\r\n  get left() {\r\n    return Math.min(this.start.x, this.end.x);\r\n  }\r\n\r\n\r\n  /**\r\n   * right - Finds right X position.\r\n   *\r\n   * @return {number} Right X position.\r\n   */\r\n  get right() {\r\n    return Math.max(this.start.x, this.end.x);\r\n  }\r\n\r\n  /**\r\n   * top - Finds top Y position.\r\n   *\r\n   * @return {number} Top Y position.\r\n   */\r\n  get top() {\r\n    return Math.min(this.start.y, this.end.y);\r\n  }\r\n\r\n  /**\r\n   * bottom - Finds bottom Y position.\r\n   *\r\n   * @return {number} Bottom Y position.\r\n   */\r\n  get bottom() {\r\n    return Math.max(this.start.y, this.end.y);\r\n  }\r\n\r\n  /**\r\n   * reverse - Replace line start and end points.\r\n   *\r\n   * @return {Line} This line.\r\n   */\r\n  reverse() {\r\n    let start = this.start;\r\n    this.start = this.end;\r\n    this.end = start;\r\n\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * normalize - Change line's length to one. Moves end point.\r\n   *\r\n   * @return {Line} This line.\r\n   */\r\n  normalize() {\r\n    this.end\r\n      .subtract(this.start)\r\n      .normalize()\r\n      .add(this.start);\r\n\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * scale - Change line's length to scaled. Moves end point.\r\n   *\r\n   * @return {Line} This line.\r\n   */\r\n  scale(multyplier) {\r\n    this.end\r\n      .subtract(this.start)\r\n      .multiplyScalar(multyplier)\r\n      .add(this.start);\r\n\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * zero - Description\r\n   *\r\n   * @return {Line} Description\r\n   */\r\n  zero() {\r\n    return this.set(new Vector(), new Vector());\r\n  }\r\n\r\n  /**\r\n   * length - Length of this line.\r\n   *\r\n   * @return {number} length.\r\n   */\r\n  length() {\r\n    return this.start.distance(this.end);\r\n  }\r\n\r\n  /**\r\n   * center - Represents center as vector.\r\n   *\r\n   * @param {Vector=} outVector Object for result.\r\n   *\r\n   * @return {Vector} Center point.\r\n   */\r\n  center(outVector = undefined) {\r\n    outVector = outVector || new Vector();\r\n    return outVector.set((this.start.x + this.end.x) / 2, (this.start.y + this.end.y) / 2);\r\n  }\r\n\r\n\r\n  /**\r\n   * type - Description\r\n   *\r\n   * @return {string} Description\r\n   */\r\n  get type() {\r\n    return 'Line';\r\n  }\r\n\r\n  /**\r\n   * containsXY - Shows whether point is on line.\r\n   *\r\n   * @param {number} x Point position x.\r\n   * @param {number} y Point position y.\r\n   *\r\n   * @return {boolean} True if line contains point.\r\n   */\r\n  containsXY(x, y) {\r\n    return this.contains(new Vector(x, y));\r\n  }\r\n\r\n  /**\r\n   * contains - Shows whether point is on line.\r\n   *\r\n   * @param {Vector} vector Point to check.\r\n   *\r\n   * @return {boolean} True if line contains point.\r\n   */\r\n  contains(vector) {\r\n    return this.start.distance(vector) + this.end.distance(vector) === this.length();\r\n  }\r\n\r\n  /**\r\n   * intersects - Shows whether this line intersects another.\r\n   *\r\n   * @param {Line} line Line to check.\r\n   *\r\n   * @return {boolean} True if intersects.\r\n   */\r\n  intersects(line) {\r\n    let start1 = this.start;\r\n    let end1 = this.end;\r\n    let start2 = line.start;\r\n    let end2 = line.end;\r\n\r\n    let denominator = ((end2.y - start2.y) * (end1.x - start1.x)) - ((end2.x - start2.x) * (end1.y - start1.y));\r\n\r\n    if (denominator === 0) {\r\n      return false;\r\n    }\r\n\r\n    let a = start1.y - start2.y;\r\n    let b = start1.x - start2.x;\r\n    let numerator1 = ((end2.x - start2.x) * a) - ((end2.y - start2.y) * b);\r\n    let numerator2 = ((end1.x - start1.x) * a) - ((end1.y - start1.y) * b);\r\n    a = numerator1 / denominator;\r\n    b = numerator2 / denominator;\r\n\r\n    return a >= 0 && a <= 1 && b > 0 && b < 1;\r\n  }\r\n\r\n  /**\r\n   * intersects - Shows whether this line intersects circle.\r\n   *\r\n   * @param {Circle} circle Circle to check.\r\n   *\r\n   * @return {boolean} True if intersects.\r\n   */\r\n  intersectsCircle(circle) {\r\n    let start = this.start;\r\n    let end = this.end;\r\n\r\n    if (circle.contains(start) || circle.contains(end)) {\r\n      return true;\r\n    }\r\n\r\n    let distance = start.distance(end);\r\n    let directionX = (end.x - start.x) / distance;\r\n    let directionY = (end.y - start.y) / distance;\r\n\r\n    let t = directionX * (circle.x - start.x) + directionY * (circle.y - start.y);\r\n\r\n    let nearest = new Vector((t * directionX) + start.x, (t * directionY) + start.y);\r\n    let nearestDistance = nearest.distance(new Vector(circle.x, circle.y));\r\n\r\n    if (nearestDistance < circle.r) {\r\n      let dt = Math.sqrt(Math.pow(circle.r, 2) - Math.pow(nearestDistance, 2));\r\n\r\n      let x1 = ((t - dt) * directionX + start.x).toFixed(15);\r\n      let y1 = ((t - dt) * directionY + start.y).toFixed(15);\r\n      let x2 = ((t + dt) * directionX + start.x).toFixed(15);\r\n      let y2 = ((t + dt) * directionY + start.y).toFixed(15);\r\n\r\n      return this.__isInBoundsXY(x1, y1) || this.__isInBoundsXY(x2, y2);\r\n    }\r\n\r\n    return false;\r\n  }\r\n\r\n  __isInBoundsXY(x, y) {\r\n    let x1 = this.start.x;\r\n    let y1 = this.start.y;\r\n    let x2 = this.end.x;\r\n    let y2 = this.end.y;\r\n\r\n    return x > Math.min(x1, x2) && x < Math.max(x1, x2) && y > Math.min(y1, y2) && y < Math.max(y1, y2);\r\n  }\r\n\r\n  /**\r\n   * toString - String representation of this line.\r\n   *\r\n   * @param {number=} [digits=2] Number of digits after float point.\r\n   *\r\n   * @return {string} Description.\r\n   */\r\n  toString(digits = 2) {\r\n    return `Line { start: ${this.start.toString(digits)}, end: ${this.end.toString(digits)} }`;\r\n  }\r\n}\r\n\r\n/** @type {Line}\r\n * @nocollapse\r\n */\r\nLine.__cache = new Line(new Vector(), new Vector());\r\n","/**\r\n * @cat geom\r\n */\r\n\r\nclass Polygon {\r\n  /**\r\n   * Creates new Polygon instance.\r\n   *\r\n   * @param  {Array<Vector>} vertices = [] Array of vertex points;\r\n   */\r\n  constructor(vertices = []) {\r\n\r\n    /**\r\n     * @private\r\n     * @type {Array<Vector>}\r\n     */\r\n    this.mVertices = vertices;\r\n\r\n    /**\r\n     * @private\r\n     * @type {Array<Line>}\r\n     */\r\n    this.mLines = [];\r\n\r\n    /**\r\n     * @private\r\n     * @type {Rectangle}\r\n     */\r\n    this.mBounds = new Rectangle();\r\n\r\n    /**\r\n     * @private\r\n     * @type {Vector}\r\n     */\r\n    this.mCenter = new Vector();\r\n\r\n    this.refresh();\r\n  }\r\n\r\n  /**\r\n   * set - Sets new vertices.\r\n   *\r\n   * @param {Array<Vector>} vertices New points.\r\n   *\r\n   * @return {Polygon} This polygon.\r\n   */\r\n  set(vertices) {\r\n    this.mVertices = vertices;\r\n    this.refresh();\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * copyTo - Copy this properties to another polygon.\r\n   *\r\n   * @param {Polygon} polygon Object to copy to.\r\n   *\r\n   * @return {Polygon} Passed polygon.\r\n   */\r\n  copyTo(polygon) {\r\n    let len = this.mVertices.length;\r\n    let vertices = [];\r\n\r\n    for (let i = 0; i < len; i++) {\r\n      vertices.push(this.mVertices[i].clone());\r\n    }\r\n\r\n    return polygon.set(vertices);\r\n  }\r\n\r\n  /**\r\n   * copyFrom - Copy another polygon properties to this.\r\n   *\r\n   * @param {Polygon} polygon Object to copy from.\r\n   *\r\n   * @return {Polygon} This polygon.\r\n   */\r\n  copyFrom(polygon) {\r\n    let polygonVertices = polygon.mVertices;\r\n    let len = polygonVertices.length;\r\n    let vertices = [];\r\n\r\n    for (let i = 0; i < len; i++) {\r\n      vertices.push(polygonVertices[i].clone());\r\n    }\r\n\r\n    return this.set(vertices);\r\n  }\r\n\r\n  /**\r\n   * clone - Clones this polygon.\r\n   *\r\n   * @return {Polygon} Created polygon.\r\n   */\r\n  clone() {\r\n    let thisVertices = this.mVertices;\r\n    let len = thisVertices.length;\r\n    let vertices = [];\r\n\r\n    for (let i = 0; i < len; i++) {\r\n      vertices.push(thisVertices[i].clone());\r\n    }\r\n\r\n    return new Polygon(vertices);\r\n  }\r\n\r\n  get width() {\r\n    return this.mBounds.width;\r\n  }\r\n\r\n  get height() {\r\n    return this.mBounds.height;\r\n  }\r\n\r\n  /**\r\n   * containsXY - Shows whether point is in polygon.\r\n   *\r\n   * @param {number} x Point position x.\r\n   * @param {number} y Point position y.\r\n   *\r\n   * @return {boolean} True if polygon contains point.\r\n   */\r\n  containsXY(x, y) {\r\n    return this.contains(new Vector(x, y));\r\n  }\r\n\r\n  /**\r\n   * contains - Shows whether point is in polygon.\r\n   *\r\n   * @param {Vector} vector Point to check.\r\n   *\r\n   * @return {boolean} True if polygon contains point.\r\n   */\r\n  contains(vector) {\r\n    let center = this.mCenter;\r\n    let lines = this.mLines;\r\n    let len = lines.length;\r\n\r\n    if (center.equals(vector)) {\r\n      return true;\r\n    }\r\n\r\n    let intersectionLine = new Line(vector, center.clone());\r\n    let intersects = 0;\r\n    intersectionLine.scale((this.width + this.height) / intersectionLine.length());\r\n\r\n    for (let i = 0; i < len; i++) {\r\n      intersects += lines[i].intersects(intersectionLine) ? 1 : 0;\r\n    }\r\n\r\n    return intersects % 2 !== 0;\r\n  }\r\n\r\n  /**\r\n   * perimeter - Perimeter of this polygon.\r\n   *\r\n   * @return {number} perimeter.\r\n   */\r\n  get perimeter() {\r\n    let thisLines = this.mLines;\r\n    let len = thisLines.length;\r\n    let perimeter = 0;\r\n\r\n    for (let i = 0; i < len; i++) {\r\n      perimeter += thisLines[i].length();\r\n    }\r\n\r\n    return perimeter;\r\n  }\r\n\r\n  /**\r\n   * collide - Checks collides between two polygons.\r\n   *\r\n   * @param {Polygon} polygon Object to check.\r\n   *\r\n   * @return {boolean} True if polygon collides with another polygon.\r\n   */\r\n  collide(polygon) {\r\n    if (!this.mBounds.intersects(polygon.mBounds)) {\r\n      return false;\r\n    }\r\n\r\n    let thisLines = this.mLines;\r\n    let thisLen = thisLines.length;\r\n    let polygonLines = polygon.mLines;\r\n    let polygonLen = polygonLines.length;\r\n\r\n    for (let i = 0; i < thisLen; i++) {\r\n      for (let j = 0; j < polygonLen; j++) {\r\n        if (thisLines[i].intersects(polygonLines[j])) {\r\n          return true;\r\n        }\r\n      }\r\n    }\r\n\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * collideCircle - Checks collides between this polygon and circle.\r\n   *\r\n   * @param {Circle} circle Object to check.\r\n   *\r\n   * @return {boolean} True if polygon collides with circle.\r\n   */\r\n  collideCircle(circle) {\r\n    let bounds = this.mBounds;\r\n    let lines = this.mLines;\r\n\r\n    if (bounds.left > circle.right || bounds.right < circle.left || bounds.top > circle.bottom || bounds.bottom < circle.top) {\r\n      return false;\r\n    }\r\n\r\n    let len = lines.length;\r\n    for (let i = 0; i < len; i++) {\r\n      if (lines[i].intersectsCircle(circle)) {\r\n        return true;\r\n      }\r\n    }\r\n\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * collideRectangle - Checks collides between this polygon and rectangle.\r\n   *\r\n   * @param {Rectangle} rectangle Object to check.\r\n   *\r\n   * @return {boolean} True if polygon collides with rectangle.\r\n   */\r\n  collideRectangle(rectangle) {\r\n    if (!this.mBounds.intersects(rectangle)) {\r\n      return false;\r\n    }\r\n\r\n    let thisLines = this.mLines;\r\n    let thisLen = thisLines.length;\r\n    let rectangleLines = rectangle.lines;\r\n    let rectangleLen = rectangleLines.length;\r\n\r\n    for (let i = 0; i < thisLen; i++) {\r\n      for (let j = 0; j < rectangleLen; j++) {\r\n        if (thisLines[i].intersects(rectangleLines[j])) {\r\n          return true;\r\n        }\r\n      }\r\n    }\r\n\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * overlap - Checks overlaps between this polygon and another.\r\n   *\r\n   * @param {Polygon} polygon Object to check.\r\n   *\r\n   * @return {boolean} True if polygon overlaps second.\r\n   */\r\n  overlap(polygon) {\r\n    if (this.mBounds.width < polygon.mBounds.width || this.mBounds.height < polygon.mBounds.height) {\r\n      return false;\r\n    }\r\n\r\n    if (!this.contains(polygon.mCenter)) {\r\n      return false;\r\n    }\r\n\r\n    let thisLines = this.mLines;\r\n    let thisLen = thisLines.length;\r\n    let polygonLines = polygon.mLines;\r\n    let polygonLen = polygonLines.length;\r\n\r\n    for (let i = 0; i < thisLen; i++) {\r\n      for (let j = 0; j < polygonLen; j++) {\r\n        if (thisLines[i].intersects(polygonLines[j])) {\r\n          return false;\r\n        }\r\n      }\r\n    }\r\n\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * overlapCircle - Checks overlaps between this polygon and circle.\r\n   *\r\n   * @param {Circle} circle Object to check.\r\n   *\r\n   * @return {boolean} True if polygon overlaps circle.\r\n   */\r\n  overlapCircle(circle) {\r\n    if (!this.containsXY(circle.x, circle.y)) {\r\n      return false;\r\n    }\r\n\r\n    let thisLines = this.mLines;\r\n    let len = thisLines.length;\r\n\r\n    for (let i = 0; i < len; i++) {\r\n      if (thisLines[i].intersectsCircle(circle)) {\r\n        return false;\r\n      }\r\n    }\r\n\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * overlapRectangle - Checks overlaps between this polygon and rectangle.\r\n   *\r\n   * @param {Rectangle} rectangle Object to check.\r\n   *\r\n   * @return {boolean} True if polygon overlaps rectangle.\r\n   */\r\n  overlapRectangle(rectangle) {\r\n    if (!this.contains(rectangle.center())) {\r\n      return false;\r\n    }\r\n\r\n    let thisLines = this.mLines;\r\n    let thisLen = thisLines.length;\r\n    let rectangleLines = rectangle.lines;\r\n    let rectangleLen = rectangleLines.length;\r\n\r\n    for (let i = 0; i < thisLen; i++) {\r\n      for (let j = 0; j < rectangleLen; j++) {\r\n        if (thisLines[i].intersects(rectangleLines[j])) {\r\n          return false;\r\n        }\r\n      }\r\n    }\r\n\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * refresh - ReCalc center, bounds, and edges of this polygon.\r\n   *\r\n   * @return {Polygon} This polygon.\r\n   */\r\n  refresh() {\r\n    let center = this.mCenter;\r\n    let bounds = this.mBounds;\r\n    let vertices = this.mVertices;\r\n    let lines = this.mLines = [];\r\n    center.set(0, 0);\r\n\r\n    // bounds\r\n    let maxX = -Number.MAX_VALUE;\r\n    let maxY = -Number.MAX_VALUE;\r\n    let minX = Number.MAX_VALUE;\r\n    let minY = Number.MAX_VALUE;\r\n\r\n    for (let i = 0; i < vertices.length; i++) {\r\n      let vector = vertices[i];\r\n      center.add(vector);\r\n\r\n      // bounds\r\n      let {\r\n        x,\r\n        y\r\n      } = vector;\r\n      maxX = x > maxX ? x : maxX;\r\n      maxY = y > maxY ? y : maxY;\r\n      minX = x < minX ? x : minX;\r\n      minY = y < minY ? y : minY;\r\n\r\n      lines.push(new Line(vector, vertices[i + 1] || vertices[0]));\r\n    }\r\n\r\n    center.multiplyScalar(1 / vertices.length);\r\n    bounds.set(minX, minY, maxX - minX, maxY - minY);\r\n\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * refreshCenter - ReCalc center of this polygon.\r\n   *\r\n   * @return {Polygon} This polygon.\r\n   */\r\n  refreshCenter() {\r\n    let center = this.mCenter;\r\n    let vertices = this.mVertices;\r\n    let len = vertices.length;\r\n    center.set(0, 0);\r\n\r\n    for (let i = 0; i < len; i++) {\r\n      center.add(vertices[i]);\r\n    }\r\n\r\n    center.multiplyScalar(1 / vertices.length);\r\n\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * refreshBounds - ReCalc bounds of this polygon.\r\n   *\r\n   * @return {Polygon} This polygon.\r\n   */\r\n  refreshBounds() {\r\n    let bounds = this.mBounds;\r\n    let vertices = this.mVertices;\r\n    let maxX = -Number.MAX_VALUE;\r\n    let maxY = -Number.MAX_VALUE;\r\n    let minX = Number.MAX_VALUE;\r\n    let minY = Number.MAX_VALUE;\r\n    let len = vertices.length;\r\n    let x;\r\n    let y;\r\n\r\n    for (let i = 0; i < len; i++) {\r\n      x = vertices[i].x;\r\n      y = vertices[i].y;\r\n      maxX = x > maxX ? x : maxX;\r\n      maxY = y > maxY ? y : maxY;\r\n      minX = x < minX ? x : minX;\r\n      minY = y < minY ? y : minY;\r\n    }\r\n\r\n    bounds.set(minX, minY, maxX - minX, maxY - minY);\r\n\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * refreshLines - ReCalc edges of this polygon.\r\n   *\r\n   * @return {Polygon} This polygon.\r\n   */\r\n  refreshLines() {\r\n    let vertices = this.mVertices;\r\n    let lines = this.mLines = [];\r\n\r\n    for (let i = 0; i < vertices.length; i += 2) {\r\n      lines.push(new Line(vertices[i], vertices[i + 1] || vertices[0]));\r\n    }\r\n\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * fromPath - Creates instance of Polygon.\r\n   *\r\n   * @param {string} path Numbers x y divided with space.\r\n   *\r\n   * @return {Polygon} Created polygon.\r\n   */\r\n  static fromPath(path) {\r\n    let vertices = [];\r\n    let path2 = path.split(' ');\r\n\r\n    for (let i = 0; i < path2.length; i += 2) {\r\n      vertices.push(new Vector(Number(path2[i]), Number(path2[i + 1])));\r\n    }\r\n\r\n    return new Polygon(vertices);\r\n  }\r\n\r\n  /**\r\n   * setRotation - Sets rotation. Rotate this polygon around it center.\r\n   *\r\n   * @param {number} rotation Angle in radians.\r\n   *\r\n   * @return {Polygon} This polygon.\r\n   */\r\n  setRotation(rotation) {\r\n    let center = this.mCenter;\r\n    let vertices = this.mVertices;\r\n    let cos = Math.cos(rotation).toFixed(15);\r\n    let sin = Math.sin(rotation).toFixed(15);\r\n\r\n    for (let i = 0, len = vertices.length; i < len; i++) {\r\n      let vector = vertices[i];\r\n      vector\r\n        .subtract(center)\r\n        .set(vector.x * cos - vector.y * sin, vector.x * sin + vector.y * cos)\r\n        .add(center);\r\n    }\r\n\r\n    return this.refresh();\r\n  }\r\n\r\n  /**\r\n   * setTranslation - Translates this polygon to specified position.\r\n   *\r\n   * @param {Vector} point Translation vector.\r\n   *\r\n   * @return {Polygon} This vertices.\r\n   */\r\n  setTranslation(point) {\r\n    let center = this.mCenter;\r\n    let vertices = this.mVertices;\r\n    let len = vertices.length;\r\n    point.subtract(center);\r\n\r\n    for (let i = 0; i < len; i++) {\r\n      vertices[i].add(point);\r\n    }\r\n\r\n    return this.refresh();\r\n  }\r\n\r\n  /**\r\n   * toString - String representation of this polygon.\r\n   *\r\n   * @param {number=} [digits=2] Number of digits after float point.\r\n   *\r\n   * @return {string} Description.\r\n   */\r\n  toString(digits = 2) {\r\n    let thisLines = this.mLines;\r\n    let thisVertices = this.mVertices;\r\n    let len = thisLines.length;\r\n    let vertices = '';\r\n    let lines = '';\r\n\r\n    for (let i = 0; i < len; i++) {\r\n      lines += thisLines[i].toString(digits);\r\n    }\r\n\r\n    len = thisVertices.length;\r\n    for (let i = 0; i < len; i++) {\r\n      vertices += thisVertices[i].toString(digits);\r\n    }\r\n\r\n    return `Polygon { vertices: ${vertices}, bounds: ${this.mBounds.toString(digits)}, center: ${this.mCenter.toString()}, lines: ${lines} }`;\r\n  }\r\n\r\n}\r\n\r\n/** @type {Polygon}\r\n * @nocollapse\r\n */\r\nPolygon.__cache = new Polygon();\r\n","/**\r\n * Mathematical representation of a bezier curve.\r\n *\r\n * @cat geom\r\n */\r\n\r\nclass Curve {\r\n  /**\r\n   * Creates new Curve instance.\r\n   */\r\n  constructor() {\r\n    /**\r\n     * @private\r\n     * @type {Array<number>}\r\n     */\r\n    this.mPoints = [];\r\n\r\n    /**\r\n     * @private\r\n     * @type {Array<Vector>}\r\n     */\r\n    this.mLookup = null;\r\n\r\n    /**\r\n     * @private\r\n     * @type {boolean}\r\n     */\r\n    this.mBaked = false;\r\n\r\n    /**\r\n     * @private\r\n     * @type {number}\r\n     */\r\n    this.mStep = 1 / 60;\r\n\r\n    /**\r\n     * @private\r\n     * @type {Array<number>}\r\n     */\r\n    this.mEachT = [];\r\n  }\r\n\r\n  /**\r\n   * Sets new points coordinates.\r\n   *\r\n   * @param  {...number} points Coordinates: startX, startY, cpStartX, cpStartY, cpEndX, cpEndY, endX/start2X, endY/start2Y, cp2StartX, cp2StartX... 8 or 14 or 20...\r\n   *\r\n   * @return {Curve} This curve.\r\n   */\r\n  set(...points) {\r\n    this.mPoints = this.__initPoints(points);\r\n    this.__refreshEachT();\r\n\r\n    if (this.mBaked)\r\n      this.__refreshCache();\r\n\r\n    return this;\r\n  }\r\n\r\n\r\n  /**\r\n   * Enables or disables interpolation from cache (lookup).\r\n   * Returns true or false depending on baked is enabled or not.\r\n   *\r\n   * @return {boolean}\r\n   */\r\n  get baked() {\r\n    return this.mBaked;\r\n  }\r\n\r\n  /**\r\n   * @ignore\r\n   * @param  {boolean} label\r\n   */\r\n  set baked(label) {\r\n    this.mBaked = label;\r\n\r\n    if (!this.mLookup && this.mPoints) {\r\n      this.__refreshCache();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Wides points array. Sets first point for next bezier same as last of previous.\r\n   * @private\r\n   * @param  {Array<number>} points Array of points coordinates.\r\n   *\r\n   * @return {Array<number>} Points coordinates array.\r\n   */\r\n  __initPoints(points) {\r\n    let res = [];\r\n\r\n    for (let i = 6; i < points.length; i += 6) {\r\n      res = res.concat(points.slice(i - 6, i + 2));\r\n    }\r\n\r\n    return res;\r\n  }\r\n\r\n  /**\r\n   * Refresh cache (lookup) for fast interpolations.\r\n   *\r\n   * @private\r\n   *\r\n   * @return {Curve} This curve.\r\n   */\r\n  __refreshCache() {\r\n    let lookup = this.mLookup = [];\r\n    let getFullLength = this.getFullLength();\r\n    let points = this.mPoints;\r\n    let pointsLen = points.length;\r\n\r\n    for (let i = 0; i < pointsLen; i += 8) {\r\n      let length = Curve.getLength(...points.slice(i, i + 8));\r\n      let step = this.mStep * getFullLength / length;\r\n\r\n      for (let t = step; t < 1; t += step)\r\n        lookup.push(Curve.lerp(t, ...points.slice(i, i + 8)));\r\n    }\r\n\r\n    return this;\r\n  }\r\n\r\n\r\n  /**\r\n   * Refresh local interpolation kof for each bezier in curve.\r\n   * @private\r\n   * @return {Curve} This curve.\r\n   */\r\n  __refreshEachT() {\r\n    let points = this.mPoints;\r\n    let eachT = this.mEachT = [];\r\n    let pointsLen = points.length;\r\n    let eachLength = [];\r\n\r\n    for (let i = 0; i < pointsLen; i += 8)\r\n      eachLength.push(Curve.getLength(...points.slice(i, i + 8)));\r\n\r\n    let length = this.getFullLength();\r\n    let s = 0;\r\n    for (let i = 0; i < pointsLen; i += 8) {\r\n      s += eachLength[i / 8];\r\n      eachT.push(s / length);\r\n    }\r\n\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Interpolates single bezier on t position.\r\n   *\r\n   * @param  {number} t Interpolation position (0...1).\r\n   * @param  {number} startX\r\n   * @param  {number} startY\r\n   * @param  {number} cpStartX\r\n   * @param  {number} cpStartY\r\n   * @param  {number} cpEndX\r\n   * @param  {number} cpEndY\r\n   * @param  {number} endX\r\n   * @param  {number} endY\r\n   * @param  {Vector=} outVector\r\n   *\r\n   * @return {Vector} Position on bezier.\r\n   */\r\n  static lerp(t, startX, startY, cpStartX, cpStartY, cpEndX, cpEndY, endX, endY, outVector) {\r\n    let u = 1 - t;\r\n    let tt = t * t;\r\n    let uu = u * u;\r\n    let uuu = uu * u;\r\n    let ttt = tt * t;\r\n\r\n    let p = outVector || new Vector();\r\n    p.set(startX, startY);\r\n    p.x *= uuu;\r\n    p.y *= uuu;\r\n\r\n    // first\r\n    p.x += 3 * uu * t * cpStartX;\r\n    p.y += 3 * uu * t * cpStartY;\r\n\r\n    // second\r\n    p.x += 3 * u * tt * cpEndX;\r\n    p.y += 3 * u * tt * cpEndY;\r\n\r\n    // third\r\n    p.x += ttt * endX;\r\n    p.y += ttt * endY;\r\n\r\n    return p;\r\n  }\r\n\r\n  /**\r\n   * Interpolates across whole curve.\r\n   *\r\n   * @param  {number} t Interpolation position (0...1).\r\n   * @param  {Vector=} outVector\r\n   *\r\n   * @return {Vector} Position on curve.\r\n   */\r\n  interpolate(t, outVector) {\r\n    let res = outVector || new Vector();\r\n    let lookup = this.mLookup;\r\n\r\n    if (this.mBaked) {\r\n      let i = Math.ceil((lookup.length - 1) * t);\r\n      let p = lookup[i];\r\n      res.copyFrom(p);\r\n\r\n      return res;\r\n    }\r\n\r\n    // not backed\r\n    let { mEachT, mPoints } = this;\r\n    let i = 0;\r\n\r\n    while (mEachT[i] < t)\r\n      i++;\r\n\r\n    let minT = mEachT[i - 1] || 0;\r\n    let maxT = mEachT[i];\r\n    let bezier = mPoints.slice(i * 8, i * 8 + 8);\r\n\r\n    return Curve.lerp((t - minT) / (maxT - minT), ...bezier, res);\r\n  }\r\n\r\n  /**\r\n   * Returns single bezier length.\r\n   *\r\n   * @param  {...number} points Coordinates: startX, startY, cpStartX, cpStartY, cpEndX, cpEndY, endX, endY\r\n   *\r\n   * @return {number} Length.\r\n   */\r\n  static getLength(...points) {\r\n    let p0 = new Vector(points[0], points[1]);\r\n    let p1 = new Vector(points[2], points[3]);\r\n    let p2 = new Vector(points[4], points[5]);\r\n    let p3 = new Vector(points[6], points[7]);\r\n\r\n    return (p3.distance(p0) + p0.distance(p1) + p1.distance(p2) + p2.distance(p3)) / 2;\r\n  }\r\n\r\n  /**\r\n   * Returns this curve length.\r\n   *\r\n   * @return {number} Length.\r\n   */\r\n  getFullLength() {\r\n    let points = this.mPoints;\r\n    let mPointsLen = points.length;\r\n    let res = 0;\r\n\r\n    for (let i = 0; i < mPointsLen; i += 8)\r\n      res += Curve.getLength(...points.slice(i, i + 8));\r\n\r\n    return res;\r\n  }\r\n}\r\n\r\n/**\r\n * @private\r\n * @type {Curve}\r\n * @nocollapse\r\n */\r\nCurve.__cache = new Curve();\r\n","/**\r\n * Utility class for logging and debugging.\r\n *\r\n * @cat core\r\n */\r\n\r\nclass Debug {\r\n  constructor() {\r\n    Debug.assert(false, 'Static class.');\r\n  }\r\n\r\n  static assert(value, message) {\r\n    if (value === true)\r\n      return;\r\n\r\n    message = message == null ? 'Assertation failed.' : message;\r\n\r\n    if (Debug.logOnFail)\r\n      console.error('[ASSERT]', message);\r\n\r\n    if (Debug.throwOnFail)\r\n      throw new Error(message);\r\n  }\r\n\r\n  static log(...message) {\r\n    console.info('%c%s', 'color: black;', 'LOG:', ...message);\r\n  }\r\n\r\n  static info(...message) {\r\n    console.info('%c%s', 'color: #003bd2;', 'INFO:', ...message);\r\n  }\r\n\r\n  static warn(...message) {\r\n    console.info('%c%s', 'color: #f67400;', 'WARN:', ...message);\r\n  }\r\n\r\n  static error(...message) {\r\n    console.info('%c%s', 'color: #d50000;', 'ERROR:', ...message);\r\n  }\r\n}\r\n\r\nDebug.throwOnFail = false;\r\nDebug.logOnFail = true;\r\n","/**\r\n * Message holds all information about dispatched event.\r\n *\r\n * @cat core\r\n */\r\n\r\nclass Message {\r\n  constructor() {\r\n    /**\r\n     * @private\r\n     * @type {*}\r\n     */\r\n    this.mSender = null;\r\n\r\n    /**\r\n     * @private\r\n     * @type {string}\r\n     */\r\n    this.mName;\r\n\r\n    /**\r\n     * @private\r\n     * @type {string|null}\r\n     */\r\n    this.mPathMask = null;\r\n\r\n    /**\r\n     * @private\r\n     * @type {string|null}\r\n     */\r\n    this.mComponentMask = null;\r\n\r\n    /**\r\n     * @private\r\n     * @type {string}\r\n     */\r\n    this.mDirection = 'none';\r\n\r\n    /**\r\n     * @private\r\n     * @type {boolean}\r\n     */\r\n    this.mSibblings = false;\r\n\r\n    /**\r\n     * @private\r\n     * @type {Object}\r\n     */\r\n    this.mOrigin = null;\r\n\r\n    /**\r\n     * @private\r\n     * @type {Object}\r\n     */\r\n    this.mTarget = null;\r\n\r\n    /**\r\n     * @private\r\n     * @type {boolean}\r\n     */\r\n    this.mCanceled = false;\r\n  }\r\n\r\n  /**\r\n   * @return {string|null}\r\n   */  \r\n  get path() {\r\n    var hasComponentMask = this.mComponentMask !== null;\r\n\r\n    if (this.mPathMask !== null) {\r\n      if (hasComponentMask === true)\r\n        return this.mPathMask + '#' + this.mComponentMask;\r\n      else\r\n        return this.mPathMask;  \r\n    }\r\n    else if (hasComponentMask === true) {\r\n      return this.mComponentMask;\r\n    }\r\n\r\n    return null;\r\n  }\r\n\r\n  /**\r\n   * Who send the message.\r\n   *\r\n   * @return {*}\r\n   */\r\n  get sender() {\r\n    return this.mSender;\r\n  }\r\n\r\n  /**\r\n   * The name of the message.\r\n   *\r\n   * @return {string}\r\n   */\r\n  get name() {\r\n    return this.mName;\r\n  }\r\n\r\n  /**\r\n   * Direction in what message was sent. Can be 'none', 'up' and 'down'.\r\n   *\r\n   * @return {string}\r\n   */\r\n  get direction() {\r\n    return this.mDirection;\r\n  }\r\n\r\n  /**\r\n   * Indicates if sibblings should be included into dispatching process.\r\n   *\r\n   * @return {boolean}\r\n   */\r\n  get sibblings() {\r\n    return this.mSibblings;\r\n  }\r\n\r\n  /**\r\n   * The GameObject.name mask string if was used.\r\n   *\r\n   * @return {string|null}\r\n   */\r\n  get pathMask() {\r\n    return this.mPathMask;\r\n  }\r\n\r\n  /**\r\n   * Component mask string if was used.\r\n   *\r\n   * @return {string|null}\r\n   */\r\n  get componentMask() {\r\n    return this.mComponentMask;\r\n  }\r\n\r\n  /**\r\n   * The original sender of a message.\r\n   *\r\n   * @return {*|null}\r\n   */\r\n  get origin() {\r\n    return this.mOrigin;\r\n  }\r\n\r\n  /**\r\n   * The listener object.\r\n   *\r\n   * @return {*|null}\r\n   */\r\n  get target() {\r\n    return this.mTarget;\r\n  }\r\n\r\n  // /**\r\n  //  * Stops propagation of the message.\r\n  //  *\r\n  //  * @return {void}\r\n  //  */\r\n  // cancel() {\r\n  //   this.mCanceled = true;\r\n  // }\r\n\r\n  // /**\r\n  //  * True if message was canceled by the user.\r\n  //  *\r\n  //  * @return {boolean}\r\n  //  */\r\n  // get canceled() {\r\n  //   return this.mCanceled;\r\n  // }\r\n\r\n  static get PROGRESS() {\r\n    return 'progress';\r\n  }\r\n  static get COMPLETE() {\r\n    return 'complete';\r\n  }\r\n}","/**\r\n * The MessageDispatcher class is the base class for all classes that posts messages.\r\n *\r\n * Global messages will not be dispatched on non GameObject objects.\r\n *\r\n *\r\n *\r\n * @cat core\r\n * @unrestricted\r\n */\r\n\r\nclass MessageDispatcher {\r\n  constructor() {\r\n    // object of arrays\r\n\r\n    /**\r\n     * @private\r\n     * @type {Object<string, Array>}\r\n     */\r\n    this.mListeners = null;\r\n  }\r\n\r\n  /**\r\n   * Listens to message by given name\r\n   *\r\n   * @param {string} name           Name of a message to listen\r\n   * @param {Function} callback       The callback function\r\n   * @param {Object=} [context=null] The context for callback function\r\n   *\r\n   * @return {void}\r\n   */\r\n  on(name, callback, context = null) {\r\n    Debug.assert(name !== null, 'name cannot be null.');\r\n    Debug.assert(callback !== null, 'callback cannot be null.');\r\n\r\n    // TODO: refactor, expore dispatching provider\r\n    let filterIx = name.indexOf('@');\r\n    if (filterIx !== -1) {\r\n      // global handler\r\n\r\n      let pureName = name.substring(0, filterIx);\r\n      let pathMask = name.substring(filterIx + 1);\r\n\r\n      if (MessageDispatcher.mOverheardHandlers.hasOwnProperty(pureName) === false)\r\n        MessageDispatcher.mOverheardHandlers[pureName] = [];\r\n\r\n      let dispatchers = (MessageDispatcher.mOverheardHandlers[pureName]);\r\n      // for (let i = 0; i < dispatchers.length; i++)\r\n      //   if (dispatchers[i].callback === callback)\r\n      //     return;\r\n\r\n      dispatchers.push({\r\n        callback: callback,\r\n        context: context,\r\n        pathMask: pathMask\r\n      });\r\n\r\n      return;\r\n    }\r\n\r\n    if (this.mListeners === null)\r\n      this.mListeners = {};\r\n\r\n    if (this.mListeners.hasOwnProperty(name) === false)\r\n      this.mListeners[name] = [];\r\n\r\n    let dispatchers = /** @type {Array<{callback: Function, context}>} */ (this.mListeners[name]);\r\n\r\n    // TODO: check for dups somehow\r\n    // for (let i = 0; i < dispatchers.length; i++)\r\n    //   if (dispatchers[i].callback === callback)\r\n    //     return;\r\n\r\n    dispatchers.push({\r\n      callback: callback,\r\n      context: context\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Returns true if this object is subscribed for any messages with a given name.\r\n   *\r\n   * @param {string} name Message name to check.\r\n   *\r\n   * @returns {boolean} True if found.\r\n   */\r\n  hasOn(name) {\r\n    Debug.assert(name !== null, 'name cannot be null.');\r\n\r\n    let filterIx = name.indexOf('@');\r\n    if (filterIx !== -1) {\r\n      let pureName = name.substring(0, filterIx);\r\n      if (MessageDispatcher.mOverheardHandlers.hasOwnProperty(pureName) === false)\r\n        return false;\r\n    } else {\r\n      if (this.mListeners === null)\r\n        return false;\r\n      else if (this.mListeners.hasOwnProperty(name) === false)\r\n        return false;\r\n    }\r\n\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * Removes listener.\r\n   * If callback is null then all callbacks will be removed.\r\n   *\r\n   * @param {string} name\r\n   * @param {Function=} [callback=null]\r\n   *\r\n   * @return {void}\r\n   */\r\n  removeOn(name, callback = null) {\r\n    Debug.assert(name !== null, 'name cannot be null.');\r\n    //Debug.assert(callback !== null, 'callback cannot be null.');\r\n\r\n    let filterIx = name.indexOf('@');\r\n    if (filterIx !== -1) {\r\n      //we are working with overheared message\r\n      let pureName = name.substring(0, filterIx);\r\n      let pathMask = name.substring(filterIx + 1);\r\n\r\n      if (MessageDispatcher.mOverheardHandlers.hasOwnProperty(pureName) === false)\r\n        return;\r\n\r\n      let dispatchers = (MessageDispatcher.mOverheardHandlers[pureName]);\r\n\r\n      if (callback === null) {\r\n        dispatchers.splice(0, dispatchers.length);\r\n        return;\r\n      } else {\r\n        for (let i = dispatchers.length; i--;) {\r\n          if (dispatchers[i].callback === callback) {\r\n            dispatchers.splice(i, 1);\r\n            return;\r\n          }\r\n        }\r\n      }\r\n\r\n    } else {\r\n      // regular message\r\n      if (this.mListeners === null)\r\n        return;\r\n\r\n      let dispatchers = /** @type {Array<{callback: Function, context}>} */ (this.mListeners[name]);\r\n\r\n      if (dispatchers === undefined)\r\n        return;\r\n\r\n      if (callback === null) {\r\n        dispatchers.splice(0, dispatchers.length);\r\n        return;\r\n      } else {\r\n        for (let i = dispatchers.length; i--;) {\r\n          if (dispatchers[i].callback === callback) {\r\n            dispatchers.splice(i, 1);\r\n            return;\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Sends message with given pattern and params\r\n   *\r\n   * @param {string}  name   The name of a message\r\n   * @param {...*} params A list of params to send\r\n   *\r\n   * @return {void}\r\n   */\r\n  post(name, ...params) {\r\n    // TODO: add wildcard support and name mask annotation support\r\n    Debug.assert(name !== null, 'name cannot be null.');\r\n    // if (name === null || name.length === 0)\r\n    //   throw new Error('Name cannot be null.');\r\n\r\n    let message = this.__parseMessage(this, name);\r\n\r\n    //if (message.name === null && message.name === '')\r\n    Debug.assert(message.name !== '', 'Message.name cannot be null.');  \r\n\r\n    // TODO: o'really 62?\r\n    let isGameObjectOrComponent = this instanceof GameObject || this instanceof Component;\r\n    if (message.mDirection !== 'none' && isGameObjectOrComponent === false)\r\n      throw new Error('Dispatching not direct messages are not allowed on non Game Objects.');\r\n\r\n    if (message.mDirection === 'none') {\r\n      this.__invoke(this, message, ...params);\r\n      this.__invokeComponents(this, message, ...params);\r\n      this.__invokeOverheard(this, message, ...params);\r\n    } else if (message.mDirection === 'down') {\r\n      message.mOrigin = ( /** @type {GameObject} */ (this)).root;\r\n\r\n      if (message.mSibblings === true) {\r\n        this.__sendGlobal(this, message, null, ...params);\r\n        message.mOrigin.__invokeOverheard(this, message, ...params);\r\n      } else {\r\n        this.__sendBubbles(this, message, false, ...params);\r\n        message.mSender.__invokeOverheard(message.sender, message, ...params);\r\n      }\r\n    } else if (message.mDirection === 'up') {\r\n      this.__sendBubbles(this, message, true, ...params);\r\n      message.mSender.__invokeOverheard(message.sender, message, ...params);\r\n    } else {\r\n      throw new Error('Unknown message type.');\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @private\r\n   * @param {*}  sender\r\n   * @param {Message}  message\r\n   * @param {boolean}  toTop\r\n   * @param {...*} params\r\n   *\r\n   * @return {void}\r\n   */\r\n  __sendBubbles(sender, message, toTop, ...params) {\r\n    message.mOrigin = toTop === true ? this : ( /** @type {GameObject} */ (this)).root;\r\n\r\n    let list = [this];\r\n\r\n    let current = /** @type {GameObject} */ (this);\r\n    while (current.parent !== null) {\r\n      list.push(current.parent);\r\n      current = current.parent;\r\n    }\r\n\r\n    if (toTop) {\r\n      for (let i = 0; i < list.length; i++) {\r\n        let dispatcher = /** @type {GameObject} */ (list[i]);\r\n        dispatcher.__invoke(sender, message, ...params);\r\n        dispatcher.__invokeComponents(sender, message, ...params);\r\n      }\r\n    } else {\r\n      for (let i = list.length - 1; i >= 0; i--) {\r\n        let dispatcher = /** @type {GameObject} */ (list[i]);\r\n        dispatcher.__invoke(sender, message, ...params);\r\n        dispatcher.__invokeComponents(sender, message, ...params);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @private\r\n   * @param {*}  sender\r\n   * @param {Message}  message\r\n   * @param {GameObject=}  origin\r\n   * @param {...*} params\r\n   *\r\n   * @return {void}\r\n   */\r\n  __sendGlobal(sender, message, origin, ...params) {\r\n    if (origin === null)\r\n      origin = /** @type {GameObject} */ (message.mOrigin);\r\n\r\n    origin.__invoke(sender, message, ...params);\r\n    origin.__invokeComponents(sender, message, ...params);\r\n\r\n    for (let i = 0; i < origin.numChildren; i++) {\r\n      let child = origin.getChildAt(i);\r\n      child.__sendGlobal(sender, message, child, ...params);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @private\r\n   * @param {*}  sender\r\n   * @param {Message}  message\r\n   * @param {...*} params\r\n   *\r\n   * @return {void}\r\n   */\r\n  __invoke(sender, message, ...params) {\r\n    if (this.mListeners === null)\r\n      return;\r\n\r\n    let dispatchers = /** @type {Array<{callback: Function, context}>} */ (this.mListeners[message.mName]);\r\n\r\n    if (dispatchers === undefined || dispatchers.length === 0)\r\n      return;\r\n\r\n    if (message.path !== null) {\r\n      let inPath = this.__checkPath(this.path, message.path);\r\n      if (!inPath)\r\n        return;\r\n    }\r\n\r\n    // no path filter found - just invoke it\r\n    let clone = dispatchers.slice(0);\r\n\r\n    for (let i = 0; i < clone.length; i++) {\r\n      let dispatcher = /** @type {{callback: Function, context: *}} */ (clone[i]);\r\n      message.mTarget = this;\r\n      dispatcher.callback.call(dispatcher.context, message, ...params);\r\n    }\r\n  }\r\n\r\n  __invokeComponents(sender, message, toTop, ...params) {\r\n    let isGameObject = this instanceof GameObject;\r\n    if (isGameObject === false)\r\n      return;  \r\n    \r\n    let go = /** @type {GameObject} */ (this);\r\n\r\n    let len = go.mComponents.length;\r\n    for (let i = 0; i < len; i++) {\r\n      let c = go.mComponents[i];\r\n      c.__invoke(sender, message, ...params);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @private\r\n   * @param {*}  sender\r\n   * @param {Message}  message\r\n   * @param {...*} params\r\n   *\r\n   * @return {void}\r\n   */\r\n  __invokeOverheard(sender, message, ...params) {\r\n    let dispatchers = MessageDispatcher.mOverheardHandlers[message.mName];\r\n\r\n    if (dispatchers === undefined || dispatchers.length === 0)\r\n      return;\r\n\r\n    let clone = dispatchers.slice(0);\r\n\r\n    for (let i = 0; i < clone.length; i++) {\r\n      let dispatcher = /** @type {{callback: Function, context: *}} */ (clone[i]);\r\n\r\n      if (!this.__checkPath(sender.path, dispatcher.pathMask))\r\n        continue;\r\n\r\n      message.mTarget = this;\r\n      dispatcher.callback.call(dispatcher.context, message, ...params);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @private\r\n   * @param {string} path\r\n   * @param {string} pathMask\r\n   *\r\n   * @return {boolean}\r\n   */\r\n  __checkPath(path, pathMask) {\r\n    if (path == null || pathMask == null)\r\n      return false;\r\n\r\n    if (path === pathMask)\r\n      return true;\r\n\r\n    if (pathMask.indexOf('*') === -1)\r\n      return path === pathMask;\r\n    else\r\n      return new RegExp(\"^\" + pathMask.split(\"*\").join(\".*\") + \"$\").test(path);\r\n  }\r\n\r\n  // TODO: parse exception path'ses like: ~tatata@@@omg####imnotidiout###@@~~\r\n  /**\r\n   * @private\r\n   * @param {*} sender\r\n   * @param {string} info\r\n   *\r\n   * @return {Message}\r\n   */\r\n  __parseMessage(sender, info) {\r\n    // TODO: make message pool... this type of objects shall not be\r\n    // but dont forget to take care about cancel property\r\n\r\n    let result = new Message();\r\n    result.mSender = sender;\r\n    result.mDirection = 'none';\r\n    result.mSibblings = true;\r\n    result.mPathMask = null;\r\n    result.mComponentMask = null;\r\n\r\n    if (info.charAt(0) === '~') {\r\n      result.mSibblings = false;\r\n      result.mDirection = 'up';\r\n    }\r\n\r\n    let ixAt = info.indexOf('@');\r\n    let ixHash = info.indexOf('#');\r\n\r\n    if (ixAt === -1 && ixHash === -1) {\r\n      result.mSibblings = false;\r\n      result.mName = info.substr(result.mDirection === 'up' ? 1 : 0);\r\n      return result;\r\n    }\r\n\r\n    Debug.assert(ixHash !== -1 && ixAt >= 0, 'Message syntax is not correct. Did you miss @?');\r\n\r\n    result.mDirection = 'down';\r\n\r\n    if (ixHash === -1) { // we got no hash but we have a dog\r\n      result.mName = info.substring(result.mSibblings ? 0 : 1, ixAt);\r\n\r\n      if (info.length === ixAt + 1)\r\n        result.mPathMask = null;\r\n      else\r\n        result.mPathMask = info.substring(ixAt + 1);\r\n\r\n      return result;\r\n    } else {\r\n      if (ixAt !== -1) {\r\n        result.mPathMask = info.substring(ixAt + 1, ixHash);\r\n        result.mName = info.substring(result.mSibblings ? 0 : 1, ixAt);\r\n      } else {\r\n        result.mName = info.substring(result.mSibblings ? 0 : 1, ixHash);\r\n      }\r\n\r\n      if (info.length === ixHash + 1)\r\n        result.mComponentMask = null;\r\n      else\r\n        result.mComponentMask = info.substring(ixHash + 1);\r\n\r\n      return result;\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * @private\r\n * @dict\r\n */\r\nMessageDispatcher.mOverheardHandlers = {};","/**\r\n * Provides time related methods.\r\n *\r\n * @cat core\r\n * @static\r\n */\r\n\r\nclass Time {\r\n  constructor() {\r\n  }\r\n\r\n  /**\r\n   * Time since start in seconds.\r\n   * @returns {number}\r\n   */\r\n  static get time(){\r\n    return Time.mTime;\r\n  }\r\n\r\n  /**\r\n   * @ignore\r\n   */\r\n  static get dt() {\r\n    return Time.mDeltaTime;\r\n  }\r\n\r\n  /**\r\n   * @ignore\r\n   */\r\n  static get scale() {\r\n    return Time.mScale;\r\n  }\r\n\r\n  /**\r\n   * @ignore\r\n   */\r\n  static set scale(value) {\r\n    Debug.assert(value >= 0, 'Time.scale must be >= 0.');\r\n\r\n    Time.mScale = value;\r\n  }\r\n}\r\n\r\n/**\r\n * @ignore\r\n * @type {number}\r\n */\r\nTime.mTime = 0;\r\n\r\n/** \r\n * @ignore\r\n * @type {number}\r\n */\r\nTime.mDeltaTime = 0;\r\n\r\n/** \r\n * @ignore\r\n * @type {number}\r\n */\r\nTime.mScale = 1;\r\n","/**\r\n * Base class for custom systems. System is used to listen scene changes.\r\n *\r\n * @cat core\r\n * @extends MessageDispatcher\r\n */\r\n\r\nclass System extends MessageDispatcher {\r\n  constructor(){\r\n    super();\r\n  }\r\n\r\n\r\n  /**\r\n   * onFixedUpdate - Description\r\n   *\r\n   * @param {number} dt Description\r\n   *\r\n   * @return {void} Description\r\n   */\r\n  onFixedUpdate(dt){\r\n  }\r\n\r\n\r\n  /**\r\n   * onUpdate - Description\r\n   *\r\n   * @param {number} dt Description\r\n   * @param {number} t Description\r\n   *\r\n   * @return {void} Description\r\n   */\r\n  onUpdate(dt, t){\r\n  }\r\n\r\n  /**\r\n   * onPostUpdate - Description\r\n   *\r\n   * @param {number} dt Description\r\n   * @param {number} t Description\r\n   *\r\n   * @return {void} Description\r\n   */\r\n  onPostUpdate(dt, t){\r\n  }\r\n\r\n\r\n  /**\r\n   * onChildrenAdded - Description\r\n   *\r\n   * @param {GameObject} child Description\r\n   *\r\n   * @return {void} Description\r\n   */\r\n  onChildrenAdded(child){\r\n  }\r\n\r\n\r\n  /**\r\n   * onChildrenRemoved - Description\r\n   *\r\n   * @param {GameObject} child Description\r\n   *\r\n   * @return {void} Description\r\n   */\r\n  onChildrenRemoved(child){\r\n  }\r\n\r\n\r\n  /**\r\n   * onComponentAdded - Description\r\n   *\r\n   * @param {GameObject} child     Description\r\n   * @param {Component} component Description\r\n   *\r\n   * @return {void} Description\r\n   */\r\n  onComponentAdded(child, component)\r\n  {}\r\n\r\n\r\n  /**\r\n   * onComponentRemoved - Description\r\n   *\r\n   * @param {GameObject} child     Description\r\n   * @param {Component} component Description\r\n   *\r\n   * @return {void} Description\r\n   */\r\n  onComponentRemoved(child, component)\r\n  {}\r\n}\r\n","/**\r\n * Manages viewport, handles DOM container resize events and updates internal data.\r\n *\r\n * @cat core\r\n * @fires resize\r\n * @extends MessageDispatcher\r\n */\r\n\r\nclass Viewport extends MessageDispatcher {\r\n  /**\r\n   * constructor\r\n   * @param {HTMLElement} containerElement\r\n   * @return {void}\r\n   */\r\n  constructor(containerElement) {\r\n    super();\r\n\r\n    /** @type {HTMLElement} */\r\n    this.mContainerElement = containerElement;\r\n\r\n    this.mContainerElement.style.userSelect = 'none';\r\n    this.mContainerElement.style.touchAction = 'none';\r\n    this.mContainerElement.style.overflow = 'hidden';\r\n    this.mContainerElement.style.cursor = 'auto';\r\n    this.mContainerElement.style.WebkitTapHighlightColor = 'rgba(0, 0, 0, 0)';\r\n\r\n    let size = this.mContainerElement.getBoundingClientRect();\r\n\r\n    /** @type {Rectangle} */\r\n    this.mSize = new Rectangle(size.left, size.top, size.width, size.height);\r\n\r\n    window.addEventListener('resize', x=> this.__onResize());\r\n  }\r\n\r\n  __onResize() {\r\n    let size = this.mContainerElement.getBoundingClientRect();\r\n    this.mSize = new Rectangle(size.left, size.top, size.width, size.height);\r\n\r\n    this.post('resize', this.mSize);\r\n  }\r\n\r\n  /**\r\n   * size - Returns the size of a viewport.\r\n   * @return {Rectangle}\r\n   */\r\n  get size(){\r\n    return this.mSize;\r\n  }\r\n\r\n  /**\r\n   * nativeDOM - Retruns the HTML container element the engine runs in.\r\n   * @return {Element}\r\n   */\r\n  get nativeDOM(){\r\n    return this.mContainerElement;\r\n  }\r\n\r\n  // TODO: dispose, remove resize event\r\n}\r\n","/**\r\n * A base class for custom components.\r\n *\r\n * @cat core\r\n * @unrestricted\r\n * @extends MessageDispatcher\r\n */\r\n\r\nclass Component extends MessageDispatcher {\r\n  /**\r\n   * Creates new Component instance.\r\n   */\r\n  constructor() {\r\n    super();\r\n\r\n    /**\r\n     * @private\r\n     * @type {number} \r\n     */\r\n    this.mId = ++GameObject.ID;\r\n\r\n    /**\r\n     * @private\r\n     * @type {GameObject|null}\r\n     */\r\n    this.mGameObject = null;\r\n\r\n    /**\r\n     * @private\r\n     * @type {boolean}\r\n     */\r\n    this.mAdded = false;\r\n  }\r\n\r\n  /**\r\n   * Called when attached to GameObject.\r\n   *\r\n   * @public\r\n   *\r\n   * @param  {GameObject} gameObject The owner of this component.\r\n   * @return {void}\r\n   */\r\n  onAdded(gameObject) {}\r\n\r\n  /**\r\n   * Called when detached from GameObject.\r\n   *\r\n   * @public\r\n   *\r\n   * @param  {GameObject} gameObject The owner of this component.\r\n   * @return {void}\r\n   */\r\n  onRemoved(gameObject) {}\r\n\r\n  /**\r\n   * Called at every fixed frame update.\r\n   * @public\r\n   *\r\n   * @param  {number} dt Amount of seconds since the last update.\r\n   * @return {void}\r\n   */\r\n  onFixedUpdate(dt) {}\r\n\r\n  /**\r\n   * Called at every engine update.\r\n   * @public\r\n   *\r\n   * @param  {number} dt Amount of seconds since the last update.\r\n   * @return {void}\r\n   */\r\n  onUpdate(dt) {}\r\n\r\n  /**\r\n   * Called after all updates have been executed.\r\n   * @public\r\n   *\r\n   * @param  {number} dt Amount of seconds since the last update.\r\n   * @return {void}\r\n   */\r\n  onPostUpdate(dt) {}\r\n\r\n  // TODO: finish\r\n  dispose() {}\r\n\r\n  // TODO: finish\r\n\r\n  /**\r\n   * Detaches this Component from its parent GameObject.\r\n   * @returns {void}\r\n   */\r\n  removeFromParent() {\r\n    if (this.mGameObject === null)\r\n      return;\r\n\r\n    this.mGameObject.removeComponent(this);\r\n  }\r\n\r\n  /**\r\n   * Returns owner of this component.\r\n   *\r\n   * @returns {GameObject}\r\n   */\r\n  get gameObject() {\r\n    return this.mGameObject;\r\n  }\r\n\r\n  /**\r\n   * Returns string representing a url like path to this object in the display\r\n   * tree.\r\n   *\r\n   * @readonly\r\n   *\r\n   * @return {string|null}\r\n   */\r\n  get path() {\r\n    if (this.mGameObject !== null)\r\n      return this.mGameObject.path + '#' + this.constructor.name;\r\n\r\n    return this.constructor.name;\r\n  }\r\n}\r\n\r\n/**\r\n * @ignore\r\n * @type {number}\r\n * @nocollapse\r\n */\r\nComponent.ID = 0;","/**\r\n * Building block in Black Engine.\r\n *\r\n * @cat core\r\n * @unrestricted\r\n * @extends MessageDispatcher\r\n */\r\n\r\nclass GameObject extends MessageDispatcher {\r\n  /**\r\n   * Creates new instance of GameObject.\r\n   */\r\n  constructor() {\r\n    super();\r\n\r\n    /**\r\n     * @private\r\n     * @type {number}\r\n     */\r\n    this.mId = ++GameObject.ID;\r\n\r\n    /**\r\n     * @private\r\n     * @type {string|null}\r\n     */\r\n    this.mName = null;\r\n\r\n    /**\r\n     * @private\r\n     * @type {Array<Component>}\r\n     */\r\n    this.mComponents = [];\r\n\r\n    /**\r\n     * @private\r\n     * @type {Array<GameObject>}\r\n     */\r\n    this.mChildren = [];\r\n\r\n    /**\r\n     * @private\r\n     * @type {number}\r\n     */\r\n    this.mX = 0;\r\n\r\n    /**\r\n     * @private\r\n     * @type {number}\r\n     */\r\n    this.mY = 0;\r\n\r\n    /**\r\n     * @private\r\n     * @type {number}\r\n     */\r\n    this.mScaleX = 1;\r\n\r\n    /**\r\n     * @private\r\n     * @type {number}\r\n     */\r\n    this.mScaleY = 1;\r\n\r\n    /**\r\n     * @private\r\n     * @type {number}\r\n     */\r\n    this.mPivotX = 0;\r\n\r\n    /**\r\n     * @private\r\n     * @type {number}\r\n     */\r\n    this.mPivotY = 0;\r\n\r\n    /**\r\n     * @private\r\n     * @type {number}\r\n     */\r\n    this.mRotation = 0;\r\n\r\n    /**\r\n     * @private\r\n     * @type {Rectangle}\r\n     */\r\n    this.mBounds = null;\r\n\r\n    /**\r\n     * @private\r\n     * @type {Matrix}\r\n     */\r\n    this.mLocalTransform = new Matrix();\r\n\r\n    /**\r\n     * @private\r\n     * @type {Matrix}\r\n     */\r\n    this.mWorldTransform = new Matrix();\r\n\r\n    /**\r\n     * @private\r\n     * @type {DirtyFlag}\r\n     */\r\n    this.mDirty = DirtyFlag.DIRTY;\r\n\r\n    /**\r\n     * @private\r\n     * @type {GameObject}\r\n     */\r\n    this.mParent = null;\r\n\r\n    /**\r\n     * @private\r\n     * @type {string|null}\r\n     */\r\n    this.mTag = null;\r\n\r\n    /**\r\n     * @private\r\n     * @type {number}\r\n     */\r\n    this.mIndex = 0;\r\n\r\n    /**\r\n     * @private\r\n     * @type {boolean}\r\n     */\r\n    this.mAdded = false;\r\n\r\n    /**\r\n     * @private\r\n     * @type {number}\r\n     */\r\n    this.mNumChildrenRemoved = 0;\r\n\r\n    /**\r\n     * @private\r\n     * @type {number}\r\n     */\r\n    this.mNumComponentsRemoved = 0;\r\n  }\r\n\r\n  /**\r\n   * Returns unique object id.\r\n   *\r\n   * @returns {number}\r\n   */\r\n  get id() {\r\n    return this.mId;\r\n  }\r\n\r\n  /**\r\n   * This method called each time object added to stage.\r\n   *\r\n   * @public\r\n   * @return {void}\r\n   */\r\n  onAdded() { }\r\n\r\n  /**\r\n   * Called when object is removed from stage.\r\n   *\r\n   * @public\r\n   * @return {void}\r\n   */\r\n  onRemoved() { }\r\n\r\n\r\n  /**\r\n   * Sugar method for adding child GameObjects or Components in a simple manner.\r\n   *\r\n   * @param {...(GameObject|Component)} gameObjectsAndOrComponents A GameObject or Component to add.\r\n   * @return {Array<GameObject|Component>} The passed GameObject or Component.\r\n   */\r\n  add(...gameObjectsAndOrComponents) {\r\n    for (let i = 0; i < gameObjectsAndOrComponents.length; i++) {\r\n      let gooc = gameObjectsAndOrComponents[i];\r\n\r\n      if (gooc instanceof GameObject)\r\n        this.addChild( /** @type {!GameObject} */(gooc));\r\n      else\r\n        this.addComponent( /** @type {!Component} */(gooc));\r\n    }\r\n\r\n    return gameObjectsAndOrComponents;\r\n  }\r\n\r\n  /**\r\n   * Adds a child GameObject instance to this GameObject instance. The child is added to the top of all other children in this GameObject instance.\r\n   *\r\n   * @param  {GameObject} child The GameObject instance to add as a child of this GameObject instance.\r\n   * @return {GameObject}\r\n   */\r\n  addChild(child) {\r\n    return this.addChildAt(child, this.mChildren.length);\r\n  }\r\n\r\n  /**\r\n   * Adds a child GameObject instance to this GameObject instance. The child is added to the top of all other children in this GameObject instance.\r\n   *\r\n   * @param  {GameObject} child The GameObject instance to add as a child of this GameObject instance.\r\n   * @param  {number=} index = 0 The index position to which the child is added.\r\n   * @return {GameObject} The GameObject instance that you pass in the child parameter.\r\n   */\r\n  addChildAt(child, index = 0) {\r\n    let numChildren = this.mChildren.length;\r\n\r\n    if (index < 0 || index > numChildren)\r\n      throw new Error('Child index is out of bounds.');\r\n\r\n    if (child.mParent === this)\r\n      return this.setChildIndex(child, index);\r\n\r\n    // this operation should be atomic. since __setParent can throw exception.\r\n    this.mChildren.splice(index, 0, child);\r\n\r\n    child.removeFromParent();\r\n    child.__setParent(this);\r\n\r\n    if (this.root !== null)\r\n      Black.instance.onChildrenAdded(child);\r\n\r\n    return child;\r\n  }\r\n\r\n  /**\r\n   * @protected\r\n   * @ignore\r\n   * @param {GameObject} value\r\n   *\r\n   * @return {boolean}\r\n   */\r\n  __setParent(value) {\r\n    let p = value;\r\n\r\n    while (p !== null && p !== this)\r\n      p = p.mParent;\r\n\r\n    if (p === this)\r\n      throw new Error('Object cannot be a child to itself.');\r\n\r\n    this.mParent = value;\r\n    this.setTransformDirty();\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * Sets the index (layer) of the specified GameObject to the specified index (layer).\r\n   *\r\n   * @param {GameObject} child The GameObject instance to change index for.\r\n   * @param {number} index Desired index.\r\n   *\r\n   * @returns {GameObject} The GameObject instance that you pass in the child parameter.\r\n   */\r\n  setChildIndex(child, index) {\r\n    let ix = this.mChildren.indexOf(child);\r\n\r\n    if (ix < 0)\r\n      throw new Error('Given child element was not found in children list.');\r\n\r\n    if (ix === index)\r\n      return child;\r\n\r\n    // NOTE: systems needs to know when trees changes\r\n    child.removeFromParent();\r\n    this.addChildAt(child, index);\r\n    this.setTransformDirty();\r\n\r\n    return child;\r\n  }\r\n\r\n  /**\r\n   * Removes this GameObject instance from its parent.\r\n   *\r\n   * @param {boolean} [dispose=false]\r\n   *\r\n   * @return {void}\r\n   */\r\n  removeFromParent(dispose = false) {\r\n    if (this.mParent !== null)\r\n      this.mParent.removeChild(this);\r\n\r\n    if (dispose)\r\n      this.dispose();\r\n\r\n    this.setTransformDirty();\r\n  }\r\n\r\n  /**\r\n   * Removes specified child GameObject instance from children.\r\n   *\r\n   * @param {GameObject} child GameObject instance to remove.\r\n   * @param {boolean} [dispose=false]\r\n   *\r\n   * @return {GameObject} The GameObject instance that you pass in the child parameter.\r\n   */\r\n  removeChild(child, dispose) {\r\n    let ix = this.mChildren.indexOf(child);\r\n\r\n    if (ix < 0)\r\n      return null;\r\n\r\n    return this.removeChildAt(ix);\r\n  }\r\n\r\n\r\n  /**\r\n   * Finds children by name.\r\n   *\r\n   * @param {string} name Name of the child object to find.\r\n   *\r\n   * @return {GameObject|null} GameObject instance of null if not found.\r\n   */\r\n  getChildByName(name) {\r\n    for (var i = 0; i < this.mChildren.length; i++) {\r\n      if (this.mChildren[i].name === name)\r\n        return this.mChildren[i];\r\n    }\r\n\r\n    return null;\r\n  }\r\n\r\n  /**\r\n   * Removes GameObjects instance from specified index.\r\n   *\r\n   * @param {number} index Description\r\n   * @param {boolean} [dispose=false]\r\n   *\r\n   * @return {GameObject} The removed GameObject instance.\r\n   */\r\n  removeChildAt(index, dispose) {\r\n    if (index < 0 || index > this.numChildren)\r\n      throw new Error('Child index is out of bounds.');\r\n\r\n    let hadRoot = this.root !== null;\r\n\r\n    let child = this.mChildren[index];\r\n    child.__setParent(null);\r\n\r\n    this.mChildren.splice(index, 1);\r\n\r\n    if (hadRoot)\r\n      Black.instance.onChildrenRemoved(child);\r\n\r\n    if (dispose)\r\n      child.dispose();\r\n\r\n    this.setTransformDirty();\r\n\r\n    this.mNumChildrenRemoved++;\r\n\r\n    return child;\r\n  }\r\n\r\n  /**\r\n   * Returns GameObject at specified index.\r\n   *\r\n   * @param {number} index The index of child GameObject.\r\n   *\r\n   * @return {GameObject} The GameObject at specified index.\r\n   */\r\n  getChildAt(index) {\r\n    return this.mChildren[index];\r\n  }\r\n\r\n  /**\r\n   * Adds Component instance to the end of the list,\r\n   *\r\n   * @param  {Component} component Component instance or instances.\r\n   * @return {Component} The Component instance you pass in the instances parameter.\r\n   */\r\n  addComponent(component) {\r\n    let instance = component;\r\n\r\n    if (instance.gameObject)\r\n      throw new Error('Component cannot be added to two game objects at the same time.');\r\n\r\n    this.mComponents.push(instance);\r\n    instance.mGameObject = this;\r\n\r\n    if (this.root !== null)\r\n      Black.instance.onComponentAdded(this, instance);\r\n\r\n    instance.onAdded(this);\r\n\r\n    return instance;\r\n  }\r\n\r\n  /**\r\n   * Remove specified component.\r\n   *\r\n   * @param {Component} instance The component instance.\r\n   *\r\n   * @return {Component|null}\r\n   */\r\n  removeComponent(instance) {\r\n    if (!instance)\r\n      return null;\r\n\r\n    let index = this.mComponents.indexOf(instance);\r\n    if (index > -1)\r\n      this.mComponents.splice(index, 1);\r\n\r\n    // detach game object after or before?\r\n    instance.mGameObject = null;\r\n    instance.onRemoved(this);\r\n\r\n    if (this.root !== null)\r\n      Black.instance.onComponentRemoved(this, instance);\r\n\r\n    this.mNumComponentsRemoved++;\r\n\r\n    return instance;\r\n  }\r\n\r\n  /**\r\n   * Get component by type.\r\n   *\r\n   * @param {Object} typeName The component type.\r\n   *\r\n   * @return {Component|null} The Component instance or null if not found.\r\n   */\r\n  getComponent(typeName) {\r\n    for (let i = 0; i < this.mComponents.length; i++) {\r\n      let c = this.mComponents[i];\r\n      if (c instanceof typeName)\r\n        return c;\r\n    }\r\n\r\n    return null;\r\n  }\r\n\r\n  /**\r\n   * Returns number of component's of this GameObject.\r\n   *\r\n   * @return {number}\r\n   */\r\n  get numComponenets() {\r\n    return this.mComponents.length;\r\n  }\r\n\r\n  /**\r\n   * Retrives Component at given index.\r\n   *\r\n   * @param {number} index\r\n   *\r\n   * @return {Component|null}\r\n   */\r\n  getComponentAt(index) {\r\n    if (index >= 0 && index < this.mComponents.length)\r\n      return this.mComponents[index];\r\n\r\n    return null;\r\n  }\r\n\r\n  /**\r\n   * Retun local transformation Matrix\r\n   *\r\n   * @return {Matrix}\r\n   */\r\n  get localTransformation() {\r\n    if (this.mDirty & DirtyFlag.LOCAL) {\r\n      this.mDirty ^= DirtyFlag.LOCAL;\r\n\r\n      if (this.mRotation === 0) {\r\n        let tx = this.mX - this.mPivotX * this.mScaleX;\r\n        let ty = this.mY - this.mPivotY * this.mScaleY;\r\n        return this.mLocalTransform.set(this.mScaleX, 0, 0, this.mScaleY, tx, ty);\r\n      } else {\r\n        let cos = Math.cos(this.mRotation);\r\n        let sin = Math.sin(this.mRotation);\r\n        let a = this.mScaleX * cos;\r\n        let b = this.mScaleX * sin;\r\n        let c = this.mScaleY * -sin;\r\n        let d = this.mScaleY * cos;\r\n        let tx = this.mX - this.mPivotX * a - this.mPivotY * c;\r\n        let ty = this.mY - this.mPivotX * b - this.mPivotY * d;\r\n        return this.mLocalTransform.set(a, b, c, d, tx, ty);\r\n      }\r\n    }\r\n\r\n    return this.mLocalTransform;\r\n  }\r\n\r\n  /**\r\n   * Returns cloned Matrix object which represents object orientation in world space.\r\n   *\r\n   * @return {Matrix}\r\n   */\r\n  get worldTransformation() {\r\n    if (this.mDirty & DirtyFlag.WORLD) {\r\n      this.mDirty ^= DirtyFlag.WORLD;\r\n\r\n      if (this.mParent !== null)\r\n        this.mParent.worldTransformation.copyTo(this.mWorldTransform).append(this.localTransformation);\r\n      else\r\n        this.localTransformation.copyTo(this.mWorldTransform);\r\n    }\r\n\r\n    return this.mWorldTransform;\r\n  }\r\n\r\n  set worldTransformation(matrix) {\r\n    const PI_Q = Math.PI / 4.0;\r\n\r\n    let a = matrix.value[0];\r\n    let b = matrix.value[1];\r\n    let c = matrix.value[2];\r\n    let d = matrix.value[3];\r\n    let tx = matrix.value[4];\r\n    let ty = matrix.value[5];\r\n\r\n    this.mPivotX = this.mPivotX = 0;\r\n    this.mX = tx;\r\n    this.mY = ty;\r\n\r\n    let skewX = Math.atan(-c / d);\r\n    let skewY = Math.atan(b / a);\r\n\r\n    if (skewX != skewX)\r\n      skewX = 0.0;\r\n    if (skewY != skewY)\r\n      skewY = 0.0;\r\n\r\n    this.mScaleY = (skewX > -PI_Q && skewX < PI_Q) ?  d / Math.cos(skewX) : -c / Math.sin(skewX);\r\n    this.mScaleX = (skewY > -PI_Q && skewY < PI_Q) ?  a / Math.cos(skewY) :  b / Math.sin(skewY);\r\n\r\n    if (MathEx.equals(skewX, skewY)) {\r\n      this.mRotation = skewX;\r\n      skewX = skewY = 0;\r\n    } else {\r\n      this.mRotation = 0;\r\n    }\r\n\r\n    this.setTransformDirty();\r\n  }\r\n\r\n  /**\r\n   * Returns cloned and inversed Matrix object which represents object orientation in world space\r\n   *\r\n   * @return {Matrix}\r\n   */\r\n  get worldTransformationInversed() {\r\n    // TODO: optimize, cache\r\n    return this.worldTransformation.clone().invert();\r\n  }\r\n\r\n  /**\r\n   * @ignore\r\n   * @param {number} dt\r\n   *\r\n   * @return {void}\r\n   */\r\n  __fixedUpdate(dt) {\r\n    this.onFixedUpdate(dt);\r\n\r\n    for (let k = 0; k < this.mComponents.length; k++) {\r\n      let c = this.mComponents[k];\r\n      c.mGameObject = this;\r\n      c.onFixedUpdate(dt);\r\n\r\n      if (this.__checkRemovedComponents(k))\r\n        break;\r\n    }\r\n\r\n    for (let i = 0; i < this.mChildren.length; i++) {\r\n      this.mChildren[i].__fixedUpdate(dt);\r\n\r\n      if (this.__checkRemovedChildren(i))\r\n        break;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @ignore\r\n   * @param {number} dt time since the last frame\r\n   *\r\n   * @return {void}\r\n   */\r\n  __update(dt) {\r\n    this.onUpdate(dt);\r\n\r\n    for (let k = 0; k < this.mComponents.length; k++) {\r\n      let c = this.mComponents[k];\r\n      c.mGameObject = this;\r\n      c.onUpdate(dt);\r\n\r\n      if (this.__checkRemovedComponents(k))\r\n        break;\r\n    }\r\n\r\n    for (let i = 0; i < this.mChildren.length; i++) {\r\n      this.mChildren[i].__update(dt);\r\n\r\n      if (this.__checkRemovedChildren(i))\r\n        break;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @ignore\r\n   * @param {number} dt time since the last frame\r\n   *\r\n   * @return {void}\r\n   */\r\n  __postUpdate(dt) {\r\n    this.onPostUpdate(dt);\r\n\r\n    for (let k = 0; k < this.mComponents.length; k++) {\r\n      let c = this.mComponents[k];\r\n      c.mGameObject = this;\r\n      c.onPostUpdate(dt);\r\n\r\n      if (this.__checkRemovedComponents(k))\r\n        break;\r\n    }\r\n\r\n    for (let i = 0; i < this.mChildren.length; i++) {\r\n      this.mChildren[i].__postUpdate(dt);\r\n\r\n      if (this.__checkRemovedChildren(i))\r\n        break;\r\n    }\r\n  }\r\n\r\n  __checkRemovedComponents(i) {\r\n    if (this.mComponents == 0)\r\n      return false;\r\n\r\n    i -= this.mNumComponentsRemoved;\r\n    this.mNumComponentsRemoved = 0;\r\n\r\n    if (i < 0)\r\n      return true;\r\n\r\n    return false;\r\n  }\r\n\r\n  __checkRemovedChildren(i) {\r\n    if (this.mNumChildrenRemoved == 0)\r\n      return false;\r\n\r\n    i -= this.mNumChildrenRemoved;\r\n    this.mNumChildrenRemoved = 0;\r\n\r\n    if (i < 0)\r\n      return true;\r\n\r\n    return false;\r\n  }\r\n\r\n\r\n  /**\r\n   * Called at every fixed frame update.\r\n   *\r\n   * @public\r\n   * @param {number} dt time since the last frame\r\n   *\r\n   * @return {void}\r\n   */\r\n  onFixedUpdate(dt) { }\r\n\r\n  /**\r\n   * Called at every engine update.\r\n   *\r\n   * @public\r\n   * @param {number} dt time since the last frame\r\n   *\r\n   * @return {void}\r\n   */\r\n  onUpdate(dt) { }\r\n\r\n  /**\r\n   * Called after all updates have been executed.\r\n   *\r\n   * @public\r\n   * @param {number} dt Description\r\n   *\r\n   * @return {void}\r\n   */\r\n  onPostUpdate(dt) { }\r\n\r\n  /**\r\n   * @ignore\r\n   * @param {VideoNullDriver} video   *\r\n   * @param {number} time\r\n   * @param {number} parentAlpha\r\n   *\r\n   * @return {void}\r\n   */\r\n  __render(video, time, parentAlpha) {\r\n    this.onRender(video, time);\r\n\r\n    let child = null;\r\n    let childLen = this.mChildren.length;\r\n    for (let i = 0; i < childLen; i++) {\r\n      child = this.mChildren[i];\r\n      child.__render(video, time, parentAlpha);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @protected\r\n   * @param {VideoNullDriver} video Description\r\n   * @param {number} time  Description\r\n   *\r\n   * @return {void}\r\n   */\r\n  onRender(video, time) { }\r\n\r\n  /**\r\n   * Override this method if you need to specify GameObject size. Should be always be a local coordinates.\r\n   *\r\n   * @protected\r\n   * @param {Rectangle=} outRect Description\r\n   *\r\n   * @return {Rectangle} bounds in local space withoout taking care about transformation matrix\r\n   */\r\n  onGetLocalBounds(outRect = undefined) {\r\n    outRect = outRect || new Rectangle();\r\n    return outRect.set(0, 0, 0, 0);\r\n  }\r\n\r\n  /**\r\n   * Returns world bounds of this object and all children if specified (true by default).\r\n   *\r\n   * object.getBounds() - relative to world.\r\n   * object.getBounds(object) - local bounds.\r\n   * object.getBounds(object.parent) - relative to parent.\r\n   * object.getBounds(objectB) - relative to objectB space.\r\n   *\r\n   * @param {GameObject} [space=undefined]\r\n   * @param {boolean} [includeChildren=true]\r\n   * @param {Rectangle=} [outRect=null]\r\n   *\r\n   * @return {Rectangle} returns bounds of the object and all childrens\r\n   */\r\n  getBounds(space = undefined, includeChildren = true, outRect = undefined) {\r\n    outRect = outRect || new Rectangle();\r\n\r\n    let matrix = this.worldTransformation;\r\n\r\n    // TODO: optimize, check if space == null, space == this, space == parent\r\n    // TODO: use wtInversed instead\r\n    if (space != null) {\r\n      matrix = this.worldTransformation.clone();\r\n      matrix.prepend(space.worldTransformation.clone().invert());\r\n    }\r\n\r\n    let bounds = new Rectangle();\r\n    this.onGetLocalBounds(bounds);\r\n\r\n    matrix.transformRect(bounds, bounds);\r\n    outRect.expand(bounds.x, bounds.y, bounds.width, bounds.height);\r\n\r\n    if (includeChildren)\r\n      for (let i = 0; i < this.numChildren; i++)\r\n        this.getChildAt(i).getBounds(space, includeChildren, outRect);\r\n\r\n    return outRect;\r\n  }\r\n\r\n  /**\r\n   * Sets the object transform in one line.\r\n   *\r\n   * @param {number} [x=0]       Cord X.\r\n   * @param {number} [y=0]       Cord Y.\r\n   * @param {number} [r=0]       Rotation.\r\n   * @param {number} [scaleX=1]  scale X.\r\n   * @param {number} [scaleY=1]  scale Y.\r\n   * @param {number} [anchorX=0] Anchor X.\r\n   * @param {number} [anchorY=0] Anchor Y.\r\n   * @param {boolean} [includeChildren=true] Include children when adjusting pivot?\r\n   *\r\n   * @return {GameObject} This.\r\n   */\r\n  setTransform(x = 0, y = 0, r = 0, scaleX = 1, scaleY = 1, anchorX = 0, anchorY = 0, includeChildren = true) {\r\n    this.mX = x;\r\n    this.mY = y;\r\n    this.mRotation = r;\r\n    this.mScaleX = scaleX;\r\n    this.mScaleY = scaleY;\r\n\r\n    this.getBounds(this, includeChildren, Rectangle.__cache.zero());\r\n    this.mPivotX = Rectangle.__cache.width * anchorX;\r\n    this.mPivotY = Rectangle.__cache.height * anchorY;\r\n\r\n    this.setTransformDirty();\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Calculate global position of the object.\r\n   *\r\n   * @param {Vector} localPoint\r\n   * @param {Vector|null} [outVector=null]\r\n   *\r\n   * @return {Vector}\r\n   */\r\n  localToGlobal(localPoint, outVector = null) {\r\n    return this.worldTransformation.transformVector(localPoint, outVector);\r\n  }\r\n\r\n  /**\r\n   * Calculate local position of the object\r\n   *\r\n   * @param {Vector} globalPoint\r\n   * @param {Vector|null} [outVector=null]\r\n   *\r\n   * @return {Vector}\r\n   */\r\n  globalToLocal(globalPoint, outVector = null) {\r\n    return this.worldTransformationInversed.transformVector(globalPoint, outVector);\r\n  }\r\n  /**\r\n   * Gets/Sets count of children elements.\r\n   *\r\n   * @return {number}\r\n   */\r\n  get numChildren() {\r\n    return this.mChildren.length;\r\n  }\r\n\r\n  /**\r\n   * Returns name of this GameoObject instance.\r\n   *\r\n   * @return {string|null}\r\n   */\r\n  get name() {\r\n    return this.mName;\r\n  }\r\n\r\n  /**\r\n   * @ignore\r\n   * @param {string|null} value Description\r\n   *\r\n   * @return {void}\r\n   */\r\n  set name(value) {\r\n    this.mName = value;\r\n  }\r\n\r\n  /**\r\n   * Gets/Sets the x coordinate of the GameoObject instance relative to the local coordinates of the parent GameoObject.\r\n   *\r\n   * @return {number}\r\n   */\r\n  get x() {\r\n    return this.mX;\r\n  }\r\n\r\n  /**\r\n   * @ignore\r\n   * @param {number} value\r\n   *\r\n   * @return {void}\r\n   */\r\n  set x(value) {\r\n    if (this.mX == value)\r\n      return;\r\n\r\n    this.mX = value;\r\n    this.setTransformDirty();\r\n  }\r\n\r\n  /**\r\n   * Gets/Sets the y coordinate of the GameoObject instance relative to the local coordinates of the parent GameoObject.\r\n   *\r\n   * @return {number}\r\n   */\r\n  get y() {\r\n    return this.mY;\r\n  }\r\n\r\n  /**\r\n   * @ignore\r\n   * @param {number} value\r\n   *\r\n   * @return {void}\r\n   */\r\n  set y(value) {\r\n    if (this.mY == value)\r\n      return;\r\n\r\n    this.mY = value;\r\n    this.setTransformDirty();\r\n  }\r\n\r\n  /**\r\n   * Gets/Sets the x coordinate of the object's origin in its local space.\r\n   *\r\n   * @return {number}\r\n   */\r\n  get pivotX() {\r\n    return this.mPivotX;\r\n  }\r\n\r\n  /**\r\n   * @ignore\r\n   * @param {number} value\r\n   *\r\n   * @return {void}\r\n   */\r\n  set pivotX(value) {\r\n    if (this.mPivotX == value)\r\n      return;\r\n\r\n    this.mPivotX = value;\r\n    this.setTransformDirty();\r\n  }\r\n\r\n  /**\r\n   * Gets/Sets the y coordinate of the object's origin in its local space.\r\n   *\r\n   * @return {number}\r\n   */\r\n  get pivotY() {\r\n    return this.mPivotY;\r\n  }\r\n\r\n  /**\r\n   * @ignore\r\n   * @param {number} value\r\n   *\r\n   * @return {void}\r\n   */\r\n  set pivotY(value) {\r\n    if (this.mPivotY == value)\r\n      return;\r\n\r\n    this.mPivotY = value;\r\n    this.setTransformDirty();\r\n  }\r\n\r\n  /**\r\n   * Sets pivot point to given position.\r\n   *\r\n   * @param {number}  [ax=0.5]               Align along x-axis.\r\n   * @param {number}  [ay=0.5]               Align along y-axis.\r\n   * @param {boolean} [includeChildren=true] Include children elements when\r\n   * calculating bounds?\r\n   *\r\n   * @return {GameObject} This.\r\n   */\r\n  alignPivot(ax = 0.5, ay = 0.5, includeChildren = true) {\r\n    this.getBounds(this, includeChildren, Rectangle.__cache.zero());\r\n\r\n    this.mPivotX = Rectangle.__cache.width * ax;\r\n    this.mPivotY = Rectangle.__cache.height * ay;\r\n    this.setTransformDirty();\r\n\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Gets/Sets the scale factor of this object along x-axis.\r\n   *\r\n   * @return {number}\r\n   */\r\n  get scaleX() {\r\n    return this.mScaleX;\r\n  }\r\n\r\n  /**\r\n   * @ignore\r\n   * @param {number} value\r\n   *\r\n   * @return {void}\r\n   */\r\n  set scaleX(value) {\r\n    if (this.mScaleX == value)\r\n      return;\r\n\r\n    this.mScaleX = value;\r\n    this.setTransformDirty();\r\n  }\r\n\r\n  /**\r\n   * Gets/Sets the scale factor of this object along y-axis.\r\n   *\r\n   * @return {number} Description\r\n   */\r\n  get scaleY() {\r\n    return this.mScaleY;\r\n  }\r\n\r\n  /**\r\n   * @ignore\r\n   * @param {number} value Description\r\n   *\r\n   * @return {void}\r\n   */\r\n  set scaleY(value) {\r\n    if (this.mScaleY == value)\r\n      return;\r\n\r\n    this.mScaleY = value;\r\n    this.setTransformDirty();\r\n  }\r\n\r\n  /**\r\n   * Gets/Sets rotation in radians.\r\n   *\r\n   * @return {number}\r\n   */\r\n  get rotation() {\r\n    return this.mRotation;\r\n  }\r\n\r\n  /**\r\n   * @ignore\r\n   * @param {number} value Description\r\n   *\r\n   * @return {void}\r\n   */\r\n  set rotation(value) {\r\n    if (this.mRotation == value)\r\n      return;\r\n\r\n    this.mRotation = value;\r\n    this.setTransformDirty();\r\n  }\r\n\r\n  /**\r\n   * Returns this GameObject parent GameObject.\r\n   * @readonly\r\n   *\r\n   * @return {GameObject}\r\n   */\r\n  get parent() {\r\n    return this.mParent;\r\n  }\r\n\r\n  /**\r\n   * Returns topmost parent element of this GameObject or null if this\r\n   * GameObject is not a child.\r\n   *\r\n   * @readonly\r\n   *\r\n   * @return {GameObject|null}\r\n   */\r\n  get root() {\r\n    if (Black.instance == null)\r\n      return null;\r\n\r\n    let current = this;\r\n\r\n    if (current === Black.instance.root)\r\n      return current;\r\n\r\n    while (current.mParent) {\r\n      if (current === Black.instance.root)\r\n        return current;\r\n      else if (current.mParent === Black.instance.root)\r\n        return Black.instance.root;\r\n      else\r\n        current = current.mParent;\r\n    }\r\n\r\n    return null;\r\n  }\r\n\r\n  // /**\r\n  //  * Returns how deep this GameObject in the display tree.\r\n  //  *\r\n  //  * @readonly\r\n  //  *\r\n  //  * @return {number}\r\n  //  */\r\n  // get depth() {\r\n  //   if (this.mParent)\r\n  //     return this.mParent.depth + 1;\r\n  //   else\r\n  //     return 0;\r\n  // }\r\n\r\n  // TODO: review and make sure this func is required\r\n  // get displayDepth() {\r\n  //   // Many thanks to Roman Kopansky\r\n  //   const flatten = arr => arr.reduce((acc, val) => acc.concat(val.mChildren.length ? flatten(val.mChildren) : val), []);\r\n  //   return flatten(this.root.mChildren).indexOf(this);\r\n  // }\r\n\r\n  // /**\r\n  //  * @ignore\r\n  //  * @return {number}\r\n  //  */\r\n  // get index() {\r\n  //   // TODO: this is only required by Input component and its pretty heavy.\r\n  //   // Try to workaround it.\r\n  //   return this.parent.mChildren.indexOf(this);\r\n  // }\r\n\r\n  /**\r\n   * Gets/sets the width of this object.\r\n   *\r\n   * @return {number}\r\n   */\r\n  get width() {\r\n    return this.getBounds(this.mParent).width;\r\n  }\r\n\r\n  /**\r\n   * @ignore\r\n   *\r\n   * @param {number} value\r\n   *\r\n   * @return {void}\r\n   */\r\n  set width(value) {\r\n    this.scaleX = 1;\r\n    const currentWidth = this.width;\r\n\r\n    if (currentWidth != 0.0)\r\n      this.scaleX = value / currentWidth;\r\n  }\r\n\r\n  /**\r\n   * Gets/sets the height of this object.\r\n   *\r\n   * @return {number}\r\n   */\r\n  get height() {\r\n    return this.getBounds(this.mParent).height;\r\n  }\r\n\r\n  /**\r\n   * @ignore\r\n   * @param {number} value\r\n   *\r\n   * @return {void}\r\n   */\r\n  set height(value) {\r\n    this.scaleY = 1;\r\n    const currentHeight = this.height;\r\n\r\n    if (currentHeight != 0)\r\n      this.scaleY = value / currentHeight;\r\n  }\r\n\r\n\r\n  /**\r\n   * Returns width of this GameObject in local space without including children\r\n   * elements.\r\n   *\r\n   * @readonly\r\n   *\r\n   * @return {number}\r\n   */\r\n  get localWidth() {\r\n    return this.getBounds(this, false).width;\r\n  }\r\n\r\n\r\n  /**\r\n   * Returns height of this GameObject in local space without including children\r\n   * elements.\r\n   *\r\n   * @readonly\r\n   *\r\n   * @return {number}\r\n   */\r\n  get localHeight() {\r\n    return this.getBounds(this, false).height;\r\n  }\r\n\r\n  // TODO: precache\r\n  /**\r\n   * Returns string representing a url like path to this object in the display\r\n   * tree.\r\n   *\r\n   * @readonly\r\n   *\r\n   * @return {string|null}\r\n   */\r\n  get path() {\r\n    if (this.mParent !== null)\r\n      return this.mParent.path + '/' + this.mName;\r\n\r\n    return this.mName;\r\n  }\r\n\r\n  /**\r\n   * Gets/Sets tag of this GameObject.\r\n   *\r\n   * @return {string|null}\r\n   */\r\n  get tag() {\r\n    return this.mTag;\r\n  }\r\n\r\n  /**\r\n   * @ignore\r\n   *\r\n   * @param {string|null} value\r\n   *\r\n   * @return {void}\r\n   */\r\n  set tag(value) {\r\n    if (this.mTag === value)\r\n      return;\r\n\r\n    /** @type {string|null} */\r\n    let old = this.mTag;\r\n    this.mTag = value;\r\n\r\n    if (this.mAdded)\r\n      Black.instance.onTagUpdated(this, old, value);\r\n  }\r\n\r\n  /**\r\n   * Starts coroutine.\r\n   *\r\n   * @param {Function} gen  Generator function.\r\n   * @param {*=} [ctx=null] Context for Generator function.\r\n   *\r\n   * @return {Generator}\r\n   */\r\n  spawn(gen, ctx = null) {\r\n    var iter = gen.apply(ctx == null ? this : ctx);\r\n\r\n    function step(it) {\r\n      if (it.done)\r\n        return;\r\n\r\n      if (typeof it.value === 'function')\r\n        it.value(x => step(iter.next(x)));\r\n      else\r\n        step(iter.next(it.value));\r\n    }\r\n\r\n    step(iter.next());\r\n    return iter;\r\n  }\r\n\r\n  /**\r\n   * Waits for given amount of seconds before processing.\r\n   *\r\n   * @return {function(*):*}\r\n   */\r\n  wait(seconds = 1) {\r\n    return cb => setTimeout(cb.bind(this, seconds * 1000), seconds * 1000);\r\n  }\r\n\r\n\r\n  /**\r\n   * Waits for a speceific message.\r\n   *\r\n   * @param {string} message The name of the message to wait for.\r\n   *\r\n   * @return {function(*):*}\r\n   */\r\n  waitMessage(message) {\r\n    return cb => this.on(message, cb.bind(this));\r\n  }\r\n\r\n\r\n  /**\r\n   * Marks this GameObject and/or its children elements as dirty.\r\n   *\r\n   * @param {DirtyFlag} flag                 The flag or flag bit mask.\r\n   * @param {boolean} [includeChildren=true] Description\r\n   *\r\n   * @return {void}\r\n   */\r\n  setDirty(flag, includeChildren = true) {\r\n    if (includeChildren) {\r\n      GameObject.forEach(this, x => {\r\n        x.mDirty |= flag;\r\n      });\r\n    } else {\r\n      this.mDirty |= flag;\r\n    }\r\n  }\r\n\r\n\r\n  /**\r\n   * Marks this GameObject as Local dirty and all children elements as World\r\n   * dirty.\r\n   *\r\n   * @returns {void}\r\n   */\r\n  setTransformDirty() {\r\n    this.setDirty(DirtyFlag.LOCAL, false);\r\n    this.setDirty(DirtyFlag.WORLD, true);\r\n  }\r\n\r\n  /**\r\n   * @ignore\r\n   *\r\n   * @return {void}\r\n   */\r\n  dispose() { }\r\n\r\n  // TODO: rename method\r\n  /**\r\n   * @ignore\r\n   *\r\n   * @param {Array<number>} points\r\n   * @param {Matrix} worldTransformation\r\n   * @param {Rectangle=} outRect\r\n   *\r\n   * @return {Rectangle}\r\n   */\r\n  static getBoundsWithPoints(points, worldTransformation, outRect) {\r\n    outRect = outRect || new Rectangle();\r\n\r\n    let minX = Number.MAX_VALUE;\r\n    let maxX = -Number.MAX_VALUE;\r\n    let minY = Number.MAX_VALUE;\r\n    let maxY = -Number.MAX_VALUE;\r\n    let xx = 0;\r\n    let yy = 0;\r\n    let tmpVector = new Vector();\r\n\r\n    for (let i = 0; i < points.length; i += 2) {\r\n      worldTransformation.transformXY(points[i], points[i + 1], tmpVector);\r\n\r\n      if (minX > tmpVector.x)\r\n        minX = tmpVector.x;\r\n\r\n      if (maxX < tmpVector.x)\r\n        maxX = tmpVector.x;\r\n\r\n      if (minY > tmpVector.y)\r\n        minY = tmpVector.y;\r\n\r\n      if (maxY < tmpVector.y)\r\n        maxY = tmpVector.y;\r\n    }\r\n\r\n    outRect.set(minX, minY, maxX - minX, maxY - minY);\r\n    return outRect;\r\n  }\r\n\r\n  /**\r\n   * Returns whenever a given GameObject intersects with a point.\r\n   *\r\n   * @param {GameObject} gameObject GameObject to test.\r\n   * @param {Vector} point          A point to test.\r\n   *\r\n   * @return {boolean} True if intersects.\r\n   */\r\n  static intersects(gameObject, point) {\r\n    let tmpVector = new Vector();\r\n    let inv = gameObject.worldTransformationInversed;\r\n\r\n    inv.transformVector(point, tmpVector);\r\n\r\n    let rect = gameObject.getBounds(gameObject, false);\r\n    return rect.containsXY(tmpVector.x, tmpVector.y);\r\n  }\r\n\r\n  /**\r\n   * Returns a point where intersection were made in local space.\r\n   *\r\n   * @param {GameObject} gameObject GameObject to test intersection with.\r\n   * @param {Vector}     point      The point to test.\r\n   * @param {Vector=}    outVector  If passed point of intersection will be\r\n   * stored in it.\r\n   *\r\n   * @return {boolean} True if intersects.\r\n   */\r\n  static intersectsAt(gameObject, point, outVector = undefined) {\r\n    outVector = outVector || new Vector();\r\n\r\n    let tmpVector = Vector.__cache;\r\n    let inv = gameObject.worldTransformationInversed;\r\n\r\n    inv.transformVector(point, tmpVector);\r\n\r\n    let rect = gameObject.getBounds(gameObject, false);\r\n    let contains = rect.containsXY(tmpVector.x, tmpVector.y);\r\n\r\n    if (!contains)\r\n      return false;\r\n\r\n    outVector.x = tmpVector.x - rect.x;\r\n    outVector.y = tmpVector.y - rect.y;\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * Checks if GameObject or any of its children elements intersects the given\r\n   * point, the difference between `hits` and `intersectsWith` that `hits` also\r\n   * checks for presence of `InputComponent`.\r\n   *\r\n   * @param {GameObject} gameObject GameObject to test.\r\n   * @param {Vector} point          Point to test.\r\n   *\r\n   * @return {GameObject|null} Intersecting object or null.\r\n   */\r\n  static hits(gameObject, point) {\r\n    // TODO: add colliders\r\n\r\n    let obj = null;\r\n    for (let i = gameObject.numChildren - 1; i >= 0; --i) {\r\n      let child = gameObject.mChildren[i];\r\n\r\n      obj = GameObject.hits(child, point);\r\n      if (obj != null)\r\n        return obj;\r\n\r\n      let c = child.getComponent(InputComponent);\r\n      let touchable = c !== null && c.touchable;\r\n      if (touchable && GameObject.intersects(child, point)) {\r\n        obj = child;\r\n        break;\r\n      }\r\n    }\r\n\r\n    if (obj === null) {\r\n      let c = gameObject.getComponent(InputComponent);\r\n      let touchable = c !== null && c.touchable;\r\n\r\n      if (touchable && GameObject.intersects(gameObject, point))\r\n        return gameObject;\r\n    }\r\n\r\n    return null;\r\n  }\r\n\r\n  /**\r\n   * Checks if GameObject or any of its children elements intersects the given\r\n   * point.\r\n   *\r\n   * @param {GameObject} gameObject GameObject to test.\r\n   * @param {Vector} point          Point to test.\r\n   *\r\n   * @return {GameObject|null} Intersecting object or null.\r\n   */\r\n  static intersectsWith(gameObject, point) {\r\n    let obj = null;\r\n    for (let i = gameObject.numChildren - 1; i >= 0; --i) {\r\n      let child = gameObject.mChildren[i];\r\n\r\n      obj = GameObject.intersectsWith(child, point);\r\n      if (obj != null)\r\n        return obj;\r\n\r\n      let inside = GameObject.intersects(child, point);\r\n      if (inside) {\r\n        obj = child;\r\n        break;\r\n      }\r\n    }\r\n\r\n    if (obj === null && GameObject.intersects(gameObject, point))\r\n      return gameObject;\r\n\r\n    return null;\r\n  }\r\n\r\n  /**\r\n   * Returns all GameObject with given tag.\r\n   *\r\n   * @param {string} tag Tag to find.\r\n   *\r\n   * @returns {Array<GameObject>|null} Array of GameObject or null if not found.\r\n   */\r\n  static findWithTag(tag) {\r\n    if (Black.instance.mTagCache.hasOwnProperty(tag) === false)\r\n      return null;\r\n\r\n    return Black.instance.mTagCache[tag];\r\n  }\r\n\r\n  /**\r\n   * Returns a list of Components.\r\n   *\r\n   * @param {GameObject} gameObject         GameObject to start search from.\r\n   * @param {function (new:Component)} type Type of Component.\r\n   *\r\n   * @return {Array<Component>} Array of Component or empty array.\r\n   */\r\n  static findComponents(gameObject, type) {\r\n    Debug.assert(gameObject !== null, 'gameObject cannot be null.');\r\n    Debug.assert(type !== null, 'type cannot be null.');\r\n\r\n    /** @type {Array<Component>} */\r\n    let list = [];\r\n\r\n    /** @type {function(GameObject, function(new:Component)):void} */\r\n    let f = function (gameObject, type) {\r\n      for (let i = 0; i < gameObject.mComponents.length; i++) {\r\n        let c = gameObject.mComponents[i];\r\n        if (c instanceof type)\r\n          list.push(c);\r\n      }\r\n\r\n      for (let i = 0; i < gameObject.mChildren.length; i++)\r\n        f(gameObject.mChildren[i], type);\r\n    };\r\n\r\n    f(gameObject, type);\r\n\r\n    return list;\r\n  }\r\n\r\n  /**\r\n   * Runs action accross all GameObjects.\r\n   *\r\n   * @param {GameObject} node                  GameObject to start iteration from.\r\n   * @param {function(GameObject)} action The function to be executed on\r\n   * every GameObject.\r\n   *\r\n   * @return {void}\r\n   */\r\n  static forEach(node, action) {\r\n    if (node == null)\r\n      node = Black.instance.root;\r\n\r\n    action(node);\r\n\r\n    for (let i = 0; i < node.numChildren; i++)\r\n      GameObject.forEach(node.getChildAt(i), action);\r\n  }\r\n\r\n\r\n  /**\r\n   * Finds object by its name. If node is not passed the root will be taken as\r\n   * starting point.\r\n   *\r\n   * @param {string} name      Name to search.\r\n   * @param {GameObject=} node Starting GameObject.\r\n   *\r\n   * @return {GameObject} GameObject or null.\r\n   */\r\n  static find(name, node) {\r\n    if (node == null)\r\n      node = Black.instance.root;\r\n\r\n    if (node.name === name)\r\n      return node;\r\n\r\n    for (let i = 0; i < node.numChildren; i++) {\r\n      let r = GameObject.find(name, node.getChildAt(i));\r\n      if (r != null)\r\n        return r;\r\n    }\r\n\r\n    return null;\r\n  }\r\n\r\n  /**\r\n   * Finds object by its id property. If node is not passed the root will be taken as\r\n   * starting point.\r\n   *\r\n   * @param {number} id         Id to search.\r\n   * @param {GameObject=} node  Starting GameObject or null.\r\n   *\r\n   * @return {GameObject} GameObject or null.\r\n   */\r\n  static findById(id, node) {\r\n    if (node == null)\r\n      node = Black.instance.root;\r\n\r\n    if (node.id === id)\r\n      return node;\r\n\r\n    for (let i = 0; i < node.numChildren; i++) {\r\n      let r = GameObject.findById(id, node.getChildAt(i));\r\n      if (r !== null)\r\n        return r;\r\n    }\r\n\r\n    return null;\r\n  }\r\n}\r\n\r\n/**\r\n * @private\r\n * @type {number}\r\n * @nocollapse\r\n */\r\nGameObject.ID = 0;\r\n\r\n/**\r\n * @enum {number}\r\n */\r\n\r\nvar DirtyFlag = {\r\n  LOCAL: 1,\r\n  WORLD: 2,\r\n  DIRTY: 0xffffff\r\n};\r\n","// TODO:\r\n// [_] Do not handle is loaded or not.\r\n// Texture shall not be responsible for loading itself.\r\n// We have TextureAsset for it.\r\n// native size - always the size of physical texture\r\n// source size - the original size of a texture to\r\n//\r\n\r\n/**\r\n * A number scatter for defining a range in 2D space.\r\n *\r\n * @cat video\r\n * @extends Scatter\r\n */\r\n\r\nclass Texture {\r\n  /**\r\n   * Creates new Texture instance.\r\n   * @param  {HTMLImageElement|HTMLVideoElement|HTMLCanvasElement} nativeTexture A source of the texture.\r\n   * @param  {Rectangle=} region = undefined                                     A region to be drawn.\r\n   * @param  {Rectangle=} untrimmedRect = undefined                              Actual size of a texture when not trimmed.\r\n   */\r\n  constructor(nativeTexture, region, untrimmedRect) {\r\n    /**\r\n     * @private\r\n     * @type {Image}\r\n     */\r\n    this.mTexture = nativeTexture;\r\n\r\n    /**\r\n     * @private\r\n     * @type {Rectangle}\r\n     */\r\n    this.mRegion = null;\r\n\r\n    /**\r\n     * @private\r\n     * @type {boolean}\r\n     */\r\n    this.mIsSubtexture = false;\r\n\r\n    /**\r\n     * @private\r\n     * @type {number}\r\n     */\r\n    this.mId = ++Texture.__ID;\r\n\r\n    if (region === undefined) {\r\n      if(nativeTexture instanceof HTMLImageElement)\r\n        this.mRegion = new Rectangle(0, 0, nativeTexture.naturalWidth, nativeTexture.naturalHeight);\r\n      else\r\n        this.mRegion = new Rectangle(0, 0, nativeTexture.width, nativeTexture.height);\r\n    } else {\r\n      this.mRegion = /** @type {Rectangle} */ (region);\r\n      this.mIsSubtexture = true;\r\n    }\r\n\r\n    /**\r\n     * @private\r\n     * @type {boolean}\r\n     */\r\n    this.mTrimmed = untrimmedRect !== undefined;\r\n\r\n    if (this.mTrimmed === false)\r\n      untrimmedRect = new Rectangle(0, 0, this.mRegion.width, this.mRegion.height);\r\n\r\n    /**\r\n     * @private\r\n     * @type {Rectangle}\r\n     */\r\n    this.mUntrimmedRect = /** @type {Rectangle} */ (untrimmedRect);\r\n\r\n    /**\r\n     * @private\r\n     * @type {boolean}\r\n     */\r\n    this.mIsLoaded = true;\r\n\r\n    // TODO: refactor, make private\r\n    this.nativeWidth = nativeTexture.naturalWidth || nativeTexture.width;\r\n    this.nativeHeight = nativeTexture.naturalHeight || nativeTexture.height;\r\n\r\n    this.coord = new Uint32Array(4);\r\n    this.refreshCoord();\r\n    \r\n    this._vSlotWebGL = -1;  // virtual slot for batch calculations\r\n    this.premultiplyAlpha = true;\r\n  }\r\n\r\n  refreshCoord() {\r\n    const coord = this.coord;\r\n    const region = this.mRegion;\r\n    const w = this.nativeWidth;\r\n    const h = this.nativeHeight;\r\n\r\n    const x0 = region.left / w;\r\n    const y0 = region.top / h;\r\n\r\n    const x1 = region.right / w;\r\n    const y1 = region.top / h;\r\n\r\n    const x2 = region.left / w;\r\n    const y2 = region.bottom / h;\r\n\r\n    const x3 = region.right / w;\r\n    const y3 = region.bottom / h;\r\n\r\n    coord[0] = (((y0 * 65535) & 0xffff) << 16) | ((x0 * 65535) & 0xffff);\r\n    coord[1] = (((y1 * 65535) & 0xffff) << 16) | ((x1 * 65535) & 0xffff);\r\n    coord[2] = (((y2 * 65535) & 0xffff) << 16) | ((x2 * 65535) & 0xffff);\r\n    coord[3] = (((y3 * 65535) & 0xffff) << 16) | ((x3 * 65535) & 0xffff);\r\n  }\r\n\r\n  /**\r\n   * Returns the unique id of this texture.\r\n   *\r\n   * @return {number}\r\n   */\r\n  get id() {\r\n    return this.mId;\r\n  }\r\n\r\n  /**\r\n   * Returns True if this texture has been trimmed.\r\n   *\r\n   * @return {boolean}\r\n   */\r\n  get isTrimmed() {\r\n    return this.mTrimmed;\r\n  }\r\n\r\n  /**\r\n   * Returns True if this texture is a part of other Texture object\r\n   *\r\n   * @return {boolean} Description\r\n   */\r\n  get isSubTexture() {\r\n    return this.mIsSubtexture;\r\n  }\r\n\r\n  // TODO: if we update texture we have to nofity everything, send signal\r\n  // update(nativeTexture = null, region = null, source = null, crop = null){\r\n  // }\r\n\r\n  // render width\r\n  // render height\r\n  // croppedWidth, croppedHeight\r\n  // width, height\r\n  //\r\n\r\n  /**\r\n   * Returns a Rect object representing the untrimmed size and position of this\r\n   * texture withing other texture if so.\r\n   *\r\n   * @return {Rectangle}\r\n   */\r\n  get untrimmedRect() {\r\n    return this.mUntrimmedRect;\r\n  }\r\n\r\n  /**\r\n   * The width of this texture.\r\n   *\r\n   * @return {number}\r\n   */\r\n  get width() {\r\n    if (this.mRegion)\r\n      return this.mRegion.width;\r\n\r\n    return this.mTexture.naturalWidth;\r\n  }\r\n\r\n  /**\r\n   * The width of this texture.\r\n   *\r\n   * @return {number}\r\n   */\r\n  get height() {\r\n    if (this.mRegion)\r\n      return this.mRegion.height;\r\n\r\n    return this.mTexture.naturalHeight;\r\n  }\r\n\r\n  /**\r\n   * If isSubTexture, returns the physical region inside parent texture.\r\n   *\r\n   * @return {Rectangle}\r\n   */\r\n  get region() {\r\n    return this.mRegion;\r\n  }\r\n\r\n  /**\r\n   * Returns native object. Usually DOM Image element.\r\n   *\r\n   * @return {Image}\r\n   */\r\n  get native() {\r\n    return this.mTexture;\r\n  }\r\n\r\n  /**\r\n   * True if fully loaded and ready.\r\n   *\r\n   * @return {boolean}\r\n   */\r\n  get isLoaded() {\r\n    return this.mIsLoaded;\r\n  }\r\n\r\n  /**\r\n   * Dispose and releases all resources related to this texture.\r\n   *\r\n   * @return {void}\r\n   */\r\n  dispose() {\r\n    this.mTexture = null;\r\n  }\r\n\r\n  /**\r\n   * @ignore\r\n   *\r\n   * @param {string} string\r\n   *\r\n   * @return {Texture}\r\n   */\r\n  static fromBase64String(string) {\r\n    let imgElement = new Image();\r\n    imgElement.src = string;\r\n    return new Texture(imgElement);\r\n  }\r\n\r\n\r\n  /**\r\n   * @ignore\r\n   *\r\n   * @param {HTMLElement}   canvas\r\n   * @param {string} [type=image/png]\r\n   * @param {number} [quality=1]\r\n   *\r\n   * @return {Texture}\r\n   */\r\n  static fromCanvasAsImage(canvas, type = 'image/png', quality = 1) {\r\n    let imgElement = new Image();\r\n    imgElement.src = canvas.toDataURL(type, quality);\r\n\r\n    return new Texture(imgElement);\r\n  }\r\n\r\n  /**\r\n   * @ignore\r\n   *\r\n   * @param {HTMLElement} canvas\r\n   *\r\n   * @return {Texture}\r\n   */\r\n  static fromCanvas(canvas) {\r\n    return Black.instance.video.getTextureFromCanvas(canvas);\r\n  }\r\n}\r\n\r\n/**\r\n * @private\r\n * @type {number}\r\n * @nocollapse\r\n */\r\nTexture.__ID = 0;\r\n\r\n/**\r\n * @private\r\n * @type {Image|null}\r\n * @nocollapse\r\n */\r\nTexture.MISSING_IMAGE_CACHE = null;\r\n","/**\r\n * A number scatter for defining a range in 2D space.\r\n *\r\n * @cat video\r\n * @extends Texture\r\n */\r\n\r\nclass AtlasTexture extends Texture {\r\n  /**\r\n   * Creates new AtlasTexture instance.\r\n   *\r\n   * @param {Texture}              texture A base texture object.\r\n   * @param {{meta: *, frames: *}} Black json object.\r\n   */\r\n  constructor(texture, jsonObject) {\r\n    super(texture.native);\r\n\r\n    /** @type {Object} */\r\n    this.mMeta = {};\r\n\r\n    /** @dict */\r\n    this.mSubTextures = {}; // dictionary\r\n\r\n    this.__parseJson(jsonObject);\r\n  }\r\n\r\n  /**\r\n   * @private\r\n   *\r\n   * @param  {{meta: *, frames: *}} o\r\n   * @return {void}\r\n   */\r\n  __parseJson(o) {\r\n    const NEGATIVE_HALF_PI = -(Math.PI / 2);\r\n\r\n    // if (o.meta.format)\r\n    //   this.mMeta.format = o.meta.format;\r\n    //\r\n    // if (o.meta.scale)\r\n    //   this.mMeta.scale = parseFloat(o.meta.scale);\r\n\r\n    for (let key in o.frames) {\r\n      let data = /** @type {Array<number>} */ (o.frames[key]);\r\n\r\n      let region = new Rectangle(data[0], data[1], data[2], data[3]);\r\n      let untrimmedRect = new Rectangle(data[4], data[5], data[6], data[7]);\r\n\r\n      this.mSubTextures[key] = new Texture(this.native, region, untrimmedRect);\r\n    }\r\n  }\r\n\r\n  // addRegion(name, region, frame) {}\r\n  //\r\n  // removeRegion() {}\r\n\r\n  /**\r\n   * Returns the texture by a given name.\r\n   *\r\n   * @param {string} name The name of the texture to find.\r\n   *\r\n   * @return {Texture} The Texture or null if not found.\r\n   */\r\n  getTexture(name) {\r\n    /** @type {Texture} */\r\n    let t = this.mSubTextures[name];\r\n    if (t === undefined)\r\n      console.warn('Texture \\'%s\\' was not found in cache.', name);\r\n\r\n    return /** @type {Texture} */ (t);\r\n  }\r\n\r\n  /**\r\n   * Returns array of Texture by given name or wildcard mask.\r\n   * If `nameMask` is null then all textures will be returned.\r\n   * This method sorts all resulting textures using neurural sort algorith.\r\n   *\r\n   * @param {string|null} [nameMask=null] The mask to filter by.\r\n   * @param {Array<Texture>|null}         outTextures If passed will be\r\n   * overwritten by result object.\r\n   *\r\n   * @return {Array<Texture>} The list of found textures.\r\n   */\r\n  getTextures(nameMask = null, outTextures = null) {\r\n    let out = outTextures || [];\r\n    if (nameMask === null) {\r\n      for (let key in this.mSubTextures)\r\n        out.push(this.mSubTextures[key]);\r\n\r\n      return /** @type {Array<Texture>} */ (out);\r\n    }\r\n\r\n    let names = [];\r\n\r\n    // TODO: make helper wild function\r\n    let re = new RegExp(\"^\" + nameMask.split(\"*\").join(\".*\") + \"$\");\r\n    for (let key in this.mSubTextures)\r\n      if (re.test(key))\r\n        names.push(key);\r\n\r\n    //names.sort(AtlasTexture.__naturalComparer);\r\n    AtlasTexture.naturalSort(names);\r\n\r\n    for (let i = 0; i < names.length; i++)\r\n      out.push(this.mSubTextures[names[i]]);\r\n\r\n    return out;\r\n  }\r\n\r\n  static naturalSort(dataset, field = null) {\r\n    dataset.sort(AtlasTexture.__naturalComparer(field));\r\n  }\r\n\r\n  static __naturalComparer(field = null, useAbs = true) {\r\n    return function(a, b) {\r\n      const NUMBER_GROUPS = /(-?\\d*\\.?\\d+)/g;\r\n      let aa = String(field == null ? a : a[field]).split(NUMBER_GROUPS);\r\n      let bb = String(field == null ? b : b[field]).split(NUMBER_GROUPS);\r\n      let min = Math.min(aa.length, bb.length);\r\n\r\n      for (let i = 0; i < min; i++) {\r\n        let x = 0;\r\n        let y = 0;\r\n\r\n        if (useAbs) {\r\n          x = Math.abs(parseFloat(aa[i])) || aa[i].toLowerCase();\r\n          y = Math.abs(parseFloat(bb[i])) || bb[i].toLowerCase();\r\n        } else {\r\n          x = parseFloat(aa[i]) || aa[i].toLowerCase();\r\n          y = parseFloat(bb[i]) || bb[i].toLowerCase();\r\n        }\r\n\r\n        if (x < y)\r\n          return -1;\r\n        else if (x > y)\r\n          return 1;\r\n      }\r\n\r\n      return 0;\r\n    }\r\n  }\r\n\r\n  //dispose() {}\r\n}\r\n","/**\r\n * Holds information about external assets.\r\n *\r\n * @cat loaders\r\n * @extends MessageDispatcher\r\n */\r\n\r\nclass Asset extends MessageDispatcher {\r\n  /**\r\n   * Creates new Assets instance.\r\n   * @param  {string} name Name of asset.\r\n   * @param  {string} url  URL of the asset to load it from.\r\n   */\r\n  constructor(name, url) {\r\n    super();\r\n\r\n    /**\r\n     * @private\r\n     * @type {string}\r\n     */\r\n    this.mName = name;\r\n\r\n    /**\r\n     * @private\r\n     * @type {string}\r\n     */\r\n    this.mUrl = url;\r\n\r\n    /**\r\n     * @private\r\n     * @type {*|null}\r\n     */\r\n    this.mData = null;\r\n\r\n    /**\r\n     * @private\r\n     * @type {boolean}\r\n     */\r\n    this.mIsLoaded = false;\r\n\r\n    /**\r\n     * @private\r\n     * @type {string|undefined}\r\n     */\r\n    this.mMimeType = undefined;\r\n\r\n    /**\r\n     * @private\r\n     * @type {string}\r\n     */\r\n    this.mResponseType = '';\r\n\r\n    /**\r\n     * @private\r\n     * @type {string}\r\n     */\r\n    this.mExtension = this.getExtension(url);\r\n\r\n    /**\r\n     * @private\r\n     * @type {XMLHttpRequest|null}\r\n     */\r\n    this.mRequest = null;\r\n  }\r\n\r\n  /**\r\n   * Loads asset from an external source.\r\n   *\r\n   * @return {void}\r\n   */\r\n  load() {\r\n    //console.log('Asset: loading asset \\'%s\\' from \\'%s\\'', this.mName, this.mUrl);\r\n\r\n    this.mRequest = new XMLHttpRequest();\r\n    //this.mRequest.onprogress = (pe) => this.onProgressChanged(pe);\r\n\r\n    if (this.mRequest.overrideMimeType && this.mMimeType)\r\n      this.mRequest.overrideMimeType(this.mMimeType);\r\n\r\n    this.mRequest.responseType = this.mResponseType;\r\n    this.mRequest.open(\"GET\", this.mUrl, true);\r\n    this.mRequest.onreadystatechange = () => {\r\n      if (this.mRequest.readyState === 4) {\r\n        if ((this.mRequest.status === 200) || ((this.mRequest.status === 0) && this.mRequest.responseText))\r\n          this.onLoaded();\r\n        else\r\n          throw new Error('Error loading ' + this.mUrl + \" (\" + this.mRequest.status + \":\"+ this.mRequest.responseText + \")\"); //TODO handle errors\r\n      }\r\n    };\r\n\r\n    this.mRequest.send(null);\r\n  }\r\n\r\n  /**\r\n   * Called when asset is fully loaded.\r\n   *\r\n   * @protected\r\n   * @fires complete\r\n   *\r\n   * @return {void}\r\n   */\r\n  onLoaded() {\r\n    this.mIsLoaded = true;\r\n    this.post('complete');\r\n  }\r\n\r\n  /**\r\n   * Returns the name of this asset.\r\n   *\r\n   * @return {string}\r\n   */\r\n  get name() {\r\n    return this.mName;\r\n  }\r\n\r\n  /**\r\n   * Returns loaded data object associated with this asset.\r\n   *\r\n   * @return {*}\r\n   */\r\n  get data() {\r\n    return this.mData;\r\n  }\r\n\r\n  /**\r\n   * Returns true if asset is preloaded.\r\n   *\r\n   * @return {boolean}\r\n   */\r\n  get isLoaded() {\r\n    return this.mIsLoaded;\r\n  }\r\n\r\n  // TODO: finish\r\n  dispose() {}\r\n\r\n  /**\r\n   * Helper function. Returns the file extension.\r\n   *\r\n   * @param {string} url Url to get extension from.\r\n   *\r\n   * @return {string} Empty string if no extension were found or extension itself.\r\n   */\r\n  getExtension(url) {\r\n    if (url.indexOf('.') === -1)\r\n      return '';\r\n\r\n    return url.substring(url.indexOf('.')).toLowerCase();\r\n  }\r\n}\r\n","/**\r\n * Single Texture file asset class responsible for loading images file and\r\n * converting them into Textures.\r\n *\r\n * @cat loaders\r\n * @extends Asset\r\n */\r\n\r\nclass TextureAsset extends Asset {\r\n  /**\r\n   * Creates TextureAsset instance.\r\n   *\r\n   * @param {string} name Asset name.\r\n   * @param {string} url  URL to load image from.\r\n   */\r\n  constructor(name, url) {\r\n    super(name, url);\r\n\r\n    /**\r\n     * @private\r\n     * @type {Image}\r\n     */\r\n    this.mImageElement = new Image();\r\n  }\r\n\r\n  /**\r\n   * @override\r\n   * @inheritDoc\r\n   *\r\n   * @return {void}\r\n   */\r\n  onLoaded() {\r\n    this.mData = new Texture(this.mImageElement);\r\n\r\n    super.onLoaded();\r\n  }\r\n\r\n  /**\r\n   * @override\r\n   * @inheritDoc\r\n   *\r\n   * @return {void}\r\n   */\r\n  load() {\r\n    this.mImageElement.src = this.mUrl;\r\n    this.mImageElement.onload = () => {\r\n      this.onLoaded();\r\n    }\r\n  }\r\n}\r\n","/**\r\n * Single JSON file asset class responsible for loading json file.\r\n *\r\n * @cat loaders\r\n * @extends Asset\r\n */\r\n\r\nclass JSONAsset extends Asset {\r\n  /**\r\n   * Creates new JSONAsset instance.\r\n   *\r\n   * @param {string} name The name of asset.\r\n   * @param {string} url  URL to the json file.\r\n   *\r\n   * @return {void}\r\n   */\r\n  constructor(name, url) {\r\n    super(name, url);\r\n\r\n    this.mimeType = 'application/json';\r\n  }\r\n\r\n  /**\r\n   * @override\r\n   * @inheritDoc\r\n   *\r\n   * @return {void}\r\n   */\r\n  onLoaded(){\r\n    this.mData = JSON.parse(/** @type {string} */ (this.mRequest.responseText) );\r\n    super.onLoaded();\r\n  }\r\n}\r\n","/**\r\n * Font file asset class responsible for loading local font files.\r\n *\r\n * Note: this class need a body to work preoperly.\r\n *\r\n * @cat loaders\r\n * @extends Asset\r\n */\r\n\r\nclass FontAsset extends Asset {\r\n  /**\r\n   * @param {string} name        The custom name of the font\r\n   * @param {string|null} url    The path to the font\r\n   * @param {boolean} local      Is this font local?\r\n   */\r\n  constructor(name, url, local) {\r\n    if (local === false)\r\n      url = 'https://fonts.googleapis.com/css?family=' + name.replace(new RegExp(' ', 'g'), '+');\r\n    \r\n    super(name, url);\r\n\r\n    /**\r\n     * @private\r\n     * @type {string}\r\n     */\r\n    this.mTestingFontName = 'Courier New';\r\n\r\n    /**\r\n     * @private\r\n     * @type {boolean}\r\n     */\r\n    this.mLocal = local;\r\n\r\n    /**\r\n     * @private\r\n     * @type {string}\r\n     */\r\n    this.mTestingString = '~ GHBDTN,.#$Mlck';\r\n\r\n    /**\r\n     * @private\r\n     * @type {number}\r\n     */\r\n    this.mLoadingTimeout = 2500;\r\n\r\n    /**\r\n     * @private\r\n     * @type {number}\r\n     */\r\n    this.mCheckDelay = 50;\r\n\r\n    /**\r\n     * @private\r\n     * @type {HTMLElement}\r\n     */\r\n    this.mTestingElement = this.__getTestingElement();\r\n\r\n    /**\r\n     * @private\r\n     * @type {HTMLElement}\r\n     */\r\n    this.mLoaderElement = this.__getLoaderElement(this.mLocal);\r\n    this.mTestingElement.style.fontFamily = this.mTestingFontName;\r\n    \r\n    /**\r\n     * @private\r\n     * @type {number}\r\n     */\r\n    this.mDefaultFontWidth = this.mTestingElement.offsetWidth;\r\n\r\n    this.mTestingElement.style.fontFamily = name + ',' + this.mTestingFontName;\r\n  }\r\n\r\n  /**\r\n   * @private\r\n   * @return {HTMLElement}\r\n   */\r\n  __getLoaderElement(local) {\r\n    let loaderElement = document.createElement(local ? 'style' : 'link');\r\n    loaderElement.type = 'text/css';\r\n    loaderElement.media = 'all';\r\n    loaderElement.rel = 'stylesheet';\r\n    loaderElement.onerror = function () {\r\n      //debugger;\r\n      // TODO: handle fail\r\n    };\r\n    document.getElementsByTagName('head')[0].appendChild(loaderElement);\r\n    return loaderElement;\r\n  }\r\n\r\n  /**\r\n   * @private\r\n   * @return {HTMLElement}\r\n   */\r\n  __getTestingElement() {\r\n    let testingElement = document.createElement('span');\r\n    testingElement.style.position = 'absolute';\r\n    testingElement.style.top = '-9999px';\r\n    testingElement.style.left = '-9999px';\r\n    testingElement.style.visibility = 'hidden';\r\n    testingElement.style.fontSize = '250px';\r\n    testingElement.innerHTML = this.mTestingString;\r\n    document.body.appendChild(testingElement);\r\n\r\n    return testingElement;\r\n  }\r\n\r\n  /**\r\n   * @override\r\n   * @return {void}\r\n   */\r\n  load() {\r\n    if (this.mLocal)\r\n      this.mLoaderElement.innerHTML += (`\\n @font-face {font-family: ${this.mName}; src: url(${this.mUrl});}`);\r\n    else\r\n      this.mLoaderElement.href = this.mUrl;\r\n\r\n    this.checkLoadingStatus();\r\n  }\r\n\r\n  /**\r\n   * @return {void}\r\n   */\r\n  checkLoadingStatus() {\r\n    if (this.mDefaultFontWidth === this.mTestingElement.offsetWidth) {\r\n      if ((this.mLoadingTimeout -= this.mCheckDelay) <= 0) {\r\n        this.onLoadingFail();\r\n        return;\r\n      }\r\n\r\n      setTimeout(this.checkLoadingStatus.bind(this), this.mCheckDelay);\r\n      return;\r\n    }\r\n    this.onLoaded();\r\n  }\r\n\r\n  onLoaded() {\r\n    var a = this.mLoaderElement;\r\n\r\n    super.onLoaded();\r\n    this.mTestingElement.parentNode.removeChild(this.mTestingElement);\r\n  }\r\n\r\n  /**\r\n   * @return {void}\r\n   */\r\n  onLoadingFail() {\r\n    console.warn(`loading ${this.name} font failed.`);\r\n    this.onLoaded(); //TODO what to do here?\r\n  }\r\n}","/**\r\n * Texture Atlas asset responsible for loading Image file and coresponding Json\r\n * file.\r\n *\r\n * @cat loaders\r\n * @extends Asset\r\n */\r\n\r\nclass AtlasTextureAsset extends Asset {\r\n  /**\r\n   * Creates new AtlasTextureAsset instance.\r\n   *\r\n   * @param {string} name     Name of the asset.\r\n   * @param {string} imageUrl Image URL.\r\n   * @param {string} dataUrl  Json URL.\r\n   */\r\n  constructor(name, imageUrl, dataUrl) {\r\n    super(name, imageUrl);\r\n\r\n    /**\r\n     * @private\r\n     * @type {Image}\r\n     */\r\n    this.mImageElement = new Image();\r\n\r\n    /**\r\n     * @private\r\n     * @type {JSONAsset}\r\n     */\r\n    this.dataAsset = new JSONAsset(name, dataUrl);\r\n    this.dataAsset.on('complete', this.onJsonLoaded, this);\r\n  }\r\n\r\n\r\n  /**\r\n   * @ignore\r\n   * @returns {void}\r\n   */\r\n  onJsonLoaded() {\r\n    this.mImageElement.src = this.mUrl;\r\n    this.mImageElement.onload = () => {\r\n      this.onLoaded();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @override\r\n   * @inheritDoc\r\n   * @return {void}\r\n   */\r\n  onLoaded() {\r\n    this.mData = new AtlasTexture(new Texture(this.mImageElement), /** @type {{meta: *, frames: *}} */ (this.dataAsset.data));\r\n\r\n    super.onLoaded();\r\n  }\r\n\r\n  /**\r\n   * @inheritDoc\r\n   * @override\r\n   *\r\n   * @return {void}\r\n   */\r\n  load() {\r\n    this.dataAsset.load();\r\n  }\r\n}\r\n","/**\r\n * Sound file asset class responsible for preloading audio files.\r\n *\r\n * @cat loaders\r\n * @extends Asset\r\n */\r\n\r\nclass SoundAsset extends Asset {\r\n  /**\r\n   * Creates SoundAsset instance.\r\n   *\r\n   * @param {string} name Sound name.\r\n   * @param {string} url  URL to load audio from.\r\n   */\r\n  constructor(name, url) {\r\n    super(name, url);\r\n\r\n    /**\r\n     * @private\r\n     * @type {Audio}\r\n     */\r\n    this.mAudioElement = new Audio();\r\n  }\r\n\r\n  /**\r\n   * @override\r\n   * @inheritDoc\r\n   *\r\n   * @return {void}\r\n   */\r\n  onLoaded() {\r\n    this.mData = this.mAudioElement;\r\n\r\n    if (Device.isMobile) {\r\n      this.__enableOnMobile();\r\n    }\r\n\r\n    super.onLoaded();\r\n  }\r\n\r\n  /**\r\n   * @override\r\n   * @inheritDoc\r\n   *\r\n   * @return {void}\r\n   */\r\n  load() {\r\n    this.mAudioElement.autoplay = false;\r\n    this.mAudioElement.src = this.mUrl;\r\n    this.mAudioElement.preload = 'auto';\r\n    this.mAudioElement.load();\r\n    this.mAudioElement.oncanplaythrough = () => {\r\n      if (!this.mData) {\r\n        this.onLoaded();\r\n      }\r\n    };\r\n  }\r\n\r\n  /**\r\n   * @private\r\n   *\r\n   * @return {void}\r\n   */\r\n  __enableOnMobile() {\r\n    let unlock = () => {\r\n      this.mAudioElement.play();\r\n      this.mAudioElement.pause();\r\n      document.removeEventListener('touchend', unlock, true);\r\n    };\r\n    document.addEventListener('touchend', unlock, true);\r\n  }\r\n}\r\n","/*\r\nTODO:\r\n  1. propper error handling\r\n  2. max parallel downloads\r\n  3. check for name dublicates\r\n  4. load progress\r\n*/\r\n\r\n/**\r\n * Reponsible for preloading assets and manages its in memory state.\r\n *\r\n * @cat loaders\r\n * @extends MessageDispatcher\r\n */\r\n\r\nclass AssetManager extends MessageDispatcher {\r\n  /**\r\n   * Creates new AssetManager instance. AssetManager exposes static property\r\n   * called 'default' and many internal classes uses default instance.\r\n   */\r\n  constructor() {\r\n    super();\r\n\r\n    /**\r\n     * @private\r\n     * @type {string}\r\n     */\r\n    this.mDefaultPath = '';\r\n\r\n    /**\r\n     * @private\r\n     * @type {number}\r\n     */\r\n    this.mTotalLoaded = 0;\r\n\r\n    /**\r\n     * @private\r\n     * @type {boolean}\r\n     */\r\n    this.mIsAllLoaded = false;\r\n\r\n    /**\r\n     * @private\r\n     * @type {number}\r\n     */\r\n    this.mLoadingProgress = 0;\r\n\r\n    /**\r\n     * @private\r\n     * @type {Array<Asset>}\r\n     */\r\n    this.mQueue = [];\r\n\r\n    /**\r\n     * @private\r\n     * @member\r\n     * @dict\r\n     */\r\n    this.mTextures = {};\r\n\r\n    /**\r\n     * @private\r\n     * @member\r\n     * @dict\r\n     */\r\n    this.mAtlases = {};\r\n\r\n    /**\r\n     * @private\r\n     * @member\r\n     * @dict\r\n     */\r\n    this.mJsons = {};\r\n\r\n    /**\r\n     * @private\r\n     * @member\r\n     * @dict\r\n     */\r\n    this.mSounds = {};\r\n\r\n    /**\r\n     * @private\r\n     * @member\r\n     * @dict\r\n     */\r\n    this.mFonts = {};\r\n  }\r\n\r\n  /**\r\n   * Adds single image to the loading queue.\r\n   *\r\n   * @param {string} name Name of the asset.\r\n   * @param {string} url  The URL of the image.\r\n   *\r\n   * @returns {void}\r\n   */\r\n  enqueueImage(name, url) {\r\n    this.mQueue.push(new TextureAsset(name, this.mDefaultPath + url));\r\n  }\r\n\r\n  /**\r\n   * Adds atlas to the loading queue.\r\n   *\r\n   * @param {string} name     Name of the asset.\r\n   * @param {string} imageUrl Atlas URL.\r\n   * @param {string} dataUrl  URL to the .json file which describes the atlas.\r\n   *\r\n   * @returns {void}\r\n   */\r\n  enqueueAtlas(name, imageUrl, dataUrl) {\r\n    this.mQueue.push(new AtlasTextureAsset(name, this.mDefaultPath + imageUrl, this.mDefaultPath + dataUrl));\r\n  }\r\n\r\n  /**\r\n   * Adds single json file to the loading queue.\r\n   *\r\n   * @param {string} name Name of the asset.\r\n   * @param {string} url  The URL of the json.\r\n   *\r\n   * @returns {void}\r\n   */\r\n  enqueueJson(name, url) {\r\n    this.mQueue.push(new JSONAsset(name, this.mDefaultPath + url));\r\n  }\r\n\r\n  /**\r\n   * Adds single sound to the loading queue.\r\n   *\r\n   * @param {string} name Name of the sound.\r\n   * @param {string} url  The URL of the sound.\r\n   *\r\n   * @returns {void}\r\n   */\r\n  enqueueSound(name, url) {\r\n    this.mQueue.push(new SoundAsset(name, this.mDefaultPath + url));\r\n  }\r\n\r\n  /*\r\n   * Adds local font to the loading queue.\r\n   *\r\n   * @param {string} name Name of the asset.\r\n   * @param {string} url  The URL to the font.\r\n   *\r\n   * @returns {void}\r\n   */\r\n  enqueueFont(name, url) {\r\n    this.mQueue.push(new FontAsset(name, this.mDefaultPath + url, true));\r\n  }\r\n\r\n  /**\r\n   * Adds Google Font to the loading queue.\r\n   *\r\n   * @param {string} name Name of the asset.\r\n   *\r\n   * @returns {void}\r\n   */\r\n  enqueueGoogleFont(name) {\r\n    this.mQueue.push(new FontAsset(name, null, false));\r\n  }\r\n\r\n  /**\r\n   * Starts preloading all enqueued assets.\r\n   * @fires complete\r\n   *\r\n   * @return {void}\r\n   */\r\n  loadQueue() {\r\n    for (let i = 0; i < this.mQueue.length; i++) {\r\n      let item = this.mQueue[i];\r\n\r\n      item.on(Message.COMPLETE, this.onAssetLoaded, this);\r\n      item.load();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @protected\r\n   * @ignore\r\n   *\r\n   * @param {Message} msg\r\n   *\r\n   * @return {void}\r\n   */\r\n  onAssetLoaded(msg) {\r\n    this.mTotalLoaded++;\r\n    this.mLoadingProgress = this.mTotalLoaded / this.mQueue.length;\r\n\r\n    let item = msg.sender;\r\n\r\n    // TODO: rework this\r\n    // TODO: check for dups\r\n    if (item.constructor === TextureAsset)\r\n      this.mTextures[item.name] = item.data;\r\n    else if (item.constructor === AtlasTextureAsset)\r\n      this.mAtlases[item.name] = item.data;\r\n    else if (item.constructor === JSONAsset)\r\n      this.mJsons[item.name] = item.data;\r\n    else if (item.constructor === SoundAsset)\r\n      this.mSounds[item.name] = item.data;\r\n    else if (item.constructor === FontAsset) {\r\n      this.mFonts[item.name] = item.data;\r\n    } else\r\n      console.error('Unable to handle asset type.', item);\r\n\r\n    this.post(Message.PROGRESS, this.mLoadingProgress);\r\n\r\n    if (this.mTotalLoaded === this.mQueue.length) {\r\n      this.mQueue.splice(0, this.mQueue.length);\r\n      this.mTotalLoaded = 0;\r\n      this.mIsAllLoaded = true;\r\n      this.post(Message.COMPLETE);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Returns Texture object by given name.\r\n   *\r\n   * @param {string} name The name of the Asset.\r\n   *\r\n   * @return {Texture|null} Returns a Texture if found or null.\r\n   */\r\n  getTexture(name) {\r\n    /** @type {Texture} */\r\n    let t = this.mTextures[name];\r\n\r\n    if (t != null)\r\n      return t;\r\n\r\n    for (let key in this.mAtlases) {\r\n      t = this.mAtlases[key].getTexture(name);\r\n      if (t != null)\r\n        return t;\r\n    }\r\n\r\n    Debug.warn('Unable to find texture', name);\r\n    return null;\r\n  }\r\n\r\n\r\n  /**\r\n   * Returns array of Texture by given name mask.\r\n   * Searches across all loaded images and atlasses.\r\n   *\r\n   * @param {string} nameMask\r\n   *\r\n   * @returns {Array<Texture>|null}\r\n   */\r\n  getTextures(nameMask) {\r\n    //if (nameMask == null)\r\n\r\n    let out = [];\r\n    let names = [];\r\n\r\n    let re = new RegExp(\"^\" + nameMask.split(\"*\").join(\".*\") + \"$\");\r\n\r\n    // collect single textures\r\n    for (let key in this.mTextures)\r\n      if (re.test(key))\r\n        names.push({ name: key, atlas: null });\r\n\r\n    // collect textures from all atlases\r\n    for (let key in this.mAtlases) {\r\n      let atlas = this.mAtlases[key];\r\n\r\n      for (let key2 in atlas.mSubTextures)\r\n        if (re.test(key2))\r\n          names.push({ name: key2, atlas: atlas });\r\n    }\r\n\r\n    AtlasTexture.naturalSort(names, 'name');\r\n\r\n    for (let i = 0; i < names.length; i++) {\r\n      let ao = names[i];\r\n\r\n      if (ao.atlas == null)\r\n        out.push(this.mTextures[ao.name]);\r\n      else\r\n        out.push(ao.atlas.mSubTextures[ao.name]);\r\n    }\r\n\r\n    if (out.length > 0)\r\n      return out;\r\n\r\n    return null;\r\n  }\r\n\r\n  /**\r\n   * Returns AtlasTexture by given name.\r\n   *\r\n   * @param {string} name The name of the Asset.\r\n   *\r\n   * @return {AtlasTexture} Returns atlas or null.\r\n   */\r\n  getAtlas(name) {\r\n    return this.mAtlases[name];\r\n  }\r\n\r\n  /**\r\n   * Returns Sound by given name.\r\n   *\r\n   * @param {string} name The name of the sound.\r\n   *\r\n   * @return {Audio} Returns sound or null.\r\n   */\r\n  getSound(name) {\r\n    return this.mSounds[name];\r\n  }\r\n\r\n  /**\r\n   * Gets/Sets default path for preloading. Usefull when url's getting too long.\r\n   * The asset path will be concatenated with defaultPath.\r\n   *\r\n   * @return {string}\r\n   */\r\n  get defaultPath() {\r\n    return this.mDefaultPath;\r\n  }\r\n\r\n  /**\r\n   * @ignore\r\n   * @param {string} value\r\n   *\r\n   * @return {void}\r\n   */\r\n  set defaultPath(value) {\r\n    this.mDefaultPath = value;\r\n  }\r\n\r\n  /**\r\n   * Returns True if all assets were loaded.\r\n   *\r\n   * @return {boolean}\r\n   */\r\n  get isAllLoaded() {\r\n    return this.mIsAllLoaded;\r\n  }\r\n}\r\n\r\n/**\r\n * Default instance. Sprite and other classes uses this instance to find textures by name.\r\n * @static\r\n * @type {AssetManager}\r\n */\r\nAssetManager.default = new AssetManager();\r\n","/**\r\n * A blend mode enum.\r\n * @cat drivers\r\n * @enum {string}\r\n */\r\n\r\nvar BlendMode = {\r\n  AUTO       : 'auto',\r\n  NORMAL     : 'source-over',\r\n  ADD        : 'lighter',\r\n  MULTIPLY   : 'multiply',\r\n  SCREEN     : 'screen',\r\n  OVERLAY    : 'overlay',\r\n  DARKEN     : 'darken',\r\n  LIGHTEN    : 'lighten',\r\n  COLOR_DODGE: 'color-dodge',\r\n  COLOR_BURN : 'color-burn',\r\n  HARD_LIGHT : 'hard-light',\r\n  SOFT_LIGHT : 'soft-light',\r\n  DIFFERENCE : 'difference',\r\n  EXCLUSION  : 'exclusion',\r\n  HUE        : 'hue',\r\n  SATURATE   : 'saturate',\r\n  COLOR      : 'color',\r\n  LUMINOSITY : 'luminosity'\r\n};\r\n","/**\r\n * Base class for custom video drivers. VideoDriver is used to render things\r\n * onto the screen.\r\n *\r\n * @cat drivers\r\n */\r\n\r\nclass VideoNullDriver {\r\n  /**\r\n   * @param  {HTMLElement} containerElement\r\n   * @param  {number} width\r\n   * @param  {number} height\r\n   */\r\n  constructor(containerElement, width, height) {\r\n    /**\r\n     * @private\r\n     * @type {string}\r\n     */\r\n    this.mGlobalBlendMode = 'auto';\r\n\r\n    /**\r\n     * @protected\r\n     * @type {HTMLElement}\r\n     */\r\n    this.mContainerElement = /**\r\n     * @private\r\n     * @type {HTMLElement} */ (containerElement\r\n    );\r\n\r\n    /**\r\n     * @private\r\n     * @type {number}\r\n     */\r\n    this.mClientWidth = width;\r\n\r\n    /**\r\n     * @private\r\n     * @type {number}\r\n     */\r\n    this.mClientHeight = height;\r\n\r\n    /**\r\n     * @private\r\n     * @type {Matrix}\r\n     */\r\n    this.mTransform = new Matrix();\r\n\r\n    /**\r\n     * @private\r\n     * @type {number}\r\n     */\r\n    this.mGlobalAlpha = 1;\r\n\r\n    /**\r\n     * @private\r\n     * @type {HTMLElement}\r\n     */\r\n    this.mMeasureElement = /** @type {HTMLElement} */ (document.createElement('span'));\r\n    this.mMeasureElement.style.position = 'absolute';\r\n    this.mContainerElement.appendChild(this.mMeasureElement);\r\n\r\n    Black.instance.viewport.on('resize', this.__onResize, this);\r\n  }\r\n\r\n\r\n  /**\r\n   * @protected\r\n   * @ignore\r\n   * @param {Message} msg\r\n   * @param {Rectangle} rect\r\n   *\r\n   * @returns {void}\r\n   */\r\n  __onResize(msg, rect) {\r\n    let w = this.mContainerElement.clientWidth;\r\n    let h = this.mContainerElement.clientHeight;\r\n\r\n    this.mClientWidth = w;\r\n    this.mClientHeight = h;\r\n  }\r\n\r\n  /**\r\n   * Initialization function.\r\n   *\r\n   * @protected\r\n   *\r\n   * @return {void}\r\n   */\r\n  start() {\r\n  }\r\n\r\n\r\n  /**\r\n   * Called before rendering anything. Usually used to clear back-buffer.\r\n   *\r\n   * @protected\r\n   *\r\n   * @returns {void}\r\n   */\r\n  beginFrame() {\r\n  }\r\n\r\n\r\n  /**\r\n   * Called after rendering is finished.\r\n   * @protected\r\n   *\r\n   * @returns {void}\r\n   */\r\n  endFrame() {\r\n  }\r\n\r\n  /**\r\n   * @ignore\r\n   * @param {HTMLElement} canvas\r\n   * @return {Texture|null}\r\n   */\r\n  getTextureFromCanvas(canvas) {\r\n    return null;\r\n  }\r\n\r\n  /**\r\n   * Sets world transformation for future use.\r\n   *\r\n   * @public\r\n   * @param {Matrix} m An transformation matrix to store.\r\n   *\r\n   * @return {void}\r\n   */\r\n  setTransform(m) {\r\n    this.mTransform = m;\r\n  }\r\n\r\n  /**\r\n   * Gets/Sets the global alpha. Used to calculate alpha relative to parent\r\n   * object.\r\n   *\r\n   * @protected\r\n   *\r\n   * @return {number}\r\n   */\r\n  get globalAlpha() {\r\n    return this.mGlobalAlpha;\r\n  }\r\n\r\n  /**\r\n   * @ignore\r\n   * @param {number} value\r\n   *\r\n   * @return {void}\r\n   */\r\n  set globalAlpha(value) {\r\n    this.mGlobalAlpha = value;\r\n  }\r\n\r\n  /**\r\n   * Gets/Sets global blending mode. Used to calculate blend mode relative to\r\n   * parent object.\r\n   *\r\n   * @return {string}\r\n   */\r\n  get globalBlendMode() {\r\n    return this.mGlobalBlendMode;\r\n  }\r\n\r\n  /**\r\n   * @ignore\r\n   * @param {string} value\r\n   *\r\n   * @return {void}\r\n   */\r\n  set globalBlendMode(value) {\r\n    this.mGlobalBlendMode = value;\r\n  }\r\n\r\n  /**\r\n   * Draws image onto the back-buffer. GlobalAlpha, BlendMode and transformation\r\n   * matrix must be set prior to calling this method.\r\n   *\r\n   * @public\r\n   *\r\n   * @param  {Sprite|Particle} object\r\n   * @param  {Texture} texture\r\n   * \r\n   */\r\n  drawImage(object, texture) {\r\n  }\r\n\r\n  /**\r\n   * Draws text onto back-buffer.\r\n   *\r\n   * @public\r\n   *\r\n   * @param {TextField} text TextField object to draw.\r\n   * @param {TextInfo} style The style information.\r\n   * @param {Rectangle} bounds Clipping bounds, text will be drawn outside this bounds.\r\n   *\r\n   * @return {void}\r\n   */\r\n  drawText(text, style, bounds) {\r\n  }\r\n\r\n\r\n  /**\r\n   * Clears back-buffer.\r\n   *\r\n   * @protected\r\n   *\r\n   * @returns {void}\r\n   */\r\n  clear() {\r\n  }\r\n\r\n  /**\r\n   * Used to save context if extists.\r\n   *\r\n   * @ignore\r\n   * @protected\r\n   * @param {GameObject|null} gameObject Used for internal binding.\r\n   *\r\n   * @return {void}\r\n   */\r\n  save(gameObject) {\r\n  }\r\n\r\n  /**\r\n   * Used to restore context if extists.\r\n   *\r\n   * @protected\r\n   * @ignore\r\n   * @returns {type}\r\n   */\r\n  restore() {\r\n  }\r\n\r\n\r\n  /**\r\n   * Convers number color to hex string.\r\n   *\r\n   * @param {number} color The color to convert.\r\n   *\r\n   * @returns {string} The resuling hex string.\r\n   */\r\n  hexColorToString(color) {\r\n    let parsedColor = color.toString(16);\r\n    return '#000000'.substring(0, 7 - parsedColor.length) + parsedColor;\r\n  }\r\n\r\n  /**\r\n   * Measures text with a given style.\r\n   *\r\n   * @param {TextField} textField    Text to measure.\r\n   * @param {TextInfo} style Text style to apply onto text.\r\n   * @param {Rectangle} bounds.\r\n   *\r\n   * @return {Rectangle} Local bounds.\r\n   */\r\n  measureText(textField, style, bounds) {\r\n  }\r\n}\r\n","/**\r\n * An video driver that draw everything into DOM Canvas element.\r\n *\r\n * @cat drivers\r\n * @extends VideoNullDriver\r\n */\r\n\r\nclass CanvasDriver extends VideoNullDriver {\r\n  /**\r\n   * @param  {HTMLElement} containerElement The DOM element to draw into.\r\n   * @param  {number} width                 The width of the viewport.\r\n   * @param  {number} height                The height of the viewport.\r\n   */\r\n  constructor(containerElement, width, height) {\r\n    super(containerElement, width, height);\r\n\r\n    /**\r\n     * @private\r\n     * @type {CanvasRenderingContext2D|null}\r\n     */\r\n    this.mCtx = null;\r\n\r\n    this.mGlobalAlpha = 1;\r\n    this.mGlobalBlendMode = BlendMode.NORMAL;\r\n    this.mCurrentObject = null;\r\n    this.mLetterSpacing = 0;\r\n\r\n    this.__createCanvas();\r\n  }\r\n\r\n  /**\r\n   * @private\r\n   * @return {void}\r\n   */\r\n  __createCanvas() {\r\n    let cvs = /** @type {HTMLCanvasElement} */ (document.createElement('canvas'));\r\n    cvs.id = 'canvas';\r\n    cvs.style.position = 'absolute';\r\n    this.mContainerElement.appendChild(cvs);\r\n\r\n    this.mCtx = /** @type {CanvasRenderingContext2D} */ (cvs.getContext('2d'));\r\n    this.mCtx.canvas.width = this.mClientWidth;\r\n    this.mCtx.canvas.height = this.mClientHeight;\r\n  }\r\n\r\n\r\n  /**\r\n   * @private\r\n   * @param {Message} msg\r\n   * @param {Rectangle} rect\r\n   *\r\n   * @returns {void}\r\n   */\r\n  __onResize(msg, rect) {\r\n    super.__onResize(msg, rect);\r\n\r\n    this.mCtx.canvas.width = this.mClientWidth;\r\n    this.mCtx.canvas.height = this.mClientHeight;\r\n  }\r\n\r\n  /**\r\n   * @ignore\r\n   * @param {Matrix} m\r\n   *\r\n   * @return {void}\r\n   */\r\n  setTransform(m) {\r\n    super.setTransform(m);\r\n\r\n    let v = m.value;\r\n    this.mCtx.setTransform(v[0], v[1], v[2], v[3], v[4], v[5]);\r\n  }\r\n\r\n  /**\r\n   * @param {number} value\r\n   *\r\n   * @return {void}\r\n   */\r\n  set globalAlpha(value) {\r\n    if (value == this.mGlobalAlpha)\r\n      return;\r\n\r\n    this.mGlobalAlpha = value;\r\n    this.mCtx.globalAlpha = value;\r\n  }\r\n\r\n  /**\r\n   * @inheritDoc\r\n   * @override\r\n   *\r\n   * @param {string} blendMode\r\n   *\r\n   * @return {void}\r\n   */\r\n  set globalBlendMode(blendMode) {\r\n    // if (blendMode === BlendMode.AUTO)\r\n    //   return;\r\n\r\n    if (this.mGlobalBlendMode === blendMode)\r\n      return;\r\n\r\n    // small performance win\r\n    // if (this.mCtx.globalCompositeOperation === blendMode)\r\n    //   return;\r\n\r\n    this.mGlobalBlendMode = blendMode;\r\n    this.mCtx.globalCompositeOperation = blendMode;\r\n  }\r\n\r\n  /**\r\n   * drawImage\r\n   *\r\n   * @inheritDoc\r\n   * @override\r\n   *\r\n   * @param {Sprite|Particle} object\r\n   * @param {Texture} texture\r\n   *\r\n   * @return {void}\r\n   */\r\n  drawImage(object, texture) {\r\n    let w = texture.width;\r\n    let h = texture.height;\r\n    let ox = texture.untrimmedRect.x;\r\n    let oy = texture.untrimmedRect.y;\r\n\r\n    this.mCtx.drawImage(texture.native, texture.region.x, texture.region.y, w, h, ox, oy, w, h);\r\n  }\r\n  \r\n  /**\r\n   * Measures text with a given style.\r\n   *\r\n   * @inheritDoc\r\n   * @override\r\n   * \r\n   * @param {TextField} textField    Text to measure.\r\n   * @param {TextInfo} style Text style to apply onto text.\r\n   * @param {Rectangle} bounds.\r\n   *\r\n   * @return {Rectangle} A Vector with width and height of the text bounds.\r\n   */\r\n  measureText(textField, style, bounds) {\r\n    let lines = textField.lines;\r\n    let widths = textField.lineWidths;\r\n    let lineHeight = textField.lineHeight;\r\n    let text = textField.text;\r\n    let multiLine = textField.multiLine;\r\n    let strokeThickness = style.strokeThickness;\r\n    let ctx = this.mCtx;\r\n    \r\n    if (this.mLetterSpacing !== textField.letterSpacing) {\r\n      this.mLetterSpacing = textField.letterSpacing;\r\n      \r\n      let canvas = ctx.canvas;\r\n      canvas.style.letterSpacing = `${textField.letterSpacing}px`;\r\n      // ctx = this.mCtx = canvas.getContext(`2d`);\r\n    }\r\n    \r\n    ctx.font = `${style.style} ${style.weight} ${style.size}px \"${style.name}\"`;\r\n    ctx.textBaseline = `top`;\r\n    \r\n    lines.length = 0;\r\n    widths.length = 0;\r\n    multiLine ? lines.push(...text.split(`\\n`)) : lines.push(text);\r\n\r\n    for (let i = 0, l = lines.length; i < l; i++) {\r\n      widths[i] = ctx.measureText(lines[i]).width + strokeThickness;\r\n    }\r\n    \r\n    if (!textField.autoSize) {\r\n      return bounds.set(0, 0, textField.fieldWidth, textField.fieldHeight);\r\n    }\r\n    \r\n    return bounds.set(0, 0, Math.max(...widths), lines.length * lineHeight * (style.size + strokeThickness));\r\n  }\r\n\r\n  /**\r\n   * drawText\r\n   *\r\n   * @inheritDoc\r\n   * @override\r\n   *\r\n   * @param {TextField} textField\r\n   * @param {TextInfo} style\r\n   * @param {Rectangle} bounds\r\n   *\r\n   * @return {void}\r\n   */\r\n  drawText(textField, style, bounds) {\r\n    let lines = textField.lines;\r\n    let widths = textField.lineWidths;\r\n    let lineOffset = textField.lineHeight * style.size;\r\n    let strokeThickness = style.strokeThickness;\r\n    let align = style.align;\r\n    let maxWidth = bounds.width;\r\n    let ctx = this.mCtx;\r\n\r\n    if (this.mLetterSpacing !== textField.letterSpacing) {\r\n      this.mLetterSpacing = textField.letterSpacing;\r\n\r\n      let canvas = ctx.canvas;\r\n      canvas.style.letterSpacing = `${textField.letterSpacing}px`;\r\n      // ctx = this.mCtx = canvas.getContext(`2d`);\r\n    }\r\n\r\n    ctx.font = `${style.style} ${style.weight} ${style.size}px \"${style.name}\"`;\r\n    ctx.fillStyle = this.hexColorToString(style.color);\r\n    ctx.textBaseline = `bottom`;\r\n\r\n    if (strokeThickness !== 0) {\r\n      ctx.lineJoin = `round`;\r\n      ctx.miterLimit = 2;\r\n      ctx.lineWidth = strokeThickness;\r\n      ctx.strokeStyle = this.hexColorToString(style.strokeColor);\r\n    }\r\n\r\n    if (!textField.autoSize) {\r\n      ctx.rect(0, 0, maxWidth, bounds.height);\r\n      ctx.clip();\r\n    }\r\n\r\n    // ctx.fillRect(0, 0, maxWidth, bounds.height);\r\n\r\n    for (let i = 0, l = lines.length; i < l; i++) {\r\n      let width = widths[i];\r\n      let y = bounds.height - strokeThickness / 2 - lineOffset * (l - i - 1);\r\n      let x = strokeThickness / 2;\r\n\r\n      if (align === `center`) {\r\n        x += maxWidth / 2 - width / 2;\r\n      } else if (align === `right`) {\r\n        x += maxWidth - width;\r\n      }\r\n\r\n      strokeThickness !== 0 && ctx.strokeText(lines[i], x, y);\r\n      ctx.fillText(lines[i], x, y);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * clear\r\n   * @inheritDoc\r\n   * @override\r\n   *\r\n   * @return {void}\r\n   */\r\n  clear() {\r\n    this.mCtx.setTransform(1, 0, 0, 1, 0, 0);\r\n    this.mCtx.clearRect(0, 0, this.mCtx.canvas.width, this.mCtx.canvas.height);\r\n  }\r\n\r\n  /**\r\n   * @inheritDoc\r\n   * @override\r\n   *\r\n   * @return {void}\r\n   */\r\n  beginFrame() {\r\n    super.beginFrame();\r\n\r\n    this.clear();\r\n    //this.mCtx.save();\r\n\r\n    this.mCtx.globalCompositeOperation = this.mGlobalBlendMode;\r\n  }\r\n\r\n  /**\r\n   * @inheritDoc\r\n   * @override\r\n   *\r\n   * @return {void}\r\n   */\r\n  endFrame() {\r\n    super.endFrame();\r\n\r\n    //this.mCtx.restore();\r\n  }\r\n\r\n  /**\r\n   * @ignore\r\n   * @param {HTMLElement} canvas\r\n   *\r\n   * @return {Texture|null}\r\n   */\r\n  getTextureFromCanvas(canvas) {\r\n    return new Texture(canvas);\r\n  }\r\n\r\n  /**\r\n   * save\r\n   *\r\n   * @override\r\n   * @param {GameObject|null} gameObject Used for internal binding.\r\n   *\r\n   * @return {void}\r\n   */\r\n  save(gameObject) {\r\n    this.mCtx.save();\r\n    this.mCurrentObject = gameObject;\r\n  }\r\n\r\n  /**\r\n   * restore\r\n   *\r\n   * @return {void}\r\n   */\r\n  restore() {\r\n    this.mCtx.restore();\r\n  }\r\n\r\n  clip(rect) {\r\n    //this.mCtx.beginPath();\r\n    console.log('123');\r\n    \r\n    this.mCtx.rect(rect.x, rect.y, rect.width, rect.height);\r\n    this.mCtx.clip();\r\n\r\n    //this.mCtx.endPath();\r\n  }\r\n}\r\n","/**\r\n * An video driver that draw everything into DOM elements itself.\r\n *\r\n * @cat drivers\r\n * @extends VideoNullDriver\r\n */\r\n\r\nclass DOMDriver extends VideoNullDriver {\r\n  /**\r\n   * @param  {HTMLElement} containerElement The DOM element to draw into.\r\n   * @param  {number} width                 The width of the viewport.\r\n   * @param  {number} height                The height of the viewport.\r\n   */\r\n  constructor(containerElement, width, height) {\r\n    super(containerElement, width, height);\r\n\r\n    /** @type {number} */\r\n    this.mGlobalAlpha = 1;\r\n\r\n    /** @type {Array<Element>} */\r\n    this.mCache = [];\r\n\r\n    /** @type {number} */\r\n    this.mCounter = 0;\r\n\r\n    /** @type {boolean} */\r\n    this.mPixelated = true;\r\n\r\n    /** @type {GameObject|null} */\r\n    this.mCurrentObject = null;\r\n    this.__initCSS();\r\n\r\n    this.measureEl = document.createElement(`div`);\r\n    this.measureEl.style.position = `absolute`;\r\n    this.measureEl.style.visibility = `hidden`;\r\n    this.measureEl.style.height = `auto`;\r\n    this.measureEl.style.width = `auto`;\r\n    this.measureEl.style.whiteSpace = `nowrap`;\r\n    document.getElementsByTagName(`body`)[0].appendChild(this.measureEl);\r\n  }\r\n\r\n  /**\r\n   * @inheritDoc\r\n   * @override\r\n   * @param {GameObject|null} gameObject Used for internal binding.\r\n   *\r\n   * @return {void} Description\r\n   */\r\n  save(gameObject) {\r\n    this.mCurrentObject = gameObject;\r\n  }\r\n\r\n  /**\r\n   * @private\r\n   *\r\n   * @return {void}  description\r\n   */\r\n  __initCSS() {\r\n    let imgRendering = 'image-rendering:optimizeSpeed; image-rendering:optimize-contrast; image-rendering:crisp-edges; image-rendering:pixelated';\r\n\r\n    let sSprite = document.createElement('style');\r\n    sSprite.type = 'text/css';\r\n    sSprite.innerHTML = '.sprite { position: absolute; background-repeat: no-repeat; cursor: default !important; -webkit-transform-origin: 0px 0px;}';\r\n    document.getElementsByTagName('head')[0].appendChild(sSprite);\r\n\r\n    let sSpritePixelated = document.createElement('style');\r\n    sSpritePixelated.type = 'text/css';\r\n    sSpritePixelated.innerHTML = '.sprite-p { position: absolute; background-repeat: no-repeat; cursor: default !important; -webkit-transform-origin: 0px 0px; ' + imgRendering + '}';\r\n    document.getElementsByTagName('head')[0].appendChild(sSpritePixelated);\r\n\r\n    let sText = document.createElement('style');\r\n    sText.type = 'text/css';\r\n    sText.innerHTML = '.text { position: absolute; white-space: pre; overflow: hidden; cursor: default !important; -webkit-transform-origin: 0px 0px;}';\r\n    document.getElementsByTagName('head')[0].appendChild(sText);\r\n\r\n    let sViewport = document.createElement('style');\r\n    sViewport.type = 'text/css';\r\n    sViewport.innerHTML = '.viewport { width: 100%; height: 100%; position: relative; overflow: hidden; cursor: default; }';\r\n    document.getElementsByTagName('head')[0].appendChild(sViewport);\r\n\r\n    this.mContainerElement.className = 'viewport';\r\n  }\r\n\r\n  /**\r\n   * @inheritDoc\r\n   * @override\r\n   *\r\n   * @return {void}  description\r\n   */\r\n  beginFrame() {\r\n    this.mCounter = 0;\r\n  }\r\n\r\n  /**\r\n   * @inheritDoc\r\n   * @override\r\n   *\r\n   * @return {void}  description\r\n   */\r\n  endFrame() {\r\n    if (this.mCounter === this.mCache.length)\r\n      return;\r\n\r\n    //TODO: cleanup unused divs\r\n    //TODO: remove them instead of hiding\r\n    for (let i = this.mCounter; i < this.mCache.length; i++) {\r\n      let el = this.mCache[i];\r\n\r\n      el.parentNode.removeChild(el);\r\n    }\r\n\r\n    this.mCache.splice(this.mCounter);\r\n  }\r\n\r\n  /**\r\n   * @ignore\r\n   * @param {HTMLElement} canvas\r\n   *\r\n   * @return {Texture|null}\r\n   */\r\n  getTextureFromCanvas(canvas) {\r\n    return Texture.fromCanvasAsImage(canvas);\r\n  }\r\n\r\n  /**\r\n   * @override\r\n   * @inheritDoc\r\n   *\r\n   * @param  {Sprite|Particle} object\r\n   * @param  {Texture} texture\r\n   *\r\n   * @return {void}\r\n   */\r\n  drawImage(object, texture) {\r\n    /** @type {Matrix|null} */\r\n    let oldTransform = this.mTransform.clone();\r\n    let uw = texture.untrimmedRect.x;\r\n    let uh = texture.untrimmedRect.y;\r\n\r\n    //this.mTransform.translate(px, py);\r\n\r\n    if (texture.untrimmedRect.x !== 0 || texture.untrimmedRect.y !== 0) {\r\n      Matrix.__cache.set(1, 0, 0, 1, texture.untrimmedRect.x, texture.untrimmedRect.y);\r\n      this.mTransform = this.mTransform.clone().append(Matrix.__cache);\r\n      //this.mTransform = this.mTransform.clone().translate(texture.untrimmedRect.x, texture.untrimmedRect.y);\r\n    }\r\n\r\n    let el = this.__popElement(this.mPixelated ? 'sprite-p' : 'sprite');\r\n    this.__updateElementCommon(el);\r\n    this.__updateImageElement(el, texture);\r\n\r\n    this.mTransform = oldTransform.clone();\r\n  }\r\n\r\n  /**\r\n   * Measures text with a given style.\r\n   *\r\n   * @inheritDoc\r\n   * @override\r\n   *\r\n   * @param {TextField} textField    Text to measure.\r\n   * @param {TextInfo} style Text style to apply onto text.\r\n   * @param {Rectangle} bounds.\r\n   *\r\n   * @return {Rectangle} A Vector with width and height of the text bounds.\r\n   */\r\n  measureText(textField, style, bounds) {\r\n    let el = this.measureEl;\r\n\r\n    textField.lines = textField.multiLine ? textField.text : textField.text.replace(/\\n/mg, ` `);\r\n\r\n    el.style.whiteSpace = 'pre';\r\n    el.style.fontSize = style.size + 'px';\r\n    el.style.fontFamily = style.name;\r\n    el.style.fontStyle = style.style;\r\n    el.style.fontWeight = style.weight;\r\n    el.style.lineHeight = `${textField.lineHeight}`;\r\n    el.style.letterSpacing = `${textField.letterSpacing}px`;\r\n    el.innerHTML = textField.lines;\r\n\r\n    let widths = textField.lineWidths;\r\n    widths.length = 0;\r\n    widths[0] = el.offsetWidth + style.strokeThickness;\r\n\r\n    if (!textField.autoSize) {\r\n      bounds.set(0, 0, textField.fieldWidth, textField.fieldHeight);\r\n    } else {\r\n      bounds.set(0, 0,\r\n        el.clientWidth + 1 + style.strokeThickness,\r\n        el.clientHeight + 1 + style.strokeThickness);\r\n    }\r\n\r\n    el.innerHTML = ``;\r\n\r\n    return bounds;\r\n  }\r\n\r\n  /**\r\n   * @inheritDoc\r\n   * @override\r\n   *\r\n   * @param {TextField} textField\r\n   * @param {TextInfo} style\r\n   * @param {Rectangle} bounds\r\n   *\r\n   * @return {void}\r\n   */\r\n  drawText(textField, style, bounds) {\r\n    let el = this.__popElement('text');\r\n\r\n    // TODO: check this type. review the code.\r\n    this.__updateTextElement(\r\n      /** @type {HTMLElement} */ (el), textField, style, bounds);\r\n  }\r\n\r\n  /**\r\n   * @private\r\n   * @param {string} className\r\n   *\r\n   * @return {Element}\r\n   */\r\n  __popElement(className) {\r\n    this.mCounter++;\r\n\r\n    if (this.mCounter <= this.mCache.length)\r\n      return this.mCache[this.mCounter - 1];\r\n\r\n    let el = document.createElement('div');\r\n    el.className = className;\r\n    this.mContainerElement.appendChild(el);\r\n\r\n    this.mCache.push(el);\r\n    return (el);\r\n  }\r\n\r\n  /**\r\n   * @private\r\n   * @param {Element} el\r\n   *\r\n   * @return {void}\r\n   */\r\n  __updateElementCommon(el) {\r\n    let v = this.mTransform.value;\r\n\r\n    // TODO: slow, rework\r\n    // NOTE: toFixed(0) is faster then toFixed(6)\r\n    let transform = `matrix(${v[0].toFixed(6)}, ${v[1].toFixed(6)}, ${v[2].toFixed(6)}, ${v[3].toFixed(6)}, ${v[4].toFixed(6)}, ${v[5].toFixed(6)})`;\r\n    //let transform = `matrix(${v[0]}, ${v[1]}, ${v[2]}, ${v[3]}, ${v[4]}, ${v[5]})`;\r\n\r\n    //console.log(el.style.transform, transform);\r\n    if (el.style.webkitTransform !== transform)\r\n      el.style.webkitTransform = transform;\r\n\r\n    //el.style.transform = transform;\r\n\r\n    //if (el.style.opacity != this.mGlobalAlpha)\r\n    el.style.opacity = this.mGlobalAlpha; // would be faster to not compare string and int\r\n\r\n    //if (el.style.backgroundImage !== '') {\r\n    //el.style.backgroundImage = '';\r\n    //console.log('reset img');\r\n    //}\r\n\r\n    // if (el.style.width !== null)\r\n    //   el.style.width = null;\r\n    //\r\n    // if (el.style.height !== null)\r\n    //   el.style.height = null;\r\n\r\n    // if (el.style.display === 'none')\r\n    //   el.style.display = 'block';\r\n  }\r\n\r\n  /**\r\n   * @private\r\n   * @param  {Element} el      description\r\n   * @param  {Texture} texture description\r\n   * @return {void}         description\r\n   */\r\n  __updateImageElement(el, texture) {\r\n    if (texture) {\r\n      let url = 'url(' + texture.native.src + ')';\r\n\r\n      if (el.style.backgroundImage !== url)\r\n        el.style.backgroundImage = url;\r\n\r\n      if (texture.isSubTexture) {\r\n        let vBackgroundPosition = `${-texture.region.x}px ${-texture.region.y}px`;\r\n\r\n        if (el.style.backgroundPosition !== vBackgroundPosition)\r\n          el.style.backgroundPosition = vBackgroundPosition;\r\n      }\r\n    } else {\r\n      el.style.backgroundImage = 'none';\r\n    }\r\n\r\n    if (el.style.width != texture.width + 'px')\r\n      el.style.width = texture.width + 'px';\r\n\r\n    if (el.style.height != texture.height + 'px')\r\n      el.style.height = texture.height + 'px';\r\n\r\n    if (el.innerHTML !== '')\r\n      el.innerHTML = '';\r\n  }\r\n\r\n  /**\r\n   * @private\r\n   * @param {HTMLElement} el\r\n   * @param {TextField} textField\r\n   * @param {TextInfo} style\r\n   * @param {Rectangle} bounds\r\n   *\r\n   * @return {void}\r\n   */\r\n  __updateTextElement(el, textField, style, bounds) {\r\n    let width = textField.lineWidths[0];\r\n    let text = textField.lines;\r\n    let align = style.align;\r\n    let x = 0;\r\n\r\n    if (align === `center`) {\r\n      x -= bounds.width / 2 - width / 2;\r\n    } else if (align === `right`) {\r\n      x -= bounds.width - width;\r\n    }\r\n\r\n    let v = this.mTransform.value;\r\n    el.style.webkitTransform = `matrix(${v[0]}, ${v[1]}, ${v[2]}, ${v[3]}, ${v[4] - x}, ${v[5]})`;\r\n    el.style.opacity = this.mGlobalAlpha;\r\n\r\n    if (!textField.autoSize) {\r\n      // top right bottom left. There is no width and height\r\n      el.style.clip = `rect(0px ${bounds.width + x}px ${bounds.height}px ${x}px)`;\r\n    }\r\n\r\n    el.style.lineHeight = `${textField.lineHeight}`;\r\n    el.style.fontSize = style.size + 'px';\r\n    el.style.letterSpacing = `${textField.letterSpacing}px`;\r\n    el.innerHTML = text;\r\n\r\n    if (el.style.width !== bounds.width + x + 'px') {\r\n      el.style.width = bounds.width + x + 'px';\r\n    }\r\n\r\n    if (el.style.height !== bounds.height + 'px') {\r\n      el.style.height = bounds.height + 'px';\r\n    }\r\n\r\n    if (el.style.fontFamily !== style.name) {\r\n      el.style.fontFamily = style.name;\r\n    }\r\n\r\n    let color = this.hexColorToString(style.color);\r\n\r\n    if (el.style.color != color) {\r\n      el.style.color = color;\r\n    }\r\n\r\n    if (el.style.fontStyle !== style.style)\r\n      el.style.fontStyle = style.style;\r\n\r\n    if (el.style.fontWeight != style.weight) {\r\n      el.style.fontWeight = style.weight;\r\n    }\r\n\r\n    if (el.style.textAlign !== style.align) {\r\n      el.style.textAlign = style.align;\r\n    }\r\n\r\n    if (el.style.backgroundImage !== 'none') {\r\n      el.style.backgroundImage = 'none';\r\n    }\r\n\r\n    if (style.strokeThickness > 0) {\r\n      let strokeColor = this.hexColorToString(style.strokeColor);\r\n\r\n      if (el.style.webkitTextStrokeColor != strokeColor) {\r\n        el.style.webkitTextStrokeColor = strokeColor;\r\n      }\r\n\r\n      if (el.style.webkitTextStrokeWidth != style.strokeThickness + 'px') {\r\n        el.style.webkitTextStrokeWidth = style.strokeThickness + 'px';\r\n      }\r\n    }\r\n  }\r\n}\r\n","/**\r\n * An video driver that draw everything into DOM Canvas element.\r\n *\r\n * @cat drivers\r\n * @extends VideoNullDriver\r\n */\r\n\r\nclass WebGLDriver extends VideoNullDriver {\r\n  /**\r\n   * @param  {HTMLElement} containerElement description\r\n   * @param  {number} width            description\r\n   * @param  {number} height           description\r\n   */\r\n  constructor(containerElement, width, height) {\r\n    super(containerElement, width, height);\r\n\r\n    console.log(`WebGL`);\r\n\r\n    const fn = () => {\r\n    };\r\n    this.mEmptyPlugin = {\r\n      stop: fn, start: fn, drawImage: fn, drawText: fn, onResize: fn, setTransform: fn,\r\n      set blendMode(v) {\r\n      },\r\n      set globalAlpha(v) {\r\n      }\r\n    };\r\n    this.mActivePlugin = this.mEmptyPlugin;\r\n    this.mActiveArrayBuffer = null;\r\n    this.mActiveElementBuffer = null;\r\n    this.blend = null;\r\n    this.boundTextures = [];\r\n\r\n    this.__createCanvas();\r\n\r\n    const gl = this.gl;\r\n    gl.enable(gl.BLEND);\r\n\r\n    this.MAX_TEXTURE_IMAGE_UNITS = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);\r\n    this.glTextures = new WebGLTextures(this);\r\n    this.blender = new WebGLBlendMode(gl);\r\n\r\n    this.mPlugins = {\r\n      [WebGLTexPlugin.name]      : new WebGLTexPlugin(this),\r\n      [WebGLParticlesPlugin.name]: new WebGLParticlesPlugin(this)\r\n    };\r\n  }\r\n\r\n  /**\r\n   * __createCanvas\r\n   *\r\n   * @return {void}\r\n   */\r\n  __createCanvas() {\r\n    let canvas = /** @type {HTMLCanvasElement} */ (document.createElement(`canvas`));\r\n    canvas.id = `canvas`;\r\n    this.mContainerElement.appendChild(canvas);\r\n\r\n    const config = {\r\n      antialias         : true, // default true\r\n      alpha             : false,\r\n      premultipliedAlpha: false\r\n    };\r\n\r\n    this.gl = canvas.getContext(`webgl`, config) || canvas.getContext(`webgl-experimental`, config);\r\n    this.__onResize(`init`, new Rectangle(0, 0, this.mClientWidth, this.mClientHeight))\r\n  }\r\n\r\n  __onResize(msg, rect) {\r\n    super.__onResize(msg, rect);\r\n\r\n    const gl = this.gl;\r\n    const canvas = gl.canvas;\r\n\r\n    const desiredWidthInCSSPixels = rect.width;\r\n    const desiredHeightInCSSPixels = rect.height;\r\n\r\n    // set the display size of the canvas.\r\n    canvas.style.width = desiredWidthInCSSPixels + `px`;\r\n    canvas.style.height = desiredHeightInCSSPixels + `px`;\r\n\r\n    // set the size of the drawingBuffer\r\n    var devicePixelRatio = window.devicePixelRatio || 1;\r\n    canvas.width = desiredWidthInCSSPixels * devicePixelRatio;\r\n    canvas.height = desiredHeightInCSSPixels * devicePixelRatio;\r\n    gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);\r\n\r\n    this.mActivePlugin.onResize(msg, rect);\r\n  }\r\n\r\n  drawImage(object, texture) {\r\n    let plugin = this.mPlugins[object.pluginName];\r\n\r\n    if (plugin !== this.mActivePlugin) {\r\n      this.mActivePlugin.stop();\r\n      this.mActivePlugin = plugin;\r\n      plugin.start();\r\n    }\r\n\r\n    plugin.globalAlpha = this.mGlobalAlpha;\r\n    plugin.globalBlendMode = this.mGlobalBlendMode;\r\n    plugin.setTransform(this.mTransform);\r\n    plugin.drawImage(object, texture);\r\n  }\r\n\r\n  drawText(textField, style, bounds) {\r\n    let plugin = this.mPlugins[textField.pluginName];\r\n\r\n    if (plugin !== this.mActivePlugin) {\r\n      this.mActivePlugin.stop();\r\n      this.mActivePlugin = plugin;\r\n      plugin.start();\r\n    }\r\n\r\n    plugin.globalAlpha = this.mGlobalAlpha;\r\n    plugin.globalBlendMode = this.mGlobalBlendMode;\r\n    plugin.setTransform(this.mTransform);\r\n    plugin.drawText(textField, style, bounds);\r\n  }\r\n\r\n  bindTexture(texture, slot) {\r\n    const gl = this.gl;\r\n    gl.activeTexture(gl.TEXTURE0 + slot);\r\n    // gl.bindTexture(gl.TEXTURE_2D, this.glTextures[slot]);\r\n    gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, Number(texture.premultiplyAlpha));\r\n    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, texture.native);\r\n\r\n    // only sprite plugin usable\r\n    // _vSlotWebGL can be -1 even texture is bound\r\n    const boundTextures = this.boundTextures;\r\n    boundTextures[slot]._vSlotWebGL = -1;\r\n    boundTextures[slot] = texture;\r\n    texture._vSlotWebGL = slot;\r\n  }\r\n\r\n  bindArrayBuffer(buffer) {\r\n    if (buffer === this.mActiveArrayBuffer) return;\r\n\r\n    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, buffer);\r\n    this.mActiveArrayBuffer = buffer;\r\n  }\r\n\r\n  bindElementBuffer(buffer) {\r\n    if (buffer === this.mActiveElementBuffer) return;\r\n\r\n    this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, buffer);\r\n    this.mActiveElementBuffer = buffer;\r\n  }\r\n\r\n  setBlend(blend) {\r\n    const blendFunc = this.blender[blend];\r\n    if (!blendFunc) debugger\r\n    this.gl.blendFunc(blendFunc.src, blendFunc.dst);\r\n    this.blend = blend;\r\n  }\r\n\r\n  endFrame() {\r\n    this.mActivePlugin.stop();\r\n  }\r\n\r\n  measureText(textField, style, bounds) {\r\n    let lines = textField.lines;\r\n    let widths = textField.lineWidths;\r\n    let lineHeight = textField.lineHeight;\r\n    let text = textField.text;\r\n    let multiLine = textField.multiLine;\r\n    let strokeThickness = style.strokeThickness;\r\n    let ctx = textField.context;\r\n    let canvas;\r\n\r\n    if (!ctx) {\r\n      canvas = document.createElement(`canvas`);\r\n      ctx = textField.context = canvas.getContext(`2d`);\r\n      ctx.mLetterSpacing = 0;\r\n    } else {\r\n      canvas = ctx.canvas;\r\n    }\r\n\r\n    if (ctx.mLetterSpacing !== textField.letterSpacing) {\r\n      ctx.mLetterSpacing = textField.letterSpacing;\r\n\r\n      let canvas = ctx.canvas;\r\n      document.getElementsByTagName(`body`)[0].appendChild(canvas);\r\n      canvas.style.letterSpacing = `${textField.letterSpacing}px`;\r\n      canvas.style.visibility = `hidden`; // todo\r\n      // canvas.style.display = `none`;  this doesn't work\r\n      // ctx = textField.context = canvas.getContext(`2d`);\r\n    }\r\n\r\n    ctx.font = `${style.style} ${style.weight} ${style.size}px \"${style.name}\"`;\r\n    ctx.textBaseline = `bottom`;\r\n\r\n    lines.length = 0;\r\n    widths.length = 0;\r\n    multiLine ? lines.push(...text.split(`\\n`)) : lines.push(text);\r\n\r\n    for (let i = 0, l = lines.length; i < l; i++) {\r\n      widths[i] = ctx.measureText(lines[i]).width + strokeThickness;\r\n    }\r\n\r\n    if (!textField.autoSize) {\r\n      bounds.set(0, 0, textField.fieldWidth, textField.fieldHeight);\r\n    } else {\r\n      bounds.set(0, 0, Math.max(...widths), lines.length * lineHeight * (style.size + strokeThickness));\r\n    }\r\n    \r\n    ctx.clearRect(0, 0, canvas.width, canvas.height);\r\n    canvas.width = canvas.naturalWidth = bounds.width;\r\n    canvas.height = canvas.naturalHeight = bounds.height;\r\n    textField.mTexture = new Texture(canvas); // todo cache\r\n    textField.mTexture.premultiplyAlpha = true;\r\n    \r\n    return bounds;\r\n  }\r\n}\r\n","\r\nconst WebGLConstants = {\r\n  FLOAT                        : 0x1406,\r\n  FLOAT_VEC2                   : 0x8B50,\r\n  FLOAT_VEC3                   : 0x8B51,\r\n  FLOAT_VEC4                   : 0x8B52,\r\n  INT                          : 0x1404,\r\n  INT_VEC2                     : 0x8B53,\r\n  INT_VEC3                     : 0x8B54,\r\n  INT_VEC4                     : 0x8B55,\r\n  BOOL                         : 0x8B56,\r\n  BOOL_VEC2                    : 0x8B57,\r\n  BOOL_VEC3                    : 0x8B58,\r\n  BOOL_VEC4                    : 0x8B59,\r\n  FLOAT_MAT2                   : 0x8B5A,\r\n  FLOAT_MAT3                   : 0x8B5B,\r\n  FLOAT_MAT4                   : 0x8B5C,\r\n  SAMPLER_2D                   : 0x8B5E,\r\n  SAMPLER_CUBE                 : 0x8B60,\r\n  SAMPLER_3D                   : 0x8B5F,\r\n  SAMPLER_2D_SHADOW            : 0x8B62,\r\n  FLOAT_MAT2x3                 : 0x8B65,\r\n  FLOAT_MAT2x4                 : 0x8B66,\r\n  FLOAT_MAT3x2                 : 0x8B67,\r\n  FLOAT_MAT3x4                 : 0x8B68,\r\n  FLOAT_MAT4x2                 : 0x8B69,\r\n  FLOAT_MAT4x3                 : 0x8B6A,\r\n  SAMPLER_2D_ARRAY             : 0x8DC1,\r\n  SAMPLER_2D_ARRAY_SHADOW      : 0x8DC4,\r\n  SAMPLER_CUBE_SHADOW          : 0x8DC5,\r\n  UNSIGNED_INT                 : 0x1405,\r\n  UNSIGNED_INT_VEC2            : 0x8DC6,\r\n  UNSIGNED_INT_VEC3            : 0x8DC7,\r\n  UNSIGNED_INT_VEC4            : 0x8DC8,\r\n  INT_SAMPLER_2D               : 0x8DCA,\r\n  INT_SAMPLER_3D               : 0x8DCB,\r\n  INT_SAMPLER_CUBE             : 0x8DCC,\r\n  INT_SAMPLER_2D_ARRAY         : 0x8DCF,\r\n  UNSIGNED_INT_SAMPLER_2D      : 0x8DD2,\r\n  UNSIGNED_INT_SAMPLER_3D      : 0x8DD3,\r\n  UNSIGNED_INT_SAMPLER_CUBE    : 0x8DD4,\r\n  UNSIGNED_INT_SAMPLER_2D_ARRAY: 0x8DD7,\r\n\r\n  TEXTURE_2D      : 0x0DE1,\r\n  TEXTURE_CUBE_MAP: 0x8513,\r\n  TEXTURE_3D      : 0x806F,\r\n  TEXTURE_2D_ARRAY: 0x8C1A\r\n};\r\n","/**\r\n * Maps black blend modes to WebGl blend functions.\r\n */\r\n\r\nclass WebGLBlendMode {\r\n  constructor(gl) {\r\n    return {\r\n      [BlendMode.NORMAL]     : {src: gl.ONE, dst: gl.ONE_MINUS_SRC_ALPHA},\r\n      [BlendMode.ADD]        : {src: gl.ONE, dst: gl.DST_ALPHA},\r\n      [BlendMode.MULTIPLY]   : {src: gl.DST_COLOR, dst: gl.ONE_MINUS_SRC_ALPHA},\r\n      [BlendMode.SCREEN]     : {src: gl.ONE, dst: gl.ONE_MINUS_SRC_COLOR},\r\n      [BlendMode.OVERLAY]    : {src: gl.ONE, dst: gl.ONE_MINUS_SRC_ALPHA},\r\n      [BlendMode.DARKEN]     : {src: gl.ONE, dst: gl.ONE_MINUS_SRC_ALPHA},\r\n      [BlendMode.LIGHTEN]    : {src: gl.ONE, dst: gl.ONE_MINUS_SRC_ALPHA},\r\n      [BlendMode.COLOR_DODGE]: {src: gl.ONE, dst: gl.ONE_MINUS_SRC_ALPHA},\r\n      [BlendMode.COLOR_BURN] : {src: gl.ONE, dst: gl.ONE_MINUS_SRC_ALPHA},\r\n      [BlendMode.HARD_LIGHT] : {src: gl.ONE, dst: gl.ONE_MINUS_SRC_ALPHA},\r\n      [BlendMode.SOFT_LIGHT] : {src: gl.ONE, dst: gl.ONE_MINUS_SRC_ALPHA},\r\n      [BlendMode.DIFFERENCE] : {src: gl.ONE, dst: gl.ONE_MINUS_SRC_ALPHA},\r\n      [BlendMode.EXCLUSION]  : {src: gl.ONE, dst: gl.ONE_MINUS_SRC_ALPHA},\r\n      [BlendMode.HUE]        : {src: gl.ONE, dst: gl.ONE_MINUS_SRC_ALPHA},\r\n      [BlendMode.SATURATE]   : {src: gl.ONE, dst: gl.ONE_MINUS_SRC_ALPHA},\r\n      [BlendMode.COLOR]      : {src: gl.ONE, dst: gl.ONE_MINUS_SRC_ALPHA},\r\n      [BlendMode.LUMINOSITY] : {src: gl.ONE, dst: gl.ONE_MINUS_SRC_ALPHA}\r\n    };\r\n  }\r\n}\r\n","const typeMap = {\r\n  [WebGLConstants.FLOAT]     : `uniform1f`,\r\n  [WebGLConstants.FLOAT_VEC2]: `uniform2fv`,\r\n  [WebGLConstants.FLOAT_VEC3]: `uniform3fv`,\r\n  [WebGLConstants.FLOAT_VEC4]: `uniform4fv`,\r\n  [WebGLConstants.INT]       : `uniform1i`,\r\n  [WebGLConstants.INT_VEC2]  : `uniform2iv`,\r\n  [WebGLConstants.INT_VEC3]  : `uniform3iv`,\r\n  [WebGLConstants.INT_VEC4]  : `uniform4iv`,\r\n  [WebGLConstants.FLOAT_MAT2]: `uniformMatrix2fv`,\r\n  [WebGLConstants.FLOAT_MAT3]: `uniformMatrix3fv`,\r\n  [WebGLConstants.FLOAT_MAT4]: `uniformMatrix4fv`,\r\n  [WebGLConstants.SAMPLER_2D]: `uniform1i`\r\n};\r\n\r\n\r\nclass WebGLBasePlugin {\r\n  constructor(renderer, vertexShaderSource, fragmentShaderSource, attributesInfo) {\r\n    this.mRenderer = renderer;\r\n    this.mBlendMode = BlendMode.NORMAL;\r\n    this.mTransform = new Matrix();\r\n    this.mGlobalAlpha = 1;\r\n\r\n    const gl = this.gl = renderer.gl;\r\n    const vertexShader = gl.createShader(gl.VERTEX_SHADER);\r\n    const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);\r\n    gl.shaderSource(vertexShader, vertexShaderSource);\r\n    gl.shaderSource(fragmentShader, fragmentShaderSource);\r\n    gl.compileShader(vertexShader);\r\n    gl.compileShader(fragmentShader);\r\n    const program = this.program = gl.createProgram();\r\n    gl.attachShader(program, vertexShader);\r\n    gl.attachShader(program, fragmentShader);\r\n    gl.linkProgram(program);\r\n    gl.useProgram(program); // set up uniforms for\r\n    gl.deleteShader(vertexShader);\r\n    gl.deleteShader(fragmentShader);\r\n\r\n    const uniforms = this.uniforms = {};\r\n    const uniformsAmount = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);\r\n\r\n    for (let i = 0; i < uniformsAmount; i++) {\r\n      const uniformInfo = gl.getActiveUniform(program, i);\r\n      let name = uniformInfo.name;\r\n      const isArray = name.slice(-3) === `[0]`;\r\n      name = isArray ? name.slice(0, -3) : name;\r\n\r\n      const location = gl.getUniformLocation(program, uniformInfo.name);\r\n      const sSetter = typeMap[uniformInfo.type] + (isArray ? `v` : ``);\r\n      const setter = gl[sSetter].length === 2 ?\r\n        v => gl[sSetter](location, v) : v => gl[sSetter](location, false, v);\r\n\r\n      // setter.location = location;\r\n      Object.defineProperty(uniforms, name, {set: setter, get: () => location});\r\n    }\r\n  }\r\n\r\n  onResize(msg, rect) {\r\n\r\n  }\r\n\r\n  set globalBlendMode(blendMode) {\r\n    this.mBlendMode = blendMode;\r\n  }\r\n\r\n  setTransform(m) {\r\n    this.mTransform = m;\r\n  }\r\n\r\n  set globalAlpha(value) {\r\n    this.mGlobalAlpha = value;\r\n  }\r\n\r\n  drawImage(object, texture) {\r\n\r\n  }\r\n\r\n  drawText(textField, style, bounds) {\r\n\r\n  }\r\n\r\n  start() {\r\n    \r\n  }\r\n  \r\n  stop() {\r\n    \r\n  }\r\n}\r\n","\r\nclass WebGLTextures {\r\n  constructor(renderer) {\r\n    const gl = this.gl = renderer.gl;\r\n    const UNITS = renderer.MAX_TEXTURE_IMAGE_UNITS;\r\n    const glTextures = [];\r\n    const canvas = document.createElement(`canvas`);\r\n    const ctx = canvas.getContext(`2d`);\r\n    canvas.width = canvas.height = 8;\r\n    ctx.fillRect(0, 0, 8, 8);\r\n\r\n    for (let i = 0; i < UNITS; i++) {\r\n      const glTexture = glTextures[i] = gl.createTexture();\r\n      const texture = new Texture(canvas);\r\n      texture._vSlotWebGL = i;\r\n      renderer.boundTextures[i] = texture;\r\n\r\n      gl.activeTexture(gl.TEXTURE0 + i);\r\n      gl.bindTexture(gl.TEXTURE_2D, glTexture);\r\n      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, texture.native);\r\n      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);\r\n      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\r\n      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\r\n      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\r\n    }\r\n    \r\n    return glTextures;\r\n  }\r\n}\r\n","const vertexShaderSource = `\r\n  precision highp float;\r\n  \r\n  attribute vec2 aPosition; // 2 * float = 8\r\n  attribute vec2 aTexCoord; // 2 * unsigned short = 4\r\n  attribute vec4 aColor;    // 4 * UNSIGNED BYTE = 4\r\n  attribute float aTexSlot; // 1 * float = 4\r\n  \r\n  varying vec2 vTexCoord;\r\n  varying float vTexSlot;\r\n  varying vec4 vColor;\r\n\r\n  uniform vec2 uProjection;\r\n\r\n  void main() {\r\n    gl_Position = vec4(aPosition.x * uProjection.x - 1.0, -aPosition.y * uProjection.y + 1.0, 0.0, 1.0);\r\n    \r\n    vTexCoord = aTexCoord;\r\n    vTexSlot = aTexSlot;\r\n    vColor = aColor;\r\n  }\r\n`;\r\n\r\nconst fragmentShaderSource = `\r\n  precision lowp float;\r\n  \r\n  varying vec2 vTexCoord;\r\n  varying float vTexSlot;\r\n  varying vec4 vColor;\r\n  \r\n  uniform sampler2D uSamplers[MAX_TEXTURE_IMAGE_UNITS];\r\n  \r\n  void main() {\r\n    int texSlot = int(vTexSlot);\r\n    \r\n    for (int i = 0; i < MAX_TEXTURE_IMAGE_UNITS; i++) {\r\n      if (i == texSlot) {\r\n        gl_FragColor = texture2D(uSamplers[i], vTexCoord) * vColor;\r\n        return;\r\n      }\r\n    }\r\n  }\r\n`;\r\n\r\nlet LAST_SLOT = 0;\r\n\r\n\r\nclass WebGLTexPlugin extends WebGLBasePlugin {\r\n  constructor(renderer) {\r\n    const gl = renderer.gl;\r\n    const UNITS = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);\r\n\r\n    super(renderer, vertexShaderSource, fragmentShaderSource.replace(/MAX_TEXTURE_IMAGE_UNITS/g, UNITS));\r\n\r\n    this.MAX_TEXTURE_IMAGE_UNITS = UNITS;\r\n    this.batchSize = 2048;\r\n    this.objects = [];\r\n    this.batches = [];\r\n    this.buffers = [];\r\n\r\n    for (let i = 0, l = this.batchSize; i < l; i++) {\r\n      this.batches.push({textures: [], texturesLength: 0, slots: {}, start: 0, size: 0, blend: null});\r\n    }\r\n\r\n    for (let i = 1, l = this.nextPow2(this.batchSize); i <= l; i *= 2) {\r\n      const buffer = {data: new ArrayBuffer(i * 4 * 20)};\r\n      buffer.float32View = new Float32Array(buffer.data);\r\n      buffer.uint32View = new Uint32Array(buffer.data);\r\n      this.buffers[i] = buffer;\r\n    }\r\n\r\n\r\n    // Element Buffer\r\n    const len = this.batchSize * 6;\r\n    const indices = new Uint16Array(len);\r\n\r\n    for (let i = 0, j = 0; i < len; i += 6, j += 4) {\r\n      indices[i] = j;\r\n      indices[i + 1] = j + 1;\r\n      indices[i + 2] = j + 2;\r\n      indices[i + 3] = j + 3;\r\n      indices[i + 4] = j + 3;\r\n      indices[i + 5] = j + 4;\r\n    }\r\n\r\n    this.mElementBuffer = gl.createBuffer();\r\n    renderer.bindElementBuffer(this.mElementBuffer);\r\n    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indices, gl.STREAM_DRAW);\r\n\r\n\r\n    // Array Buffer\r\n    this.mArrayBuffer = gl.createBuffer();\r\n    const location = {\r\n      aPosition: gl.getAttribLocation(this.program, `aPosition`),\r\n      aTexCoord: gl.getAttribLocation(this.program, `aTexCoord`),\r\n      aColor   : gl.getAttribLocation(this.program, `aColor`),\r\n      aTexSlot : gl.getAttribLocation(this.program, `aTexSlot`)\r\n    };\r\n    gl.bindBuffer(gl.ARRAY_BUFFER, this.mArrayBuffer);\r\n    gl.vertexAttribPointer(location.aPosition, 2, gl.FLOAT, false, 20, 0);\r\n    gl.vertexAttribPointer(location.aTexCoord, 2, gl.UNSIGNED_SHORT, true, 20, 8);\r\n    gl.vertexAttribPointer(location.aColor, 4, gl.UNSIGNED_BYTE, true, 20, 12);\r\n    gl.vertexAttribPointer(location.aTexSlot, 1, gl.FLOAT, false, 20, 16);\r\n    gl.enableVertexAttribArray(location.aPosition);\r\n    gl.enableVertexAttribArray(location.aTexCoord);\r\n    gl.enableVertexAttribArray(location.aColor);\r\n    gl.enableVertexAttribArray(location.aTexSlot);\r\n\r\n\r\n    gl.uniform2f(this.uniforms.uProjection, 2 / renderer.mClientWidth, 2 / renderer.mClientHeight);\r\n    gl.uniform1iv(this.uniforms.uSamplers, new Int32Array(new Array(this.MAX_TEXTURE_IMAGE_UNITS).fill(0).map((v, i) => i)));\r\n\r\n    this.stop = this.flush;\r\n  }\r\n\r\n  onResize(msg, rect) {\r\n    this.gl.uniform2f(this.uniforms.uProjection, 2 / rect.width, 2 / rect.height);\r\n  }\r\n\r\n  drawImage(object) {\r\n    if (object.worldAlpha === 0) return;\r\n\r\n    this.objects.push(object);\r\n\r\n    if (this.objects.length === this.batchSize) {\r\n      this.flush();\r\n    }\r\n  }\r\n  \r\n  drawText(textField, style, bounds) {\r\n    if (!textField.mNeedInvalidate) {\r\n      return this.drawImage(textField);\r\n    }\r\n\r\n    let lines = textField.lines;\r\n    let widths = textField.lineWidths;\r\n    let lineOffset = textField.lineHeight * style.size;\r\n    let strokeThickness = style.strokeThickness;\r\n    let align = style.align;\r\n    let maxWidth = bounds.width;\r\n    let ctx = textField.context;\r\n\r\n    if (ctx.mLetterSpacing !== textField.letterSpacing) {\r\n      ctx.mLetterSpacing = textField.letterSpacing;\r\n\r\n      let canvas = ctx.canvas;\r\n      canvas.style.letterSpacing = `${textField.letterSpacing}px`;\r\n      // ctx = this.mCtx = canvas.getContext(`2d`);\r\n    }\r\n\r\n    ctx.font = `${style.style} ${style.weight} ${style.size}px \"${style.name}\"`;\r\n    ctx.fillStyle = this.mRenderer.hexColorToString(style.color);\r\n    ctx.textBaseline = `bottom`;\r\n\r\n    if (strokeThickness !== 0) {\r\n      ctx.lineJoin = `round`;\r\n      ctx.miterLimit = 2;\r\n      ctx.lineWidth = strokeThickness;\r\n      ctx.strokeStyle = this.mRenderer.hexColorToString(style.strokeColor);\r\n    }\r\n\r\n    // ctx.fillRect(0, 0, maxWidth, bounds.height);\r\n\r\n    for (let i = 0, l = lines.length; i < l; i++) {\r\n      let width = widths[i];\r\n      let y = bounds.height - strokeThickness / 2 - lineOffset * (l - i - 1);\r\n      let x = strokeThickness / 2;\r\n\r\n      if (align === `center`) {\r\n        x += maxWidth / 2 - width / 2;\r\n      } else if (align === `right`) {\r\n        x += maxWidth - width;\r\n      }\r\n\r\n      strokeThickness !== 0 && ctx.strokeText(lines[i], x, y);\r\n      ctx.fillText(lines[i], x, y);\r\n    }\r\n\r\n    this.drawImage(textField);\r\n  }\r\n\r\n  flush() {\r\n    const objects = this.objects;\r\n    const length = objects.length;\r\n\r\n    if (length === 0) return;\r\n\r\n    const gl = this.gl;\r\n    const renderer = this.mRenderer;\r\n    const rendererBoundTextures = renderer.boundTextures;\r\n    const vBoundTextures = rendererBoundTextures.slice();\r\n    const batches = this.batches;\r\n    const MAX_TEXTURE_IMAGE_UNITS = this.MAX_TEXTURE_IMAGE_UNITS;\r\n    const buffer = this.buffers[this.nextPow2(length)];\r\n    const uint32View = buffer.uint32View;\r\n    const float32View = buffer.float32View;\r\n\r\n    let index = 0;\r\n    let currentBatchIndex = 0;\r\n    let currentBatch = batches[0];\r\n    let currentBlend = currentBatch.blend = objects[0].blendMode;\r\n    let currentBatchSlots = currentBatch.slots;\r\n    currentBatch.texturesLength = 0;\r\n    let i;\r\n\r\n    for (i = 0; i < length; i++) {\r\n      const object = objects[i];\r\n      const alpha = object.worldAlpha;\r\n      const tint = object.tint;\r\n      const nextBlend = object.blendMode;\r\n      const texture = object.mTexture;\r\n      /* object.lateDirty && */object.refreshVertexData();  // todo late dirt\r\n\r\n      if (currentBlend !== nextBlend) {\r\n        currentBlend = nextBlend;\r\n\r\n        currentBatchSlots = 0;\r\n        currentBatch.texturesLength = MAX_TEXTURE_IMAGE_UNITS;\r\n      }\r\n\r\n      if (currentBatchSlots[texture.id] === undefined) {\r\n        if (currentBatch.texturesLength === MAX_TEXTURE_IMAGE_UNITS) {\r\n          currentBatch.size = i - currentBatch.start;\r\n          // currentBatch.texturesLength = currentBatch.textures.length;\r\n\r\n          currentBatch = batches[++currentBatchIndex];\r\n          currentBatch.start = i;\r\n          currentBatch.blend = nextBlend;\r\n          currentBatch.texturesLength = 0;\r\n          currentBatchSlots = currentBatch.slots;\r\n        }\r\n\r\n        if (texture._vSlotWebGL === -1) {\r\n          for (let j = 0; j < MAX_TEXTURE_IMAGE_UNITS; j++) {\r\n            const k = (j + LAST_SLOT) % MAX_TEXTURE_IMAGE_UNITS;\r\n            const tex = vBoundTextures[k];\r\n\r\n            if (currentBatchSlots[tex.mId] === undefined) {\r\n              tex._vSlotWebGL = -1;\r\n              texture._vSlotWebGL = k;\r\n              vBoundTextures[k] = texture;\r\n              LAST_SLOT++;\r\n\r\n              break;\r\n            }\r\n          }\r\n        }\r\n\r\n        currentBatchSlots[texture.mId] = texture._vSlotWebGL;\r\n        currentBatch.textures[currentBatch.texturesLength++] = texture;\r\n      }\r\n\r\n      const vertexData = object.vertexData;\r\n      float32View[index] = vertexData[0];\r\n      float32View[index + 1] = vertexData[1];\r\n      float32View[index + 5] = vertexData[2];\r\n      float32View[index + 6] = vertexData[3];\r\n      float32View[index + 10] = vertexData[4];\r\n      float32View[index + 11] = vertexData[5];\r\n      float32View[index + 15] = vertexData[6];\r\n      float32View[index + 16] = vertexData[7];\r\n\r\n      const texCoord = texture.coord;\r\n      uint32View[index + 2] = texCoord[0];\r\n      uint32View[index + 7] = texCoord[1];\r\n      uint32View[index + 12] = texCoord[2];\r\n      uint32View[index + 17] = texCoord[3];\r\n\r\n      uint32View[index + 3] = uint32View[index + 8] = uint32View[index + 13] = uint32View[index + 18] = alpha === 1 ?\r\n      (alpha * 255 << 24) + tint :\r\n      (alpha * 255 << 24) + ((((tint >> 16) & 0xff) * alpha + 0.5 | 0) << 16) +\r\n      ((((tint >> 8) & 0xff) * alpha + 0.5 | 0) << 8) + ((tint & 0xff) * alpha + 0.5 | 0);\r\n\r\n      float32View[index + 4] = float32View[index + 9] = \r\n        float32View[index + 14] = float32View[index + 19] = texture._vSlotWebGL + 0.5;\r\n\r\n      index += 20;\r\n    }\r\n\r\n    currentBatch.size = i - currentBatch.start;\r\n    gl.bufferData(gl.ARRAY_BUFFER, buffer.data, gl.STREAM_DRAW);\r\n\r\n    for (let i = 0, len = currentBatchIndex + 1; i < len; i++) {\r\n      const batch = batches[i];\r\n      const textures = batch.textures;\r\n      const slots = batch.slots;\r\n\r\n      for (let j = 0, l = batch.textures.length; j < l; j++) {\r\n        const texture = textures[j];\r\n        const slot = slots[texture.id];\r\n        slots[texture.id] = undefined;\r\n\r\n        if (rendererBoundTextures[slot] !== texture) {\r\n          renderer.bindTexture(texture, slot);\r\n        }\r\n      }\r\n\r\n      if (renderer.blend !== batch.blend) {\r\n        renderer.setBlend(batch.blend);\r\n      }\r\n\r\n      gl.drawElements(gl.TRIANGLE_STRIP, batch.size * 6 - 2, gl.UNSIGNED_SHORT, batch.start * 12);\r\n    }\r\n\r\n    objects.length = 0;\r\n  }\r\n\r\n  start() {\r\n    this.gl.useProgram(this.program);\r\n  }\r\n\r\n  nextPow2(v) {\r\n    v += v === 0;\r\n    --v;\r\n    v |= v >>> 1;\r\n    v |= v >>> 2;\r\n    v |= v >>> 4;\r\n    v |= v >>> 8;\r\n    v |= v >>> 16;\r\n\r\n    return v + 1;\r\n  }\r\n}\r\n","const vertexShaderSource1 = `\r\n  precision highp float;\r\n  \r\n  attribute vec2 aPosition; // 2 * float = 8\r\n  attribute vec2 aTexCoord; // 2 * unsigned short = 4\r\n  attribute vec4 aColor;    // 4 * UNSIGNED BYTE = 4\r\n  attribute float aTexSlot; // 1 * float = 4\r\n  \r\n  varying vec2 vTexCoord;\r\n  varying float vTexSlot;\r\n  varying vec4 vColor;\r\n\r\n  uniform vec2 uProjection;\r\n\r\n  void main() {\r\n    gl_Position = vec4(aPosition.x * uProjection.x - 1.0, -aPosition.y * uProjection.y + 1.0, 0.0, 1.0);\r\n    \r\n    vTexCoord = aTexCoord;\r\n    vTexSlot = aTexSlot;\r\n    vColor = aColor;\r\n  }\r\n`;\r\n\r\nconst fragmentShaderSource1 = `\r\n  precision lowp float;\r\n  \r\n  varying vec2 vTexCoord;\r\n  varying float vTexSlot;\r\n  varying vec4 vColor;\r\n  \r\n  uniform sampler2D uSamplers[MAX_TEXTURE_IMAGE_UNITS];\r\n  \r\n  void main() {\r\n    int texSlot = int(vTexSlot);\r\n    \r\n    for (int i = 0; i < MAX_TEXTURE_IMAGE_UNITS; i++) {\r\n      if (i == texSlot) {\r\n        gl_FragColor = texture2D(uSamplers[i], vTexCoord) * vColor;\r\n        return;\r\n      }\r\n    }\r\n  }\r\n`;\r\n\r\nlet LAST_SLOT_ = 0;\r\n\r\n\r\nclass WebGLParticlesPlugin extends WebGLBasePlugin {\r\n  constructor(renderer) {\r\n    const gl = renderer.gl;\r\n    const UNITS = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);\r\n\r\n    super(renderer, vertexShaderSource1, fragmentShaderSource1.replace(/MAX_TEXTURE_IMAGE_UNITS/g, UNITS));\r\n\r\n    this.MAX_TEXTURE_IMAGE_UNITS = UNITS;\r\n    this.batchSize = 2048;\r\n    this.objects = new Array(this.batchSize).fill(``)\r\n      .map(v => {\r\n        return {transform: new Matrix(), vertexData: []}\r\n      });\r\n    this.objectsLength = 0;\r\n    this.batches = [];\r\n    this.buffers = [];\r\n\r\n    for (let i = 0, l = this.batchSize; i < l; i++) {\r\n      this.batches.push({textures: [], texturesLength: 0, slots: {}, start: 0, size: 0, blend: null});\r\n    }\r\n\r\n    for (let i = 1, l = this.nextPow2(this.batchSize); i <= l; i *= 2) {\r\n      const buffer = {data: new ArrayBuffer(i * 4 * 20)};\r\n      buffer.float32View = new Float32Array(buffer.data);\r\n      buffer.uint32View = new Uint32Array(buffer.data);\r\n      this.buffers[i] = buffer;\r\n    }\r\n\r\n\r\n    // Element Buffer\r\n    const len = this.batchSize * 6;\r\n    const indices = new Uint16Array(len);\r\n\r\n    for (let i = 0, j = 0; i < len; i += 6, j += 4) {\r\n      indices[i] = j;\r\n      indices[i + 1] = j + 1;\r\n      indices[i + 2] = j + 2;\r\n      indices[i + 3] = j + 3;\r\n      indices[i + 4] = j + 3;\r\n      indices[i + 5] = j + 4;\r\n    }\r\n\r\n    this.mElementBuffer = gl.createBuffer();\r\n    renderer.bindElementBuffer(this.mElementBuffer);\r\n    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indices, gl.STREAM_DRAW);\r\n\r\n\r\n    // Array Buffer\r\n    this.mArrayBuffer = gl.createBuffer();\r\n    const location = {\r\n      aPosition: gl.getAttribLocation(this.program, `aPosition`),\r\n      aTexCoord: gl.getAttribLocation(this.program, `aTexCoord`),\r\n      aColor   : gl.getAttribLocation(this.program, `aColor`),\r\n      aTexSlot : gl.getAttribLocation(this.program, `aTexSlot`)\r\n    };\r\n    gl.bindBuffer(gl.ARRAY_BUFFER, this.mArrayBuffer);\r\n    gl.vertexAttribPointer(location.aPosition, 2, gl.FLOAT, false, 20, 0);\r\n    gl.vertexAttribPointer(location.aTexCoord, 2, gl.UNSIGNED_SHORT, true, 20, 8);\r\n    gl.vertexAttribPointer(location.aColor, 4, gl.UNSIGNED_BYTE, true, 20, 12);\r\n    gl.vertexAttribPointer(location.aTexSlot, 1, gl.FLOAT, false, 20, 16);\r\n    gl.enableVertexAttribArray(location.aPosition);\r\n    gl.enableVertexAttribArray(location.aTexCoord);\r\n    gl.enableVertexAttribArray(location.aColor);\r\n    gl.enableVertexAttribArray(location.aTexSlot);\r\n\r\n\r\n    gl.uniform2f(this.uniforms.uProjection, 2 / renderer.mClientWidth, 2 / renderer.mClientHeight);\r\n    gl.uniform1iv(this.uniforms.uSamplers, new Int32Array(new Array(this.MAX_TEXTURE_IMAGE_UNITS).fill(0).map((v, i) => i)));\r\n\r\n    this.stop = this.flush;\r\n  }\r\n\r\n  onResize(msg, rect) {\r\n    this.gl.uniform2f(this.uniforms.uProjection, 2 / rect.width, 2 / rect.height);\r\n  }\r\n\r\n  set globalBlendMode(blendMode) {\r\n    this.mBlendMode = blendMode;\r\n  }\r\n\r\n  setTransform(m) {\r\n    this.mTransform = m;\r\n  }\r\n\r\n  set globalAlpha(value) {\r\n    this.mGlobalAlpha = value;\r\n  }\r\n\r\n  refreshVertexData(object) {\r\n    const vertexData = object.vertexData;\r\n    const transform = object.transform.value;\r\n    const a = transform[0];\r\n    const b = transform[1];\r\n    const c = transform[2];\r\n    const d = transform[3];\r\n    const tx = transform[4];\r\n    const ty = transform[5];\r\n    const texture = object.mTexture;\r\n    const region = texture.mRegion;\r\n    const w = region.width;\r\n    const h = region.height;\r\n\r\n    if (texture.isTrimmed) {\r\n      const untrimmedRegion = texture.untrimmedRect;\r\n      const left = untrimmedRegion.x;\r\n      const top = untrimmedRegion.y;\r\n      const right = left + w;\r\n      const bottom = top + h;\r\n\r\n      // left top\r\n      vertexData[0] = a * left + c * top + tx;\r\n      vertexData[1] = d * top + b * left + ty;\r\n\r\n      // right top\r\n      vertexData[2] = a * right + c * top + tx;\r\n      vertexData[3] = d * top + b * right + ty;\r\n\r\n      // left bottom\r\n      vertexData[4] = a * left + c * bottom + tx;\r\n      vertexData[5] = d * bottom + b * left + ty;\r\n\r\n      // right bottom\r\n      vertexData[6] = a * right + c * bottom + tx;\r\n      vertexData[7] = d * bottom + b * right + ty;\r\n    } else {\r\n\r\n      // left top\r\n      vertexData[0] = tx;\r\n      vertexData[1] = ty;\r\n\r\n      // right top\r\n      vertexData[2] = a * w + tx;\r\n      vertexData[3] = b * w + ty;\r\n\r\n      // left bottom\r\n      vertexData[4] = c * h + tx;\r\n      vertexData[5] = d * h + ty;\r\n\r\n      // right bottom\r\n      vertexData[6] = a * w + c * h + tx;\r\n      vertexData[7] = d * h + b * w + ty;\r\n    }\r\n  }\r\n  \r\n  drawImage(particle, texture) {\r\n    if (particle.worldAlpha === 0) return;\r\n\r\n    let object = this.objects[this.objectsLength++];\r\n    object.transform.copyFrom(this.mTransform);\r\n    object.mTexture = texture;\r\n    object.worldAlpha = particle.worldAlpha;\r\n    object.tint = 0xffffff;\r\n    object.blendMode = this.mBlendMode;\r\n\r\n    if (this.objectsLength === this.batchSize) {\r\n      this.flush();\r\n    }\r\n  }\r\n\r\n  flush() {\r\n    const objects = this.objects;\r\n    const length = this.objectsLength;\r\n\r\n    if (length === 0) return;\r\n\r\n    const gl = this.gl;\r\n    const renderer = this.mRenderer;\r\n    const rendererBoundTextures = renderer.boundTextures;\r\n    const vBoundTextures = rendererBoundTextures.slice();\r\n    const batches = this.batches;\r\n    const MAX_TEXTURE_IMAGE_UNITS = this.MAX_TEXTURE_IMAGE_UNITS;\r\n    const buffer = this.buffers[this.nextPow2(length)];\r\n    const uint32View = buffer.uint32View;\r\n    const float32View = buffer.float32View;\r\n\r\n    let index = 0;\r\n    let currentBatchIndex = 0;\r\n    let currentBatch = batches[0];\r\n    let currentBlend = currentBatch.blend = objects[0].blendMode;\r\n    let currentBatchSlots = currentBatch.slots;\r\n    currentBatch.texturesLength = 0;\r\n    let i;\r\n\r\n    for (i = 0; i < length; i++) {\r\n      const object = objects[i];\r\n      const alpha = object.worldAlpha;\r\n      const tint = object.tint;\r\n      const nextBlend = object.blendMode;\r\n      const texture = object.mTexture;\r\n\r\n      if (currentBlend !== nextBlend) {\r\n        currentBlend = nextBlend;\r\n\r\n        currentBatchSlots = 0;\r\n        currentBatch.texturesLength = MAX_TEXTURE_IMAGE_UNITS;\r\n      }\r\n\r\n      if (currentBatchSlots[texture.id] === undefined) {\r\n        if (currentBatch.texturesLength === MAX_TEXTURE_IMAGE_UNITS) {\r\n          currentBatch.size = i - currentBatch.start;\r\n          // currentBatch.texturesLength = currentBatch.textures.length;\r\n\r\n          currentBatch = batches[++currentBatchIndex];\r\n          currentBatch.start = i;\r\n          currentBatch.blend = nextBlend;\r\n          currentBatch.texturesLength = 0;\r\n          currentBatchSlots = currentBatch.slots;\r\n        }\r\n\r\n        if (texture._vSlotWebGL === -1) {\r\n          for (let j = 0; j < MAX_TEXTURE_IMAGE_UNITS; j++) {\r\n            const k = (j + LAST_SLOT_) % MAX_TEXTURE_IMAGE_UNITS;\r\n            const tex = vBoundTextures[k];\r\n\r\n            if (currentBatchSlots[tex.mId] === undefined) {\r\n              tex._vSlotWebGL = -1;\r\n              texture._vSlotWebGL = k;\r\n              vBoundTextures[k] = texture;\r\n              LAST_SLOT_++;\r\n\r\n              break;\r\n            }\r\n          }\r\n        }\r\n\r\n        currentBatchSlots[texture.mId] = texture._vSlotWebGL;\r\n        currentBatch.textures[currentBatch.texturesLength++] = texture;\r\n      }\r\n\r\n      this.refreshVertexData(object);\r\n      const vertexData = object.vertexData;\r\n      float32View[index] = vertexData[0];\r\n      float32View[index + 1] = vertexData[1];\r\n      float32View[index + 5] = vertexData[2];\r\n      float32View[index + 6] = vertexData[3];\r\n      float32View[index + 10] = vertexData[4];\r\n      float32View[index + 11] = vertexData[5];\r\n      float32View[index + 15] = vertexData[6];\r\n      float32View[index + 16] = vertexData[7];\r\n\r\n      const texCoord = texture.coord;\r\n      uint32View[index + 2] = texCoord[0];\r\n      uint32View[index + 7] = texCoord[1];\r\n      uint32View[index + 12] = texCoord[2];\r\n      uint32View[index + 17] = texCoord[3];\r\n\r\n      uint32View[index + 3] = uint32View[index + 8] = uint32View[index + 13] = uint32View[index + 18] = alpha === 1 ?\r\n      (alpha * 255 << 24) + tint :\r\n      (alpha * 255 << 24) + ((((tint >> 16) & 0xff) * alpha + 0.5 | 0) << 16) +\r\n      ((((tint >> 8) & 0xff) * alpha + 0.5 | 0) << 8) + ((tint & 0xff) * alpha + 0.5 | 0);\r\n\r\n      float32View[index + 4] = float32View[index + 9] = \r\n        float32View[index + 14] = float32View[index + 19] = texture._vSlotWebGL + 0.5;\r\n\r\n      index += 20;\r\n    }\r\n\r\n    currentBatch.size = i - currentBatch.start;\r\n    gl.bufferData(gl.ARRAY_BUFFER, buffer.data, gl.STREAM_DRAW);\r\n\r\n    for (let i = 0, len = currentBatchIndex + 1; i < len; i++) {\r\n      const batch = batches[i];\r\n      const textures = batch.textures;\r\n      const slots = batch.slots;\r\n\r\n      for (let j = 0, l = batch.texturesLength; j < l; j++) {\r\n        const texture = textures[j];\r\n        const slot = slots[texture.id];\r\n        slots[texture.id] = undefined;\r\n\r\n        if (rendererBoundTextures[slot] !== texture) {\r\n          renderer.bindTexture(texture, slot);\r\n        }\r\n      }\r\n\r\n      if (renderer.blend !== batch.blend) {\r\n        renderer.setBlend(batch.blend);\r\n      }\r\n\r\n      gl.drawElements(gl.TRIANGLE_STRIP, batch.size * 6 - 2, gl.UNSIGNED_SHORT, batch.start * 12);\r\n    }\r\n\r\n    this.objectsLength = 0;\r\n  }\r\n\r\n  start() {\r\n    this.gl.useProgram(this.program);\r\n  }\r\n\r\n  nextPow2(v) {\r\n    v += v === 0;\r\n    --v;\r\n    v |= v >>> 1;\r\n    v |= v >>> 2;\r\n    v |= v >>> 4;\r\n    v |= v >>> 8;\r\n    v |= v >>> 16;\r\n\r\n    return v + 1;\r\n  }\r\n}\r\n","/**\r\n * The base class for all renderable objects. Adds `alpha` and `visible` properties to GameObject.\r\n *\r\n * @cat display\r\n * @extends GameObject\r\n */\r\n\r\nclass DisplayObject extends GameObject {\r\n  constructor() {\r\n    super();\r\n\r\n    /**\r\n     * @private\r\n     * @type {number}\r\n     */\r\n    this.mAlpha = 1;\r\n\r\n    /**\r\n     * @public\r\n     * @type {string}\r\n     */\r\n    this.blendMode = BlendMode.NORMAL;\r\n\r\n    /**\r\n     * @private\r\n     * @type {boolean}\r\n     */\r\n    this.mVisible = true;\r\n    \r\n    this.pluginName = WebGLTexPlugin.name;\r\n    this.vertexData = [];\r\n    this.tint = 0xffffff;\r\n  }\r\n\r\n  /**\r\n   * @ignore\r\n   * @param {VideoNullDriver} video\r\n   * @param {number} time\r\n   * @param {number} parentAlpha\r\n   *\r\n   * @return {void}\r\n   */\r\n  __render(video, time, parentAlpha) {\r\n    if (this.mVisible === false)\r\n      return;\r\n    \r\n    this.onRender(video, time);\r\n\r\n    let child = null;\r\n    for (var i = 0; i < this.mChildren.length; i++) {\r\n      child = this.mChildren[i];\r\n      child.__render(video, time, parentAlpha);\r\n    }\r\n  }\r\n\r\n  refreshVertexData() {\r\n    const vertexData = this.vertexData;\r\n    const transform = this.worldTransformation.value;\r\n    const a = transform[0];\r\n    const b = transform[1];\r\n    const c = transform[2];\r\n    const d = transform[3];\r\n    const tx = transform[4];\r\n    const ty = transform[5];\r\n    const texture = this.mTexture;\r\n    const region = texture.mRegion;\r\n    const w = region.width;\r\n    const h = region.height;\r\n\r\n    if (texture.isTrimmed) {\r\n      const untrimmedRegion = texture.untrimmedRect;\r\n      const left = untrimmedRegion.x;\r\n      const top = untrimmedRegion.y;\r\n      const right = left + w;\r\n      const bottom = top + h;\r\n\r\n      // left top\r\n      vertexData[0] = a * left + c * top + tx;\r\n      vertexData[1] = d * top + b * left + ty;\r\n\r\n      // right top\r\n      vertexData[2] = a * right + c * top + tx;\r\n      vertexData[3] = d * top + b * right + ty;\r\n\r\n      // left bottom\r\n      vertexData[4] = a * left + c * bottom + tx;\r\n      vertexData[5] = d * bottom + b * left + ty;\r\n\r\n      // right bottom\r\n      vertexData[6] = a * right + c * bottom + tx;\r\n      vertexData[7] = d * bottom + b * right + ty;\r\n    } else {\r\n\r\n      // left top\r\n      vertexData[0] = tx;\r\n      vertexData[1] = ty;\r\n\r\n      // right top\r\n      vertexData[2] = a * w + tx;\r\n      vertexData[3] = b * w + ty;\r\n\r\n      // left bottom\r\n      vertexData[4] = c * h + tx;\r\n      vertexData[5] = d * h + ty;\r\n\r\n      // right bottom\r\n      vertexData[6] = a * w + c * h + tx;\r\n      vertexData[7] = d * h + b * w + ty;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Gets/Sets the opacity of the object.\r\n   *\r\n   * @return {number}\r\n   */\r\n  get alpha() {\r\n    return this.mAlpha;\r\n  }\r\n\r\n  /**\r\n   * @ignore\r\n   * @param {number} value\r\n   * @return {void}\r\n   */\r\n  set alpha(value) {\r\n    this.mAlpha = MathEx.clamp(value, 0, 1);\r\n  }\r\n\r\n\r\n  /**\r\n   * Gets/Sets visibility of the object.\r\n   *\r\n   * @return {boolean}\r\n   */\r\n  get visible() {\r\n    return this.mVisible;\r\n  }\r\n\r\n\r\n  /**\r\n   * @ignore\r\n   * @param {boolean} value\r\n   * @return {void}\r\n   */\r\n  set visible(value) {\r\n    this.mVisible = value;\r\n  }\r\n}\r\n","/**\r\n * Holds TextField's style details.\r\n *\r\n * @cat display.text\r\n */\r\n\r\nclass TextInfo {\r\n  /**\r\n   * @param  {string=} name Font name\r\n   * @param  {number=} color = Text color as hexadecimal number eg 0xff0000 (total red)\r\n   * @param  {number=} size = Text size\r\n   * @param  {TextInfo.FontStyle=} style = Text style eg italic\r\n   * @param  {TextInfo.FontWeight=} weight = font thick. The value is set from 100 to 900 in increments of 100.\r\n   * @param  {TextInfo.FontAlign=} align = horizontal alignment left | center | right\r\n   * @param  {number=} strokeThickness = thickness of the stroke. 0 means that no stroke\r\n   * @param  {number=} strokeColor = stroke color as hexadecimal number eg 0x00ff00 (total green)\r\n   */\r\n  constructor(name = 'sans-serif', color = 0x000000, size = 14, style = TextInfo.FontStyle.NORMAL, weight = TextInfo.FontWeight.NORMAL, align = TextInfo.FontAlign.LEFT, strokeThickness = 0, strokeColor = 0xffffff) {\r\n\r\n    /** @type {string} */\r\n    this.name = name;\r\n\r\n    /** @type {number} */\r\n    this.size = size;\r\n\r\n    /** @type {number} */\r\n    this.color = color;\r\n\r\n    /** @type {TextInfo.FontStyle} */\r\n    this.style = style;\r\n\r\n    /** @type {TextInfo.FontWeight} */\r\n    this.weight = weight;\r\n\r\n    /** @type {TextInfo.FontAlign} */\r\n    this.align = align;\r\n\r\n    /** @type {number} */\r\n    this.strokeThickness = strokeThickness;\r\n\r\n    /** @type {number} */\r\n    this.strokeColor = strokeColor;\r\n  }\r\n}\r\n\r\n/**\r\n * @enum {string}\r\n */\r\nTextInfo.FontStyle = {\r\n  NORMAL: 'normal',\r\n  ITALIC: 'italic'\r\n};\r\n\r\n/**\r\n * @enum {string}\r\n */\r\nTextInfo.FontWeight = {\r\n  NORMAL: '400',\r\n  BOLD: '700',\r\n  SUPERBOLD: '800'\r\n};\r\n\r\n/**\r\n * @enum {string}\r\n */\r\nTextInfo.FontAlign = {\r\n  LEFT: 'left',\r\n  RIGHT: 'right',\r\n  CENTER: 'center'\r\n};\r\n","/**\r\n * Sprite is used to render Texture onto screen.\r\n *\r\n * @cat display\r\n * @extends DisplayObject\r\n */\r\n\r\nclass Sprite extends DisplayObject {\r\n\r\n  /**\r\n   * constructor - Creates a new Sprite object instance.\r\n   *\r\n   * @param {Texture|string|null} texture The Texture instance or null.\r\n   */\r\n  constructor(texture = null) {\r\n    super();\r\n\r\n    /**\r\n     * @private\r\n     * @type {Texture|null} */\r\n    this.mTexture = null;\r\n\r\n    /**\r\n     * @private\r\n     * @type {string|null} */\r\n    this.mTextureName = null;\r\n\r\n    if (texture !== null && texture.constructor === String) {\r\n      this.mTextureName = /** @type {string} */ (texture);\r\n      this.mTexture = AssetManager.default.getTexture(/** @type {string} */ (texture));\r\n    } else {\r\n      this.mTexture = /** @type {Texture} */ (texture);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @override\r\n   * @private\r\n   * @param {VideoNullDriver} video\r\n   * @param {number} time\r\n   * @param {number} parentAlpha\r\n   *\r\n   * @return {void}\r\n   */\r\n  __render(video, time, parentAlpha) {\r\n    if (this.mAlpha <= 0 || this.mVisible === false) return;\r\n\r\n    this.worldAlpha = parentAlpha * this.mAlpha;\r\n\r\n    if (this.mTexture !== null) {\r\n      video.setTransform(this.worldTransformation);\r\n      video.globalAlpha = parentAlpha * this.mAlpha;\r\n      video.globalBlendMode = this.blendMode;\r\n      video.drawImage(this, this.mTexture);\r\n    }\r\n\r\n    super.__render(video, time, this.worldAlpha);\r\n  }\r\n\r\n  // __render(command) {\r\n  //   command.set(this.)\r\n  // }\r\n  \r\n  /**\r\n   * onGetLocalBounds - Returns a rectangle that completely encloses the object in local coordinate system.\r\n   *\r\n   * @override\r\n   * @protected\r\n   * @param {Rectangle=} outRect Description\r\n   *\r\n   * @return {Rectangle} The new Rectangle or outRect with .\r\n   */\r\n  onGetLocalBounds(outRect = undefined) {\r\n    outRect = outRect || new Rectangle();\r\n\r\n    if (!this.mTexture)\r\n      return outRect;\r\n\r\n    return outRect.set(0, 0, this.mTexture.untrimmedRect.width, this.mTexture.untrimmedRect.height);\r\n  }\r\n\r\n  /**\r\n   * texture - Returns the current Texture on this sprite.\r\n   *\r\n   * @return {Texture|null} The current texture set on this Sprite or null.\r\n   */\r\n  get texture() {\r\n    return this.mTexture;\r\n  }\r\n\r\n  /**\r\n   * texture - Sets the Texture on this sprite.\r\n   *\r\n   * @param {Texture|null} texture Texture to apply on.\r\n   *\r\n   * @return {void}\r\n   */\r\n  set texture(texture) {\r\n    // if (this.mTexture !== null && this.mTexture === texture)\r\n    //   return;\r\n\r\n    this.mTexture = texture;\r\n  }\r\n\r\n  get textureName() {\r\n    return this.mTextureName;\r\n  }\r\n\r\n  /**\r\n   * @editor {TextureEditor}\r\n   */\r\n  set textureName(value) {\r\n    if (this.mTextureName === value)\r\n      return;\r\n\r\n    this.mTextureName = value;\r\n    this.texture = AssetManager.default.getTexture(value);\r\n  }\r\n\r\n  set touchable(value) {\r\n    let c = this.getComponent(InputComponent);\r\n\r\n    if (value === true) {\r\n      if (c === null)\r\n        this.addComponent(new InputComponent());\r\n      else\r\n        c.touchable = true;\r\n    } else {\r\n      if (c !== null)\r\n        this.removeComponent(c);\r\n    }\r\n  }\r\n\r\n  get touchable() {\r\n    let c = this.getComponent(InputComponent);\r\n    return c !== null && c.touchable === true;\r\n  }\r\n}\r\n","/**\r\n * This class is used to create display text.\r\n *\r\n * @cat display.text\r\n * @extends DisplayObject\r\n */\r\n\r\nclass TextField extends DisplayObject {\r\n  /**\r\n   * @param  {string=} text Text to be displayed inside this text field\r\n   * @param  {number=} size text size\r\n   * @param  {string=} name font name\r\n   * @param {TextInfo=} style TextInfo object\r\n   */\r\n  constructor(text = '', size = 14, name = 'sans-serif', style = undefined) {\r\n    super();\r\n\r\n    /**\r\n     * @private\r\n     * @type {string}\r\n     */\r\n    this.mText = text;\r\n\r\n    /**\r\n     * @private\r\n     * @type {boolean}\r\n     */\r\n    this.mNeedInvalidate = true;\r\n\r\n    /**\r\n     * @private\r\n     * @type {Rectangle}\r\n     */\r\n    this.mCacheBounds = new Rectangle();\r\n\r\n    /**\r\n     * @private\r\n     * @type {number}\r\n     */\r\n    this.mTextWidth = 0;\r\n\r\n    /**\r\n     * @private\r\n     * @type {number}\r\n     */\r\n    this.mTextHeight = 0;\r\n\r\n    /**\r\n     * @private\r\n     * @type {TextInfo}\r\n     */\r\n    this.mStyle = style || new TextInfo();\r\n\r\n    /**\r\n     * @private\r\n     * @type {string}\r\n     */\r\n    this.mStyle.name = name || style.name;\r\n\r\n    /**\r\n     * @private\r\n     * @type {number}\r\n     */\r\n    this.mStyle.size = size || style.size;\r\n\r\n    /**\r\n     * @private\r\n     * @type {boolean}\r\n     */\r\n    this.mAutoSize = true;\r\n\r\n    /**\r\n     * @private\r\n     * @type {boolean}\r\n     */\r\n    this.mMultiLine = true;\r\n\r\n    /**\r\n     * @private\r\n     * @type {number}\r\n     */\r\n    this.mLineHeight = 1.2;\r\n\r\n    /**\r\n     * @public\r\n     * @type {string[]|string}\r\n     */\r\n    this.lines = [];\r\n\r\n    /**\r\n     * Useful for drivers\r\n     * @public\r\n     * @type {number[]}\r\n     */\r\n    this.lineWidths = [];\r\n\r\n    /**\r\n     * @private\r\n     * @type {number}\r\n     */\r\n    this.mLetterSpacing = 0;\r\n\r\n    /**\r\n     * @private\r\n     * @type {number}\r\n     */\r\n    this.mFieldWidth = 0;\r\n\r\n    /**\r\n     * @private\r\n     * @type {number}\r\n     */\r\n    this.mFieldHeight = this.mStyle.size * this.mLineHeight;\r\n    \r\n    this.onGetLocalBounds(this.mCacheBounds);\r\n  }\r\n\r\n  /**\r\n   * @ignore\r\n   * @override\r\n   * @protected\r\n   * @param {VideoNullDriver} video\r\n   * @param {number} time\r\n   * @param {number} parentAlpha\r\n   *\r\n   * @return {void}\r\n   */\r\n  __render(video, time, parentAlpha) {\r\n    if (this.mAlpha <= 0 || this.mVisible === false) return;\r\n\r\n    this.worldAlpha = parentAlpha * this.mAlpha;\r\n\r\n    if (this.mNeedInvalidate) {\r\n      this.onGetLocalBounds(this.mCacheBounds);\r\n      // this.setTransformDirty();  // no anchor for rebound\r\n    }\r\n\r\n    video.setTransform(this.worldTransformation);\r\n    video.globalAlpha = parentAlpha * this.mAlpha;\r\n    video.globalBlendMode = this.blendMode;\r\n    video.drawText(this, this.mStyle, this.mCacheBounds);\r\n\r\n    this.mNeedInvalidate = false;\r\n    super.__render(video, time, this.worldAlpha);\r\n  }\r\n\r\n  /**\r\n   * @protected\r\n   * @override\r\n   * @ignore\r\n   * @param {Rectangle=} outRect\r\n   *\r\n   * @return {Rectangle}\r\n   */\r\n  onGetLocalBounds(outRect = undefined) {\r\n    outRect = outRect || new Rectangle();\r\n\r\n    if (this.mNeedInvalidate) {\r\n      Black.instance.video.measureText(this, this.mStyle, this.mCacheBounds);\r\n    }\r\n\r\n    return outRect.copyFrom(this.mCacheBounds);\r\n  }\r\n\r\n  /**\r\n   * @param {number} value\r\n   * @ignore\r\n   *\r\n   * @return {void}\r\n   */\r\n  set letterSpacing(value) {\r\n    if (this.mLetterSpacing === value) return;\r\n\r\n    this.mLetterSpacing = value;\r\n    // this.setTransformDirty();  // needs pivot update and there is no anchor to accomplish\r\n    this.mNeedInvalidate = true;\r\n  }\r\n\r\n  /**\r\n   * Get/Set letterSpacing value. Default is 0 in pixels.\r\n   *\r\n   * @return {number}\r\n   */\r\n  get letterSpacing() {\r\n    return this.mLetterSpacing;\r\n  }\r\n  \r\n  /**\r\n   * @param {boolean} value\r\n   * @ignore\r\n   *\r\n   * @return {void}\r\n   */\r\n  set multiLine(value) {\r\n    this.mMultiLine = value;\r\n    this.mNeedInvalidate = true;\r\n  }\r\n\r\n  /**\r\n   * Get/Set multiLine value switcher.\r\n   *\r\n   * @return {boolean}\r\n   */\r\n  get multiLine() {\r\n    return this.mMultiLine;\r\n  }\r\n\r\n  /**\r\n   * @param {number} value\r\n   * @ignore\r\n   *\r\n   * @return {void}\r\n   */\r\n  set lineHeight(value) {\r\n    this.mLineHeight = value;\r\n    this.mNeedInvalidate = true;\r\n  }\r\n\r\n  /**\r\n   * Get/Set lines vertical offset. From top previous to top next line.\r\n   *\r\n   * @return {number}\r\n   */\r\n  get lineHeight() {\r\n    return this.mLineHeight;\r\n  }\r\n\r\n  /**\r\n   * Get/Set text size.\r\n   *\r\n   * @return {number}\r\n   */\r\n  get size() {\r\n    return this.mStyle.size;\r\n  }\r\n\r\n  /**\r\n   * @param {number} value\r\n   * @ignore\r\n   *\r\n   * @return {void}\r\n   */\r\n  set size(value) {\r\n    this.mStyle.size = value;\r\n    this.mNeedInvalidate = true;\r\n  }\r\n\r\n  /**\r\n   * Get/Set text font.\r\n   *\r\n   * @return {string}\r\n   */\r\n  get font() {\r\n    return this.mStyle.name;\r\n  }\r\n\r\n  /**\r\n   * @param {string} value\r\n   * @ignore\r\n   *\r\n   * @return {void}\r\n   */\r\n  set font(value) {\r\n    this.mStyle.name = value;\r\n    this.mNeedInvalidate = true;\r\n  }\r\n\r\n  /**\r\n   * Specifies text color as hexadecimal number eg 0xff0000 (total red)\r\n   *\r\n   * @return {number}\r\n   */\r\n  get color() {\r\n    return this.mStyle.color;\r\n  }\r\n\r\n  /**\r\n   * @param {number} value\r\n   * @ignore\r\n   *\r\n   * @return {void}\r\n   */\r\n  set color(value) {\r\n    this.mStyle.color = value;\r\n  }\r\n\r\n  /**\r\n   * Get/Set text style.\r\n   *\r\n   * @return {TextInfo.FontStyle}\r\n   */\r\n  get style() {\r\n    return this.mStyle.style;\r\n  }\r\n\r\n  /**\r\n   *\r\n   * @param {TextInfo.FontStyle} value\r\n   * @ignore\r\n   *\r\n   * @return {void}\r\n   */\r\n  set style(value) {\r\n    this.mStyle.style = value;\r\n    this.mNeedInvalidate = true;\r\n  }\r\n\r\n  /**\r\n   * Specifies the font thick. The value is set from 100 to 900 in increments of 100.\r\n   *\r\n   * @return {TextInfo.FontWeight}\r\n   */\r\n  get weight() {\r\n    return this.mStyle.weight;\r\n  }\r\n\r\n  /**\r\n   * @param {TextInfo.FontWeight} value\r\n   * @ignore\r\n   *\r\n   * @return {void}\r\n   */\r\n  set weight(value) {\r\n    this.mStyle.weight = value;\r\n    this.mNeedInvalidate = true;\r\n  }\r\n\r\n  /**\r\n   * Specifies the horizontal alignment left | center | right\r\n   *\r\n   * @return {TextInfo.FontAlign}\r\n   */\r\n  get align() {\r\n    return this.mStyle.align;\r\n  }\r\n\r\n  /**\r\n   * @param {TextInfo.FontAlign} value\r\n   * @ignore\r\n   *\r\n   * @return {void}\r\n   */\r\n  set align(value) {\r\n    this.mStyle.align = value;\r\n  }\r\n\r\n  /**\r\n   * Specifies stroke color as hexadecimal number eg 0xff0000 (total red)\r\n   * @return {number}\r\n   */\r\n  get strokeColor() {\r\n    return this.mStyle.strokeColor;\r\n  }\r\n\r\n  /**\r\n   * @param {number} value\r\n   * @ignore\r\n   *\r\n   * @return {void}\r\n   */\r\n  set strokeColor(value) {\r\n    this.mStyle.strokeColor = value;\r\n  }\r\n\r\n  /**\r\n   * Specifies the thickness of the stroke. 0 means that no stroke\r\n   * @return {number}\r\n   */\r\n  get strokeThickness() {\r\n    return this.mStyle.strokeThickness;\r\n  }\r\n\r\n  /**\r\n   * @param {number} value\r\n   * @ignore\r\n   *\r\n   * @return {void}\r\n   */\r\n  set strokeThickness(value) {\r\n    if (value === this.mStyle.strokeThickness) return;\r\n    this.mStyle.strokeThickness = value;\r\n    this.mNeedInvalidate = true;\r\n  }\r\n\r\n  /**\r\n   * Specifies the width of the text field. If autoSize set as false\r\n   *\r\n   * @return {number}\r\n   */\r\n  get fieldWidth() {\r\n    return this.mFieldWidth;\r\n  }\r\n\r\n  /**\r\n   * @param {number} value\r\n   * @ignore\r\n   *\r\n   * @return {void}\r\n   */\r\n  set fieldWidth(value) {\r\n    if (value === this.mFieldWidth) return;\r\n    this.mFieldWidth = value;\r\n    this.mNeedInvalidate = true;\r\n  }\r\n\r\n  /** Specifies the height of the text field, if autoSize set as false\r\n   *\r\n   * @return {number}\r\n   */\r\n  get fieldHeight() {\r\n    return this.mFieldHeight;\r\n  }\r\n\r\n\r\n  /**\r\n   * @param {number} value\r\n   * @ignore\r\n   *\r\n   * @return {void}\r\n   */\r\n  set fieldHeight(value) {\r\n    if (value === this.mFieldHeight) return;\r\n    this.mFieldHeight = value;\r\n    this.mNeedInvalidate = true;\r\n  }\r\n\r\n  /**Text to be displayed inside this text field.\r\n\r\n   * @return {string}\r\n   */\r\n  get text() {\r\n    return this.mText;\r\n  }\r\n\r\n  /**\r\n   * @param {string} value\r\n   * @ignore\r\n   *\r\n   * @return {void}\r\n   */\r\n  set text(value) {\r\n    if (this.mText === value)\r\n      return;\r\n\r\n    this.mText = value;\r\n    this.mNeedInvalidate = true;\r\n  }\r\n\r\n  /**\r\n   * Determines whether the size of the field will adjust to the size of the text. Note: if this set as true, you need to specify fieldHeight and fieldWidth manually\r\n   *\r\n   * @return {boolean}\r\n   */\r\n  get autoSize() {\r\n    return this.mAutoSize;\r\n  }\r\n\r\n  /**\r\n   * @param {boolean} value\r\n   * @ignore\r\n   *\r\n   * @return {void}\r\n   */\r\n  set autoSize(value) {\r\n    if (this.mAutoSize === value) return;\r\n    this.mAutoSize = value;\r\n    this.mNeedInvalidate = true;\r\n  }\r\n\r\n  // alignPivot(ax, ay, includeChildren = false) {\r\n  //   this.mNeedInvalidate = true;\r\n  //   super.alignPivot(ax, ay, includeChildren);\r\n  // }\r\n}\r\n","/**\r\n * Contains system functions.\r\n * @static\r\n * @cat system\r\n */\r\n\r\nclass Device {\r\n  /**\r\n   * Static class.\r\n   */\r\n  constructor() {\r\n    /**\r\n     * @private\r\n     * @type {Device}\r\n     */\r\n    this.constructor.mInstance = this;\r\n\r\n    /**\r\n     * @private\r\n     * @type {number}\r\n     */\r\n    this.mPixelRatio = 0;\r\n\r\n    /**\r\n     * @private\r\n     * @type {number}\r\n     */\r\n    Device.mInstance.mPixelRatio = Device.getDevicePixelRatio();\r\n  }\r\n\r\n  /**\r\n   * Returns current OS name.\r\n   * @return {string}\r\n   */\r\n  static get os() {\r\n    var userAgent = navigator.userAgent || navigator.vendor || window.opera;\r\n\r\n    if (/windows phone/i.test(userAgent))\r\n      return 'Windows Phone';\r\n\r\n    if (/android/i.test(userAgent))\r\n      return 'Android';\r\n\r\n    if (/iPad|iPhone|iPod/.test(userAgent)/* && !window.MSStream*/)\r\n      return 'iOS';\r\n\r\n    return 'unknown';\r\n  }\r\n\r\n  /**\r\n   * Returns True if touch screen is present.\r\n   *\r\n   * @return {boolean}\r\n   */\r\n  static get isTouch() {\r\n    let hasEvent = 'ontouchstart' in window;\r\n    if (hasEvent)\r\n      return true;\r\n\r\n    if (navigator.maxTouchPoints > 0)\r\n      return true;\r\n\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * Returns True if engine is running on mobile device.\r\n   *\r\n   * @return {boolean}\r\n   */\r\n  static get isMobile() {\r\n    return /Mobi/.test(navigator.userAgent);\r\n  }\r\n\r\n  /**\r\n   * Returns screen pixel ratio.\r\n   *\r\n   * @return {number}\r\n   */\r\n  static get pixelRatio() {\r\n    return Device.mInstance.mPixelRatio;\r\n  }\r\n\r\n  /**\r\n   * @private\r\n   *\r\n   * @suppress {missingProperties}\r\n   *\r\n   * @return {number} Description\r\n   */\r\n  static getDevicePixelRatio() {\r\n    if (window.screen.systemXDPI !== undefined && window.screen.logicalXDPI !== undefined && window.screen.systemXDPI > window.screen.logicalXDPI)\r\n      return window.screen.systemXDPI / window.screen.logicalXDPI;\r\n    else if (window.devicePixelRatio !== undefined)\r\n      return window.devicePixelRatio;\r\n\r\n    return 1;\r\n  }\r\n\r\n}\r\n\r\n/**\r\n * @private\r\n * @type {Device}\r\n * @nocollapse\r\n */\r\nDevice.mInstance = null;\r\n","/**\r\n * Base class for distribution objects.\r\n *\r\n * @cat scatters\r\n */\r\n\r\nclass Scatter {\r\n  /**\r\n   * Creates new Scatter instance.\r\n   */\r\n  constructor() {}\r\n\r\n  /**\r\n   * Returns random value.\r\n   * @return {*} Any object.\r\n   */\r\n  getValue() {}\r\n\r\n  /**\r\n   * Returns value at given position.\r\n   *\r\n   * @param {number} t Position to get value at.\r\n   *\r\n   * @return {*} Any object.\r\n   */\r\n  getValueAt(t) {}\r\n}\r\n","/**\r\n * A number scatter for defining a range in 1D space.\r\n *\r\n * @cat scatters\r\n * @extends Scatter\r\n */\r\n\r\nclass FloatScatter extends Scatter {\r\n  /**\r\n   * Creates new FloatScatter instance.\r\n   *\r\n   * @param {number}      min             The min value along x-axis.\r\n   * @param {number}      [max=undefined] The max value along x-axis.\r\n   * @param {function(number):number} [ease=null]     Easing function.\r\n   */\r\n  constructor(min, max = undefined, ease = null) {\r\n    super();\r\n\r\n    // NOTE: dont make us @private @member\r\n\r\n    /** @type {number} */\r\n    this.min = min;\r\n\r\n    /** @type {number} */\r\n    this.max = max == null ? min : max;\r\n\r\n    /** @type {function(number):number} */\r\n    this.ease = ease;\r\n  }\r\n\r\n  /**\r\n   * Returns random number withing defined range.\r\n   *\r\n   * @override\r\n   *\r\n   * @return {number} Random number.\r\n   */\r\n  getValue() {\r\n    return Math.random() * (this.max - this.min) + this.min;\r\n  }\r\n\r\n  /**\r\n   * Returns value at given position within defined range.\r\n   *\r\n   * @override\r\n   * @param {number} t The position.\r\n   *\r\n   * @return {number} Number at given position.\r\n   */\r\n  getValueAt(t) {\r\n    if (this.ease !== null)\r\n      t = this.ease(t);\r\n\r\n    return this.min + t * (this.max - this.min);\r\n  }\r\n}\r\n","/**\r\n * A number scatter for defining a range in 2D space.\r\n *\r\n * @cat scatters\r\n * @extends Scatter\r\n */\r\n\r\nclass VectorScatter extends Scatter {\r\n  /**\r\n   * Creates new VectorScatter instance.\r\n   *\r\n   * @param {number} minX The min value along x-axis.\r\n   * @param {number} minY The min value along y-axis.\r\n   * @param {number} maxX The max value along x-axis.\r\n   * @param {number} maxY The max value along y-axis.\r\n   */\r\n  constructor(minX, minY, maxX, maxY) {\r\n    super();\r\n\r\n    // NOTE: dont make us @private @member\r\n    this.minX = minX;\r\n    this.minY = minY;\r\n    this.maxX = maxX;\r\n    this.maxY = maxY;\r\n  }\r\n\r\n  /**\r\n   * Returns a random Vector object at given position within a range specified\r\n   * in the constructor.\r\n   * @override\r\n   *\r\n   * @return {Vector} Vector object with random values withing defined range.\r\n   */\r\n  getValue() {\r\n    let outVector = new Vector();\r\n    outVector.x = Math.random() * (this.maxX - this.minX) + this.minX;\r\n    outVector.y = Math.random() * (this.maxY - this.minY) + this.minY;\r\n    return outVector;\r\n  }\r\n\r\n  /**\r\n   * Returns a Vector object at given position.\r\n   * @override\r\n   *\r\n   * @param {number} t The position.\r\n   *\r\n   * @return {Vector} Vector object representing values in a range at\r\n   * given position.\r\n   */\r\n  getValueAt(t) {\r\n    let outVector = new Vector();\r\n    outVector.x = this.minX + t * (this.maxX - this.minX);\r\n    outVector.y = this.minY + t * (this.maxY - this.minY);\r\n    return outVector;\r\n  }\r\n}\r\n","/**\r\n * A number scatter for defining a range in 2D space on a curve.\r\n *\r\n * @cat scatters\r\n * @extends Scatter\r\n */\r\n\r\nclass FloatCurveScatter extends Scatter {\r\n  /**\r\n   * Creates new FloatCurveScatter instance.\r\n   * @param {...number} points Coordinates: startX, startY, cpStartX, cpStartY, cpEndX, cpEndY, endX/start2X, endY/start2Y, cp2StartX, cp2StartX... 8 or 14 or 20...\r\n   */\r\n  constructor(...points) {\r\n    super();\r\n\r\n    /**\r\n     * @private\r\n     * @type {Curve}\r\n     */\r\n    this.mCurve = new Curve();\r\n    this.mCurve.baked = true;\r\n    this.mCurve.set(...points);\r\n\r\n    /**\r\n     * @private\r\n     * @type {Vector}\r\n     */\r\n    this.mCache = new Vector();\r\n  }\r\n\r\n  /**\r\n   * Returns a value on a curve at random position.\r\n   * @override\r\n   *\r\n   * @return {number} A random number value on a defined curve.\r\n   */\r\n  getValue() {\r\n    let t = Math.random();\r\n    this.mCurve.interpolate(t, this.mCache);\r\n    return this.mCache.y;\r\n  }\r\n\r\n  /**\r\n   * Returns a number at given position on a curve.\r\n   * @override\r\n   *\r\n   * @param {number} t The position.\r\n   *\r\n   * @return {number} A value on a curve at given position.\r\n   */\r\n  getValueAt(t) {\r\n    this.mCurve.interpolate(t, this.mCache);\r\n    return this.mCache.y;\r\n  }\r\n}\r\n","/**\r\n * A base class for particle system actions. Every frame each action executed over each particle.\r\n *\r\n * @cat particles.actions\r\n * @abstract\r\n * @class\r\n */\r\n\r\nclass Action {\r\n  /**\r\n   * Creates new Action instance.\r\n   */\r\n  constructor(){\r\n  }\r\n\r\n  /**\r\n   * Called for every particle before any update method called.\r\n   *\r\n   * @protected\r\n   * @param {number} dt Amount of seconds since the last update.\r\n   *\r\n   * @return {void} Description\r\n   */\r\n  preUpdate(dt) {}\r\n\r\n\r\n  /**\r\n   * Called for every particle.\r\n   *\r\n   * @param {Emitter} emmiter   The owner of the particle.\r\n   * @param {Particle} particle The particle to execute update on.\r\n   * @param {number} dt         Amount of seconds since the last update.\r\n   *\r\n   * @return {void}\r\n   */\r\n  update(emmiter, particle, dt) {}\r\n\r\n\r\n  /**\r\n   * Called after all updates have been executed.\r\n   *\r\n   * @param {number} dt Amount of seconds since the last update.\r\n   *\r\n   * @return {void}\r\n   */\r\n  postUpdate(dt) {}\r\n}\r\n","/**\r\n * Adds acceleration to particles along given direction.\r\n *\r\n * @cat particles.actions\r\n * @extends Action\r\n * @class\r\n */\r\n\r\nclass Acceleration extends Action {\r\n  /**\r\n   * Creates new Acceleration instance.\r\n   *\r\n   * @param {VectorScatter} vectorScatter An VectorScatter which defines acceleration direction.\r\n   */\r\n  constructor(vectorScatter) {\r\n    super();\r\n\r\n    /**\r\n     * @private\r\n     * @type {VectorScatter}\r\n     */\r\n    this.mScatter = vectorScatter;\r\n  }\r\n\r\n  /**\r\n   * @inheritDoc\r\n   *\r\n   * @param {Emitter} emmiter\r\n   * @param {Particle} particle\r\n   * @param {number} dt\r\n   *\r\n   * @return {void}\r\n   */\r\n  update(emmiter, particle, dt) {\r\n    let v = this.mScatter.getValue();\r\n\r\n    particle.ax += v.x;\r\n    particle.ay += v.y;\r\n  }\r\n\r\n\r\n  /**\r\n   * Returns VectorScatter object that defines acceleration direction.\r\n   * @member {VectorScatter}\r\n   * @return {VectorScatter}\r\n   */\r\n  get scatter() {\r\n    return this.mScatter;\r\n  }\r\n}\r\n","/**\r\n * Sets particle's alpha value according to its energy value.\r\n *\r\n * @cat particles.actions\r\n * @extends Action\r\n * @class\r\n */\r\n\r\nclass AlphaOverLife extends Action {\r\n  /**\r\n   * Creates new AlphaOverLife instance.\r\n   *\r\n   * @param {FloatScatter} floatScatter A starting and ending values of alpha property.\r\n   */\r\n  constructor(floatScatter) {\r\n    super();\r\n\r\n    /**\r\n     * @private\r\n     * @type {FloatScatter}\r\n     */\r\n    this.mScatter = floatScatter;\r\n  }\r\n\r\n  /**\r\n   * @inheritDoc\r\n   *\r\n   * @param {Emitter} emmiter\r\n   * @param {Particle} particle\r\n   * @param {number} dt\r\n   *\r\n   * @return {void}\r\n   */\r\n  update(emmiter, particle, dt) {\r\n    particle.alpha = this.mScatter.getValueAt(particle.energy);\r\n  }\r\n\r\n  /**\r\n   * Returns FloatScatter object that defines alpha value over particle life.\r\n   * @member {FloatScatter}\r\n   * @return {FloatScatter}\r\n   */\r\n  get scatter() {\r\n    return this.mScatter;\r\n  }\r\n}\r\n","/**\r\n * Sets particle's scale value according to its energy value.\r\n *\r\n * @cat particles.actions\r\n * @extends Action\r\n * @class\r\n */\r\n\r\nclass ScaleOverLife extends Action {\r\n  constructor(floatScatter) {\r\n    super();\r\n\r\n    /**\r\n     * @private\r\n     * @type {FloatScatter}\r\n     */\r\n    this.mScatter = floatScatter;\r\n  }\r\n\r\n  /**\r\n   * @inheritDoc\r\n   * \r\n   * @param {Emitter} emmiter\r\n   * @param {Particle} particle\r\n   * @param {number} dt\r\n   *\r\n   * @return {void}\r\n   */\r\n  update(emmiter, particle, dt) {\r\n    particle.scale = this.mScatter.getValueAt(particle.energy);\r\n  }\r\n\r\n  /**\r\n   * Returns FloatScatter object that defines scale value over particle life.\r\n   * @member {FloatScatter}\r\n   * @return {FloatScatter}\r\n   */\r\n  get scatter() {\r\n    return this.mScatter;\r\n  }\r\n}\r\n","/**\r\n * Sets particle's rotation value according to its energy value.\r\n *\r\n * @cat particles.actions\r\n * @extends Action\r\n * @class\r\n */\r\n\r\nclass RotationOverLife extends Action {\r\n  constructor(floatScatter) {\r\n    super();\r\n\r\n    /**\r\n     * @private\r\n     * @type {FloatScatter}\r\n     */\r\n    this.mScatter = floatScatter;\r\n  }\r\n\r\n  /**\r\n   * @inheritDoc\r\n   *\r\n   * @param {Emitter} emmiter\r\n   * @param {Particle} particle\r\n   * @param {number} dt\r\n   *\r\n   * @return {void}\r\n   */\r\n  update(emmiter, particle, dt) {\r\n    particle.r = this.mScatter.getValueAt(particle.energy);\r\n  }\r\n\r\n  /**\r\n   * Returns FloatScatter object that defines rotation value over particle life.\r\n   * @member {FloatScatter}\r\n   * @return {FloatScatter}\r\n   */\r\n  get scatter() {\r\n    return this.mScatter;\r\n  }\r\n}\r\n","/**\r\n * Sets particle's texture according to its energy value.\r\n *\r\n * @cat particles.actions\r\n * @extends Action\r\n * @class\r\n */\r\n\r\nclass TextureOverLife extends Action {\r\n  constructor(floatScatter) {\r\n    super();\r\n\r\n    /**\r\n     * @private\r\n     * @type {FloatScatter}\r\n     */\r\n    this.mScatter = floatScatter;\r\n  }\r\n\r\n  /**\r\n   * @inheritDoc\r\n   *\r\n   * @param {Emitter} emmiter\r\n   * @param {Particle} particle\r\n   * @param {number} dt\r\n   *\r\n   * @return {void}\r\n   */\r\n  update(emmiter, particle, dt) {\r\n    particle.textureIndex = ~~this.mScatter.getValueAt(particle.energy);\r\n  }\r\n\r\n  /**\r\n   * Returns FloatScatter object that defines texture value over particle life.\r\n   * @member {FloatScatter}\r\n   * @return {FloatScatter}\r\n   */\r\n  get scatter() {\r\n    return this.mScatter;\r\n  }\r\n}\r\n","/**\r\n * Base class for particle's initializators. Each initializer updates particle data once at start, eg when particle added to scene.\r\n *\r\n * @cat particles.initializers\r\n */\r\n\r\nclass Initializer {\r\n  /**\r\n   * Creates new Initializer instance.\r\n   */\r\n  constructor() {\r\n  }\r\n\r\n  /**\r\n   * This method is called on every new particle and sets its starting values.\r\n   * Override this method when creating custom initializers.\r\n   *\r\n   * @param {Particle} particle\r\n   *\r\n   * @return {void}\r\n   */\r\n  initialize(particle) {}\r\n}\r\n","/**\r\n * Sets starting particle's life.\r\n *\r\n * @cat particles.initializers\r\n * @extends Initializer\r\n */\r\n\r\nclass Life extends Initializer {\r\n  /**\r\n   * Creates new LIfe instance.\r\n   *\r\n   * @param {FloatScatter} floatScatter The min/max range.\r\n   */\r\n  constructor(floatScatter) {\r\n    super();\r\n\r\n    /**\r\n     * The min-max range.\r\n     * @type {FloatScatter}\r\n     */\r\n    this.scatter = floatScatter;\r\n  }\r\n\r\n  /**\r\n   * @inheritDoc\r\n   * @param {Particle} particle\r\n   *\r\n   * @return {void}\r\n   */\r\n  initialize(particle) {\r\n    particle.life = this.scatter.getValue();\r\n  }\r\n}\r\n","/**\r\n * Sets starting particle's mass.\r\n *\r\n * @cat particles.initializers\r\n * @extends Initializer\r\n * @class\r\n */\r\n\r\nclass Mass extends Initializer {\r\n  /**\r\n   * Creates new Mass instance.\r\n   *\r\n   * @param {number} mass The mass.\r\n   */\r\n  constructor(mass) {\r\n    super();\r\n\r\n    /**\r\n     * The mass value.\r\n     * @type {number}\r\n     */\r\n    this.mass = mass;\r\n  }\r\n\r\n  /**\r\n   * @inheritDoc\r\n   * @param {Particle} particle\r\n   *\r\n   * @return {void}\r\n   */\r\n  initialize(particle) {\r\n    particle.mass = this.mass;\r\n  }\r\n}\r\n","/**\r\n * Sets particle's starting scale.\r\n *\r\n * @cat particles.initializers\r\n * @extends Initializer\r\n * @class\r\n */\r\n\r\nclass Scale extends Initializer {\r\n  /**\r\n   * Creates new Scale instance.\r\n   *\r\n   * @param {FloatScatter} floatScatter The min-max range for starting scale.\r\n   */\r\n  constructor(floatScatter) {\r\n    super();\r\n\r\n    /**\r\n     * The min-max range for starting scale.\r\n     * @type {FloatScatter}\r\n     */\r\n    this.scatter = floatScatter;\r\n  }\r\n\r\n  /**\r\n   * @inheritDoc\r\n   * @param {Particle} particle\r\n   *\r\n   * @return {void}\r\n   */\r\n  initialize(particle) {\r\n    particle.scale = this.scatter.getValue();\r\n  }\r\n}\r\n","/**\r\n * Sets particle's starting velocity.\r\n *\r\n * @cat particles.initializers\r\n * @extends Initializer\r\n * @class\r\n */\r\n\r\nclass Velocity extends Initializer {\r\n  /**\r\n   * Creates new Velocity instance.\r\n   *\r\n   * @param {VectorScatter} vectorScatter The min-max range for starting velocity.\r\n   */\r\n  constructor(vectorScatter) {\r\n    super();\r\n\r\n    /**\r\n     * The min-max range for starting velocity.\r\n     * @type {VectorScatter}\r\n     */\r\n    this.scatter = vectorScatter;\r\n  }\r\n\r\n  /**\r\n   * @inheritDoc\r\n   * @param {Particle} particle\r\n   *\r\n   * @return {void}\r\n   */\r\n  initialize(particle) {\r\n    // TODO: optimize!\r\n    let v = this.scatter.getValue();\r\n    particle.vx = v.x;\r\n    particle.vy = v.y;\r\n  }\r\n}\r\n","/**\r\n * Sets starting particle's position.\r\n *\r\n * @cat particles.initializers\r\n * @extends Initializer\r\n * @class\r\n */\r\n\r\nclass Position extends Initializer {\r\n  /**\r\n   * Creates new Position instance.\r\n   *\r\n   * @param {VectorScatter} vectorScatter The min/max range.\r\n   */\r\n  constructor(vectorScatter) {\r\n    super();\r\n\r\n    /**\r\n     * The min-max range for position distribution.\r\n     * @type {VectorScatter}\r\n     */\r\n    this.scatter = vectorScatter;\r\n  }\r\n\r\n  /**\r\n   * @inheritDoc\r\n   * @param {Particle} particle\r\n   *\r\n   * @return {void}\r\n   */\r\n  initialize(particle) {\r\n    // TODO: optimize!\r\n    let v = this.scatter.getValue();\r\n    particle.x = v.x;\r\n    particle.y = v.y;\r\n  }\r\n}\r\n","/**\r\n * Sets particle's default rotation.\r\n *\r\n * @cat particles.initializers\r\n * @extends Initializer\r\n */\r\n\r\nclass Rotation extends Initializer {\r\n  /**\r\n   * Creates new Rotation instance.\r\n   *\r\n   * @param {FloatScatter} floatScatter The min-max range for starting rotation.\r\n   */\r\n  constructor(floatScatter) {\r\n    super();\r\n\r\n    /**\r\n     * The min-max range for starting rotation\r\n     * @type {FloatScatter}\r\n     */\r\n    this.scatter = floatScatter;\r\n  }\r\n\r\n  /**\r\n   * @inheritDoc\r\n   * @param {Particle} particle\r\n   *\r\n   * @return {void}\r\n   */\r\n  initialize(particle) {\r\n    particle.r = this.scatter.getValue();\r\n  }\r\n}\r\n","/**\r\n * Sets particle's texture.\r\n *\r\n * @cat particles.initializers\r\n * @extends Initializer\r\n * @class\r\n */\r\n\r\nclass RandomTexture extends Initializer {\r\n  /**\r\n   * Creates new RandomTexture instance.\r\n   *\r\n   * @param {FloatScatter} floatScatter\r\n   */\r\n  constructor(floatScatter) {\r\n    super();\r\n\r\n    /**\r\n     * The float scatter defines the index of the texture. All values will be\r\n     * rounded.\r\n     *\r\n     * @see {Particle.textureIndex}\r\n     * @type {FloatScatter}\r\n     */\r\n    this.scatter = floatScatter;\r\n  }\r\n\r\n  /**\r\n   * @inheritDoc\r\n   * @param {Particle} particle\r\n   *\r\n   * @return {void}\r\n   */\r\n  initialize(particle) {\r\n    particle.textureIndex = ~~this.scatter.getValue();\r\n  }\r\n}\r\n","/**\r\n * @enum {number}\r\n */\r\nvar EmitterState = {\r\n  PENDING: 0,\r\n  EMITTING: 1,\r\n  FINISHED: 2\r\n};\r\n","/**\r\n * The particle!\r\n *\r\n * @cat particles\r\n * @class\r\n */\r\n\r\nclass Particle {\r\n  constructor() {\r\n    this.reset();\r\n  }\r\n\r\n  /**\r\n   * Resets particle to default state.\r\n   *\r\n   * @returns {void}\r\n   */\r\n  reset() {\r\n    /**\r\n     * The index of a texture.\r\n     * @type {number}\r\n     */\r\n    this.textureIndex = 0;\r\n\r\n    /**\r\n     * The x/y scale of this particle.\r\n     * @type {number}\r\n     */\r\n    this.scale = 1;\r\n\r\n    /**\r\n     * Alpha value.\r\n     * @type {number}\r\n     */\r\n    this.alpha = 1;\r\n\r\n    /**\r\n     * The life of this particle.\r\n     * @type {number}\r\n     */\r\n    this.life = 1;\r\n\r\n    /**\r\n     * The age of this particle.\r\n     * @type {number}\r\n     */\r\n    this.age = 0;\r\n\r\n    /**\r\n     * Relation of life to age.\r\n     * @type {number}\r\n     */\r\n    this.energy = this.age / this.life;\r\n\r\n    /**\r\n     * The mass.\r\n     * @type {number}\r\n     */\r\n    this.mass = 0;\r\n\r\n    /**\r\n     * X-component.\r\n     * @type {number}\r\n     */\r\n    this.x = 0;\r\n\r\n    /**\r\n     * Y-component.\r\n     * @type {number}\r\n     */\r\n    this.y = 0;\r\n\r\n    /**\r\n     * Rotation of this particle.\r\n     * @type {number}\r\n     */\r\n    this.r = 0\r\n\r\n    /**\r\n     * Velocity by x.\r\n     * @type {number}\r\n     */\r\n    this.vx = 0;\r\n\r\n    /**\r\n     * Velocity by y.\r\n     * @type {number}\r\n     */\r\n    this.vy = 0;\r\n\r\n    /**\r\n     * Particle x-acceleration.\r\n     * @type {number}\r\n     */\r\n    this.ax = 0;\r\n\r\n    /**\r\n     * Particle y-acceleration.\r\n     * @type {number}\r\n     */\r\n    this.ay = 0;\r\n    \r\n    this.pluginName = WebGLParticlesPlugin.name;\r\n  }\r\n\r\n  /**\r\n   * Internal update method.\r\n   *\r\n   * @param {number} dt Time since last update.\r\n   *\r\n   * @return {void}\r\n   */\r\n  update(dt) {\r\n    if (this.life <= 0) {\r\n      this.life = 0;\r\n      return;\r\n    }\r\n\r\n    this.x += this.vx * dt;\r\n    this.y += this.vy * dt;\r\n\r\n    if (this.mass > 0) {\r\n      this.ax *= 1 / this.mass;\r\n      this.ay *= 1 / this.mass;\r\n    }\r\n\r\n    this.vx += this.ax * dt;\r\n    this.vy += this.ay * dt;\r\n\r\n    this.ax = 0;\r\n    this.ay = 0;\r\n\r\n    this.life -= dt;\r\n    this.age += dt;\r\n\r\n    this.energy = this.age / (this.age + this.life);\r\n  }\r\n}\r\n","/**\r\n * Particle emitter.\r\n *\r\n * @cat particles\r\n * @extends DisplayObject\r\n * @class\r\n */\r\n\r\nclass Emitter extends DisplayObject {\r\n  /**\r\n   * Creates new Emitter instance.\r\n   */\r\n  constructor() {\r\n    super();\r\n\r\n    /**\r\n     * @private\r\n     * @type {Array<Texture>}\r\n     */\r\n    this.mTextures = null;\r\n\r\n    /**\r\n     * @private\r\n     * @type {Array<Particle>}\r\n     */\r\n    this.mParticles = [];\r\n\r\n    /**\r\n     * @private\r\n     * @type {Array<Particle>}\r\n     */\r\n    this.mRecycled = [];\r\n\r\n    /**\r\n     * @private\r\n     * @type {Array<Initializer>}\r\n     */\r\n    this.mInitializers = [];\r\n\r\n    /**\r\n     * @private\r\n     * @type {Array<Action>}\r\n     */\r\n    this.mActions = [];\r\n\r\n    /**\r\n     * @private\r\n     * @type {GameObject}\r\n     */\r\n    this.mSpace = null;\r\n\r\n    /**\r\n     * @private\r\n     * @type {boolean}\r\n     */\r\n    this.mIsLocal = true;\r\n\r\n    /**\r\n     * @private\r\n     * @type {number}\r\n     */\r\n    this.mMaxParticles = 10000;\r\n\r\n    /**\r\n     * @private\r\n     * @type {FloatScatter}\r\n     */\r\n    this.mEmitCount = new FloatScatter(10);\r\n\r\n    /**\r\n     * @private\r\n     * @type {FloatScatter}\r\n     */\r\n    this.mEmitNumRepeats = new FloatScatter(Infinity);\r\n\r\n    /**\r\n     * @private\r\n     * @type {number}\r\n     */\r\n    this.mEmitNumRepeatsLeft = this.mEmitNumRepeats.getValue();\r\n\r\n    /**\r\n     * @private\r\n     * @type {FloatScatter}\r\n     */\r\n    this.mEmitDuration = new FloatScatter(1);\r\n\r\n    /**\r\n     * @private\r\n     * @type {number}\r\n     */\r\n    this.mEmitDurationLeft = this.mEmitDuration.getValue();\r\n\r\n    /**\r\n     * @private\r\n     * @type {FloatScatter}\r\n     */\r\n    this.mEmitInterval = new FloatScatter(0.1);\r\n\r\n    /**\r\n     * @private\r\n     * @type {number}\r\n     */\r\n    this.mEmitIntervalLeft = this.mEmitInterval.getValue();\r\n\r\n    /**\r\n     * @private\r\n     * @type {FloatScatter}\r\n     */\r\n    this.mEmitDelay = new FloatScatter(1);\r\n\r\n    /**\r\n     * @private\r\n     * @type {number}\r\n     */\r\n    this.mEmitDelayLeft = this.mEmitDelay.getValue();\r\n\r\n    /**\r\n     * @private\r\n     * @type {number}\r\n     */\r\n    this.mNextUpdateAt = 0;\r\n\r\n    /**\r\n     * @private\r\n     * @type {EmitterState}\r\n     */\r\n    this.mState = EmitterState.PENDING;\r\n\r\n    /**\r\n     * @private\r\n     * @type {Matrix}\r\n     */\r\n    this.__tmpLocal = new Matrix();\r\n\r\n    /**\r\n     * @private\r\n     * @type {Matrix}\r\n     */\r\n    this.__tmpWorld = new Matrix();\r\n\r\n    /**\r\n     * @private\r\n     * @type {EmitterSortOrder}\r\n     */\r\n    this.__sortOrder = EmitterSortOrder.FRONT_TO_BACK;\r\n\r\n\r\n    // /** @type {function(a:Particle, b:Particle):number} */\r\n    // this.mComparer = null;\r\n  }\r\n\r\n  resetState() {\r\n    this.mState = EmitterState.PENDING;\r\n  }\r\n\r\n  /**\r\n   * updateNextTick - Updates delay, duration, interval. Use this function each time you change one of those values.\r\n   *\r\n   * @param {number} [dt=0]\r\n   *\r\n   * @return {void}\r\n   */\r\n  updateNextTick(dt = 0) {\r\n    let t = Black.instance.uptime;\r\n    let firstEmit = false;\r\n\r\n    if (this.mState === EmitterState.PENDING) {\r\n      this.mNextUpdateAt = t + this.mEmitDelayLeft;\r\n      this.mEmitDelayLeft -= dt;\r\n\r\n      if (this.mEmitDelayLeft <= 0) {\r\n        this.mEmitDelayLeft = this.mEmitDelay.getValue();\r\n        this.mState = EmitterState.EMITTING;\r\n        firstEmit = true;\r\n      }\r\n    }\r\n\r\n    if (this.mState === EmitterState.EMITTING) {\r\n      if (this.mEmitDurationLeft <= 0) {\r\n        this.mEmitDurationLeft = this.mEmitDuration.getValue();\r\n\r\n        this.mEmitNumRepeatsLeft--;\r\n\r\n        if (this.mEmitNumRepeatsLeft <= 0) {\r\n          this.mState = EmitterState.FINISHED;\r\n\r\n          this.post('complete');\r\n          return;\r\n        } else {\r\n          this.mState = EmitterState.PENDING;\r\n          return;\r\n        }\r\n      } else {\r\n        // we are getting value here each update to make sure we are up to date!\r\n        if (firstEmit) {\r\n          // for a first emit we do not want to add an extra delay. emit now!\r\n          this.mNextUpdateAt = t\r\n          this.mEmitIntervalLeft = this.mEmitInterval.getValue();\r\n        }\r\n        else {\r\n          this.mEmitIntervalLeft -= dt;\r\n          this.mNextUpdateAt = t + this.mEmitIntervalLeft;\r\n          //console.log(this.mEmitIntervalLeft);\r\n\r\n          // reset interval\r\n          if (this.mEmitIntervalLeft <= 0)\r\n            this.mEmitIntervalLeft = this.mEmitInterval.getValue();\r\n        }\r\n      }\r\n\r\n      this.mEmitDurationLeft -= dt;\r\n    }\r\n  }\r\n\r\n\r\n  /**\r\n   * addInitializer - Adds Initializer to the end of the list.\r\n   *\r\n   * @param {Initializer} initializer\r\n   *\r\n   * @return {Initializer}\r\n   */\r\n  addInitializer(initializer) {\r\n    this.mInitializers.push(initializer);\r\n    return initializer;\r\n  }\r\n\r\n\r\n  /**\r\n   * addAction - Adds action to the end of the list.\r\n   *\r\n   * @param {Action} action\r\n   *\r\n   * @return {Action}\r\n   */\r\n  addAction(action) {\r\n    this.mActions.push(action);\r\n    return action;\r\n  }\r\n\r\n  __render(video, time, parentAlpha) {\r\n\r\n    // set blend mode\r\n    video.globalBlendMode = this.blendMode;\r\n    let emitterWorldAlpha = parentAlpha * this.alpha;\r\n\r\n    // tmp matrices\r\n    let localTransform = this.__tmpLocal;\r\n    let worldTransform = this.__tmpWorld;\r\n    localTransform.identity();\r\n\r\n    let texture = null;\r\n\r\n    if (this.mTextures.length > 0) {\r\n      let plength = this.mParticles.length;\r\n\r\n      if (this.__sortOrder == EmitterSortOrder.FRONT_TO_BACK) {\r\n        for (let i = 0; i < plength; i++)\r\n          this.__renderParticle(this.mParticles[i], video, parentAlpha, localTransform, worldTransform);\r\n      }\r\n      else {\r\n        for (let i = plength - 1; i > 0; i--)\r\n          this.__renderParticle(this.mParticles[i], video, parentAlpha, localTransform, worldTransform);\r\n      }\r\n\r\n    }\r\n\r\n    super.__render(video, time, parentAlpha);\r\n  }\r\n\r\n  __renderParticle(particle, video, parentAlpha, localTransform, worldTransform) {\r\n    let texture = this.mTextures[particle.textureIndex];\r\n\r\n    let tw = texture.width * 0.5;\r\n    let th = texture.height * 0.5;\r\n\r\n    if (particle.r === 0) {\r\n      let tx = particle.x - tw * particle.scale;\r\n      let ty = particle.y - th * particle.scale;\r\n      localTransform.set(particle.scale, 0, 0, particle.scale, tx, ty);\r\n    } else {\r\n      let cos = Math.cos(particle.r);\r\n      let sin = Math.sin(particle.r);\r\n      let a = particle.scale * cos;\r\n      let b = particle.scale * sin;\r\n      let c = particle.scale * -sin;\r\n      let d = particle.scale * cos;\r\n\r\n      let tx = particle.x - tw * a - th * c;\r\n      let ty = particle.y - tw * b - th * d;\r\n      localTransform.set(a, b, c, d, tx, ty);\r\n    }\r\n\r\n    if (this.mIsLocal === true) {\r\n      worldTransform.identity();\r\n      worldTransform.copyFrom(localTransform);\r\n      worldTransform.prepend(this.worldTransformation);\r\n    } else {\r\n      this.mSpace.worldTransformation.copyTo(worldTransform);\r\n      worldTransform.append(localTransform);\r\n    }\r\n\r\n    particle.worldAlpha = parentAlpha * particle.alpha;\r\n\r\n    video.setTransform(worldTransform);\r\n    video.globalAlpha = particle.worldAlpha;\r\n\r\n    video.drawImage(particle, texture);\r\n  }\r\n\r\n  onUpdate(dt) {\r\n    // rate logic\r\n    this.updateNextTick(dt);\r\n\r\n    if (Black.instance.uptime >= this.mNextUpdateAt && this.mState === EmitterState.EMITTING)\r\n      this.__create(this.mEmitCount.getValue());\r\n\r\n    // main update login\r\n    let alength = this.mActions.length;\r\n    let plength = this.mParticles.length;\r\n\r\n    for (let i = 0; i < alength; i++)\r\n      this.mActions[i].preUpdate(dt);\r\n\r\n    let particle;\r\n\r\n    let i = this.mParticles.length;\r\n    while (i--) {\r\n      particle = this.mParticles[i];\r\n\r\n      for (let k = 0; k < alength; k++)\r\n        this.mActions[k].update(this, particle, dt);\r\n\r\n      particle.update(dt);\r\n\r\n      if (particle.life === 0) {\r\n        this.mRecycled.push(particle);\r\n        this.mParticles.splice(i, 1);\r\n      }\r\n    }\r\n\r\n    for (let j = 0; j < alength; j++)\r\n      this.mActions[j].postUpdate(dt);\r\n  }\r\n\r\n  __create(amount) {\r\n    let matrix = this.worldTransformation.clone();\r\n    let minv = null;\r\n\r\n    if (this.mIsLocal === false) {\r\n      minv = this.mSpace.worldTransformationInversed.clone();\r\n      matrix.prepend(minv);\r\n    }\r\n\r\n    for (let i = 0; i < amount; i++) {\r\n      let p = null;\r\n\r\n      if (this.mRecycled.length > 0) {\r\n        p = this.mRecycled.pop();\r\n      } else {\r\n        if (this.mParticles.length >= this.mMaxParticles)\r\n          return;\r\n\r\n        p = new Particle();\r\n      }\r\n\r\n      p.reset();\r\n\r\n      for (let k = 0; k < this.mInitializers.length; k++) {\r\n        let initer = this.mInitializers[k];\r\n        initer.initialize(p);\r\n      }\r\n\r\n      if (this.mIsLocal === false) {\r\n        matrix.transformDirectionXY(p.ax, p.ay, Vector.__cache);\r\n        p.ax = Vector.__cache.x;\r\n        p.ay = Vector.__cache.y;\r\n\r\n        matrix.transformDirectionXY(p.vx, p.vy, Vector.__cache);\r\n        p.vx = Vector.__cache.x;\r\n        p.vy = Vector.__cache.y;\r\n\r\n        matrix.transformXY(p.x, p.y, Vector.__cache);\r\n        p.x = Vector.__cache.x;\r\n        p.y = Vector.__cache.y;\r\n      }\r\n\r\n      this.mParticles.push(p);\r\n    }\r\n  }\r\n\r\n\r\n  /**\r\n   * maxParticles\r\n   *\r\n   * @return {number}\r\n   */\r\n  get maxParticles() {\r\n    return this.mMaxParticles;\r\n  }\r\n\r\n\r\n  /**\r\n   * maxParticles\r\n   *\r\n   * @param {number} value\r\n   *\r\n   * @return {void}\r\n   */\r\n  set maxParticles(value) {\r\n    if (value < 0)\r\n      throw new Error('Bad argument error.');\r\n\r\n    this.mMaxParticles = value;\r\n  }\r\n\r\n\r\n  /**\r\n   * emitCount\r\n   *\r\n   * @return {FloatScatter}\r\n   */\r\n  get emitCount() {\r\n    return this.mEmitCount;\r\n  }\r\n\r\n\r\n  /**\r\n   * emitCount\r\n   *\r\n   * @param {FloatScatter} value\r\n   *\r\n   * @return {void}\r\n   */\r\n  set emitCount(value) {\r\n    this.mEmitCount = value;\r\n  }\r\n\r\n\r\n  /**\r\n   * emitNumRepeats\r\n   *\r\n   * @return {FloatScatter}\r\n   */\r\n  get emitNumRepeats() {\r\n    return this.mEmitNumRepeats;\r\n  }\r\n\r\n  /**\r\n   * emitNumRepeats\r\n   *\r\n   * @param {FloatScatter} value\r\n   *\r\n   * @return {void}\r\n   */\r\n  set emitNumRepeats(value) {\r\n    this.mEmitNumRepeats = value;\r\n    this.mEmitNumRepeatsLeft = this.mEmitNumRepeats.getValue();\r\n  }\r\n\r\n\r\n  /**\r\n   * emitDuration\r\n   *\r\n   * @return {FloatScatter}\r\n   */\r\n  get emitDuration() {\r\n    return this.mEmitDuration;\r\n  }\r\n\r\n  /**\r\n   * emitDuration\r\n   *\r\n   * @param {FloatScatter} value\r\n   *\r\n   * @return {void}\r\n   */\r\n  set emitDuration(value) {\r\n    this.mEmitDuration = value;\r\n    this.mEmitDurationLeft = this.mEmitDuration.getValue();\r\n  }\r\n\r\n\r\n  /**\r\n   * emitInterval\r\n   *\r\n   * @return {FloatScatter}\r\n   */\r\n  get emitInterval() {\r\n    return this.mEmitInterval;\r\n  }\r\n\r\n  /**\r\n   * emitInterval\r\n   *\r\n   * @param {FloatScatter} value\r\n   *\r\n   * @return {void}\r\n   */\r\n  set emitInterval(value) {\r\n    this.mEmitInterval = value;\r\n    this.mEmitIntervalLeft = this.mEmitInterval.getValue();\r\n  }\r\n\r\n\r\n  /**\r\n   * emitDelay\r\n   *\r\n   * @return {FloatScatter}\r\n   */\r\n  get emitDelay() {\r\n    return this.mEmitDelay;\r\n  }\r\n\r\n  /**\r\n   * emitDelay\r\n   *\r\n   * @param {FloatScatter} value\r\n   *\r\n   * @return {void}\r\n   */\r\n  set emitDelay(value) {\r\n    this.mEmitDelay = value;\r\n    this.mEmitDelayLeft = this.mEmitDelay.getValue();\r\n  }\r\n\r\n\r\n  /**\r\n   * space\r\n   *\r\n   * @return {GameObject}\r\n   */\r\n  get space() {\r\n    return this.mSpace;\r\n  }\r\n\r\n  /**\r\n   * space\r\n   *\r\n   * @param {GameObject} gameObject\r\n   *\r\n   * @return {void}\r\n   */\r\n  set space(gameObject) {\r\n    this.mSpace = gameObject;\r\n    this.mIsLocal = this.mSpace === null || this.mSpace === this;\r\n  }\r\n\r\n\r\n  /**\r\n   * textures\r\n   *\r\n   * @return {Array<Texture>}\r\n   */\r\n  get textures() {\r\n    return this.mTextures;\r\n  }\r\n\r\n\r\n  /**\r\n   * textures\r\n   *\r\n   * @param {Array<Texture>} value\r\n   *\r\n   * @return {void}\r\n   */\r\n  set textures(value) {\r\n    if (value.length === 0)\r\n      throw new Error('At least one texture must be provided.');\r\n\r\n    this.mTextures = value;\r\n  }\r\n\r\n  /**\r\n   * @return {EmitterSortOrder}\r\n   */\r\n  get sortOrder() {\r\n    return this.__sortOrder;\r\n  }\r\n\r\n  /**\r\n   *\r\n   * @param {EmitterSortOrder} value The order in which particles will be sorted when rendering.\r\n   *\r\n   * @return {void}\r\n   */\r\n  set sortOrder(value) {\r\n    this.__sortOrder = value;\r\n  }\r\n}\r\n\r\n/**\r\n * A blend mode enum.\r\n * @cat particles\r\n * @enum {string}\r\n */\r\n\r\nvar EmitterSortOrder = {\r\n  FRONT_TO_BACK: 'frontToBack',\r\n  BACK_TO_FRONT: 'backToFront'\r\n};\r\n","// TODO: fix jsdoc to display this enum\r\n\r\n/**\r\n * @readonly\r\n * @enum {number}\r\n * @cat input\r\n */\r\n\r\nvar Key = {\r\n  /**\r\n   * @type {number}\r\n   */\r\n  A: 65,\r\n  /**\r\n   * @type {number}\r\n   */\r\n  B: 66,\r\n  /**\r\n   * @type {number}\r\n   */\r\n  C: 67,\r\n  /**\r\n   * @type {number}\r\n   */\r\n  D: 68,\r\n  /**\r\n   * @type {number}\r\n   */\r\n  E: 69,\r\n  /**\r\n   * @type {number}\r\n   */\r\n  F: 70,\r\n  /**\r\n   * @type {number}\r\n   */\r\n  G: 71,\r\n  /**\r\n   * @type {number}\r\n   */\r\n  H: 72,\r\n  /**\r\n   * @type {number}\r\n   */\r\n  I: 73,\r\n  /**\r\n   * @type {number}\r\n   */\r\n  J: 74,\r\n  /**\r\n   * @type {number}\r\n   */\r\n  K: 75,\r\n  /**\r\n   * @type {number}\r\n   */\r\n  L: 76,\r\n  /**\r\n   * @type {number}\r\n   */\r\n  M: 77,\r\n  /**\r\n   * @type {number}\r\n   */\r\n  N: 78,\r\n  /**\r\n   * @type {number}\r\n   */\r\n  O: 79,\r\n  /**\r\n   * @type {number}\r\n   */\r\n  P: 80,\r\n  /**\r\n   * @type {number}\r\n   */\r\n  Q: 81,\r\n  /**\r\n   * @type {number}\r\n   */\r\n  R: 82,\r\n  /**\r\n   * @type {number}\r\n   */\r\n  S: 83,\r\n  /**\r\n   * @type {number}\r\n   */\r\n  T: 84,\r\n  /**\r\n   * @type {number}\r\n   */\r\n  U: 85,\r\n  /**\r\n   * @type {number}\r\n   */\r\n  V: 86,\r\n  /**\r\n   * @type {number}\r\n   */\r\n  W: 87,\r\n  /**\r\n   * @type {number}\r\n   */\r\n  X: 88,\r\n  /**\r\n   * @type {number}\r\n   */\r\n  Y: 89,\r\n  /**\r\n   * @type {number}\r\n   */\r\n  Z: 90,\r\n  /**\r\n   * @type {number}\r\n   */\r\n  DIGIT_0: 48,\r\n  /**\r\n   * @type {number}\r\n   */\r\n  DIGIT_1: 49,\r\n  /**\r\n   * @type {number}\r\n   */\r\n  DIGIT_2: 50,\r\n  /**\r\n   * @type {number}\r\n   */\r\n  DIGIT_3: 51,\r\n  /**\r\n   * @type {number}\r\n   */\r\n  DIGIT_4: 52,\r\n  /**\r\n   * @type {number}\r\n   */\r\n  DIGIT_5: 53,\r\n  /**\r\n   * @type {number}\r\n   */\r\n  DIGIT_6: 54,\r\n  /**\r\n   * @type {number}\r\n   */\r\n  DIGIT_7: 55,\r\n  /**\r\n   * @type {number}\r\n   */\r\n  DIGIT_8: 56,\r\n  /**\r\n   * @type {number}\r\n   */\r\n  DIGIT_9: 57,\r\n  /**\r\n   * @type {number}\r\n   */\r\n  NUMPAD_0: 96,\r\n  /**\r\n   * @type {number}\r\n   */\r\n  NUMPAD_1: 97,\r\n  /**\r\n   * @type {number}\r\n   */\r\n  NUMPAD_2: 98,\r\n  /**\r\n   * @type {number}\r\n   */\r\n  NUMPAD_3: 99,\r\n  /**\r\n   * @type {number}\r\n   */\r\n  NUMPAD_4: 100,\r\n  /**\r\n   * @type {number}\r\n   */\r\n  NUMPAD_5: 101,\r\n  /**\r\n   * @type {number}\r\n   */\r\n  NUMPAD_6: 102,\r\n  /**\r\n   * @type {number}\r\n   */\r\n  NUMPAD_7: 103,\r\n  /**\r\n   * @type {number}\r\n   */\r\n  NUMPAD_8: 104,\r\n  /**\r\n   * @type {number}\r\n   */\r\n  NUMPAD_9: 105,\r\n  /**\r\n   * @type {number}\r\n   */\r\n  NUMPAD_MULTIPLY: 106,\r\n  /**\r\n   * @type {number}\r\n   */\r\n  NUMPAD_ADD: 107,\r\n  /**\r\n   * @type {number}\r\n   */\r\n  NUMPAD_SUBTRACT: 109,\r\n  /**\r\n   * @type {number}\r\n   */\r\n  NUMPAD_DECIMAL: 110,\r\n  /**\r\n   * @type {number}\r\n   */\r\n  NUMPAD_DIVIDE: 111,\r\n  /**\r\n   * @type {number}\r\n   */\r\n  LEFT_ARROW: 37,\r\n  /**\r\n   * @type {number}\r\n   */\r\n  UP_ARROW: 38,\r\n  /**\r\n   * @type {number}\r\n   */\r\n  RIGHT_ARROW: 39,\r\n  /**\r\n   * @type {number}\r\n   */\r\n  DOWN_ARROW: 40,\r\n  /**\r\n   * @type {number}\r\n   */\r\n  BACKSPACE: 8,\r\n  /**\r\n   * @type {number}\r\n   */\r\n  TAB: 9,\r\n  /**\r\n   * @type {number}\r\n   */\r\n  ENTER: 13,\r\n  /**\r\n   * @type {number}\r\n   */\r\n  SHIFT: 16,\r\n  /**\r\n   * @type {number}\r\n   */\r\n  CTRL: 17,\r\n  /**\r\n   * @type {number}\r\n   */\r\n  ALT: 18,\r\n  /**\r\n   * @type {number}\r\n   */\r\n  F1: 112,\r\n  /**\r\n   * @type {number}\r\n   */\r\n  F2: 113,\r\n  /**\r\n   * @type {number}\r\n   */\r\n  F3: 114,\r\n  /**\r\n   * @type {number}\r\n   */\r\n  F4: 115,\r\n  /**\r\n   * @type {number}\r\n   */\r\n  F5: 116,\r\n  /**\r\n   * @type {number}\r\n   */\r\n  F6: 117,\r\n  /**\r\n   * @type {number}\r\n   */\r\n  F7: 118,\r\n  /**\r\n   * @type {number}\r\n   */\r\n  F8: 119,\r\n  /**\r\n   * @type {number}\r\n   */\r\n  F9: 120,\r\n  /**\r\n   * @type {number}\r\n   */\r\n  F10: 121,\r\n  /**\r\n   * @type {number}\r\n   */\r\n  F11: 122,\r\n  /**\r\n   * @type {number}\r\n   */\r\n  F12: 123,\r\n  /**\r\n   * @type {number}\r\n   */\r\n  PAUSE_BREAK: 19,\r\n  /**\r\n   * @type {number}\r\n   */\r\n  CAPS_LOCK: 20,\r\n  /**\r\n   * @type {number}\r\n   */\r\n  ESCAPE: 27,\r\n  /**\r\n   * @type {number}\r\n   */\r\n  PAGE_UP: 33,\r\n  /**\r\n   * @type {number}\r\n   */\r\n  PAGE_DOWN: 34,\r\n  /**\r\n   * @type {number}\r\n   */\r\n  END: 35,\r\n  /**\r\n   * @type {number}\r\n   */\r\n  HOME: 36,\r\n  /**\r\n   * @type {number}\r\n   */\r\n  INSERT: 45,\r\n  /**\r\n   * @type {number}\r\n   */\r\n  DELETE: 46,\r\n  /**\r\n   * @type {number}\r\n   */\r\n  LEFT_WINDOW: 91,\r\n  /**\r\n   * @type {number}\r\n   */\r\n  RIGHT_WINDOW: 92,\r\n  /**\r\n   * @type {number}\r\n   */\r\n  CONTEXT_MENU: 93,\r\n  /**\r\n   * @type {number}\r\n   */\r\n  NUM_LOCK: 144,\r\n  /**\r\n   * @type {number}\r\n   */\r\n  SCROLL_LOCK: 145,\r\n  /**\r\n   * @type {number}\r\n   */\r\n  SEMI_COLON: 186,\r\n  /**\r\n   * @type {number}\r\n   */\r\n  EQUAL_SIGN: 187,\r\n  /**\r\n   * @type {number}\r\n   */\r\n  COMMA: 188,\r\n  /**\r\n   * @type {number}\r\n   */\r\n  DASH: 189,\r\n  /**\r\n   * @type {number}\r\n   */\r\n  PERIOD: 190,\r\n  /**\r\n   * @type {number}\r\n   */\r\n  FORWARD_SLASH: 191,\r\n  /**\r\n   * @type {number}\r\n   */\r\n  BACKQUOTE: 192,\r\n  /**\r\n   * @type {number}\r\n   */\r\n  BRAKET_LEFT: 219,\r\n  /**\r\n   * @type {number}\r\n   */\r\n  BACK_SLASH: 220,\r\n  /**\r\n   * @type {number}\r\n   */\r\n  BRAKET_RIGHT: 221,\r\n  /**\r\n   * @type {number}\r\n   */\r\n  SINGLE_QUOTE: 222,\r\n};\r\n","/**\r\n * Holds information about keyboard event.\r\n *\r\n * @cat input\r\n */\r\n\r\nclass KeyInfo {\r\n\r\n  /**\r\n   * constructor - Description\r\n   *\r\n   * @param {Event} nativeEvent Description\r\n   *\r\n   * @return {void} Description\r\n   */\r\n  constructor(nativeEvent) {\r\n    this.keyCode = nativeEvent.keyCode;\r\n    this.code = nativeEvent.code;\r\n    this.char = nativeEvent.key;\r\n    this.shiftKey = nativeEvent.shiftKey;\r\n    this.altKey = nativeEvent.altKey;\r\n    this.ctrlKey = nativeEvent.ctrlKey;\r\n  }\r\n}\r\n","/**\r\n * A input system class is reponsible for mouse, touch and keyboard input events.\r\n * Pointer events works for a single target only.\r\n * Global Input messages has higher priority.\r\n *\r\n * When GameObject gets a `pointerDown` message it gets target locked. Other\r\n * objects will not receive `pointerMove` or `pointerUp` messages. Target locked\r\n * object will receive `pointerUp` message even if pointer is outside of its\r\n * bounds.\r\n *\r\n * @cat input\r\n * @extends System\r\n */\r\n\r\nclass Input extends System {\r\n  /**\r\n   * Private constructor.\r\n   */\r\n  constructor() {\r\n    super();\r\n\r\n    /**\r\n     * @private\r\n     * @type {Input}\r\n     */\r\n    this.constructor.instance = this;\r\n\r\n    /**\r\n     * @private\r\n     * @type {Vector}\r\n     */\r\n    this.mPointerPosition = new Vector();\r\n\r\n    /**\r\n     * @private\r\n     * @type {Element}\r\n     */\r\n    this.mDom = Black.instance.containerElement;\r\n\r\n    /**\r\n     * @private\r\n     * @type {Array<string>}\r\n     */\r\n    this.mEventList = null;\r\n\r\n    /**\r\n     * @private\r\n     * @type {Array<string>}\r\n     */\r\n    this.mKeyEventList = null;\r\n\r\n    this.__initListeners();\r\n\r\n    /**\r\n     * @private\r\n     * @type {Array<{e: Event, x: number, y:number}>}\r\n     */\r\n    this.mPointerQueue = [];\r\n\r\n    /**\r\n     * @private\r\n     * @type {Array<Event>}\r\n     */\r\n    this.mKeyQueue = [];\r\n\r\n    /**\r\n     * @private\r\n     * @type {Array<number>}\r\n     */\r\n    this.mPressedKeys = [];\r\n\r\n    /**\r\n     * @private\r\n     * @type {boolean}\r\n     */\r\n    this.mIsPointerDown = false;\r\n\r\n    /**\r\n     * @private\r\n     * @type {boolean}\r\n     */\r\n    this.mNeedUpEvent = false;\r\n\r\n    /**\r\n     * NOTE: we need guarantee that keys are not going to chage theirs order\r\n     * when iterating.\r\n     * @private\r\n     * @type {Map}\r\n     */\r\n    this.mInputListeners = new Map();\r\n\r\n    this.mTarget = null;\r\n    this.mTargetComponent = null;\r\n    this.mLockedTarget = null;\r\n\r\n    this.mLastInTargetComponent = null;\r\n  }\r\n\r\n  /**\r\n   * @private\r\n   *\r\n   * @returns {void}\r\n   */\r\n  __initListeners() {\r\n    this.mKeyEventList = Input.mKeyEventList;\r\n    //debugger;\r\n\r\n    if (window.PointerEvent)\r\n      this.mEventList = Input.mPointerEventList;\r\n    else if (Device.isTouch && Device.isMobile)\r\n      this.mEventList = Input.mTouchEventList;\r\n    else\r\n      this.mEventList = Input.mMouseEventList;\r\n\r\n    for (let i = 0; i < 6; i++)\r\n      this.mDom.addEventListener(this.mEventList[i], e => this.__onPointerEvent(e), false);\r\n\r\n    document.addEventListener(this.mEventList[Input.IX_POINTER_UP], e => this.__onPointerEventDoc(e), false);\r\n\r\n    for (let i = 0; i < this.mKeyEventList.length; i++)\r\n      document.addEventListener(this.mKeyEventList[i], e => this.__onKeyEvent(e), false);\r\n  }\r\n\r\n  /**\r\n   * @private\r\n   * @param {Event} e\r\n   *\r\n   * @return {boolean}\r\n   */\r\n  __onKeyEvent(e) {\r\n    if (Black.instance.isPaused === true)\r\n      return false;\r\n\r\n    this.mKeyQueue.push(e);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @private\r\n   * @param {Event} e\r\n   *\r\n   * @returns {void}\r\n   */\r\n  __onPointerEventDoc(e) {\r\n    if (Black.instance.isPaused === true)\r\n      return;\r\n\r\n    // dirty check\r\n    let over = e.target == this.mDom || e.target.parentElement == this.mDom;\r\n\r\n    if (over === false && this.mNeedUpEvent === true) {\r\n      this.mNeedUpEvent = false;\r\n      this.__pushEvent(e);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @private\r\n   * @param {Event} e\r\n   *\r\n   * @return {boolean}\r\n   */\r\n  __onPointerEvent(e) {\r\n    if (Black.instance.isPaused === true)\r\n      return false;\r\n\r\n    e.preventDefault();\r\n\r\n    this.__pushEvent(e);\r\n\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @private\r\n   * @param {Event} e\r\n   *\r\n   * @returns {void}\r\n   */\r\n  __pushEvent(e) {\r\n    let /** @type {Vector|null} */ p = null;\r\n    if (e.type.indexOf('touch') === 0)\r\n      p = this.__getTouchPos(this.mDom, /** @type {TouchEvent} */ (e));\r\n    else\r\n      p = this.__getPointerPos(this.mDom, e);\r\n\r\n    this.mPointerQueue.push({\r\n      e: e,\r\n      x: p.x,\r\n      y: p.y\r\n    });\r\n  }\r\n\r\n  /**\r\n   * @private\r\n   * @param {Element} canvas\r\n   * @param {Event} evt\r\n   *\r\n   * @return {Vector}\r\n   */\r\n  __getPointerPos(canvas, evt) {\r\n    let rect = canvas.getBoundingClientRect();\r\n    let scaleX = canvas.clientWidth / rect.width;\r\n    let scaleY = canvas.clientHeight / rect.height;\r\n    return new Vector((evt.clientX - rect.left) * scaleX, (evt.clientY - rect.top) * scaleY);\r\n  }\r\n\r\n  /**\r\n   * @private\r\n   * @param {Element} canvas\r\n   * @param {TouchEvent} evt\r\n   *\r\n   * @return {Vector}\r\n   */\r\n  __getTouchPos(canvas, evt) {\r\n    let rect = canvas.getBoundingClientRect();\r\n\r\n    /** @type {Touch} */\r\n    let touch = evt.changedTouches[0]; // ios? what about android?\r\n    let x = touch.clientX;\r\n    let y = touch.clientY;\r\n\r\n    let scaleX = canvas.clientWidth / rect.width;\r\n    let scaleY = canvas.clientHeight / rect.height;\r\n    return new Vector((x - rect.left) * scaleX, (y - rect.top) * scaleY);\r\n  }\r\n\r\n  /**\r\n   * @inheritDoc\r\n   * \r\n   * @param {number} dt\r\n   *\r\n   * @return {void}\r\n   */\r\n  onUpdate(dt) {\r\n    // omg, who gave you keyboard?\r\n    this.__updateKeyboard();\r\n\r\n    // we had no actual events but still we need to know if something were moved\r\n    if (this.mPointerQueue.length === 0) {\r\n      this.__findTarget(Input.pointerPosition);\r\n      this.__processInOut(Input.pointerPosition);\r\n    }\r\n\r\n    for (var i = 0; i < this.mPointerQueue.length; i++) {\r\n      let nativeEvent =  this.mPointerQueue[i];\r\n\r\n      // update to the lattest position\r\n      this.mPointerPosition.x = nativeEvent.x;\r\n      this.mPointerPosition.y = nativeEvent.y;\r\n\r\n      let pointerPos = new Vector(nativeEvent.x, nativeEvent.y);\r\n      let eventType = Input.mInputEventsLookup[this.mEventList.indexOf(nativeEvent.e.type)];\r\n\r\n      this.__findTarget(pointerPos);\r\n      this.__processInOut(Input.pointerPosition);\r\n      this.__processNativeEvent(nativeEvent, pointerPos, eventType);\r\n    }\r\n\r\n    // Erase the pointer queue\r\n    this.mPointerQueue.splice(0, this.mPointerQueue.length);\r\n    this.mKeyQueue.splice(0, this.mKeyQueue.length);\r\n  }\r\n\r\n  __findTarget(pos) {\r\n    let obj = GameObject.hits(Black.instance.root, pos);\r\n\r\n    if (obj === null) {\r\n      this.mTarget = null;\r\n      this.mTargetComponent = null;\r\n      return;\r\n    }\r\n\r\n    let c = obj.getComponent(InputComponent);\r\n    if (c === null) {\r\n      this.mTarget = null;\r\n      this.mTargetComponent = null;\r\n      return;\r\n    }\r\n\r\n    if (c.touchable === false) {\r\n      this.mTarget = null;\r\n      this.mTargetComponent = null;\r\n      return;\r\n    }\r\n\r\n    this.mTarget = obj;\r\n    this.mTargetComponent = c;\r\n  }\r\n\r\n  __processNativeEvent(nativeEvent, pos, type) {\r\n    if (type === Input.POINTER_DOWN) {\r\n      this.mIsPointerDown = true;\r\n      this.mNeedUpEvent = true;\r\n    }\r\n    else if (type === Input.POINTER_UP) {\r\n      this.mIsPointerDown = false;\r\n    }\r\n\r\n    this.post(type);\r\n\r\n    if (this.mTarget === null && this.mLockedTarget === null)\r\n      return;\r\n\r\n    let info = new PointerInfo(this.mTarget, pos.x, pos.y);\r\n\r\n    if (type === Input.POINTER_DOWN) {\r\n      this.mLockedTarget = this.mTarget;\r\n    }\r\n    else if (type === Input.POINTER_UP && this.mLockedTarget !== null) {\r\n      this.mLockedTarget.post('~pointerUp', info);\r\n      this.mLockedTarget = null;\r\n      return;\r\n    }\r\n\r\n    let sameTarget = this.mTarget === this.mLockedTarget;\r\n\r\n    if (this.mLockedTarget === null) {\r\n      if (this.mTarget !== null) {\r\n        // regular non locked post\r\n        //console.log('regular');\r\n        this.mTarget.post('~' + type, info);\r\n      }\r\n    } else {\r\n      if (sameTarget === true) {\r\n        // just bubble the event\r\n        this.mLockedTarget.post('~' + type, info);\r\n      }\r\n      else {\r\n        // send skipping this gameObject\r\n        if (this.mLockedTarget.mParent !== null && this.mTarget !== null) {\r\n          console.log('parent');\r\n          this.mLockedTarget.mParent.post('~' + type, info);\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  __postInMessage() {\r\n    if (this.mLockedTarget !== null) {\r\n      if (this.mLockedTarget !== this.mTargetComponent.gameObject && this.mTargetComponent.gameObject !== null)\r\n        return;\r\n    }\r\n\r\n    this.mTargetComponent.mPointerInDispatched = true;\r\n    this.mTargetComponent.gameObject.post('~pointerIn');\r\n    this.mLastInTargetComponent = this.mTargetComponent;\r\n  }\r\n\r\n  __postOutMessage() {\r\n    if (this.mLockedTarget !== null && this.mTargetComponent !== null) {\r\n      if (this.mLockedTarget !== this.mTargetComponent.gameObject)\r\n        return;\r\n    }\r\n\r\n    this.mLastInTargetComponent.mPointerInDispatched = false;\r\n    this.mLastInTargetComponent.gameObject.post('~pointerOut');\r\n    this.mLastInTargetComponent = null;\r\n  }\r\n\r\n  __processInOut(pos) {\r\n\r\n    if (this.mTargetComponent === null) {\r\n      if (this.mLastInTargetComponent !== null)\r\n        this.__postOutMessage();\r\n    } else {\r\n      if (this.mLastInTargetComponent !== null && this.mLastInTargetComponent !== this.mTargetComponent) {\r\n        this.__postOutMessage();\r\n        return;\r\n      }\r\n\r\n      if (this.mTargetComponent.mPointerInDispatched === false)\r\n        this.__postInMessage();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @private\r\n   *\r\n   * @returns {void}\r\n   */\r\n  __updateKeyboard() {\r\n    for (let i = 0; i < this.mKeyQueue.length; i++) {\r\n      let nativeEvent = this.mKeyQueue[i];\r\n\r\n      let ix = this.mKeyEventList.indexOf(nativeEvent.type);\r\n      let pIx = this.mPressedKeys.indexOf(nativeEvent.keyCode);\r\n      let fnName = Input.mKeyEventsLookup[ix];\r\n\r\n      if (fnName === 'keyUp' && pIx !== -1)\r\n        this.mPressedKeys.splice(pIx, 1);\r\n\r\n      else if (fnName === 'keyDown' && pIx === -1) {\r\n        this.mPressedKeys.push(nativeEvent.keyCode);\r\n        fnName = 'keyPress';\r\n      }\r\n\r\n      this.post(fnName, new KeyInfo(nativeEvent), nativeEvent);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Listens for global input event by given message name.\r\n   *\r\n   * @param {string} name            The name of the message to listen for.\r\n   * @param {Function} callback      The callback function that will be called when message received.\r\n   * @param {Object=} [context=null] Optional context.\r\n   *\r\n   * @return {void}\r\n   */\r\n  static on(name, callback, context = null) {\r\n    Input.instance.on(name, callback, context);\r\n  }\r\n\r\n  /**\r\n   * Indicates if mouse or touch in down at this moment.\r\n   *\r\n   * @return {boolean}\r\n   */\r\n  static get isPointerDown() {\r\n    return Input.instance.mIsPointerDown;\r\n  }\r\n\r\n  /**\r\n   * Returns mouse or touch pointer x-component.\r\n   * @return {number}\r\n   */\r\n  static get pointerX() {\r\n    return Input.instance.mPointerPosition.x;\r\n  }\r\n\r\n  /**\r\n   * Returns mouse or touch pointer x-component.\r\n   *\r\n   * @return {number} Description\r\n   */\r\n  static get pointerY() {\r\n    return Input.instance.mPointerPosition.y;\r\n  }\r\n\r\n  /**\r\n   * Returns mouse or touch pointer position.\r\n   *\r\n   * @return {Vector}\r\n   */\r\n  static get pointerPosition() {\r\n    return Input.instance.mPointerPosition;\r\n  }\r\n\r\n  /**\r\n   * Returns list of pressed keys.\r\n   *\r\n   * @returns {Array<number>}\r\n   */\r\n  static get pressedKeys() {\r\n    return Input.instance.mPressedKeys;\r\n  }\r\n}\r\n\r\nInput.POINTER_DOWN = 'pointerDown';\r\nInput.POINTER_MOVE = 'pointerMove';\r\nInput.POINTER_UP   = 'pointerUp';\r\nInput.POINTER_IN   = 'pointerIn';\r\nInput.POINTER_OUT  = 'pointerOut';\r\n\r\n/**\r\n * @type {Input}\r\n * @nocollapse\r\n */\r\nInput.instance = null;\r\n\r\n/**\r\n * @type {number}\r\n * @const\r\n */\r\nInput.IX_POINTER_MOVE = 0;\r\n\r\n/**\r\n * @type {number}\r\n * @const\r\n */\r\nInput.IX_POINTER_DOWN = 1;\r\n\r\n/**\r\n * @type {number}\r\n * @const\r\n */\r\nInput.IX_POINTER_UP = 2;\r\n\r\n// /**\r\n//  * @type {number}\r\n//  * @const\r\n//  */\r\n// Input.IX_POINTER_IN = 3;\r\n//\r\n// /**\r\n//  * @type {number}\r\n//  * @const\r\n//  */\r\n// Input.IX_POINTER_OUT = 4;\r\n\r\n/**\r\n * @private\r\n * @type {Array<string>}\r\n * @const\r\n */\r\nInput.mKeyEventList = ['keydown', 'keyup'];\r\n\r\n/**\r\n * @private\r\n * @type {Array<string>}\r\n * @const\r\n */\r\nInput.mKeyEventsLookup = ['keyDown', 'keyUp', 'keyPress'];\r\n\r\n/**\r\n * @private\r\n * @type {Array<string>}\r\n * @const\r\n */\r\nInput.mInputEventsLookup = ['pointerMove', 'pointerDown', 'pointerUp', 'pointerIn', 'pointerOut'];\r\n\r\n/**\r\n * @private\r\n * @type {Array<string>}\r\n * @const\r\n */\r\nInput.mPointerEventList = ['pointermove', 'pointerdown', 'pointerup', 'pointerenter', 'pointerleave'];\r\n\r\n/**\r\n * @private\r\n * @type {Array<string>}\r\n * @const\r\n */\r\nInput.mMouseEventList = ['mousemove', 'mousedown', 'mouseup', 'mouseenter', 'mouseleave'];\r\n\r\n/**\r\n * @private\r\n * @type {Array<string>}\r\n * @const\r\n */\r\nInput.mTouchEventList = ['touchmove', 'touchstart', 'touchend', 'touchenter', 'touchleave'];\r\n\r\n\r\n/**\r\n * Stores additional information about pointer events.\r\n *\r\n * @cat input\r\n */\r\n\r\nclass PointerInfo {\r\n  /**\r\n   * Creates new PointerInfo instance. For internal use only.\r\n   *\r\n   * @param {GameObject} activeObject\r\n   * @param {number} x\r\n   * @param {number} y\r\n   */\r\n  constructor(activeObject, x, y) {\r\n    /**\r\n     * @private\r\n     * @type {GameObject}\r\n     */\r\n    this.mActiveObject = activeObject;\r\n\r\n    /**\r\n     * @private\r\n     * @type {number}\r\n     */\r\n    this.mX = x;\r\n\r\n    /**\r\n     * @private\r\n     * @type {number}\r\n     */\r\n    this.mY = y;\r\n  }\r\n\r\n  /**\r\n   * Returns the object under cursor right now.\r\n   * @readonly\r\n   *\r\n   * @returns {GameObject}\r\n   */\r\n  get activeObject() {\r\n    return this.mActiveObject;\r\n  }\r\n\r\n  get x() {\r\n    return this.mX;\r\n  }\r\n\r\n  get y() {\r\n    return this.mY;\r\n  }\r\n}\r\n","/**\r\n * This component will allow you to subscribe for some input messages.\r\n *\r\n * @cat input\r\n * @extends Component\r\n */\r\n\r\nclass InputComponent extends Component {\r\n  /**\r\n   * @return {void}\r\n   */\r\n  constructor() {\r\n    super();\r\n\r\n    /** @type {boolean} */\r\n    this.touchable = true;\r\n\r\n    /* INTERNAL */\r\n    /** @type {boolean} */\r\n    this.mPointerInDispatched = false;\r\n  }\r\n}\r\n","/**\r\n * Basic FPS component. Shows frame rate.\r\n *\r\n * @cat components\r\n * @extends Component\r\n */\r\n\r\nclass FPSComponent extends Component  {\r\n  constructor() {\r\n    super();\r\n\r\n    /**\r\n     * @private\r\n     * @type {TextField}\r\n     */\r\n    this.txtFPS = null;\r\n  }\r\n\r\n  onAdded(){\r\n    this.txtFPS = new TextField('FPS: 0');\r\n    this.txtFPS.x = 0;\r\n    this.txtFPS.y = 0;\r\n    this.gameObject.addChild(this.txtFPS);\r\n  }\r\n\r\n  onRemoved(){\r\n  }\r\n\r\n  onUpdate(){\r\n    this.txtFPS.text = 'FPS: ' + Black.instance.FPS;\r\n  }\r\n}\r\n","/**\r\n * Basic mulri resolution utility component. Resizes an GameObject to match desired resolution.\r\n *\r\n * @cat components\r\n * @extends Component\r\n */\r\n\r\nclass MRComponent extends Component {\r\n  /**\r\n   * Creates new instance of MRComponent. Used to scale and position GameObject to a specified width and height.\r\n   * Simplified version of scale manager.\r\n   *\r\n   * @param {number} [width=960]  The width.\r\n   * @param {number} [height=640] The height.\r\n   */\r\n  constructor(width = 960, height = 640) {\r\n    super();\r\n\r\n    /**\r\n     * @private\r\n     * @type {number}\r\n     */\r\n    this.mWidth = width;\r\n\r\n    /**\r\n     * @private\r\n     * @type {number}\r\n     */\r\n    this.mHeight = height;\r\n\r\n    /**\r\n     * @private\r\n     * @type {number}\r\n     */\r\n    this.mScale = 0;\r\n\r\n    /**\r\n     * @private\r\n     * @type {number}\r\n     */\r\n    this.mInvScale = 0;\r\n\r\n    /**\r\n     * @private\r\n     * @type {number}\r\n     */\r\n    this.mAspect = 0;\r\n\r\n    Black.instance.viewport.on('resize', this.__onResize, this);\r\n  }\r\n\r\n  __onResize(msg, rect) {\r\n    this.setSize(this.mWidth, this.mHeight);\r\n  }\r\n\r\n  /**\r\n   * Sets size of the latout.\r\n   *\r\n   * @param  {number} width = 960  The width.\r\n   * @param  {number} height = 640 The height.\r\n   * @return {void}\r\n   */\r\n  setSize(width = 960, height = 640){\r\n    this.mWidth = width;\r\n    this.mHeight = height;\r\n\r\n    this.updateLayout();\r\n  }\r\n\r\n  /**\r\n   * Updates layout to match specified settings.\r\n   *\r\n   * @return {void}\r\n   */\r\n  updateLayout() {\r\n    if (!this.gameObject)\r\n      return;\r\n\r\n    /** @type {Rectangle} */\r\n    let size = Black.instance.viewport.size;\r\n\r\n    /** @type {number} */\r\n    let scaleX = size.width / this.mWidth;\r\n\r\n    /** @type {number} */\r\n    let scaleY = size.height / this.mHeight;\r\n\r\n    this.mScale = Math.min(scaleX, scaleY);\r\n    this.mInvScale = 1 / this.mScale;\r\n\r\n    this.gameObject.scaleX = this.gameObject.scaleY = this.mScale;\r\n    this.gameObject.x = (size.width / 2) - (this.mWidth / 2) * this.mScale;\r\n    this.gameObject.y = (size.height / 2) - (this.mHeight / 2) * this.mScale;\r\n  }\r\n\r\n  onAdded() {\r\n    this.updateLayout();\r\n  }\r\n}\r\n","/**\r\n * A static class with many static easing functions.\r\n *\r\n * @cat animation\r\n * @static\r\n */\r\n\r\nclass Ease {\r\n  /**\r\n   * linear\r\n   * @param {number} k\r\n   * @return {number}\r\n   */\r\n  static linear(k) {\r\n    return k;\r\n  }\r\n\r\n  /**\r\n   * quadraticIn\r\n   *\r\n   * @param {number} k\r\n   *\r\n   * @return {number}\r\n   */\r\n  static quadraticIn(k) {\r\n    return k * k;\r\n  }\r\n\r\n  /**\r\n   * quadraticOut\r\n   *\r\n   * @param {number} k\r\n   *\r\n   * @return {number}\r\n   */\r\n  static quadraticOut(k) {\r\n    return k * (2 - k);\r\n  }\r\n\r\n  /**\r\n   * quadraticInOut\r\n   *\r\n   * @param {number} k\r\n   *\r\n   * @return {number}\r\n   */\r\n  static quadraticInOut(k) {\r\n    if ((k *= 2) < 1)\r\n      return 0.5 * k * k;\r\n\r\n    return -0.5 * (--k * (k - 2) - 1);\r\n  }\r\n\r\n  /**\r\n   * cubicIn\r\n   *\r\n   * @param {number} k\r\n   *\r\n   * @return {number}\r\n   */\r\n  static cubicIn(k) {\r\n    return k * k * k;\r\n  }\r\n\r\n  /**\r\n   * cubicOut\r\n   *\r\n   * @param {number} k\r\n   *\r\n   * @return {number}\r\n   */\r\n  static cubicOut(k) {\r\n    return --k * k * k + 1;\r\n  }\r\n\r\n  /**\r\n   * cubicInOut\r\n   *\r\n   * @param {number} k\r\n   *\r\n   * @return {number}\r\n   */\r\n  static cubicInOut(k) {\r\n    if ((k *= 2) < 1)\r\n      return 0.5 * k * k * k;\r\n\r\n    return 0.5 * ((k -= 2) * k * k + 2);\r\n  }\r\n\r\n  /**\r\n   * quarticIn\r\n   *\r\n   * @param {number} k\r\n   *\r\n   * @return {number}\r\n   */\r\n  static quarticIn(k) {\r\n    return k * k * k * k;\r\n  }\r\n\r\n  /**\r\n   * quarticOut\r\n   *\r\n   * @param {number} k\r\n   *\r\n   * @return {number}\r\n   */\r\n  static quarticOut(k) {\r\n    return 1 - (--k * k * k * k);\r\n  }\r\n\r\n  /**\r\n   * quarticInOut\r\n   *\r\n   * @param {number} k\r\n   *\r\n   * @return {number}\r\n   */\r\n  static quarticInOut(k) {\r\n    if ((k *= 2) < 1)\r\n      return 0.5 * k * k * k * k;\r\n\r\n    return -0.5 * ((k -= 2) * k * k * k - 2);\r\n  }\r\n\r\n  /**\r\n   * quinticIn\r\n   *\r\n   * @param {number} k\r\n   *\r\n   * @return {number}\r\n   */\r\n  static quinticIn(k) {\r\n    return k * k * k * k * k;\r\n  }\r\n\r\n  /**\r\n   * quinticOut\r\n   *\r\n   * @param {number} k\r\n   *\r\n   * @return {number}\r\n   */\r\n  static quinticOut(k) {\r\n    return --k * k * k * k * k + 1;\r\n  }\r\n\r\n  /**\r\n   * quinticInOut\r\n   *\r\n   * @param {number} k\r\n   *\r\n   * @return {number}\r\n   */\r\n  static quinticInOut(k) {\r\n    if ((k *= 2) < 1)\r\n      return 0.5 * k * k * k * k * k;\r\n\r\n    return 0.5 * ((k -= 2) * k * k * k * k + 2);\r\n  }\r\n\r\n  /**\r\n   * sinusoidalIn\r\n   *\r\n   * @param {number} k\r\n   *\r\n   * @return {number}\r\n   */\r\n  static sinusoidalIn(k) {\r\n    return 1 - Math.cos(k * Math.PI / 2);\r\n  }\r\n\r\n  /**\r\n   * sinusoidalOut\r\n   *\r\n   * @param {number} k\r\n   *\r\n   * @return {number}\r\n   */\r\n  static sinusoidalOut(k) {\r\n    return Math.sin(k * Math.PI / 2);\r\n  }\r\n\r\n  /**\r\n   * sinusoidalInOut\r\n   *\r\n   * @param {number} k\r\n   *\r\n   * @return {number}\r\n   */\r\n  static sinusoidalInOut(k) {\r\n    return 0.5 * (1 - Math.cos(Math.PI * k));\r\n  }\r\n\r\n  /**\r\n   * exponentialIn\r\n   *\r\n   * @param {number} k\r\n   *\r\n   * @return {number}\r\n   */\r\n  static exponentialIn(k) {\r\n    return k === 0 ? 0 : Math.pow(1024, k - 1);\r\n  }\r\n\r\n  /**\r\n   * exponentialOut\r\n   *\r\n   * @param {number} k\r\n   *\r\n   * @return {number}\r\n   */\r\n  static exponentialOut(k) {\r\n    return k === 1 ? 1 : 1 - Math.pow(2, -10 * k);\r\n  }\r\n\r\n  /**\r\n   * exponentialInOut\r\n   *\r\n   * @param {number} k\r\n   *\r\n   * @return {number}\r\n   */\r\n  static exponentialInOut(k) {\r\n    if (k === 0)\r\n      return 0;\r\n\r\n    if (k === 1)\r\n      return 1;\r\n\r\n    if ((k *= 2) < 1)\r\n      return 0.5 * Math.pow(1024, k - 1);\r\n\r\n    return 0.5 * (-Math.pow(2, -10 * (k - 1)) + 2);\r\n  }\r\n\r\n  /**\r\n   * circularIn\r\n   *\r\n   * @param {number} k\r\n   *\r\n   * @return {number}\r\n   */\r\n  static circularIn(k) {\r\n    return 1 - Math.sqrt(1 - k * k);\r\n  }\r\n\r\n  /**\r\n   * circularOut\r\n   *\r\n   * @param {number} k\r\n   *\r\n   * @return {number}\r\n   */\r\n  static circularOut(k) {\r\n    return Math.sqrt(1 - (--k * k));\r\n  }\r\n\r\n  /**\r\n   * circularInOut\r\n   *\r\n   * @param {number} k\r\n   *\r\n   * @return {number}\r\n   */\r\n  static circularInOut(k) {\r\n    if ((k *= 2) < 1)\r\n      return -0.5 * (Math.sqrt(1 - k * k) - 1);\r\n\r\n    return 0.5 * (Math.sqrt(1 - (k -= 2) * k) + 1);\r\n  }\r\n\r\n  /**\r\n   * elasticIn\r\n   *\r\n   * @param {number} k\r\n   *\r\n   * @return {number}\r\n   */\r\n  static elasticIn(k) {\r\n    if (k === 0)\r\n      return 0;\r\n\r\n    if (k === 1)\r\n      return 1;\r\n\r\n    return -Math.pow(2, 10 * (k - 1)) * Math.sin((k - 1.1) * 5 * Math.PI);\r\n  }\r\n\r\n  /**\r\n   * elasticOut\r\n   *\r\n   * @param {number} k\r\n   *\r\n   * @return {number}\r\n   */\r\n  static elasticOut(k) {\r\n    if (k === 0)\r\n      return 0;\r\n\r\n    if (k === 1)\r\n      return 1;\r\n\r\n    return Math.pow(2, -10 * k) * Math.sin((k - 0.1) * 5 * Math.PI) + 1;\r\n  }\r\n\r\n  /**\r\n   * elasticInOut\r\n   *\r\n   * @param {number} k\r\n   *\r\n   * @return {number}\r\n   */\r\n  static elasticInOut(k) {\r\n    if (k === 0)\r\n      return 0;\r\n\r\n    if (k === 1)\r\n      return 1;\r\n\r\n    k *= 2;\r\n\r\n    if (k < 1)\r\n      return -0.5 * Math.pow(2, 10 * (k - 1)) * Math.sin((k - 1.1) * 5 * Math.PI);\r\n\r\n    return 0.5 * Math.pow(2, -10 * (k - 1)) * Math.sin((k - 1.1) * 5 * Math.PI) + 1;\r\n\r\n  }\r\n\r\n  /**\r\n   * backIn\r\n   *\r\n   * @param {number} k\r\n   *\r\n   * @return {number}\r\n   */\r\n  static backIn(k) {\r\n    const s = 1.70158;\r\n    return k * k * ((s + 1) * k - s);\r\n  }\r\n\r\n  /**\r\n   * backOut\r\n   *\r\n   * @param {number} k\r\n   *\r\n   * @return {number}\r\n   */\r\n  static backOut(k) {\r\n    const s = 1.70158;\r\n    return --k * k * ((s + 1) * k + s) + 1;\r\n  }\r\n\r\n  /**\r\n   * backInOut\r\n   *\r\n   * @param {number} k\r\n   *\r\n   * @return {number}\r\n   */\r\n  static backInOut(k) {\r\n    const s = 1.70158 * 1.525;\r\n\r\n    if ((k *= 2) < 1)\r\n      return 0.5 * (k * k * ((s + 1) * k - s));\r\n\r\n    return 0.5 * ((k -= 2) * k * ((s + 1) * k + s) + 2);\r\n  }\r\n\r\n  /**\r\n   * bounceIn\r\n   *\r\n   * @param {number} k\r\n   *\r\n   * @return {number}\r\n   */\r\n  static bounceIn(k) {\r\n    return 1 - Ease.bounceOut(1 - k);\r\n  }\r\n\r\n  /**\r\n   * bounceOut\r\n   *\r\n   * @param {number} k\r\n   *\r\n   * @return {number}\r\n   */\r\n  static bounceOut(k) {\r\n    if (k < (1 / 2.75))\r\n      return 7.5625 * k * k;\r\n    else if (k < (2 / 2.75))\r\n      return 7.5625 * (k -= (1.5 / 2.75)) * k + 0.75;\r\n    else if (k < (2.5 / 2.75))\r\n      return 7.5625 * (k -= (2.25 / 2.75)) * k + 0.9375;\r\n\r\n    return 7.5625 * (k -= (2.625 / 2.75)) * k + 0.984375;\r\n  }\r\n\r\n  /**\r\n   * bounceInOut\r\n   *\r\n   * @param {number} k\r\n   *\r\n   * @return {number}\r\n   */\r\n  static bounceInOut(k) {\r\n    if (k < 0.5)\r\n      return Ease.bounceIn(k * 2) * 0.5;\r\n\r\n    return Ease.bounceOut(k * 2 - 1) * 0.5 + 0.5;\r\n  }\r\n\r\n  /**\r\n   * smoothstep\r\n   *\r\n   * @param {number} k\r\n   *\r\n   * @return {number}\r\n   */\r\n  static smootherStep(k) {\r\n    return k * k * k * (k * (6.0 * k - 15.0) + 10.0);\r\n  }\r\n}\r\n","/**\r\n * Interpolation functions.\r\n *\r\n * @cat animation\r\n * @static\r\n */\r\n\r\nclass Interpolation {\r\n  /**\r\n   * Singleton.\r\n   */\r\n  constructor() {}\r\n\r\n  /**\r\n   * linear\r\n   *\r\n   * @param {Array}  v The input array of values to interpolate between.\r\n   * @param {number} k The percentage of interpolation, between 0 and 1.\r\n   * @return {number}  The interpolated value\r\n   */\r\n  static linear(v, k) {\r\n    let m = v.length - 1;\r\n    let f = m * k;\r\n    let i = Math.floor(f);\r\n\r\n    let fn = (p0, p1, t) => {\r\n      return (p1 - p0) * t + p0;\r\n    };\r\n\r\n    if (k < 0) {\r\n      return fn(v[0], v[1], f);\r\n    }\r\n\r\n    if (k > 1) {\r\n      return fn(v[m], v[m - 1], m - f);\r\n    }\r\n\r\n    return fn(v[i], v[i + 1 > m ? m : i + 1], f - i);\r\n  }\r\n\r\n  /**\r\n   * bezier\r\n   *\r\n   * @param {Array}  v The input array of values to interpolate between.\r\n   * @param {number} k The percentage of interpolation, between 0 and 1.\r\n   * @return {number}  The interpolated value\r\n   */\r\n  static bezier(v, k) {\r\n    let b = 0;\r\n    let n = v.length;\r\n    let pow = Math.pow;\r\n    // Bernstein basis polynomials\r\n    let bn = (n, i) => {\r\n      let fc = Interpolation.__factorial;\r\n      return fc(n) / fc(i) / fc(n - i);\r\n    };\r\n\r\n    for (let i = 0; i < n; i++) {\r\n      b += pow(1 - k, n - i) * pow(k, i) * v[i] * bn(n, i);\r\n    }\r\n\r\n    return b;\r\n  }\r\n\r\n  /**\r\n   * catmullRom\r\n   *\r\n   * @param {Array}  v The input array of values to interpolate between.\r\n   * @param {number} k The percentage of interpolation, between 0 and 1.\r\n   * @return {number}  The interpolated value\r\n   */\r\n  static catmullRom(v, k) {\r\n    let m = v.length - 1;\r\n    let f = m * k;\r\n    let i = Math.floor(f);\r\n    let fn = (p0, p1, p2, p3, t) => {\r\n      let v0 = (p2 - p0) * 0.5;\r\n      let v1 = (p3 - p1) * 0.5;\r\n      let t2 = t * t;\r\n      let t3 = t * t2;\r\n\r\n      return ((p1 - p2) * 2 + v0 + v1) * t3 + ((p2 - p1) * 3 - 2 * v0 - v1) * t2 + v0 * t + p1;\r\n    };\r\n\r\n    if (v[0] === v[m]) {\r\n      if (k < 0) {\r\n        i = Math.floor(f = m * (1 + k));\r\n      }\r\n\r\n      return fn(v[(i - 1 + m) % m], v[i], v[(i + 1) % m], v[(i + 2) % m], f - i);\r\n    } else {\r\n      if (k < 0) {\r\n        return v[0] - (fn(v[0], v[0], v[1], v[1], -f) - v[0]);\r\n      }\r\n\r\n      if (k > 1) {\r\n        return v[m] - (fn(v[m], v[m], v[m - 1], v[m - 1], f - m) - v[m]);\r\n      }\r\n\r\n      return fn(v[i ? i - 1 : 0], v[i], v[m < i + 1 ? m : i + 1], v[m < i + 2 ? m : i + 2], f - i);\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * @private\r\n * @param {number} n\r\n *\r\n * @return {number}\r\n */\r\nInterpolation.__factorial = (function() {\r\n  let a = [1];\r\n\r\n  return function(n) {\r\n    if (a[n]) {\r\n      return a[n];\r\n    }\r\n\r\n    let s = n;\r\n\r\n    while (--n) {\r\n      s *= n;\r\n    }\r\n\r\n    a[n] = s;\r\n    return s;\r\n  };\r\n})();\r\n","/**\r\n * A tweening component.\r\n *\r\n * @cat animation\r\n * @unrestricted\r\n * @extends Component\r\n */\r\n\r\nclass Tween extends Component {\r\n  /**\r\n   * Creates new instance of Tween Component.\r\n   * @param {Object}        values            The values to tween.\r\n   * @param {number}        [duration=0.25]   Duraction in seconds.\r\n   * @param {Object|null}   [properties=null] Tween properties Object.\r\n   */\r\n  constructor(values, duration = 0.250, properties = null) {\r\n    super();\r\n\r\n    /**\r\n     * @private\r\n     * @dict\r\n     */\r\n    this.mValues = values;\r\n\r\n    /**\r\n     * @private\r\n     * @type {number}\r\n     */\r\n    this.mDuration = duration;\r\n\r\n    /**\r\n     * @private\r\n     * @dict\r\n     */\r\n    this.mProperties = properties;\r\n\r\n    /**\r\n     * @private\r\n     * @type {boolean}\r\n     */\r\n    this.mIsPlaying = false;\r\n\r\n    /**\r\n     * @private\r\n     * @type {boolean}\r\n     */\r\n    this.mIsPaused = false;\r\n\r\n    /**\r\n     * @private\r\n     * @type {number}\r\n     */\r\n    this.mStartTime = 0;\r\n\r\n    /**\r\n     * @private\r\n     * @type {number}\r\n     */\r\n    this.mPausedTime = 0;\r\n\r\n    /**\r\n     * @private\r\n     * @dict\r\n     */\r\n    this.mValuesStart = {};\r\n\r\n    /**\r\n     * @private\r\n     * @type {number}\r\n     */\r\n    this.mElapsed = 0;\r\n\r\n    /**\r\n     * @private\r\n     * @type {function (Array, number):number}\r\n     */\r\n    this.mInterpolation = Interpolation.linear;\r\n\r\n    /**\r\n     * @private\r\n     * @type {number}\r\n     */\r\n    this.mDelay = 0;\r\n\r\n    /**\r\n     * @private\r\n     * @type {number}\r\n     */\r\n    this.mRepeatTimes = 0;\r\n\r\n    /**\r\n     * @private\r\n     * @type {boolean}\r\n     */\r\n    this.mInitiated = false;\r\n\r\n    /**\r\n     * @private\r\n     * @type {boolean}\r\n     */\r\n    this.mStarted = false;\r\n\r\n    /**\r\n     * @private\r\n     * @type {boolean}\r\n     */\r\n    this.mReverse = false;\r\n\r\n    /**\r\n     * @private\r\n     * @type {boolean}\r\n     */\r\n    this.mRemoveOnComplete = true;\r\n\r\n    /**\r\n     * @private\r\n     * @type {boolean}\r\n     */\r\n    this.mPlayOnAdded = true;\r\n\r\n   /**\r\n    * @private\r\n    * @type {function(number):number}\r\n    */\r\n    this.mEase = Ease.smootherStep;\r\n\r\n    // TODO: fix ESDOC issue\r\n    if (this.mProperties !== null) {\r\n      for (let f in this.mProperties) {\r\n        this[f] = /** @dict */ (this.mProperties[f]);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Returns active ease function.\r\n   *\r\n   * @return {function(number):number}\r\n   */\r\n  get ease() {\r\n    return this.mEase;\r\n  }\r\n\r\n  /**\r\n   * Sets easing function to use.\r\n   *\r\n   * @param {function(number):number} value The easing function.\r\n   * @return {void}\r\n   */\r\n  set ease(value) {\r\n    this.mEase = value;\r\n  }\r\n\r\n  /**\r\n   * Returns the interpolation algorithm.\r\n   *\r\n   * @return {function(Array, number):number}\r\n   */\r\n  get interpolation() {\r\n    return this.mInterpolation;\r\n  }\r\n\r\n  /**\r\n   * Sets the interpolation algorithm. Possible values Interpolation.linear, Interpolation.bezier, Interpolation.catmullRom or your custom function.\r\n   *\r\n   * @param {function(Array, number):number} value The interpolation function.\r\n   * @return {void}\r\n   */\r\n  set interpolation(value) {\r\n    this.mInterpolation = value;\r\n  }\r\n\r\n  /**\r\n   * Time elapsed since tween start in seconds.\r\n   *\r\n   * @return {number}\r\n   */\r\n  get elapsed() {\r\n    return this.mElapsed;\r\n  }\r\n\r\n  /**\r\n   * Returns amount of seconds to wait before tweening.\r\n   *\r\n   * @return {number}\r\n   */\r\n  get delay() {\r\n    return this.mDelay;\r\n  }\r\n\r\n  /**\r\n   * Set amount of seconds to wait before tweening.\r\n   *\r\n   * @param {number} value Seconds to wait.\r\n   * @return {void}\r\n   */\r\n  set delay(value) {\r\n    this.mDelay = value;\r\n  }\r\n\r\n  /**\r\n   * Returns if Tween Component should be automatically detached from owner GameObject after completation.\r\n   *\r\n   * @return {boolean}\r\n   */\r\n  get removeOnComplete() {\r\n    return this.mRemoveOnComplete;\r\n  }\r\n\r\n  /**\r\n   * Sets if Tween Component should be automatically detached from owner GameObject after completation.\r\n   *\r\n   * @param {boolean} value\r\n   * @return {void}\r\n   */\r\n  set removeOnComplete(value) {\r\n    this.mRemoveOnComplete = value;\r\n  }\r\n\r\n  /**\r\n   * Returns whether the tween should start playing automatically when added to the root.\r\n   * @return {boolean}\r\n   */\r\n  get playOnAdded() {\r\n    return this.mPlayOnAdded;\r\n  }\r\n\r\n  /**\r\n   * Sets whether the tween should start playing automatically when added to the root.\r\n   *\r\n   * @param {boolean} value\r\n   * @return {void}\r\n   */\r\n  set playOnAdded(value) {\r\n    this.mPlayOnAdded = value;\r\n  }\r\n\r\n  /**\r\n   * @private\r\n   * @param {number} t\r\n   *\r\n   * @return {void}\r\n   */\r\n  __start(t) {\r\n    this.mIsPlaying = true;\r\n    this.mStartTime = t + this.mDelay;\r\n  }\r\n\r\n  /**\r\n   * Starts tweening.\r\n   *\r\n   * @return {Tween} Returns this.\r\n   */\r\n  play() {\r\n    if (!this.mIsPaused) {\r\n      this.__start(Black.instance.uptime);\r\n    } else {\r\n      this.__resume();\r\n    }\r\n\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Stops current tween.\r\n   *\r\n   * @return {Tween} Returns this.\r\n   */\r\n  stop() {\r\n    if (!this.mIsPlaying)\r\n      return this;\r\n\r\n    this.mIsPlaying = false;\r\n\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Sets the values for tweening.\r\n   *\r\n   * @param {Object} values   Values to tween.\r\n   * @param {number} duration Duration in seconds.\r\n   *\r\n   * @return {Tween} Returns this.\r\n   */\r\n  to(values = {}, duration = 0.250) {\r\n    this.mValues = values;\r\n\r\n    this.mDuration = duration;\r\n\r\n    this.mInitiated = false;\r\n\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Pauses current tween.\r\n   *\r\n   * @return {Tween} Returns this.\r\n   */\r\n  pause() {\r\n    if (!this.mIsPlaying)\r\n      return this;\r\n\r\n    this.mIsPaused = true;\r\n    this.mPausedTime = Black.instance.uptime;\r\n\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * @private\r\n   * @return {void} Description\r\n   */\r\n  __resume() {\r\n    if (!this.mIsPaused)\r\n      return;\r\n\r\n    this.mIsPaused = false;\r\n    this.mStartTime += Black.instance.uptime - this.mPausedTime;\r\n  }\r\n\r\n\r\n  /**\r\n   * @protected\r\n   * @return {void}\r\n   */\r\n  removeFromParent() {\r\n    if (this.mIsPlaying)\r\n      this.stop();\r\n\r\n    super.removeFromParent();\r\n  }\r\n\r\n  // /**\r\n  //  * @return {void}\r\n  //  */\r\n  // dispose() {\r\n  //   this.remove();\r\n  // }\r\n\r\n  /**\r\n   * Sets the number of times the tween wiil be repeated after first execution.\r\n   *\r\n   * @return {Tween} Returns this.\r\n   */\r\n  repeat(times) {\r\n    this.mRepeatTimes = times;\r\n\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Sets if tween should be looped over.\r\n   *\r\n   * @return {Tween} Return this.\r\n   */\r\n  loop(value = true) {\r\n    this.mRepeatTimes = value ? Infinity : 0;\r\n    return this;\r\n  }\r\n\r\n   /**\r\n   * Enables/disables reversing of tween values.\r\n   *\r\n   * @return {Tween} Returns this.\r\n   */\r\n  reverse(value = true) {\r\n    this.mReverse = value;\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Add specified tween object into the queue. The specified tween will be executed after completation of this tween,\r\n   *\r\n   * @return {Tween} Returns this.\r\n   */\r\n  chain(tween) {\r\n    if (!tween) {\r\n      return this;\r\n    }\r\n\r\n    this.mRemoveOnComplete = false;\r\n\r\n    this.on('complete', () => {\r\n      tween.play();\r\n    });\r\n\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * @inheritDoc\r\n   * \r\n   * @param  {GameObject} gameObject\r\n   * @return {void}\r\n   */\r\n  onAdded(gameObject) {\r\n    if (this.mPlayOnAdded) {\r\n      this.__start(Black.instance.uptime);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @private\r\n   * @param {number} t\r\n   *\r\n   * @return {void}\r\n   */\r\n  __update(t) {\r\n\r\n  }\r\n\r\n  /**\r\n   * Updates tween values.\r\n   *\r\n   * @param {Object} values The Object to get values from.\r\n   * @return {void}\r\n   */\r\n  set(values) {\r\n    this.mValues = values;\r\n\r\n    for (let f in this.mValues)\r\n      this.mValuesStart[f] = parseFloat(this.gameObject[f]);\r\n  }\r\n\r\n  /**\r\n   * @inheritDoc\r\n   *\r\n   * @param {number} dt\r\n   *\r\n   * @returns {void}\r\n   */\r\n  onPostUpdate(dt){\r\n    let t = Time.time;\r\n\r\n    if (t < this.mStartTime || !this.mIsPlaying || this.mIsPaused)\r\n      return;\r\n\r\n    // copy values only when starting tween...\r\n    // since values may change\r\n    if (this.mStarted === false) {\r\n      this.mStarted = true;\r\n      this.post('start', this.gameObject);\r\n\r\n      for (let f in this.mValues) {\r\n        if (!this.mInitiated && Array.isArray(this.mValues[f])) {\r\n          this.mValues[f] = [this.gameObject[f]].concat(this.mValues[f]);\r\n        }\r\n        this.mValuesStart[f] = parseFloat(this.gameObject[f]);\r\n      }\r\n\r\n      this.mInitiated = true;\r\n    }\r\n\r\n    this.mElapsed = (t - this.mStartTime) / this.mDuration;\r\n\r\n    if (this.mElapsed > 1)\r\n      this.mElapsed = 1;\r\n\r\n    let value = this.mEase(this.mElapsed);\r\n\r\n    for (let f in this.mValues) {\r\n      let start = /** @type {number} */ (this.mValuesStart[f]);\r\n      let end = /** @type {number|Array} */ (this.mValues[f]);\r\n\r\n      if (Array.isArray(end)) {\r\n        this.gameObject[f] = this.mInterpolation(end, value);\r\n      } else {\r\n        this.gameObject[f] = /** @type {number} */ (start + (end - start) * value);\r\n      }\r\n    }\r\n\r\n    this.post('update', this.gameObject);\r\n\r\n    if (this.mElapsed === 1) {\r\n      if (this.mRepeatTimes-- > 0) {\r\n        if (this.mReverse) {\r\n          for (let f in this.mValues) {\r\n            [this.mValues[f], this.mValuesStart[f]] = [this.mValuesStart[f], this.mValues[f]];\r\n          }\r\n        }\r\n\r\n        this.mStartTime = t + this.mDelay;\r\n\r\n        this.post('loop', this.gameObject);\r\n      } else {\r\n        this.mIsPlaying = false;\r\n        this.post('complete', this.gameObject);\r\n\r\n        if (this.mRemoveOnComplete) {\r\n          this.removeFromParent();\r\n        } else {\r\n          for (let f in this.mValues) {\r\n            this.mValuesStart[f] = this.mValues[f];\r\n          }\r\n\r\n          this.mStarted = false;\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n","/**\r\n * Holds details about sprite animation.\r\n *\r\n * @cat animation\r\n */\r\n\r\nclass AnimationInfo {\r\n  /**\r\n   * Creates an instance of Animation class\r\n   *\r\n   * @param {AnimationController}    controller  Animation controller\r\n   * @param {string}                 name        The name of animation\r\n   * @param {Array<Texture>}         frames      Array of Textures for this animation\r\n   * @param {number}                 [fps=14]    Frame rate\r\n   * @param {boolean}                [loop=true] Is animations should be looped\r\n   */\r\n  constructor(controller, name, frames, fps = 14, loop = true) {\r\n    Debug.assert(fps > 0, 'FPS must be greater than 0.');\r\n\r\n    /**\r\n     * @private\r\n     * @type {AnimationController}\r\n     */\r\n    this.mController = controller;\r\n\r\n    /**\r\n     * @private\r\n     * @type {string}\r\n     */\r\n    this.mName = name;\r\n\r\n    /**\r\n     * @private\r\n     * @type {Array<Texture>}\r\n     */\r\n    this.mFrames = frames;\r\n\r\n    /**\r\n     * @private\r\n     * @type {number}\r\n     */\r\n    this.mCurrentFrame = 0;\r\n\r\n    /**\r\n     * @private\r\n     * @type {number}\r\n     */\r\n    this.mNextFrameAt = 0;\r\n\r\n    /**\r\n     * @private\r\n     * @type {number}\r\n     */\r\n    this.mFPS = fps;\r\n\r\n    /**\r\n     * @private\r\n     * @type {number}\r\n     */\r\n    this.mFrameDuration = 1 / this.mFPS;\r\n\r\n    /**\r\n     * @private\r\n     * @type {boolean}\r\n     */\r\n    this.mLoop = loop;\r\n\r\n    /**\r\n     * @private\r\n     * @type {boolean}\r\n     */\r\n    this.mPaused = false;\r\n\r\n    /**\r\n     * @private\r\n     * @type {number}\r\n     */\r\n    this.mElapsed = 0;\r\n\r\n    /**\r\n     * @private\r\n     * @type {boolean}\r\n     */\r\n    this.mStopped = false;\r\n\r\n    /**\r\n     * @private\r\n     * @type {boolean}\r\n     */\r\n    this.mCompleted = false;\r\n  }\r\n\r\n  /**\r\n   * Plays animation. If Animation is completed, current frame is reset to 0.\r\n   *\r\n   * @return {Texture} Returns the current frame Texture.\r\n   */\r\n  play() {\r\n    if (this.mCompleted === true) {\r\n      this.mCurrentFrame = 0;\r\n      this.mElapsed = 0;\r\n    }\r\n\r\n    this.mPaused = false;\r\n    this.mStopped = false;\r\n    this.mCompleted = false;\r\n\r\n    this.mNextFrameAt = Black.instance.uptime + this.mFrameDuration - this.mElapsed;\r\n    this.mElapsed = 0;\r\n\r\n    return this.mFrames[this.mCurrentFrame];\r\n  }\r\n\r\n  /**\r\n   * Stops animation and resets the value of current frame.\r\n   *\r\n   * @return {void}\r\n   */\r\n  stop() {\r\n    this.mStopped = true;\r\n    this.mCurrentFrame = 0;\r\n  }\r\n\r\n  /**\r\n   * Pauses animation.\r\n   *\r\n   * @return {void}\r\n   */\r\n  pause() {\r\n    this.mPaused = true;\r\n    this.mElapsed = this.mNextFrameAt - Black.instance.uptime;\r\n  }\r\n\r\n  /**\r\n   * @private\r\n   * @param {number} dt\r\n   * @param {number} t\r\n   *\r\n   * @return {Texture|null}\r\n   */\r\n  __update(dt, t) {\r\n    if (t < this.mNextFrameAt || this.mPaused === true || this.mStopped === true || this.mCompleted === true)\r\n      return null;\r\n\r\n    this.mCurrentFrame++;\r\n\r\n    if (this.mCurrentFrame >= this.mFrames.length) {\r\n      if (this.mLoop === true) {\r\n        this.mCurrentFrame = 0;\r\n      } else {\r\n        this.mCurrentFrame = this.mFrames.length - 1;\r\n        this.mController.post('complete', this);\r\n        this.mCompleted = true;\r\n        return null;\r\n      }\r\n    }\r\n\r\n    this.mNextFrameAt = Black.instance.uptime + this.mFrameDuration;\r\n    let texture = this.mFrames[this.mCurrentFrame];\r\n    return texture;\r\n  }\r\n\r\n  /**\r\n   * Get/Set animation speed in frames per second.\r\n   *\r\n   * @return {number}\r\n   */\r\n  get fps() {\r\n    return this.mFPS;\r\n  }\r\n\r\n  /**\r\n   * @ignore\r\n   * @param {number} value\r\n   * @return {void}\r\n   */\r\n  set fps(value) {\r\n    Debug.assert(value > 0, 'FPS must be greater than 0.');\r\n\r\n    this.mFPS = value;\r\n    this.mFrameDuration = 1 / this.mFPS;\r\n\r\n    // update next frame start time\r\n    let diff = this.mNextFrameAt - Black.instance.uptime;\r\n    this.mNextFrameAt += diff;\r\n  }\r\n\r\n  /**\r\n   * Get/Set if animation should be looped.\r\n   * @return {boolean}\r\n   */\r\n  get loop() {\r\n    return this.mLoop;\r\n  }\r\n\r\n  /**\r\n   * @ignore\r\n   * @param {boolean} value\r\n   * @return {void}\r\n   */\r\n  set loop(value) {\r\n    this.mLoop = value;\r\n  }\r\n\r\n  /**\r\n   * Gets array of Texture.\r\n   *\r\n   * @return {Array<Texture>}\r\n   */\r\n  get frames() {\r\n    return this.mFrames;\r\n  }\r\n\r\n  /**\r\n   * Returns true if Animation is playing (neither stopped nor paused).\r\n   *\r\n   * @return {boolean}\r\n   */\r\n  get isPlaying() {\r\n    return this.mPaused === false && this.mStopped === false;\r\n  }\r\n\r\n  /**\r\n   * Returns true if animation is completed.\r\n   *\r\n   * @return {boolean}\r\n   */\r\n  get isComplete() {\r\n    return this.mCompleted;\r\n  }\r\n\r\n  /**\r\n   * Returns name of this animation.\r\n   *\r\n   * @return {string}\r\n   */\r\n  get name() {\r\n    return this.mName;\r\n  }\r\n}\r\n","/**\r\n * A Component which allows to play sprite animations.\r\n *\r\n * @cat animation\r\n * @extends Component\r\n */\r\n\r\nclass AnimationController extends Component {\r\n  /**\r\n   * Creates an instance of AnimationController\r\n   */\r\n  constructor() {\r\n    super();\r\n\r\n    /**\r\n     * @private\r\n     * @type {Object<string, AnimationInfo>}\r\n     */\r\n    this.mAnimations = {};\r\n\r\n    /**\r\n     * @private\r\n     * @type {AnimationInfo|null}\r\n     */\r\n    this.mCurrentAnim = null;\r\n  }\r\n\r\n  /**\r\n   * Returns the Animation object that exists with the specified name.\r\n   *\r\n   * @param {string} name The name of the child to return.\r\n   * @returns {AnimationInfo} Returns the Animation object that exists with the specified name.\r\n   */\r\n  getByName(name){\r\n    Debug.assert(name !== null, 'Animation must be set first.');\r\n    Debug.assert(this.mAnimations.hasOwnProperty(name), 'Animation must be set first.');\r\n\r\n    return this.mAnimations[name];\r\n  }\r\n\r\n  /**\r\n   * Removes Animation object that exists with the specified name. If animation is playing right now it will be stopped.\r\n   *\r\n   * @param {string} name The name of the animation to remove.\r\n   * @returns {void}\r\n   */\r\n  remove(name) {\r\n    Debug.assert(name !== null, 'Animation name shall not be null.');\r\n    Debug.assert(this.mAnimations.hasOwnProperty(name) === true, 'Unable to find animation.');\r\n\r\n    let anim = this.mAnimations[name];\r\n\r\n    if (this.mCurrentAnim !== null && this.mCurrentAnim === anim) {\r\n      this.stop();\r\n      delete this.mAnimations[name];\r\n    }\r\n\r\n    this.mCurrentAnim = null;\r\n  }\r\n\r\n  /**\r\n   * Add the Animation object into the list of animations. If animation with given name already exists exception will be thrown.\r\n   *\r\n   * @param {string}          name        The name of animation to update\r\n   * @param {Array<Texture>}  textures    Array of Textures\r\n   * @param {number}          [fps=14]    Frames Per Second\r\n   * @param {boolean}         [loop=true] Indicated if animation should be started over at the end.\r\n   *\r\n   * @return {AnimationInfo} The newly created Animation Object.\r\n   */\r\n  add(name, textures, fps = 14, loop = true) {\r\n    Debug.assert(textures.length > 0, 'Animation cannot be empty.');\r\n    Debug.assert(fps > 0, 'FPS must be greater than 0.');\r\n    Debug.assert(this.mAnimations.hasOwnProperty(name) == false, 'Animatation with same name alredy exists');\r\n\r\n    let anim = new AnimationInfo(this, name, textures, fps, loop);\r\n    this.mAnimations[name] = anim;\r\n\r\n    return anim;\r\n  }\r\n\r\n  /**\r\n   * Plays animation that exists with the specified name.\r\n   *\r\n   * @param {string} name The name of animation to play.\r\n   * @return {void}\r\n   */\r\n  play(name) {\r\n    Debug.assert(this.mAnimations.hasOwnProperty(name), 'Animation must be set first.');\r\n\r\n    this.mCurrentAnim = this.mAnimations[name];\r\n\r\n    let texture = this.mCurrentAnim.play();\r\n\r\n    let sprite = /** @type {Sprite} */ (this.gameObject);\r\n    if (sprite === null)\r\n      return;\r\n\r\n    if (texture !== null)\r\n      sprite.texture = texture;\r\n  }\r\n\r\n  /**\r\n   * Stops active animation. If no animations are playing at the moment nothing will happen.\r\n   *\r\n   * @return {void}\r\n   */\r\n  stop() {\r\n    if (this.mCurrentAnim === null)\r\n      return;\r\n\r\n    this.mCurrentAnim.stop();\r\n  }\r\n\r\n  /**\r\n   * Pauses active animation.\r\n   * @return {void}\r\n   */\r\n  pause() {\r\n    if (this.mCurrentAnim === null)\r\n      return;\r\n\r\n    this.mCurrentAnim.pause();\r\n  }\r\n\r\n  /**\r\n   * @inheritDoc\r\n   * \r\n   * @param  {number} dt\r\n   * @return {void}\r\n   */\r\n  onPostUpdate(dt) {\r\n    if (this.mCurrentAnim === null)\r\n      return;\r\n\r\n    // TODO: replace with time.time\r\n    let newTexture = this.mCurrentAnim.__update(dt, Black.instance.uptime);\r\n    if (newTexture === null)\r\n      return;\r\n\r\n    let sprite = /** @type {Sprite} */ (this.gameObject);\r\n    sprite.texture = newTexture;\r\n  }\r\n\r\n  /**\r\n   * Returns current active animation.\r\n   *\r\n   * @returns {AnimationInfo|null}\r\n   */\r\n  get currentAnimation() {\r\n    return this.mCurrentAnim;\r\n  }\r\n}\r\n","/**\r\n * THE BLACK ENGINE ITSELF.\r\n *\r\n * @extends MessageDispatcher\r\n */\r\n\r\nclass Black extends MessageDispatcher {\r\n\r\n  /**\r\n   * Creates a new Black instance.\r\n   * @param {string}                          containerElementId The id of an DOM element.\r\n   * @param {function(new: GameObject)}       rootClass          Type name of an GameObject to start execution from.\r\n   * @param {function(new: VideoNullDriver)}  [videoDriverClass] Type name of an VideoDriver (VideoNullDriver, DOMDriver or CanvasDriver)\r\n   */\r\n  constructor(containerElementId, rootClass, videoDriverClass) {\r\n    super();\r\n\r\n    // Dirty GCC workaround\r\n    window['Black'] = {};\r\n    window['Black']['instance'] = this;\r\n\r\n    console.log('%c                         >>> BLACK <<<                         ', 'background: #000; color: #fff;');\r\n\r\n    /**\r\n     * @private\r\n     * @type {string}\r\n     */\r\n    this.mContainerElementId = containerElementId;\r\n\r\n    /**\r\n     * @private\r\n     * @type {HTMLElement}\r\n     */\r\n    this.mContainerElement = /** @type {!HTMLElement} */ (document.getElementById(this.mContainerElementId));\r\n\r\n    if (!this.mContainerElement)\r\n      throw new Error('Container element was not found');\r\n\r\n    /**\r\n     * @private\r\n     * @type {function(new: VideoNullDriver)}\r\n     */\r\n    this.mVideoDriverClass = videoDriverClass;\r\n\r\n    /**\r\n     * @private\r\n     * @type {number}\r\n     */\r\n    this.mStageWidth = this.mContainerElement.clientWidth;\r\n\r\n    /**\r\n     * @private\r\n     * @type {number}\r\n     */\r\n    this.mStageHeight = this.mContainerElement.clientHeight;\r\n\r\n    /**\r\n     * @private\r\n     * @type {number}\r\n     */\r\n    this.mSimulationTimestep = 1000 / 60;\r\n\r\n    /**\r\n     * @private\r\n     * @type {number}\r\n     */\r\n    this.mUptime = 0;\r\n\r\n    /**\r\n     * @private\r\n     * @type {number}\r\n     */\r\n    this.mFrameAccum = 0;\r\n\r\n    /**\r\n     * @private\r\n     * @type {number}\r\n     */\r\n    this.mLastFrameTimeMs = 0;\r\n\r\n    /**\r\n     * @private\r\n     * @type {number}\r\n     */\r\n    this.mCurrentTime = 0;\r\n\r\n    /**\r\n     * @private\r\n     * @type {number}\r\n     */\r\n    this.mFPS = 60;\r\n\r\n    /**\r\n     * @private\r\n     * @type {number}\r\n     */\r\n    this.mLastFpsUpdate = 0;\r\n\r\n    /**\r\n     * @private\r\n     * @type {number}\r\n     */\r\n    this.mFramesThisSecond = 0;\r\n\r\n    /**\r\n     * @private\r\n     * @type {number}\r\n     */\r\n    this.mNumUpdateSteps = 0;\r\n\r\n    /**\r\n     * @private\r\n     * @type {number}\r\n     */\r\n    this.mMinFrameDelay = 0;\r\n\r\n    /**\r\n     * @private\r\n     * @type {Array<System>}\r\n     */\r\n    this.mSystems = [];\r\n\r\n    /**\r\n     * @private\r\n     * @type {boolean}\r\n     */\r\n    this.mIsRunning = false;\r\n\r\n    /**\r\n     * @private\r\n     * @type {boolean}\r\n     */\r\n    this.mIsStarted = false;\r\n\r\n    /**\r\n     * @private\r\n     * @type {boolean}\r\n     */\r\n    this.mIsPanic = false;\r\n\r\n    /**\r\n     * @private\r\n     * @type {number}\r\n     */\r\n    this.mLastFrameUpdateTime = 0;\r\n\r\n    /**\r\n     * @private\r\n     * @type {number}\r\n     */\r\n    this.mLastFrameRenderTime = 0;\r\n\r\n    /**\r\n     * @private\r\n     * @type {number}\r\n     */\r\n    this.mRAFHandle = -1; // not sure\r\n\r\n    /**\r\n     * @private\r\n     * @type {Viewport}\r\n     */\r\n    this.mViewport = null;\r\n\r\n    /**\r\n     * @private\r\n     * @type {VideoNullDriver}\r\n     */\r\n    this.mVideo = null;\r\n\r\n    /**\r\n     * @private\r\n     * @type {boolean}\r\n     */\r\n    this.mPaused = false;\r\n\r\n    /**\r\n     * @private\r\n     * @type {boolean}\r\n     */\r\n    this.mUnpausing = false;\r\n\r\n    /**\r\n     * @private\r\n     * @type {boolean}\r\n     */\r\n    this.mPauseOnHide = true;\r\n\r\n    /**\r\n     * @private\r\n     * @type {boolean}\r\n     */\r\n    this.mPauseOnBlur = true;\r\n\r\n    /**\r\n     * @private\r\n     * @type {Object<string, Array>}\r\n     */\r\n    this.mTagCache = {};\r\n\r\n    /**\r\n     * @private\r\n     * @type {function(new: GameObject)|null}\r\n     */\r\n    this.mRootClass = rootClass;\r\n\r\n    /**\r\n     * @private\r\n     * @type {GameObject|null}\r\n     */\r\n    this.mRoot = null;\r\n\r\n    /**\r\n     * @private\r\n     * @type {boolean}\r\n     */\r\n    this.mEnableFixedTimeStep = false;\r\n\r\n    /**\r\n     * @private\r\n     * @type {boolean}\r\n     */\r\n    this.mWasStopped = false;\r\n  }\r\n\r\n  /**\r\n   * Pauses all engine update logic. Note: RAF is not going to be paused and will work in background.\r\n   *\r\n   * @return {void}\r\n   */\r\n  pause() {\r\n    this.mPaused = true;\r\n  }\r\n\r\n  /**\r\n   * Resumes update execution.\r\n   *\r\n   * @return {void}\r\n   */\r\n  resume() {\r\n    this.mUnpausing = true;\r\n  }\r\n\r\n  /**\r\n   * @private\r\n   * @returns {void}\r\n   */\r\n  __bootViewport() {\r\n    this.mViewport = new Viewport(this.mContainerElement);\r\n  }\r\n\r\n  /**\r\n   * @private\r\n   * @returns {void}\r\n   */\r\n  __bootSystems() {\r\n    //this.addSystem(new Input());\r\n  }\r\n\r\n  /**\r\n   * @private\r\n   * @returns {void}\r\n   */\r\n  __bootStage() {\r\n    window.onblur = event => this.__onVisbilityChange(event);\r\n    window.onfocus = event => this.__onVisbilityChange(event);\r\n    window.onpagehide = event => this.__onVisbilityChange(event);\r\n    window.onpageshow = event => this.__onVisbilityChange(event);\r\n\r\n    if (document.hidden && this.mPauseOnHide === true)\r\n      this.mPaused = true;\r\n  }\r\n\r\n  /**\r\n   * @private\r\n   * @returns {void}\r\n   */\r\n  __onVisbilityChange(event) {\r\n    let type = event.type;\r\n\r\n    if (type === 'blur' && this.mPauseOnBlur === true)\r\n      this.mPaused = true;\r\n    else if (type === 'pagehide' && this.mPauseOnHide === true)\r\n      this.mPaused = true;\r\n    else if (type === 'focus' || type === 'pageshow') {\r\n      if (document.hidden === false)\r\n        this.mUnpausing = true;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Adds a given system to the execution list.\r\n   *\r\n   * @param  {System} system The System object you want to add.\r\n   * @return {System}\r\n   */\r\n  addSystem(system) {\r\n    this.mSystems.push(system);\r\n    return system;\r\n  }\r\n\r\n  /**\r\n   * Removes the given system from execution list.\r\n   *\r\n   * @param {System} system The System instance to remove.\r\n   * @return {System|null}\r\n   */\r\n  removeSystem(system) {\r\n    // TODO: remove system on next frame\r\n    var ix = this.mSystems.indexOf(system);\r\n    if (ix === -1)\r\n      return null;\r\n\r\n    this.mSystems.splice(ix, 1);\r\n    return system;\r\n  }\r\n\r\n  /**\r\n   * @private\r\n   * @returns {void}\r\n   */\r\n  __bootVideo() {\r\n    this.mVideo = new this.mVideoDriverClass(this.mContainerElement, this.mStageWidth, this.mStageHeight);\r\n  }\r\n\r\n  /**\r\n   * Boots up the engine!\r\n   *\r\n   * @return {void}\r\n   */\r\n  start() {\r\n    if (this.mWasStopped === true) {\r\n      Debug.error('Black engine cannot be re-started.');\r\n      return;\r\n    }\r\n\r\n    this.constructor.instance = this;\r\n\r\n    if (this.mIsStarted === true)\r\n      return;\r\n\r\n    this.__bootViewport();\r\n    this.__bootSystems();\r\n    this.__bootVideo();\r\n    this.__bootStage();\r\n\r\n    this.mRoot = new this.mRootClass();\r\n    this.mRoot.name = 'root';\r\n    this.mRoot.mAdded = true; // why are not added actually?\r\n    this.mRoot.onAdded();\r\n\r\n    const self = this;\r\n\r\n    this.mIsStarted = true;\r\n    this.mVideo.start();\r\n\r\n    this.mRAFHandle = requestAnimationFrame(function (timestamp) {\r\n      // TODO: do first update here\r\n      self.mIsRunning = true;\r\n\r\n      self.mLastFrameTimeMs = timestamp;\r\n      self.mLastFpsUpdate = timestamp;\r\n      self.mFramesThisSecond = 0;\r\n\r\n      // Start the main loop.\r\n      self.mRAFHandle = requestAnimationFrame((x) => {\r\n        self.__update(x);\r\n      });\r\n    });\r\n\r\n    // TODO: show only when needed, eg required by any system\r\n    if (this.mEnableFixedTimeStep === false)\r\n      Debug.info('Fixed time-step is disabled, some systems may not work.');\r\n  }\r\n\r\n  /**\r\n   * Stops any executions, destroys resources and scene.\r\n   *\r\n   * @return {void}\r\n   */\r\n  stop() {\r\n    this.mIsStarted = false;\r\n    this.mIsRunning = false;\r\n    cancelAnimationFrame(this.mRAFHandle);\r\n\r\n    console.log('%c                        <<< BUY BUY >>>                        ', 'background: #000; color: #fff;');\r\n  }\r\n\r\n  /**\r\n   * @private\r\n   * @param {number} timestamp\r\n   *\r\n   * @return {void}\r\n   */\r\n  __update(timestamp) {\r\n    // TODO: this method seems to be totaly broken. maxAllowedFPS is not working correctly\r\n    this.constructor.instance = this;\r\n\r\n    const self = this;\r\n\r\n    if (this.mPaused === true && this.mUnpausing === true) {\r\n      this.mUnpausing = this.mPaused = false;\r\n\r\n      this.mLastFrameTimeMs = 0;\r\n      this.mLastFpsUpdate = timestamp;\r\n      this.mLastFrameTimeMs = timestamp;\r\n      this.mCurrentTime = 0; // same as first update\r\n      this.mFrameAccum = 0;\r\n    }\r\n\r\n    if (timestamp < this.mLastFrameTimeMs + this.mMinFrameDelay) {\r\n      this.mRAFHandle = window.requestAnimationFrame(this.__update.bind(this));\r\n      return;\r\n    }\r\n\r\n    if (this.mPaused === false) {\r\n      this.mFrameAccum += (timestamp - this.mLastFrameTimeMs);\r\n      this.mLastFrameTimeMs = timestamp;\r\n\r\n      // BEGIN\r\n      if (timestamp > this.mLastFpsUpdate + 1000) {\r\n        this.mFPS = this.mFramesThisSecond;\r\n\r\n        this.mLastFpsUpdate = timestamp;\r\n        this.mFramesThisSecond = 0;\r\n      }\r\n      this.mFramesThisSecond++;\r\n\r\n      this.mNumUpdateSteps = 0;\r\n\r\n      // fix first update\r\n      if (this.mCurrentTime === 0)\r\n        this.mCurrentTime = timestamp - this.mMinFrameDelay;\r\n\r\n      const dt = Time.scale * ((timestamp - this.mCurrentTime) * 0.001);\r\n      this.mCurrentTime = timestamp;\r\n      Time.mDeltaTime = dt;\r\n\r\n      if (this.mEnableFixedTimeStep === true) {\r\n        while (this.mFrameAccum >= this.mSimulationTimestep) {\r\n          this.__internalFixedUpdate(this.mSimulationTimestep * 0.001);\r\n\r\n          this.mFrameAccum -= this.mSimulationTimestep;\r\n\r\n          if (++this.mNumUpdateSteps >= (60 * 3)) { // 3 seconds window\r\n            console.log('[BLACK]: Not enough time to calculate update logic.');\r\n            this.mIsPanic = true;\r\n            break;\r\n          }\r\n        }\r\n      }\r\n\r\n      this.__internalUpdate(dt);\r\n      this.__internalPostUpdate(dt);\r\n\r\n      this.mVideo.beginFrame();\r\n      this.mRoot.__render(this.mVideo, this.mUptime, 1, BlendMode.AUTO);\r\n      this.mVideo.endFrame();\r\n\r\n      // TODO: remove uptime\r\n      this.mUptime += dt;\r\n      Time.mTime = this.mUptime;\r\n\r\n      this.mIsPanic = false;\r\n    }\r\n\r\n    this.mRAFHandle = window.requestAnimationFrame(this.__update.bind(this));\r\n  }\r\n\r\n  /**\r\n   * @private\r\n   * @param {number} dt\r\n   * @return {void}\r\n   */\r\n  __internalFixedUpdate(dt) {\r\n    for (let i = 0; i < this.mSystems.length; i++)\r\n      this.mSystems[i].onFixedUpdate(dt);\r\n\r\n    this.mRoot.__fixedUpdate(dt);\r\n  }\r\n\r\n  /**\r\n   * @private\r\n   * @param {number} dt\r\n   * @return {void}\r\n   */\r\n  __internalUpdate(dt) {\r\n    for (let i = 0; i < this.mSystems.length; i++)\r\n      this.mSystems[i].onUpdate(dt, this.mUptime);\r\n\r\n    this.mRoot.__update(dt);\r\n  }\r\n\r\n  /**\r\n   * @private\r\n   * @param {number} dt\r\n   * @return {void}\r\n   */\r\n  __internalPostUpdate(dt) {\r\n    for (let i = 0; i < this.mSystems.length; i++)\r\n      this.mSystems[i].onPostUpdate(dt, this.mUptime);\r\n\r\n    this.mRoot.__postUpdate(dt);\r\n  }\r\n\r\n  /**\r\n   * Returns the root GameObject.\r\n   * @return {GameObject}\r\n   */\r\n  get root() {\r\n    return this.mRoot;\r\n  }\r\n\r\n  /**\r\n   * Returns current video driver instance.\r\n   * @return {VideoNullDriver}\r\n   */\r\n  get video() {\r\n    return this.mVideo;\r\n  }\r\n\r\n  /**\r\n   * If `enableFixedTimeStep` is set to `true` returns number of milliseconds fixed-time-step will run over.\r\n   * @return {number}\r\n   */\r\n  get simulationTimestep() {\r\n    return this.mSimulationTimestep;\r\n  }\r\n\r\n  /**\r\n   * Sets the number of milliseconds for fixed-time-step to run over.\r\n   *\r\n   * @param {number} timestep\r\n   * @return {void}\r\n   */\r\n  set simulationTimestep(timestep) {\r\n    this.mSimulationTimestep = timestep;\r\n  }\r\n\r\n  /**\r\n   * Returns current frame rate\r\n   * @return {number}\r\n   */\r\n  get FPS() {\r\n    return this.mFPS;\r\n  }\r\n\r\n  /**\r\n   * Returns max number of updates engine must do in a second.\r\n   * @return {number}\r\n   */\r\n  get maxAllowedFPS() {\r\n    return 1000 / this.mMinFrameDelay;\r\n  }\r\n\r\n  /**\r\n   * maxAllowedFPS - Sets the number of update engine must do per second.\r\n   * @param {number} fps The max allowed FPS. If less then zero engine will be stopped.\r\n   * @return {void}\r\n   */\r\n  set maxAllowedFPS(fps) {\r\n    if (fps <= 0)\r\n      this.stop();\r\n    else\r\n      this.mMinFrameDelay = 1000 / fps;\r\n  }\r\n\r\n  /**\r\n   * Returns the current viewport instance. Used to get size of a game screen, or listen for resize messages.\r\n   * @return {Viewport}\r\n   */\r\n  get viewport() {\r\n    return this.mViewport;\r\n  }\r\n\r\n  /**\r\n   * Retruns the DOM element the engine runs in.\r\n   * @return {Element}\r\n   */\r\n  get containerElement() {\r\n    return this.mContainerElement;\r\n  }\r\n\r\n  /**\r\n   * Returns amount of seconds since engine start.\r\n   * @return {number}\r\n   */\r\n  get uptime() {\r\n    return this.mUptime;\r\n  }\r\n\r\n  /**\r\n   * @protected\r\n   * @param {GameObject} child\r\n   * @param {string|null} oldTag\r\n   * @param {string|null} newTag\r\n   *\r\n   * @return {void}\r\n   */\r\n  onTagUpdated(child, oldTag, newTag) {\r\n    if (oldTag !== null) {\r\n      let arr = this.mTagCache[oldTag];\r\n      arr.splice(arr.indexOf(child), 1);\r\n\r\n      if (arr.length === 0)\r\n        delete this.mTagCache[oldTag];\r\n    }\r\n\r\n    if (newTag !== null) {\r\n      if (this.mTagCache.hasOwnProperty(newTag) === false)\r\n        this.mTagCache[newTag] = [];\r\n\r\n      this.mTagCache[newTag].push(child);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @protected\r\n   * @param  {GameObject} child\r\n   * @return {void}\r\n   */\r\n  onChildrenAdded(child) {\r\n    for (let i = 0; i < this.mSystems.length; i++)\r\n      this.mSystems[i].onChildrenAdded(child);\r\n\r\n    GameObject.forEach(child, (x) => {\r\n      if (x.mAdded === true)\r\n        return;\r\n\r\n      this.onTagUpdated(x, null, x.mTag);\r\n\r\n      x.mAdded = true;\r\n      x.onAdded();\r\n\r\n      for (let i = 0; i < x.mComponents.length; i++) {\r\n        let c = x.mComponents[i];\r\n\r\n        if (c.mAdded === true)\r\n          continue;\r\n\r\n        c.mAdded = true;\r\n        c.onAdded(x);\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * @protected\r\n   * @param  {GameObject} child\r\n   * @return {void}\r\n   */\r\n  onChildrenRemoved(child) {\r\n    for (let i = 0; i < this.mSystems.length; i++)\r\n      this.mSystems[i].onChildrenRemoved(child);\r\n\r\n    GameObject.forEach(child, (x) => {\r\n      if (x.mAdded === true) {\r\n        this.onTagUpdated(x, x.mTag, null);\r\n\r\n        x.mAdded = false;\r\n        x.onRemoved();\r\n\r\n        for (let i = 0; i < x.mComponents.length; i++) {\r\n          let c = x.mComponents[i];\r\n\r\n          if (c.mAdded === false)\r\n            continue;\r\n\r\n          c.mAdded = false;\r\n          c.onRemoved(x);\r\n        }\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * @protected\r\n   * @param  {GameObject} child\r\n   * @param  {Component} component\r\n   * @return {void}\r\n   */\r\n  onComponentAdded(child, component) {\r\n    for (let i = 0; i < this.mSystems.length; i++)\r\n      this.mSystems[i].onComponentAdded(child, component);\r\n\r\n    if (component.mAdded === true)\r\n      return;\r\n\r\n    component.mAdded = true;\r\n    component.onAdded(child);\r\n  }\r\n\r\n  /**\r\n   * @param  {GameObject} child\r\n   * @param  {Component} component\r\n   * @return {void}\r\n   */\r\n  onComponentRemoved(child, component) {\r\n    for (let i = 0; i < this.mSystems.length; i++)\r\n      this.mSystems[i].onComponentRemoved(child, component);\r\n\r\n    if (component.mAdded === false)\r\n      return;\r\n\r\n    component.mAdded = false;\r\n    component.onRemoved(child);\r\n  }\r\n\r\n  /**\r\n   * Returns if engine should be automatically paused when window is hidden.\r\n   * @return {boolean}\r\n   */\r\n  get pauseOnHide() {\r\n    return this.mPauseOnHide;\r\n  }\r\n\r\n  /**\r\n   * Sets if engine should be automatically paused when window is hidden.\r\n   * @param {boolean} value\r\n   * @return {void}\r\n   */\r\n  set pauseOnHide(value) {\r\n    this.mPauseOnHide = value;\r\n  }\r\n\r\n  /**\r\n   * Returns if engine should be automatically paused when container element is blured.\r\n   * @return {boolean}\r\n   */\r\n  get pauseOnBlur() {\r\n    return this.mPauseOnBlur;\r\n  }\r\n\r\n  /**\r\n   * Sets if engine should be automatically paused when container element is blured.\r\n   * @param {boolean} value\r\n   * @return {void}\r\n   */\r\n  set pauseOnBlur(value) {\r\n    this.mPauseOnBlur = value;\r\n  }\r\n\r\n\r\n  /**\r\n   * Returns if fixed-time-step update should happen. When disabled the physics system and other systems may not work.\r\n   * @return {boolean}\r\n   */\r\n  get enableFixedTimeStep() {\r\n    return this.mEnableFixedTimeStep;\r\n  }\r\n\r\n\r\n  /**\r\n   * Returns True if engine is paused.\r\n   *\r\n   * @returns {boolean}\r\n   */\r\n  get isPaused() {\r\n    return this.mPaused;\r\n  }\r\n\r\n  /**\r\n   * Sets if fixed-time-step update should happen. When disabled the physics system and other systems may not work.\r\n   *\r\n   * @param {boolean} value\r\n   * @return {void}\r\n   */\r\n  set enableFixedTimeStep(value) {\r\n    this.mEnableFixedTimeStep = value;\r\n  }\r\n\r\n  dispose() {\r\n    // todo: call dispose on eveyrthing!\r\n  }\r\n\r\n  get magic() {\r\n    return Math.random();\r\n  }\r\n}"]}