{"version":3,"sources":["Debug.js","MathEx.js","Perlin.js","MapMap.js","ObjectPool.js","ColorHelper.js","Glob.js","Vector.js","Matrix.js","Rectangle.js","Circle.js","Line.js","Polygon.js","Curve.js","MessageType.js","BindingType.js","Message.js","MessageBinding.js","MessageDispatcher.js","FontMetrics.js","TextMetrics.js","Time.js","System.js","Viewport.js","Component.js","GameObject.js","StageScaleMode.js","StageOrientation.js","Stage.js","Collider.js","BoxCollider.js","CircleCollider.js","Texture.js","CanvasRenderTexture.js","AtlasTexture.js","AssetLoader.js","ImageAssetLoader.js","XHRAssetLoader.js","FontFaceAssetLoader.js","Asset.js","CustomAsset.js","TextureAsset.js","JSONAsset.js","XMLAsset.js","FontAsset.js","AtlasTextureAsset.js","BitmapFontAsset.js","SoundAsset.js","SoundAtlasAsset.js","BVGAsset.js","AssetManagerState.js","AssetManager.js","BlendMode.js","Renderer.js","RenderSession.js","TextRenderer.js","BitmapTextRenderer.js","RenderTarget.js","GraphicsRenderer.js","DisplayObjectRendererCanvas.js","TextRendererCanvas.js","BitmapTextRendererCanvas.js","EmitterRendererCanvas.js","SpriteRendererCanvas.js","RenderTargetCanvas.js","GraphicsRendererCanvas.js","VideoNullDriver.js","CanvasDriver.js","DisplayObject.js","GraphicsData.js","Graphics.js","GraphicsPath.js","GraphicsGradient.js","GraphicsLinearGradient.js","GraphicsPattern.js","GraphicsCommand.js","GraphicsCommandType.js","CapsStyle.js","JointStyle.js","FillRule.js","TilingInfo.js","Sprite.js","TextStyle.js","TextField.js","BitmapTextField.js","Device.js","Scatter.js","FloatScatter.js","ColorScatter.js","VectorScatter.js","VectorCurveScatter.js","RadialScatter.js","FloatCurveScatter.js","Modifier.js","Acceleration.js","AlphaOverLife.js","ColorOverLife.js","ScaleOverLife.js","RotationOverLife.js","TextureOverLife.js","AnchorOverLife.js","Oriented.js","VectorField.js","InitialLife.js","InitialMass.js","InitialScale.js","InitialVelocity.js","InitialPosition.js","InitialRotation.js","InitialTexture.js","InitialColor.js","InitialAnchor.js","EmitterState.js","EmitterSortOrder.js","Particle.js","Emitter.js","Key.js","KeyInfo.js","Input.js","InputComponent.js","Ease.js","Interpolation.js","Tween.js","AnimationInfo.js","AnimationController.js","MasterAudio.js","SoundEffect.js","DistortionEffect.js","StereoPanner.js","SimpleEQ.js","ReverbEffect.js","SoundState.js","SoundInstance.js","SoundClip.js","SoundAtlasClip.js","SoundChannel.js","Sound.js","SoundListener.js","RigidBody.js","Projection.js","Pair.js","BoxToBoxPair.js","BoxToCirclePair.js","CircleToCirclePair.js","BroadPhase.js","Arcade.js","ParserBase.js","BVGParser.js","BVGStyle.js","SplashScreen.js","Timer.js","Black.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC9GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC1IA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACzYA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACpDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACtEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AClPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACpCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACtYA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACtkBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACllBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACzQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC7UA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACviBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AClQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AClGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACnEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACrXA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACjPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACvTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC1FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACnFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACjGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC5HA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACp2DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACpBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACdA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACnaA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC9DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACnMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACpIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACzTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AClDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC5IA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC7EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACzCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACzDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC1HA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACvJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACXA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACjCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACjCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACpCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACrCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AChDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC5JA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACxCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC/CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AChHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACdA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACnoBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC7DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACtNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACrCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AClSA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACnGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACzEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACvMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACjBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACjBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC1HA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC9TA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC5FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACxRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC/TA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AClZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACjXA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AChqBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AClVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC7BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACjCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC5DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AChCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC3DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC7BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACbA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACbA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC7DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC7JA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC7JA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC3uBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACxNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACzIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC7BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACvEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AClCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACzFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACrCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACpDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACrCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACzEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC9BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC3BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC3BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC3BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC3BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC3BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC9BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC1BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACzFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC3BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC3BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC3BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC9BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC7BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC3BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC3BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC3BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC7BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACbA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC1GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACjdA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACpZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACtBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACvnBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACtBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACzXA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACtHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC/oBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC5PA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC3JA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AChPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC1CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC/JA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC7EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACtJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AClHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC9YA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC1IA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACxFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC/KA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACrMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC3DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACtaA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACzGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC9TA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC/JA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACpMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACjFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACpBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACruBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACtBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC7wBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC3NA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACjHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACjPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"es6-module.js","sourcesContent":["// @ifdef DEBUG\n/**\n * Utility class for logging and debugging.\n *\n * @cat core\n */\nexport \nclass Debug {\n  constructor() {\n    Debug.assert(false, 'Static class.')\n  }\n\n  static isNumber(...values) {\n    values.forEach(x => {\n      if (\n        typeof x === 'number' &&\n        isNaN(parseFloat(x)) === false &&\n        isFinite(x) === true\n      )\n        return\n\n      let message = 'Not a number.'\n\n      if (Debug.logOnFail) console.error('[ASSERT]', message)\n\n      if (Debug.throwOnFail) throw new Error(message)\n    })\n  }\n\n  static assert(value, message) {\n    if (value === true) return\n\n    message = message == null ? 'Assertion failed.' : message\n\n    if (Debug.logOnFail) console.error('[ASSERT]', message)\n\n    if (Debug.throwOnFail) throw new Error(message)\n  }\n\n  static assertWarn(value, message) {\n    if (value === true) return\n\n    message = message == null ? 'Assertion warning.' : message\n    Debug.warn(message)\n  }\n\n  static assertInfo(value, message) {\n    if (value === true) return\n\n    message = message == null ? 'Assertion info.' : message\n    Debug.info(message)\n  }\n\n  /**\n   * Outputs a message to the console\n   *\n   * @param  {...string} message\n   */\n  static log(...message) {\n    console.info('%c%s', 'color: #000000', 'LOG:', ...message)\n  }\n\n  /**\n   * Outputs a info message to the console\n   *\n   * @param  {...string} message\n   */\n  static info(...message) {\n    console.info('%c%s', 'color: #003bd2', 'INFO:', ...message)\n  }\n\n  /**\n   * Outputs a warning message to the console\n   *\n   * @param  {...string} message\n   */\n  static warn(...message) {\n    console.info('%c%s', 'color: #f67400', 'WARN:', ...message)\n  }\n\n  /**\n   * Outputs a error message to the console\n   *\n   * @param  {...string} message\n   */\n  static error(...message) {\n    console.info('%c%s', 'color: #d50000', 'ERROR:', ...message)\n  }\n\n  /**\n   *\n   * @param {string} name\n   */\n  static time(name) {\n    Debug.timeProfiles[name] = performance.now()\n  }\n\n  /**\n   *\n   * @param {string} name\n   */\n  static timeEnd(name) {\n    Debug.timeProfiles[name] = performance.now() - Debug.timeProfiles[name]\n  }\n}\n\nDebug.throwOnFail = true\nDebug.logOnFail = false\nDebug.timeProfiles = {}\n// @endif\n","/**\n * Set of math helper functions.\n *\n * @cat core\n */\nexport \nclass MathEx {\n  /**\n   * Generates a random number in given range.\n   *\n   * @param {number} a A lower value.\n   * @param {number} b A greater value.\n   * @return {number}\n   */\n  static randomBetween(a, b) {\n    return Math.floor(Math.random() * (b - a + 1) + a)\n  }\n\n  /**\n   * Clamps given value to min max range.\n   *\n   * @param {number} value A value to clamp.\n   * @param {number} min A lower threshold.\n   * @param {number} max A greater threshold.\n   * @return {number}\n   */\n  static clamp(value, min, max) {\n    return value < min ? min : value > max ? max : value\n  }\n\n  /**\n   * Calculates distance between two points.\n   *\n   * @param  {number} x1 First point x-coordinate.\n   * @param  {number} y1 First point y-coordinate.\n   * @param  {number} x2 Second point x-coordinate.\n   * @param  {number} y2 Second point y-coordinate.\n   * @return {number}\n   */\n  static distance(x1, y1, x2, y2) {\n    let x = x1 - x2\n    let y = y1 - y2\n\n    return Math.sqrt(x * x + y * y)\n  }\n\n  /**\n   * Calculates squared distance between two points.\n   *\n   * @param  {number} x1 First point x-coordinate.\n   * @param  {number} y1 First point y-coordinate.\n   * @param  {number} x2 Second point x-coordinate.\n   * @param  {number} y2 Second point y-coordinate.\n   * @return {number}\n   */\n  static distanceSqr(x1, y1, x2, y2) {\n    let x = x1 - x2\n    let y = y1 - y2\n\n    return x * x + y * y\n  }\n\n  /**\n   * Calculates angle in radians between two points.\n   *\n   * @param  {number} x1 First point x-coordinate.\n   * @param  {number} y1 First point y-coordinate.\n   * @param  {number} x2 Second point x-coordinate.\n   * @param  {number} y2 Second point y-coordinate.\n   * @return {number}\n   */\n  static angleBetween(x1, y1, x2, y2) {\n    return Math.atan2(y2 - y1, x2 - x1)\n  }\n\n  /**\n   * Maps one range onto another.\n   *\n   * @param  {number} value A value to map.\n   * @param  {number} fromA Lower value from first range.\n   * @param  {number} fromB Greater value from first range.\n   * @param  {number} toA Lower value from second range.\n   * @param  {number} toB Greater value from second range.\n   * @return {number}\n   */\n  static mapRange(value, fromA, fromB, toA, toB) {\n    return toA + ((toB - toA) * (value - fromA)) / (fromB - fromA)\n  }\n\n  /**\n   * Linearly interpolates a number.\n   *\n   * @param {number} a First value.\n   * @param {number} b Second value.\n   * @param {number} t A value between 0 and 1.\n   * @return {number}\n   */\n  static lerp(a, b, t) {\n    return a + t * (b - a)\n  }\n\n  /**\n   * Compares two numbers using given epsilon value.\n   *\n   * @param {number} a First value.\n   * @param {number} b Second value.\n   * @param {number} epsilon Comparison threshold.\n   * @returns {boolean}\n   */\n  static equals(a, b, epsilon = Number.EPSILON) {\n    return a - epsilon < b && a + epsilon > b\n  }\n}\n\n/**\n * Pi divided by 4.\n * @type {number}\n */\nMathEx.PI_Q = Math.PI / 4\n\n/**\n * PI multiplied by 2.\n * @type {number}\n */\nMathEx.PI2 = Math.PI * 2\n\n/**\n * Degrees to radians constant.\n * @const\n * @type {number}\n */\nMathEx.DEG2RAD = 0.01745329251994329576923690768489\n\n/**\n * Radians to degrees constant.\n * @type {number}\n */\nMathEx.RAD2DEG = 57.295779513082320876798154814105\n","export \nclass Perlin {\n  constructor(repeat = 0) {\n    this.mRepeat = 0\n    this.mPerm = []\n\n    for (let x = 0; x < 512; x++) this.mPerm.push(Perlin.__permutation[x % 256])\n  }\n\n  __perlin(x, y, z) {\n    if (this.mRepeat > 0) {\n      x = x % this.mRepeat\n      y = y % this.mRepeat\n      z = z % this.mRepeat\n    }\n\n    let p = this.mPerm\n\n    const xi = ~~x & 255\n    const yi = ~~y & 255\n    const zi = ~~z & 255\n    const xf = x - ~~x\n    const yf = y - ~~y\n    const zf = z - ~~z\n    const u = xf * xf * xf * (xf * (xf * 6 - 15) + 10)\n    const v = yf * yf * yf * (yf * (yf * 6 - 15) + 10)\n    const w = zf * zf * zf * (zf * (zf * 6 - 15) + 10)\n\n    const aaa = p[p[p[xi] + yi] + zi]\n    const aba = p[p[p[xi] + this.inc(yi)] + zi]\n    const aab = p[p[p[xi] + yi] + this.inc(zi)]\n    const abb = p[p[p[xi] + this.inc(yi)] + this.inc(zi)]\n    const baa = p[p[p[this.inc(xi)] + yi] + zi]\n    const bba = p[p[p[this.inc(xi)] + this.inc(yi)] + zi]\n    const bab = p[p[p[this.inc(xi)] + yi] + this.inc(zi)]\n    const bbb = p[p[p[this.inc(xi)] + this.inc(yi)] + this.inc(zi)]\n\n    let x1 = this.lerp(\n      this.grad(aaa, xf, yf, zf),\n      this.grad(baa, xf - 1, yf, zf),\n      u\n    )\n    let x2 = this.lerp(\n      this.grad(aba, xf, yf - 1, zf),\n      this.grad(bba, xf - 1, yf - 1, zf),\n      u\n    )\n    let y1 = this.lerp(x1, x2, v)\n\n    x1 = this.lerp(\n      this.grad(aab, xf, yf, zf - 1),\n      this.grad(bab, xf - 1, yf, zf - 1),\n      u\n    )\n    x2 = this.lerp(\n      this.grad(abb, xf, yf - 1, zf - 1),\n      this.grad(bbb, xf - 1, yf - 1, zf - 1),\n      u\n    )\n    let y2 = this.lerp(x1, x2, v)\n\n    return (this.lerp(y1, y2, w) + 1) * 0.5\n  }\n\n  perlin(x, y, z, octaves = 1, persistence = 1) {\n    if (octaves === 1 && persistence === 1) return this.__perlin(x, y, z)\n\n    let total = 0\n    let frequency = 1\n    let amplitude = 1\n    let maxValue = 0\n    for (let i = 0; i < octaves; i++) {\n      total +=\n        this.__perlin(x * frequency, y * frequency, z * frequency) * amplitude\n\n      maxValue += amplitude\n\n      amplitude *= persistence\n      frequency *= 2\n    }\n\n    return total / maxValue\n  }\n\n  inc(num) {\n    num++\n    if (this.mRepeat > 0) num %= this.mRepeat\n\n    return num\n  }\n\n  grad(hash, x, y, z) {\n    const b = hash & 15\n\n    switch (b) {\n      case 0:\n        return x + y\n      case 1:\n        return -x + y\n      case 2:\n        return x - y\n      case 3:\n        return -x - y\n      case 4:\n        return x + z\n      case 5:\n        return -x + z\n      case 6:\n        return x - z\n      case 7:\n        return -x - z\n      case 8:\n        return y + z\n      case 9:\n        return -y + z\n      case 10:\n        return y - z\n      case 11:\n        return -y - z\n      case 12:\n        return y + x\n      case 13:\n        return -y + z\n      case 14:\n        return y - x\n      case 15:\n        return -y - z\n    }\n  }\n\n  lerp(a, b, t) {\n    return a + t * (b - a)\n  }\n}\n\nPerlin.__permutation = [\n  151,\n  160,\n  137,\n  91,\n  90,\n  15,\n  131,\n  13,\n  201,\n  95,\n  96,\n  53,\n  194,\n  233,\n  7,\n  225,\n  140,\n  36,\n  103,\n  30,\n  69,\n  142,\n  8,\n  99,\n  37,\n  240,\n  21,\n  10,\n  23,\n  190,\n  6,\n  148,\n  247,\n  120,\n  234,\n  75,\n  0,\n  26,\n  197,\n  62,\n  94,\n  252,\n  219,\n  203,\n  117,\n  35,\n  11,\n  32,\n  57,\n  177,\n  33,\n  88,\n  237,\n  149,\n  56,\n  87,\n  174,\n  20,\n  125,\n  136,\n  171,\n  168,\n  68,\n  175,\n  74,\n  165,\n  71,\n  134,\n  139,\n  48,\n  27,\n  166,\n  77,\n  146,\n  158,\n  231,\n  83,\n  111,\n  229,\n  122,\n  60,\n  211,\n  133,\n  230,\n  220,\n  105,\n  92,\n  41,\n  55,\n  46,\n  245,\n  40,\n  244,\n  102,\n  143,\n  54,\n  65,\n  25,\n  63,\n  161,\n  1,\n  216,\n  80,\n  73,\n  209,\n  76,\n  132,\n  187,\n  208,\n  89,\n  18,\n  169,\n  200,\n  196,\n  135,\n  130,\n  116,\n  188,\n  159,\n  86,\n  164,\n  100,\n  109,\n  198,\n  173,\n  186,\n  3,\n  64,\n  52,\n  217,\n  226,\n  250,\n  124,\n  123,\n  5,\n  202,\n  38,\n  147,\n  118,\n  126,\n  255,\n  82,\n  85,\n  212,\n  207,\n  206,\n  59,\n  227,\n  47,\n  16,\n  58,\n  17,\n  182,\n  189,\n  28,\n  42,\n  223,\n  183,\n  170,\n  213,\n  119,\n  248,\n  152,\n  2,\n  44,\n  154,\n  163,\n  70,\n  221,\n  153,\n  101,\n  155,\n  167,\n  43,\n  172,\n  9,\n  129,\n  22,\n  39,\n  253,\n  19,\n  98,\n  108,\n  110,\n  79,\n  113,\n  224,\n  232,\n  178,\n  185,\n  112,\n  104,\n  218,\n  246,\n  97,\n  228,\n  251,\n  34,\n  242,\n  193,\n  238,\n  210,\n  144,\n  12,\n  191,\n  179,\n  162,\n  241,\n  81,\n  51,\n  145,\n  235,\n  249,\n  14,\n  239,\n  107,\n  49,\n  192,\n  214,\n  31,\n  181,\n  199,\n  106,\n  157,\n  184,\n  84,\n  204,\n  176,\n  115,\n  121,\n  50,\n  45,\n  127,\n  4,\n  150,\n  254,\n  138,\n  236,\n  205,\n  93,\n  222,\n  114,\n  67,\n  29,\n  24,\n  72,\n  243,\n  141,\n  128,\n  195,\n  78,\n  66,\n  215,\n  61,\n  156,\n  180,\n]\n","/**\n * A double key map.\n * @cat utils\n */\nexport \nclass MapMap {\n  constructor() {\n    this.mMap = new Map()\n  }\n\n  /**\n   * Returns true if value found.\n   *\n   * @param {string} key1\n   * @param {string} key2\n   */\n  has(key1, key2) {\n    return this.mMap.has(key1) && this.mMap.get(key1).has(key2)\n  }\n\n  /**\n   * Sets or updates value by given keys.\n   *\n   * @param {string} key1\n   * @param {string} key2\n   * @param {*} value\n   */\n  set(key1, key2, value) {\n    let map = this.mMap.get(key1)\n\n    if (map == null) {\n      map = new Map()\n      this.mMap.set(key1, map)\n    }\n    map.set(key2, value)\n  }\n\n  /**\n   * Returns value by given keys.\n   *\n   * @param {string} key1\n   * @param {string} key2\n   * @returns {*}\n   */\n  get(key1, key2) {\n    let map = this.mMap.get(key1)\n    if (map != null) {\n      return this.mMap.get(key1) && this.mMap.get(key1).get(key2)\n    }\n    return null\n  }\n}\n","/**\n * A simple object pool class. Used to avoid GC.\n *\n * @cat utils\n */\nexport \nclass ObjectPool {\n  /**\n   * Creates new ObjectPool instance.\n   * @param {Function} type\n   * @param {number} capacity\n   */\n  constructor(type, capacity = 100) {\n    /** @ignore @type {Array<*>} */\n    this.mReleased = []\n\n    /** @ignore @type {number} */\n    this.mCapacity = capacity\n\n    /** @ignore @type {Function} */\n    this.mType = type\n  }\n\n  /**\n   * Gets/Sets capacity of the pool.\n   *\n   * @returns {number}\n   */\n  get capacity() {\n    return this.mCapacity\n  }\n\n  /**\n   * @ignore\n   * @param {number} value\n   */\n  set capacity(value) {\n    Debug.assert(value !== 0, 'Capacity cannot be equal to zero.')\n    Debug.assert(value > -1, 'Capacity cannot be smaller then -1.')\n\n    this.mCapacity = value\n\n    if (this.mCapacity > this.mReleased.length)\n      this.mReleased.splice(0, this.mReleased.length - this.mCapacity)\n  }\n\n  /**\n   * Releases all objects from the pool.\n   */\n  releaseAll() {\n    this.mReleased.splice(0, this.mReleased.length)\n  }\n\n  /**\n   * Returns new object instance or an object from the pool.\n   */\n  get() {\n    return this.mReleased.length > 0 ? this.mReleased.pop() : new this.mType()\n  }\n\n  /**\n   * Releases given object.\n   *\n   * @param {*} object\n   */\n  release(object) {\n    if (this.mCapacity === -1 || this.mReleased.length < this.mCapacity)\n      this.mReleased.push(object)\n  }\n}\n","/**\n * RGB helper struct.\n *\n * @cat utils\n */\nexport \nclass RGB {\n  /**\n   * Creates new RGB instance.\n   *\n   * @param {number} r\n   * @param {number} g\n   * @param {number} b\n   */\n  constructor(r = 0, g = 0, b = 0) {\n    /** @ignore @type {number} */\n    this.r = r\n\n    /** @ignore @type {number} */\n    this.g = g\n\n    /** @ignore @type {number} */\n    this.b = b\n  }\n}\n\n/**\n * Hue, saturation, lightness helper class.\n *\n * @cat utils\n */\nexport \nclass HSV {\n  /**\n   * Creates new HSV instance.\n   *\n   * @param {number} h\n   * @param {number} s\n   * @param {number} v\n   */\n  constructor(h = 0, s = 0, v = 0) {\n    /** @ignore @type {number} */\n    this.h = h\n\n    /** @ignore @type {number} */\n    this.s = s\n\n    /** @ignore @type {number} */\n    this.v = v\n  }\n}\n\n/**\n * Set of methods related to color transformations.\n *\n * @cat utils\n * @static\n */\nexport \nclass ColorHelper {\n  /**\n   * Converts number color to RGB object.\n   *\n   * @param {number} hex The color to convert.\n   * @returns {RGB} The resulting string.\n   */\n  static hex2rgb(hex) {\n    return new RGB((hex >> 16) & 255, (hex >> 8) & 255, hex & 255)\n  }\n\n  /**\n   * Converts RGB object into number color.\n   *\n   * @param {RGB} rgb The object, which contains 'r', 'g' and 'b' properties.\n   * @returns {number} The resulting uint.\n   */\n  static rgb2hex(rgb) {\n    return (rgb.r << 16) | (rgb.g << 8) | rgb.b\n  }\n\n  /**\n   * Converts HSV object into RGB object.\n   *\n   * @param {HSV} hsv The object, which contains 'h', 's' and 'v' properties.\n   * @returns {RGB} The resulting RGB object.\n   */\n  static hsv2rgb(hsv) {\n    let { h, s, v } = hsv\n    let r = 0\n    let g = 0\n    let b = 0\n\n    let i = Math.floor(h * 6)\n    let f = h * 6 - i\n    let p = v * (1 - s)\n    let q = v * (1 - f * s)\n    let t = v * (1 - (1 - f) * s)\n\n    switch (i % 6) {\n      case 0:\n        r = v\n        g = t\n        b = p\n        break\n      case 1:\n        r = q\n        g = v\n        b = p\n        break\n      case 2:\n        r = p\n        g = v\n        b = t\n        break\n      case 3:\n        r = p\n        g = q\n        b = v\n        break\n      case 4:\n        r = t\n        g = p\n        b = v\n        break\n      case 5:\n        r = v\n        g = p\n        b = q\n        break\n    }\n\n    r *= 255\n    g *= 255\n    b *= 255\n\n    return new RGB(r, g, b)\n  }\n\n  /**\n   * Converts RGB object into HSV object.\n   *\n   * @param {RGB} rgb The object, which contains 'r', 'g' and 'b' properties.\n   * @returns {HSV} The resulting HSV object.\n   */\n  static rgb2hsv(rgb) {\n    let { r, g, b } = rgb\n    r /= 255\n    g /= 255\n    b /= 255\n\n    let max = Math.max(r, g, b)\n    let min = Math.min(r, g, b)\n\n    let h = 0\n    let s = 0\n    let v = max\n\n    let d = max - min\n    s = max === 0 ? 0 : d / max\n\n    if (max === min) {\n      h = 0\n    } else {\n      switch (max) {\n        case r:\n          h = (g - b) / d + (g < b ? 6 : 0)\n          break\n        case g:\n          h = (b - r) / d + 2\n          break\n        case b:\n          h = (r - g) / d + 4\n          break\n      }\n\n      h /= 6\n    }\n\n    return new HSV(h, s, v)\n  }\n\n  /**\n   * Linearly interpolates between two colors within HSV model.\n   *\n   * @param {number} hex1 First color number\n   * @param {number} hex2 Second color number\n   * @param {number} factor A value between 0 and 1\n   */\n  static lerpHSV(hex1, hex2, factor = 0.5) {\n    let c1 = ColorHelper.rgb2hsv(ColorHelper.hex2rgb(hex1))\n    let c2 = ColorHelper.rgb2hsv(ColorHelper.hex2rgb(hex2))\n\n    let h = 0\n    let d = c2.h - c1.h\n\n    if (c1.h > c2.h) {\n      let h3 = c2.h\n      c2.h = c1.h\n      c1.h = h3\n      d = -d\n      factor = 1 - factor\n    }\n\n    if (d > 0.5) {\n      c1.h = c1.h + 1\n      h = (c1.h + factor * (c2.h - c1.h)) % 1\n    }\n\n    if (d <= 0.5) h = c1.h + factor * d\n\n    let s = c1.s + factor * (c2.s - c1.s)\n    let v = c1.v + factor * (c2.v - c1.v)\n\n    return ColorHelper.rgb2hex(ColorHelper.hsv2rgb(new HSV(h, s, v)))\n  }\n\n  /**\n   * Converts number color to hex string.\n   *\n   * @param {number} color The color to convert.\n   * @returns {string} The resulting hex string.\n   */\n  static hexColorToString(color) {\n    let parsedColor = color.toString(16)\n    return '#000000'.substring(0, 7 - parsedColor.length) + parsedColor\n  }\n\n  /**\n   * Converts number color to RGBA string.\n   *\n   * @param {number} color The color to convert.\n   * @param {number} [alpha=1] Alpha to use in RGBA string\n   * @returns {string} The resulting string.\n   */\n  static intToRGBA(color, alpha = 1) {\n    const r = (color >> 16) & 255\n    const g = (color >> 8) & 255\n    const b = color & 255\n\n    return `rgba(${r}, ${g}, ${b}, ${alpha})`\n  }\n}\n","/**\n * Helper glob matching class.\n *\n * @cat utils\n */\nexport \nclass Glob {\n  /**\n   * Creates new Glob instance.\n   *\n   * @ignore\n   * @param {string} pattern\n   */\n  constructor(pattern) {\n    this.mRegExp = new RegExp(\n      `^${pattern\n        .replace(/\\./g, '\\\\.')\n        .replace(/\\*\\*$/g, '.+')\n        .replace(/(?:\\*\\*\\/|\\*\\*|\\*)/g, s => {\n          return Glob.mPatterns[s]\n        })}$`\n    )\n  }\n\n  /**\n   *\n   * @ignore\n   * @param {string} string\n   * @returns {boolean}\n   */\n  test(string) {\n    return this.mRegExp.test(string)\n  }\n}\n\nGlob.mPatterns = { '*': '[^/]+', '**': '.+/?[^/]+', '**/': '.+/?' }\n","/**\n * Mathematical representation of a vector.\n *\n * @cat geom\n */\nexport \nclass Vector {\n  /**\n   * Creates new Vector instance.\n   *\n   * @param  {number=} [x=0] X-component.\n   * @param  {number=} [y=0] y-component.\n   */\n  constructor(x = 0, y = 0) {\n    Debug.isNumber(x, y)\n\n    /** @export @type {number} X coordinate of a point in the space. */\n    this.x = x\n\n    /** @export @type {number} Y coordinate of a point in the space. */\n    this.y = y\n  }\n\n  /**\n   * Updates values of this vector with a given.\n   *\n   * @param {number=} [x=0] X-component.\n   * @param {number=} [y=0] y-component\n   * @return {Vector} This.\n   */\n  set(x = 0, y = 0) {\n    Debug.isNumber(x, y)\n\n    this.x = x\n    this.y = y\n\n    return this\n  }\n\n  /**\n   * Adds two vectors.\n   *\n   * @param {Vector} vector The vector object to be added to this.\n   * @return {Vector} This.\n   */\n  add(vector) {\n    this.x += vector.x\n    this.y += vector.y\n\n    return this\n  }\n\n  /**\n   * Subtract two vectors.\n   *\n   * @param {Vector} vector The vector object to be subtracted.\n   * @return {Vector} This.\n   */\n  subtract(vector) {\n    this.x -= vector.x\n    this.y -= vector.y\n\n    return this\n  }\n\n  /**\n   * Returns distance between two vectors.\n   *\n   * @param {Vector} vector Second vector to check distance with.\n   * @return {number} The distance between two vectors.\n   */\n  distance(vector) {\n    let x = this.x - vector.x\n    let y = this.y - vector.y\n\n    return Math.sqrt(x * x + y * y)\n  }\n\n  /**\n   * Returns the squared distance between two vectors.\n   *\n   * @param {Vector} vector Second vector to check distance with.\n   * @return {number} The distance between two vectors.\n   */\n  distanceSqr(vector) {\n    let x = this.x - vector.x\n    let y = this.y - vector.y\n\n    return x * x + y * y\n  }\n\n  /**\n   * Multiplies two vectors.\n   *\n   * @param {Vector} vector A second vector to multiply with.\n   * @return {Vector} This.\n   */\n  multiply(vector) {\n    this.x *= vector.x\n    this.y *= vector.y\n\n    return this\n  }\n\n  /**\n   * Multiplies this vector by scalar value.\n   *\n   * @param {number} scalar The values to mul by.\n   * @return {Vector} This.\n   */\n  multiplyScalar(scalar) {\n    Debug.isNumber(scalar)\n\n    this.x *= scalar\n    this.y *= scalar\n\n    return this\n  }\n\n  /**\n   * Find dot product between two vectors.\n   *\n   * @param {Vector} vector Second vector to find angle with.\n   * @return {number} A scalar value representing dot product.\n   */\n  dot(vector) {\n    return this.x * vector.x + this.y * vector.y\n  }\n\n  /**\n   * Returns the length of this vector.\n   *\n   * @return {number} The length of the vector.\n   */\n  length() {\n    return Math.sqrt(this.x * this.x + this.y * this.y)\n  }\n\n  /**\n   * Returns the squared length of this vector.\n   *\n   * @return {number} Squared length.\n   */\n  lengthSqr() {\n    return this.x * this.x + this.y * this.y\n  }\n\n  /**\n   * Creates unit vector out of this one.\n   *\n   * @returns {Vector} This.\n   */\n  normalize() {\n    let sum = this.lengthSqr()\n\n    if (sum > 0) {\n      sum = Math.sqrt(sum)\n      this.x /= sum\n      this.y /= sum\n    } else {\n      this.x = 0\n      this.y = 0\n    }\n\n    return this\n  }\n\n  /**\n   * Clamps values of this vector to given range.\n   *\n   * @param {number} min Min value.\n   * @param {number} max Max value.\n   * @return {Vector} This.\n   */\n  clamp(min, max) {\n    Debug.isNumber(min, max)\n\n    this.x = MathEx.clamp(this.x, min, max)\n    this.y = MathEx.clamp(this.y, min, max)\n\n    return this\n  }\n\n  /**\n   * Clamps vector length of this vector to given range.\n   *\n   * @param {number} min Min value.\n   * @param {number} max Max value.\n   * @return {Vector} This.\n   */\n  clampLength(min, max) {\n    Debug.isNumber(min, max)\n\n    let length = MathEx.clamp(this.length(), min, max)\n    this.normalize()\n    this.multiplyScalar(length)\n    return this\n  }\n\n  /**\n   * Linearly interpolates between two vectors.\n   *\n   * @param {Vector} vector The second vector to interpolate values between.\n   * @param {number} t      Alpha value.\n   * @return {Vector} This.\n   */\n  lerp(vector, t) {\n    Debug.isNumber(t)\n\n    this.x = MathEx.lerp(this.x, vector.x, t)\n    this.y = MathEx.lerp(this.y, vector.y, t)\n\n    return this\n  }\n\n  /**\n   * Copies this vector values into given vector.\n   *\n   * @param {Vector} vector The vector to store values in.\n   * @return {Vector} Given vector.\n   */\n  copyTo(vector) {\n    vector.x = this.x\n    vector.y = this.y\n\n    return vector\n  }\n\n  /**\n   * Copies values from given vector into this.\n   *\n   * @param {Vector} vector The vector to copy values from.\n   * @return {Vector} This.\n   */\n  copyFrom(vector) {\n    this.x = vector.x\n    this.y = vector.y\n\n    return this\n  }\n\n  /**\n   * Clones this vector object.\n   *\n   * @return {Vector} New Vector instance.\n   */\n  clone() {\n    return new Vector(this.x, this.y)\n  }\n\n  /**\n   * Compares two vectors for equality.\n   *\n   * @param {Vector} vector Second vector to compare with.\n   * @param {number=} epsilon Threshold.\n   * @return {boolean} True if equal.\n   */\n  equals(vector, epsilon = Number.EPSILON) {\n    return (\n      vector !== null &&\n      Math.abs(vector.x - this.x) < epsilon &&\n      Math.abs(vector.y - this.y) < epsilon\n    )\n  }\n\n  /**\n   * Checks if this vector is empty.\n   *\n   * @return {boolean} True if both components equal to zero.\n   */\n  isEmpty() {\n    return this.x === 0 && this.y === 0\n  }\n\n  /**\n   * Rotates this vector around specified point.\n   *\n   * @param {Vector} vector Center vector.\n   * @param {number} rotation Angle in radians.\n   * @return {Vector} This rotated vector.\n   */\n  setRotationFrom(vector, rotation) {\n    Debug.isNumber(rotation)\n\n    return this.subtract(vector)\n      .setRotation(rotation)\n      .add(vector)\n  }\n\n  /**\n   *  Rotates this vector around zero vector.\n   *\n   * @param {number} rotation Angle in radians.\n   * @return {Vector} This rotated vector.\n   */\n  setRotation(rotation) {\n    Debug.isNumber(rotation)\n\n    let cos = Math.cos(rotation)\n    let sin = Math.sin(rotation)\n\n    return this.set(this.x * cos - this.y * sin, this.x * sin + this.y * cos)\n  }\n\n  /**\n   * Calculates angle in radians within this and specified vectors.\n   *\n   * @param {Vector} vector Second vector.\n   * @return {number} Angle in radians.\n   */\n  angleBetween(vector) {\n    return Math.atan2(vector.y - this.y, vector.x - this.x)\n  }\n\n  /**\n   * Calculates vector angle in radians. Same as heading.\n   *\n   * @return {number} Angle in radians.\n   */\n  angle() {\n    return Math.atan2(this.y, this.x)\n  }\n\n  /**\n   * Rotates this vector to normal.\n   *\n   * @return {Vector} This vector.\n   */\n  perp() {\n    return this.set(this.y, -this.x)\n  }\n\n  /**\n   * Creates new Vector from given angle in radians.\n   *\n   * @param {number} angle Angle.\n   * @param {Vector=} outVector Vector to be returned.\n   * @return {Vector} New Vector object.\n   */\n  static fromAngle(angle, outVector) {\n    Debug.isNumber(angle)\n\n    outVector = outVector || new Vector()\n    return outVector.set(Math.cos(angle), Math.sin(angle))\n  }\n\n  /**\n   * @ignore\n   * @param {Vector} vectorMin\n   * @param {Vector} vectorMax\n   * @param {Vector=} outVector\n   * @return {Vector}\n   */\n  static randomRange(vectorMin, vectorMax, outVector) {\n    outVector = outVector || new Vector()\n\n    outVector.x = Math.random() * (vectorMax.x - vectorMin.x) + vectorMin.x\n    outVector.y = Math.random() * (vectorMax.y - vectorMin.y) + vectorMin.y\n\n    return outVector\n  }\n\n  // @ifdef DEBUG\n  /**\n   * @ignore\n   * @param {number=} [digits=2] Description\n   * @return {string} Description\n   */\n  toString(digits = 2) {\n    return `Vector: { x: ${this.x.toFixed(digits)}, y: ${this.y.toFixed(\n      digits\n    )} }`\n  }\n  // @endif\n}\n\n/**\n * @ignore\n * @type {Vector}\n * @nocollapse\n */\nVector.__cache = new Vector()\n\n/**\n * Recycled vectors pool.\n *\n * @type {ObjectPool}\n * @nocollapse\n */\nVector.pool = new ObjectPool(Vector)\n","/**\n * A 2x3 matrix allows you to transform objects in space.\n *\n * @cat geom\n */\nexport \nclass Matrix {\n  /**\n   * Creates new Matrix instance.\n   *\n   * @param  {number} [a=1]  A-component.\n   * @param  {number} [b=0]  B-component.\n   * @param  {number} [c=0]  C-component.\n   * @param  {number} [d=1]  D-component.\n   * @param  {number} [tx=0] TX-component.\n   * @param  {number} [ty=0] TY-component.\n   */\n  constructor(a = 1, b = 0, c = 0, d = 1, tx = 0, ty = 0) {\n    /** @private @type {Float32Array} */\n    this.data = new Float32Array(6)\n    this.set(a, b, c, d, tx, ty)\n  }\n\n  /**\n   * Sets components of this matrix to the given values.\n   *\n   * @param  {number} a  A-component.\n   * @param  {number} b  B-component.\n   * @param  {number} c  C-component.\n   * @param  {number} d  D-component.\n   * @param  {number} tx TX-component.\n   * @param  {number} ty TY-component.\n   * @return {Matrix} This.\n   */\n  set(a = 1, b = 0, c = 0, d = 1, tx = 0, ty = 0) {\n    Debug.isNumber(a, b, c, d, tx, ty)\n\n    let m = this.data\n\n    m[0] = a\n    m[1] = b\n    m[2] = c\n    m[3] = d\n    m[4] = tx\n    m[5] = ty\n\n    return this\n  }\n\n  /**\n   * Translates the matrix by x and y axes.\n   *\n   * @param {number} dx Amount along x-axis.\n   * @param {number} dy Amount along y-axis.\n   * @return {Matrix} This.\n   */\n  translate(dx, dy) {\n    Debug.isNumber(dx, dy)\n\n    let a = this.data\n\n    let /** @type {number} */ a0 = a[0] // a\n    let /** @type {number} */ a1 = a[1] // b\n    let /** @type {number} */ a2 = a[2] // c\n    let /** @type {number} */ a3 = a[3] // d\n    let /** @type {number} */ a4 = a[4] // tx\n    let /** @type {number} */ a5 = a[5] // ty\n\n    this.data[4] = a0 * dx + a2 * dy + a4\n    this.data[5] = a1 * dx + a3 * dy + a5\n\n    return this\n  }\n\n  /**\n   * Sets tx and ty components to given values.\n   *\n   * @param {number} x The tx component to update.\n   * @param {number} y The ty component to update.\n   * @return {Matrix} This.\n   */\n  setTranslation(x, y) {\n    Debug.isNumber(x, y)\n\n    this.data[4] = x\n    this.data[5] = y\n\n    return this\n  }\n\n  /**\n   * Sets absolute rotation of this matrix to specified angle.\n   *\n   * @param  {number} theta     Theta value.\n   * @param  {number} scale = 1 Scale value.\n   * @return {Matrix} This.\n   */\n  setRotation(theta, scale = 1) {\n    Debug.isNumber(theta, scale)\n\n    let m = this.data\n    m[0] = Math.cos(theta) * scale\n    m[2] = Math.sin(theta) * scale\n    m[1] = -m[2]\n    m[3] = m[0]\n\n    return this\n  }\n\n  /**\n   * Applies rotation to this matrix.\n   *\n   * @param  {number} angle Angle in radians.\n   * @return {Matrix} This.\n   */\n  rotate(angle) {\n    Debug.isNumber(angle)\n\n    let a = this.data\n    let cos = Math.cos(angle)\n    let sin = Math.sin(angle)\n    let a0 = a[0]\n    let a2 = a[2]\n    let a4 = a[4]\n\n    a[0] = a0 * cos - a[1] * sin\n    a[1] = a0 * sin + a[1] * cos\n    a[2] = a2 * cos - a[3] * sin\n    a[3] = a2 * sin + a[3] * cos\n    a[4] = a4 * cos - a[5] * sin\n    a[5] = a4 * sin + a[5] * cos\n\n    return this\n  }\n\n  /**\n   * Scales current matrix.\n   *\n   * @param {number} sx Abscissa of the scaling vector.\n   * @param {number} sy Ordinate of the scaling vector.\n   * @return {Matrix} This.\n   */\n  scale(sx, sy) {\n    Debug.isNumber(sx, sy)\n\n    let a = this.data\n    let /** @type {number} */ a0 = a[0] // a\n    let /** @type {number} */ a1 = a[1] // b\n    let /** @type {number} */ a2 = a[2] // c\n    let /** @type {number} */ a3 = a[3] // d\n    let /** @type {number} */ a4 = a[4] // tx\n    let /** @type {number} */ a5 = a[5] // ty\n\n    this.data[0] = a0 * sx\n    this.data[1] = a1 * sx\n    this.data[2] = a2 * sy\n    this.data[3] = a3 * sy\n\n    return this\n  }\n\n  skew(sx, sy) {\n    let sinX = Math.sin(sx)\n    let cosX = Math.cos(sx)\n    let sinY = Math.sin(sy)\n    let cosY = Math.cos(sy)\n    let d = this.data\n\n    this.set(\n      d[0] * cosY - d[1] * sinX,\n      d[0] * sinY + d[1] * cosX,\n      d[2] * cosY - d[3] * sinX,\n      d[2] * sinY + d[3] * cosX,\n      d[4] * cosY - d[5] * sinX,\n      d[4] * sinY + d[5] * cosX\n    )\n  }\n\n  /**\n   * Resets current matrix to identity state.\n   *\n   * @return {Matrix} This.\n   */\n  identity() {\n    return this.set(1, 0, 0, 1, 0, 0)\n  }\n\n  /**\n   * Specifies if current matrix is identity.\n   *\n   * @returns {boolean}\n   */\n  get isIdentity() {\n    return this.exactEquals(Matrix.__identity)\n  }\n\n  /**\n   * Concatenates a given matrix with the current one.\n   *\n   * @param  {Matrix} b The matrix to be concatenated.\n   * @return {Matrix}   This.\n   */\n  prepend(b) {\n    let a = this.data\n    let bv = b.data\n\n    let /** @type {number} */ a0 = a[0] // a\n    let /** @type {number} */ a1 = a[1] // b\n    let /** @type {number} */ a2 = a[2] // c\n    let /** @type {number} */ a3 = a[3] // d\n    let /** @type {number} */ a4 = a[4] // tx\n    let /** @type {number} */ a5 = a[5] // ty\n\n    let /** @type {number} */ b0 = bv[0] // a\n    let /** @type {number} */ b1 = bv[1] // b\n    let /** @type {number} */ b2 = bv[2] // c\n    let /** @type {number} */ b3 = bv[3] // d\n    let /** @type {number} */ b4 = bv[4] // tx\n    let /** @type {number} */ b5 = bv[5] // ty\n\n    if (b0 !== 1 || b1 !== 0 || b2 !== 0 || b3 !== 1) {\n      let a11 = a0 * b0 + a1 * b2\n      a[1] = a0 * b1 + a1 * b3\n      a[0] = a11\n\n      let c11 = a2 * b0 + a3 * b2\n      a[3] = a2 * b1 + a3 * b3\n      a[2] = c11\n    }\n\n    let tx11 = a4 * b0 + a5 * b2 + b4\n    a[5] = a4 * b1 + a5 * b3 + b5\n    a[4] = tx11\n    return this\n  }\n\n  /**\n   * Appends values to this matrix.\n   *\n   * @param  {Matrix} b The matrix to be appended.\n   * @return {Matrix} This.\n   */\n  append(b) {\n    let a = this.data\n    let bv = b.data\n\n    let /** @type {number} */ a0 = a[0]\n    let /** @type {number} */ a1 = a[1]\n    let /** @type {number} */ a2 = a[2]\n    let /** @type {number} */ a3 = a[3]\n    let /** @type {number} */ a4 = a[4]\n    let /** @type {number} */ a5 = a[5]\n    let /** @type {number} */ b0 = bv[0]\n    let /** @type {number} */ b1 = bv[1]\n    let /** @type {number} */ b2 = bv[2]\n    let /** @type {number} */ b3 = bv[3]\n    let /** @type {number} */ b4 = bv[4]\n    let /** @type {number} */ b5 = bv[5]\n\n    a[0] = a0 * b0 + a2 * b1\n    a[1] = a1 * b0 + a3 * b1\n    a[2] = a0 * b2 + a2 * b3\n    a[3] = a1 * b2 + a3 * b3\n    a[4] = a0 * b4 + a2 * b5 + a4\n    a[5] = a1 * b4 + a3 * b5 + a5\n    return this\n  }\n\n  /**\n   * Transforms given and x- and y- components of a point from a local space to world space.\n   *\n   * @param  {number} x          The x- component of a point.\n   * @param  {number} y          The y- component of a point.\n   * @param  {Vector=} outVector If given stores resulting values in it.\n   * @return {Vector} Transformed Vector object.\n   */\n  transformXY(x, y, outVector) {\n    Debug.isNumber(x, y)\n\n    outVector = outVector || new Vector()\n    let m = this.data\n\n    outVector.x = m[0] * x + m[2] * y + m[4]\n    outVector.y = m[1] * x + m[3] * y + m[5]\n\n    return outVector\n  }\n\n  /**\n   * Transforms given point from a local space to world space without applying scaling.\n   *\n   * @param  {number} x          The x- component.\n   * @param  {number} y          The y- component.\n   * @param  {Vector=} outVector If given stores results in it.\n   * @return {Vector} Just transformed Vector object.\n   */\n  transformDirectionXY(x, y, outVector) {\n    Debug.isNumber(x, y)\n\n    let m = this.data\n    outVector = outVector || new Vector()\n\n    outVector.x = m[0] * x + m[2] * y\n    outVector.y = m[1] * x + m[3] * y\n\n    return outVector\n  }\n\n  /**\n   * Transforms vector by current matrix object.\n   *\n   * @param  {Vector} vector     Vector to apply transformation on.\n   * @param  {Vector=} outVector Out Vector to store results in.\n   * @return {Vector} New transformed vector.\n   */\n  transformVector(vector, outVector) {\n    outVector = outVector || new Vector()\n    const m = this.data\n\n    const x = m[0] * vector.x + m[2] * vector.y + m[4]\n    const y = m[1] * vector.x + m[3] * vector.y + m[5]\n\n    return outVector.set(x, y)\n  }\n\n  /**\n   * Transforms rectangle by current matrix object.\n   *\n   * @param  {Rectangle} rect         Rectangle to apply transformation on.\n   * @param  {Rectangle|null} outRect When given stores results in it.\n   * @return {Rectangle} Transformed  Rectangle object.\n   */\n  transformRect(rect, outRect) {\n    outRect = outRect || new Rectangle()\n\n    let minX = Number.MAX_VALUE\n    let maxX = -Number.MAX_VALUE\n    let minY = Number.MAX_VALUE\n    let maxY = -Number.MAX_VALUE\n    let m = this.data\n    let tmpVector = Vector.pool.get()\n\n    /** @type {Array<number>} */\n    let points = [\n      rect.x,\n      rect.y,\n      rect.x + rect.width,\n      rect.y,\n      rect.x,\n      rect.y + rect.height,\n      rect.x + rect.width,\n      rect.y + rect.height,\n    ]\n\n    for (let i = 0; i < points.length; i += 2) {\n      tmpVector.x = m[0] * points[i] + m[2] * points[i + 1] + m[4]\n      tmpVector.y = m[1] * points[i] + m[3] * points[i + 1] + m[5]\n\n      if (minX > tmpVector.x) minX = tmpVector.x\n      if (maxX < tmpVector.x) maxX = tmpVector.x\n      if (minY > tmpVector.y) minY = tmpVector.y\n      if (maxY < tmpVector.y) maxY = tmpVector.y\n    }\n\n    Vector.pool.release(tmpVector)\n\n    return outRect.set(minX, minY, maxX - minX, maxY - minY)\n  }\n\n  /**\n   * Inverts current matrix.\n   *\n   * @return {Matrix} This.\n   */\n  invert() {\n    let a = this.data\n\n    let aa = a[0]\n    let ab = a[1]\n    let ac = a[2]\n    let ad = a[3]\n    let atx = a[4]\n    let aty = a[5]\n\n    let det = aa * ad - ab * ac\n    if (det === 0) {\n      a[0] = a[1] = a[2] = a[3] = 0\n      a[4] = -atx\n      a[5] = -aty\n      return this\n    }\n    det = 1.0 / det\n\n    a[0] = ad * det\n    a[1] = -ab * det\n    a[2] = -ac * det\n    a[3] = aa * det\n    a[4] = (ac * aty - ad * atx) * det\n    a[5] = (ab * atx - aa * aty) * det\n\n    return this\n  }\n\n  /**\n   * TODO: remove or finish\n   * @ignore\n   * @returns {Array<number>} Description\n   */\n  __decompose() {\n    let m = this.data\n    let a = m[0]\n    let b = m[1]\n    let c = m[2]\n    let d = m[3]\n    let tx = m[4]\n    let ty = m[5]\n\n    let skewX = -Math.atan2(-c, d)\n    let skewY = Math.atan2(b, a)\n\n    let delta = Math.abs(skewX + skewY)\n\n    let r_rotation = 0\n    let r_skewX = 0\n    let r_skewY = 0\n    let r_scaleX = 0\n    let r_scaleY = 0\n    let r_x = 0\n    let r_y = 0\n\n    if (delta < 0.00001) {\n      r_rotation = skewY\n\n      if (a < 0 && d >= 0) r_rotation += r_rotation <= 0 ? Math.PI : -Math.PI\n    } else {\n      r_skewX = skewX\n      r_skewY = skewY\n    }\n\n    r_scaleX = Math.sqrt(a * a + b * b)\n    r_scaleY = Math.sqrt(c * c + d * d)\n\n    r_x = tx\n    r_y = ty\n\n    return [r_x, r_y, r_rotation, r_scaleX, r_scaleY, r_skewX, r_skewY]\n  }\n\n  /**\n   * Clones the current matrix and returns new cloned object.\n   *\n   * @return {Matrix} New cloned object.\n   */\n  clone() {\n    let m = new Matrix()\n    let v = this.data\n    m.set(v[0], v[1], v[2], v[3], v[4], v[5])\n    return m\n  }\n\n  /**\n   * Copies values to given matrix.\n   *\n   * @param  {Matrix} matrix The destination matrix.\n   * @return {Matrix} This.\n   */\n  copyTo(matrix) {\n    let a = this.data\n    let b = matrix.data\n\n    b[0] = a[0]\n    b[1] = a[1]\n    b[2] = a[2]\n    b[3] = a[3]\n    b[4] = a[4]\n    b[5] = a[5]\n\n    return matrix\n  }\n\n  /**\n   * Copies values from given matrix into this.\n   *\n   * @param  {Matrix} matrix The matrix to copy values from.\n   * @return {Matrix} This.\n   */\n  copyFrom(matrix) {\n    return matrix.copyTo(this)\n  }\n\n  /**\n   * Compares this matrix values with given matrix and checks if they are the same.\n   *\n   * @param {Matrix} matrix Matrix object to compare with.\n   * @returns {boolean}\n   */\n  exactEquals(matrix) {\n    if (!matrix) return false\n\n    let a = this.data\n    let b = matrix.data\n\n    return (\n      a[0] === b[0] &&\n      a[1] === b[1] &&\n      a[2] === b[2] &&\n      a[3] === b[3] &&\n      a[4] === b[4] &&\n      a[5] === b[5]\n    )\n  }\n\n  /**\n   * Compares this matrix values with given matrix and checks if they are the same.\n   *\n   * @param  {Matrix} matrix                   Matrix object to compare with.\n   * @param  {number} epsilon = Number.EPSILON Comparison threshold.\n   * @return {boolean} True if equal.\n   */\n  equals(matrix, epsilon = Number.EPSILON) {\n    if (!matrix) return false\n\n    let a = this.data\n    let b = matrix.data\n\n    return (\n      Math.abs(a[0] - b[0]) < epsilon &&\n      Math.abs(a[1] - b[1]) < epsilon &&\n      Math.abs(a[2] - b[2]) < epsilon &&\n      Math.abs(a[3] - b[3]) < epsilon &&\n      Math.abs(a[4] - b[4]) < epsilon &&\n      Math.abs(a[5] - b[5]) < epsilon\n    )\n  }\n\n  /**\n   * Returns array of values representing this matrix object.\n   *\n   * @return {Float32Array}\n   */\n  get value() {\n    return this.data\n  }\n\n  // @ifdef DEBUG\n  /**\n   * @ignore\n   * @param  {number=} digits = 2\n   * @return {string}\n   */\n  toString(digits = 2) {\n    return `        | ${this.value[0].toFixed(\n      digits\n    )} | ${this.value[1].toFixed(digits)} | ${this.value[4].toFixed(digits)} |\nMatrix: | ${this.value[2].toFixed(digits)} | ${this.value[3].toFixed(\n      digits\n    )} | ${this.value[5].toFixed(digits)} |`\n  }\n  // @endif\n}\n\n/**\n * @ignore\n * @type {Matrix}\n * @nocollapse\n */\nMatrix.__cache = new Matrix()\n\n/**\n * @ignore\n * @type {Matrix}\n * @nocollapse\n */\nMatrix.__identity = new Matrix()\n\n/**\n * Recycled matrices pool.\n *\n * @type {ObjectPool}\n * @nocollapse\n */\nMatrix.pool = new ObjectPool(Matrix)\n","/**\n * Mathematical representation of a rectangle.\n *\n * @cat geom\n */\nexport \nclass Rectangle {\n  /**\n   * Creates new instance of Rectangle.\n   *\n   * @param  {number=} [y=0] X-component.\n   * @param  {number=} [x=0] Y-component.\n   * @param  {number=} [w=0] The width.\n   * @param  {number=} [h=0] The height.\n   */\n  constructor(x = 0, y = 0, w = 0, h = 0) {\n    Debug.isNumber(x, y, w, h)\n\n    /** @export @type {number} The x coordinate of the rectangle. */\n    this.x = x\n\n    /** @export @type {number} The y coordinate of the rectangle. */\n    this.y = y\n\n    /** @export @type {number} The width of the rectangle. */\n    this.width = w\n\n    /** @export @type {number} The height of the rectangle. */\n    this.height = h\n  }\n\n  /**\n   * Update rectangle values with a given.\n   *\n   * @param {number} x X-component.\n   * @param {number} y Y-component.\n   * @param {number} w The width.\n   * @param {number} h The height.\n   * @return {Rectangle} This.\n   */\n  set(x, y, w, h) {\n    Debug.isNumber(x, y, w, h)\n\n    this.x = x\n    this.y = y\n    this.width = w\n    this.height = h\n\n    return this\n  }\n\n  /**\n   * Copies values from given rectangle into this one.\n   *\n   * @param {Rectangle} rect The Rectangle to copy values from.\n   * @return {Rectangle} This.\n   */\n  copyFrom(rect) {\n    this.x = rect.x\n    this.y = rect.y\n    this.width = rect.width\n    this.height = rect.height\n\n    return this\n  }\n\n  /**\n   * Copies values from this rectangle into given rectangle.\n   *\n   * @param {Rectangle} rect The destination rect.\n   * @return {Rectangle} Given rect object.\n   */\n  copyTo(rect) {\n    rect.x = this.x\n    rect.y = this.y\n    rect.width = this.width\n    rect.height = this.height\n\n    return rect\n  }\n\n  /**\n   * Get/Sets the leftmost point of this rectangle.\n   *\n   * @return {number}\n   */\n  get left() {\n    return this.x\n  }\n\n  /**\n   * @ignore\n   * @param {number} left\n   */\n  set left(left) {\n    Debug.isNumber(left)\n    this.x = left\n  }\n\n  /**\n   * Get/Sets the rightmost point of this rectangle.\n   *\n   * @return {number}\n   */\n  get right() {\n    return this.x + this.width\n  }\n\n  /**\n   * @ignore\n   * @param {number} right\n   */\n  set right(right) {\n    Debug.isNumber(right)\n    this.x = right - this.width\n  }\n\n  /**\n   * Get/Sets the topmost point of this rectangle.\n   *\n   * @return {number}\n   */\n  get top() {\n    return this.y\n  }\n\n  /**\n   * @ignore\n   * @param {number} top\n   */\n  set top(top) {\n    Debug.isNumber(top)\n    this.y = top\n  }\n\n  /**\n   * Get/Sets the bottommost point of this rectangle.\n   *\n   * @return {number}\n   */\n  get bottom() {\n    return this.y + this.height\n  }\n\n  /**\n   * @ignore\n   * @param {number} bottom\n   */\n  set bottom(bottom) {\n    Debug.isNumber(bottom)\n\n    this.y = bottom - this.height\n  }\n\n  /**\n   * Get/Sets the top left point for this rectangle.\n   *\n   * @return {Vector}\n   */\n  get topLeft() {\n    return new Vector(this.x, this.y)\n  }\n\n  /**\n   * @ignore\n   * @param {Vector} vector\n   */\n  set topLeft(vector) {\n    this.left = vector.x\n    this.top = vector.y\n  }\n\n  /**\n   * Get/Sets the top right point for this rectangle.\n   *\n   * @return {Vector}\n   */\n  get topRight() {\n    return new Vector(this.right, this.y)\n  }\n\n  /**\n   * @ignore\n   * @param {Vector} vector\n   */\n  set topRight(vector) {\n    this.right = vector.x\n    this.top = vector.y\n  }\n\n  /**\n   * Get/Sets the top left point for this rectangle.\n   *\n   * @return {Vector}\n   */\n  get bottomRight() {\n    return new Vector(this.right, this.bottom)\n  }\n\n  /**\n   * @ignore\n   * @param {Vector} vector\n   */\n  set bottomRight(vector) {\n    this.right = vector.x\n    this.bottom = vector.y\n  }\n\n  /**\n   * Get/Sets the top left point for this rectangle.\n   *\n   * @return {Vector}\n   */\n  get bottomLeft() {\n    return new Vector(this.x, this.bottom)\n  }\n\n  /**\n   * @ignore\n   * @param {Vector} vector\n   */\n  set bottomLeft(vector) {\n    this.x = vector.x\n    this.bottom = vector.y\n  }\n\n  /**\n   * Creates a new Rectangle instance with width and height equal to current instance.\n   *\n   * @param {Vector=} outVector Resulting rect to save values in.\n   * @return {Vector} New Rectangle instance or `outVector` if passed.\n   */\n  size(outVector = undefined) {\n    outVector = outVector || new Vector()\n    return outVector.set(this.width, this.height)\n  }\n\n  /**\n   * Sets all components of this Rectangle to zero.\n   *\n   * @return {Rectangle} This.\n   */\n  zero() {\n    return this.set(0, 0, 0, 0)\n  }\n\n  /**\n   * Compares this Rectangle with a given one.\n   *\n   * @param {Rectangle} rect Rect to compare values with.\n   * @param {number} [epsilon=Number.EPSILON] Comparison threshold.\n   * @return {boolean} True if rectangles are equal.\n   */\n  equals(rect, epsilon = Number.EPSILON) {\n    return (\n      rect !== null &&\n      Math.abs(this.x - rect.x) < epsilon &&\n      Math.abs(this.y - rect.y) < epsilon &&\n      Math.abs(this.width - rect.width) < epsilon &&\n      Math.abs(this.height - rect.height) < epsilon\n    )\n  }\n\n  /**\n   * Checks if a given point is inside this rectangle.\n   *\n   * @param {number} x The x-component of a point.\n   * @param {number} y The y-component of a point.\n   * @return {boolean} True if point is inside.\n   */\n  containsXY(x, y) {\n    return x >= this.x && x <= this.right && y >= this.y && y <= this.bottom\n  }\n\n  /**\n   * Checks if a given rectangle is inside this rect.\n   *\n   * @param {Rectangle} rect Rectangle to check with.\n   * @return {boolean} True if given rectangle is inside this one.\n   */\n  contains(rect) {\n    return (\n      rect.x >= this.x &&\n      rect.y >= this.y &&\n      rect.right <= this.right &&\n      rect.bottom <= this.bottom\n    )\n  }\n\n  /**\n   * Checks if this rect intersects with a given rectangle.\n   *\n   * @param {Rectangle} rect The rect to check intersection with.\n   * @return {boolean} True if intersects.\n   */\n  intersects(rect) {\n    return (\n      rect.right > this.x &&\n      rect.bottom > this.y &&\n      rect.x < this.right &&\n      rect.y < this.bottom\n    )\n  }\n\n  /**\n   * Makes rectangle, which represents intersection between this and passed rectangles.\n   *\n   * @param {Rectangle} toIntersect Rectangle to intersect with.\n   * @param {Rectangle=} outRect Rectangle to be returned.\n   * @returns {Rectangle}\n   */\n  intersection(toIntersect, outRect) {\n    outRect = outRect || new Rectangle()\n\n    let x0 = this.x < toIntersect.x ? toIntersect.x : this.x\n    let x1 = this.right > toIntersect.right ? toIntersect.right : this.right\n\n    if (x1 <= x0) return new Rectangle()\n\n    let y0 = this.y < toIntersect.y ? toIntersect.y : this.y\n    let y1 = this.bottom > toIntersect.bottom ? toIntersect.bottom : this.bottom\n\n    if (y1 <= y0) return new Rectangle()\n\n    outRect.set(x0, y0, x1 - x0, y1 - y0)\n    return outRect\n  }\n\n  /**\n   * Adds given rectangle into this.\n   *\n   * @param {Rectangle} toUnion A rectangle object to add to this rect.\n   * @return {Rectangle} New rectangle object that is the union.\n   */\n  union(toUnion) {\n    let x0 = this.x > toUnion.x ? toUnion.x : this.x\n    let x1 = this.right < toUnion.right ? toUnion.right : this.right\n    let y0 = this.y > toUnion.y ? toUnion.y : this.y\n    let y1 = this.bottom < toUnion.bottom ? toUnion.bottom : this.bottom\n\n    return this.set(x0, y0, x1 - x0, y1 - y0)\n  }\n\n  /**\n   * Returns volume of this Rectangle.\n   *\n   * @return {number}\n   */\n  get volume() {\n    return this.width * this.height\n  }\n\n  /**\n   * Expands this rectangle object by given values.\n   *\n   * @param {number} x      X-component.\n   * @param {number} y      Y-component\n   * @param {number} width  The width.\n   * @param {number} height The height.\n   * @return {Rectangle} This.\n   */\n  expand(x, y, width, height) {\n    Debug.isNumber(x, y, width, height)\n\n    if (this.volume === 0) return this.set(x, y, width, height)\n\n    let cacheRight = this.right\n    let cacheBottom = this.bottom\n\n    if (this.x > x) {\n      this.x = x\n      this.width = cacheRight - x\n    }\n\n    if (this.y > y) {\n      this.y = y\n      this.height = cacheBottom - y\n    }\n\n    if (cacheRight < x + width) this.width = x + width - this.x\n\n    if (cacheBottom < y + height) this.height = y + height - this.y\n\n    return this\n  }\n\n  /**\n   * Expands this rectangle with a given point.\n   *\n   * @param {number} x\n   * @param {number} y\n   * @returns {Rectangle}\n   */\n  expandXY(x, y) {\n    if (x < this.x) {\n      this.width += this.x - x\n      this.x = x\n    }\n\n    if (y < this.y) {\n      this.height += this.y - y\n      this.y = y\n    }\n\n    if (x > this.x + this.width) this.width = x - this.x\n\n    if (y > this.y + this.height) this.height = y - this.y\n\n    return this\n  }\n\n  /**\n   * Increases the size of this rectangle by given x- and y- values.\n   *\n   * @param {number=} [x=0] X-component.\n   * @param {number=} [y=0] Y-component.\n   * @return {Rectangle} This.\n   */\n  inflate(x = 0, y = 0) {\n    Debug.isNumber(x, y)\n\n    this.x -= x\n    this.y -= y\n    this.width += 2 * x\n    this.height += 2 * y\n\n    return this\n  }\n\n  /**\n   * Clones this Rectangle object into new one.\n   *\n   * @return {Rectangle} New rectangle object.\n   */\n  clone() {\n    return new Rectangle(this.x, this.y, this.width, this.height)\n  }\n\n  /**\n   * Gets rectangle perimeter.\n   *\n   * @return {number}\n   */\n  get perimeter() {\n    return 2 * (this.width + this.height)\n  }\n\n  /**\n   * Returns the center point of this rectangle.\n   *\n   * @param {Vector=} outVector The out-Vector to store values in.\n   * @return {Vector} New rectangle object.\n   */\n  center(outVector = undefined) {\n    outVector = outVector || new Vector()\n    return outVector.set(this.x + this.width * 0.5, this.y + this.height * 0.5)\n  }\n\n  /**\n   *  Scales this rectangle.\n   *\n   * @param {number} x Width multiplier.\n   * @param {number} y Height multiplier.\n   * @return {Rectangle} This rectangle.\n   */\n  scale(x, y) {\n    this.width *= x\n    this.height *= y\n\n    return this\n  }\n\n  /**\n   * Checks if rectangle has area.\n   *\n   * @return {boolean} True if has.\n   */\n  get isEmpty() {\n    return this.width <= 0 || this.height <= 0\n  }\n\n  /**\n   * Gets a list of lines, which make up this rectangle.\n   *\n   * @returns {Array<Line>}\n   */\n  get lines() {\n    return [\n      new Line(this.topLeft, this.topRight),\n      new Line(this.topRight, this.bottomRight),\n      new Line(this.bottomRight, this.bottomLeft),\n      new Line(this.bottomLeft, this.topLeft),\n    ]\n  }\n\n  /**\n   * Calculates a bonding box enclosing the given list of points.\n   *\n   * @param {Array<Vector>} points\n   * @returns {Rectangle}\n   */\n  static fromPoints(points) {\n    let result = new Rectangle()\n\n    if (points.length === 0) return result\n\n    let length = points.length\n    let minX = points[0].x\n    let minY = points[0].y\n    let maxX = points[0].x\n    let maxY = points[0].y\n\n    for (let i = 1; i < length; i++) {\n      let p = points[i]\n      let x = p.x\n      let y = p.y\n\n      minX = Math.min(x, minX)\n      maxX = Math.max(x, maxX)\n      minY = Math.min(y, minY)\n      maxY = Math.max(y, maxY)\n    }\n\n    result.x = minX\n    result.y = minY\n    result.width = maxX - minX\n    result.height = maxY - minY\n    return result\n  }\n\n  /**\n   * Calculates a bonding box enclosing the given list of x-y pairs.\n   *\n   * @param {Array<number>} points\n   * @returns {Rectangle}\n   */\n  static fromPointsXY(points) {\n    let result = new Rectangle()\n\n    if (points.length < 2) return result\n\n    let length = points.length\n    let minX = points[0]\n    let minY = points[1]\n    let maxX = points[0]\n    let maxY = points[1]\n\n    for (let i = 2; i < length; i += 2) {\n      let x = points[i]\n      let y = points[i + 1]\n\n      minX = Math.min(x, minX)\n      maxX = Math.max(x, maxX)\n      minY = Math.min(y, minY)\n      maxY = Math.max(y, maxY)\n    }\n\n    result.x = minX\n    result.y = minY\n    result.width = maxX - minX\n    result.height = maxY - minY\n    return result\n  }\n\n  // @ifdef DEBUG\n  /**\n   * @ignore\n   * @param {number=} [digits=2] Description\n   * @return {string} Description\n   */\n  toString(digits = 2) {\n    return `Rectangle { x: ${this.x.toFixed(digits)}, y: ${this.y.toFixed(\n      digits\n    )}, width: ${this.width.toFixed(digits)}, height: ${this.height.toFixed(\n      digits\n    )} }`\n  }\n  // @endif\n}\n\n/**\n * @ignore\n * @type {Rectangle}\n * @nocollapse\n */\nRectangle.__cache = new Rectangle()\n\n/**\n * Recycled rectangles pool.\n *\n * @type {ObjectPool}\n * @nocollapse\n */\nRectangle.pool = new ObjectPool(Rectangle)\n","/**\n * Mathematical representation of a circle.\n *\n * @cat geom\n */\nexport \nclass Circle {\n  /**\n   * Creates new Circle instance.\n   *\n   * @param  {number=} [x = 0] Position x.\n   * @param  {number=} [y = 0] Position y.\n   * @param  {number=} [r = 1] Radius.\n   */\n  constructor(x = 0, y = 0, r = 1) {\n    /** @private @type {number} */\n    this.x = x\n\n    /** @private @type {number} */\n    this.y = y\n\n    /** @private @type {number} */\n    this.r = r\n  }\n\n  /**\n   * Sets new circle properties\n   *\n   * @param {number} x Position x.\n   * @param {number} y Position y.\n   * @param {number} r Radius.\n   * @return {Circle} This circle.\n   */\n  set(x, y, r) {\n    this.x = x\n    this.y = y\n    this.r = r\n\n    return this\n  }\n\n  /**\n   * Clones this circle.\n   *\n   * @return {Circle} Created circle.\n   */\n  clone() {\n    return new Circle(this.x, this.y, this.r)\n  }\n\n  /**\n   * Copy this properties to another circle.\n   *\n   * @param {Circle} circle Object to copy to.\n   * @return {Circle} Passed circle.\n   */\n  copyTo(circle) {\n    return circle.set(this.x, this.y, this.r)\n  }\n\n  /**\n   * Copy another circle properties to this.\n   *\n   * @param {Circle} circle Object to copy from.\n   * @return {Circle} This circle.\n   */\n  copyFrom(circle) {\n    return this.set(circle.x, circle.y, circle.r)\n  }\n\n  /**\n   * Shows whether circles are identical.\n   *\n   * @param {Circle} circle Object to comparison.\n   * @param {number=} epsilon Compare precision.\n   * @return {boolean} True if circles are identical.\n   */\n  equals(circle, epsilon = Number.EPSILON) {\n    return (\n      circle !== null &&\n      Math.abs(this.x - circle.x) < epsilon &&\n      Math.abs(this.y - circle.y) < epsilon &&\n      Math.abs(this.r - circle.r) < epsilon\n    )\n  }\n\n  /**\n   * Shows whether point is in circle.\n   *\n   * @param {number} x Point position x.\n   * @param {number} y Point position y.\n   * @return {boolean} True if circle contains point.\n   */\n  containsXY(x, y) {\n    return this.contains(new Vector(x, y))\n  }\n\n  /**\n   * Shows whether point is in circle.\n   *\n   * @param {Vector} vector Point to check.\n   * @return {boolean} True if circle contains point.\n   */\n  contains(vector) {\n    // TODO: remove new Vector init\n    return new Vector(this.x, this.y).subtract(vector).length() <= this.r\n  }\n\n  /**\n   * Resets all values to zero.\n   *\n   * @return {Circle} Returns this.\n   */\n  zero() {\n    return this.set(0, 0, 0)\n  }\n\n  /**\n   * Shows whether this circle intersects another.\n   *\n   * @param {Circle} circle Circle to check.\n   * @return {boolean} True if intersects.\n   */\n  intersects(circle) {\n    let d = new Vector(this.x, this.y).distance(new Vector(circle.x, circle.y))\n    return d <= this.r + circle.r && d >= this.r - circle.r\n  }\n\n  /**\n   * Shows whether this circle collide with another.\n   *\n   * @param {Circle} circle Circle to check.\n   * @return {boolean} True if collide.\n   */\n  collide(circle) {\n    let d = new Vector(this.x, this.y).distance(new Vector(circle.x, circle.y))\n    return d <= this.r + circle.r\n  }\n\n  /**\n   * Shows whether this circle overlap another.\n   *\n   * @param {Circle} circle Circle to check.\n   * @return {boolean} True if overlap.\n   */\n  overlap(circle) {\n    if (this.r < circle.r) {\n      return false\n    }\n\n    let d = new Vector(this.x, this.y).distance(new Vector(circle.x, circle.y))\n    return d <= this.r - circle.r\n  }\n\n  /**\n   * Represents center as vector.\n   *\n   * @param {Vector=} outVector Object for result.\n   * @return {Vector} Center point.\n   */\n  center(outVector = undefined) {\n    outVector = outVector || new Vector()\n    return outVector.set(this.x, this.y)\n  }\n\n  static getCircumferencePoint(x, y, r, angle, outVector = undefined) {\n    outVector = outVector || new Vector()\n    outVector.set(x + r * Math.sin(angle), y + r * -Math.cos(angle))\n    return outVector\n  }\n\n  /**\n   * Returns area of this circle.\n   *\n   * @return {number} area.\n   */\n  get volume() {\n    return Math.PI * this.r * this.r\n  }\n\n  /**\n   * Returns perimeter of this circle.\n   *\n   * @return {number} perimeter.\n   */\n  get perimeter() {\n    return 2 * Math.PI * this.r\n  }\n\n  /**\n   * Finds left X position.\n   *\n   * @return {number} Left X position.\n   */\n  get left() {\n    return this.x - this.r\n  }\n\n  /**\n   * Finds right X position.\n   *\n   * @return {number} Right X position.\n   */\n  get right() {\n    return this.x + this.r\n  }\n\n  /**\n   * Finds top Y position.\n   *\n   * @return {number} Top Y position.\n   */\n  get top() {\n    return this.y - this.r\n  }\n\n  /**\n   * Finds bottom Y position.\n   *\n   * @return {number} Bottom Y position.\n   */\n  get bottom() {\n    return this.y + this.r\n  }\n\n  /**\n   * Returns top point of this circle.\n   *\n   * @return {Vector}\n   */\n  get topPoint() {\n    return new Vector(this.x, this.top)\n  }\n\n  /**\n   * Returns bottom point of this circle.\n   *\n   * @return {Vector}\n   */\n  get bottomPoint() {\n    return new Vector(this.x, this.bottom)\n  }\n\n  // @ifdef DEBUG\n  /**\n   * String representation of this circle.\n   *\n   * @ignore\n   * @param {number=} [digits=2] Number of digits after float point.\n   * @return {string} Returns string representation of this circle.\n   */\n  toString(digits = 2) {\n    return `Circle { x: ${this.x.toFixed(digits)}, y: ${this.y.toFixed(\n      digits\n    )}, r: ${this.r.toFixed(digits)} }`\n  }\n  // @endif\n}\n\n/**\n * @ignore\n * @type {Circle}\n * @nocollapse\n */\nCircle.__cache = new Circle()\n","/**\n * Mathematical representation of a bezier curve.\n *\n * @cat geom\n */\nexport \nclass Line {\n  /**\n   * Creates new Line instance.\n   * @param  {Vector} start Start point.\n   * @param  {Vector} end End point.\n   */\n  constructor(start, end) {\n    /** @type {Vector} The start point coordinates */\n    this.start = start\n\n    /** @type {Vector} The end point coordinates */\n    this.end = end\n  }\n\n  /**\n   * set - Sets new line properties\n   *\n   * @param  {Vector} start Start point.\n   * @param  {Vector} end End point.\n   *\n   * @return {Line} This circle.\n   */\n  set(start, end) {\n    this.start = start\n    this.end = end\n\n    return this\n  }\n\n  /**\n   * clone - Clones this line.\n   *\n   * @return {Line} Created line.\n   */\n  clone() {\n    return new Line(this.start.clone(), this.end.clone())\n  }\n\n  /**\n   * copyTo - Copy this properties to another line.\n   *\n   * @param {Line} line Object to copy to.\n   *\n   * @return {Line} Passed line.\n   */\n  copyTo(line) {\n    return line.set(this.start.clone(), this.end.clone())\n  }\n\n  /**\n   * copyFrom - Copy another line properties to this.\n   *\n   * @param {Line} line Object to copy from.\n   *\n   * @return {Line} This circle.\n   */\n  copyFrom(line) {\n    return this.set(line.start.clone(), line.end.clone())\n  }\n\n  /**\n   * equals - Shows whether lines are identical.\n   *\n   * @param {Line} line Object to comparison.\n   * @param {number=} epsilon Compare precision.\n   *\n   * @return {boolean} True if lines are identical.\n   */\n  equals(line, epsilon = Number.EPSILON) {\n    return (\n      (this.start.equals(line.start, epsilon) &&\n        this.end.equals(line.end, epsilon)) ||\n      (this.start.equals(line.end, epsilon) &&\n        this.end.equals(line.start, epsilon))\n    )\n  }\n\n  /**\n   * left - Finds left X position.\n   *\n   * @return {number} Left X position.\n   */\n  get left() {\n    return Math.min(this.start.x, this.end.x)\n  }\n\n  /**\n   * right - Finds right X position.\n   *\n   * @return {number} Right X position.\n   */\n  get right() {\n    return Math.max(this.start.x, this.end.x)\n  }\n\n  /**\n   * top - Finds top Y position.\n   *\n   * @return {number} Top Y position.\n   */\n  get top() {\n    return Math.min(this.start.y, this.end.y)\n  }\n\n  /**\n   * bottom - Finds bottom Y position.\n   *\n   * @return {number} Bottom Y position.\n   */\n  get bottom() {\n    return Math.max(this.start.y, this.end.y)\n  }\n\n  /**\n   * reverse - Replace line start and end points.\n   *\n   * @return {Line} This line.\n   */\n  reverse() {\n    let start = this.start\n    this.start = this.end\n    this.end = start\n\n    return this\n  }\n\n  /**\n   * normalize - Change line's length to one. Moves end point.\n   *\n   * @return {Line} This line.\n   */\n  normalize() {\n    this.end\n      .subtract(this.start)\n      .normalize()\n      .add(this.start)\n\n    return this\n  }\n\n  /**\n   * scale - Change line's length to scaled. Moves end point.\n   *\n   * @return {Line} This line.\n   */\n  scale(multiplier) {\n    this.end\n      .subtract(this.start)\n      .multiplyScalar(multiplier)\n      .add(this.start)\n\n    return this\n  }\n\n  /**\n   * zero - Description\n   *\n   * @return {Line} Description\n   */\n  zero() {\n    return this.set(new Vector(), new Vector())\n  }\n\n  /**\n   * length - Length of this line.\n   *\n   * @return {number} length.\n   */\n  length() {\n    return this.start.distance(this.end)\n  }\n\n  /**\n   * center - Represents center as vector.\n   *\n   * @param {Vector=} outVector Object for result.\n   *\n   * @return {Vector} Center point.\n   */\n  center(outVector = undefined) {\n    outVector = outVector || new Vector()\n    return outVector.set(\n      (this.start.x + this.end.x) / 2,\n      (this.start.y + this.end.y) / 2\n    )\n  }\n\n  /**\n   * type - Description\n   *\n   * @return {string} Description\n   */\n  get type() {\n    return 'Line'\n  }\n\n  /**\n   * containsXY - Shows whether point is on line.\n   *\n   * @param {number} x Point position x.\n   * @param {number} y Point position y.\n   *\n   * @return {boolean} True if line contains point.\n   */\n  containsXY(x, y) {\n    return this.contains(new Vector(x, y))\n  }\n\n  /**\n   * contains - Shows whether point is on line.\n   *\n   * @param {Vector} vector Point to check.\n   *\n   * @return {boolean} True if line contains point.\n   */\n  contains(vector) {\n    return (\n      this.start.distance(vector) + this.end.distance(vector) === this.length()\n    )\n  }\n\n  /**\n   * intersects - Shows whether this line intersects another.\n   *\n   * @param {Line} line Line to check.\n   *\n   * @return {boolean} True if intersects.\n   */\n  intersects(line) {\n    let start1 = this.start\n    let end1 = this.end\n    let start2 = line.start\n    let end2 = line.end\n\n    let denominator =\n      (end2.y - start2.y) * (end1.x - start1.x) -\n      (end2.x - start2.x) * (end1.y - start1.y)\n\n    if (denominator === 0) {\n      return false\n    }\n\n    let a = start1.y - start2.y\n    let b = start1.x - start2.x\n    let numerator1 = (end2.x - start2.x) * a - (end2.y - start2.y) * b\n    let numerator2 = (end1.x - start1.x) * a - (end1.y - start1.y) * b\n    a = numerator1 / denominator\n    b = numerator2 / denominator\n\n    return a >= 0 && a <= 1 && b > 0 && b < 1\n  }\n\n  /**\n   * intersects - Shows whether this line intersects circle.\n   *\n   * @param {Circle} circle Circle to check.\n   *\n   * @return {boolean} True if intersects.\n   */\n  intersectsCircle(circle) {\n    let start = this.start\n    let end = this.end\n\n    if (circle.contains(start) || circle.contains(end)) {\n      return true\n    }\n\n    let distance = start.distance(end)\n    let directionX = (end.x - start.x) / distance\n    let directionY = (end.y - start.y) / distance\n\n    let t =\n      directionX * (circle.x - start.x) + directionY * (circle.y - start.y)\n\n    let nearest = new Vector(t * directionX + start.x, t * directionY + start.y)\n    let nearestDistance = nearest.distance(new Vector(circle.x, circle.y))\n\n    if (nearestDistance < circle.r) {\n      let dt = Math.sqrt(Math.pow(circle.r, 2) - Math.pow(nearestDistance, 2))\n\n      let x1 = (t - dt) * directionX + start.x\n      let y1 = (t - dt) * directionY + start.y\n      let x2 = (t + dt) * directionX + start.x\n      let y2 = (t + dt) * directionY + start.y\n\n      return this.__isInBoundsXY(x1, y1) || this.__isInBoundsXY(x2, y2)\n    }\n\n    return false\n  }\n\n  __isInBoundsXY(x, y) {\n    let x1 = this.start.x\n    let y1 = this.start.y\n    let x2 = this.end.x\n    let y2 = this.end.y\n\n    return (\n      x > Math.min(x1, x2) &&\n      x < Math.max(x1, x2) &&\n      y > Math.min(y1, y2) &&\n      y < Math.max(y1, y2)\n    )\n  }\n\n  // @ifdef DEBUG\n  /**\n   * toString - String representation of this line.\n   *\n   * @param {number=} [digits=2] Number of digits after float point.\n   *\n   * @return {string} Description.\n   */\n  toString(digits = 2) {\n    return `Line { start: ${this.start.toString(\n      digits\n    )}, end: ${this.end.toString(digits)} }`\n  }\n  // @endif\n}\n\n/**\n * @type {Line}\n * @nocollapse\n * @ignore\n */\nLine.__cache = new Line(new Vector(), new Vector())\n","/**\n * @cat geom\n */\nexport \nclass Polygon {\n  /**\n   * Creates new Polygon instance.\n   *\n   * @param  {Array<Vector>} vertices = [] Array of vertex points;\n   */\n  constructor(vertices = []) {\n    /** @private @type {Array<Vector>} */\n    this.mVertices = vertices\n\n    /** @private @type {Array<Line>} */\n    this.mLines = []\n\n    /** @private @type {Rectangle} */\n    this.mBounds = new Rectangle()\n\n    /** @private @type {Vector} */\n    this.mCenter = new Vector()\n\n    if (vertices.length > 2) this.refresh()\n  }\n\n  /**\n   * Sets new vertices.\n   *\n   * @param {Array<Vector>} vertices New points.\n   * @return {Polygon} This polygon.\n   */\n  set(vertices) {\n    this.mVertices = vertices\n    this.refresh()\n    return this\n  }\n\n  /**\n   * Copies this properties to another polygon.\n   *\n   * @param {Polygon} polygon Object to copy to.\n   * @return {Polygon} Passed polygon.\n   */\n  copyTo(polygon) {\n    let len = this.mVertices.length\n    let vertices = []\n\n    for (let i = 0; i < len; i++) {\n      vertices.push(this.mVertices[i].clone())\n    }\n\n    return polygon.set(vertices)\n  }\n\n  /**\n   * Copies another polygon properties to this.\n   *\n   * @param {Polygon} polygon Object to copy from.\n   * @return {Polygon} This polygon.\n   */\n  copyFrom(polygon) {\n    let polygonVertices = polygon.mVertices\n    let len = polygonVertices.length\n    let vertices = []\n\n    for (let i = 0; i < len; i++) {\n      vertices.push(polygonVertices[i].clone())\n    }\n\n    return this.set(vertices)\n  }\n\n  /**\n   * Clones this polygon.\n   *\n   * @return {Polygon} Created polygon.\n   */\n  clone() {\n    let thisVertices = this.mVertices\n    let len = thisVertices.length\n    let vertices = []\n\n    for (let i = 0; i < len; i++) {\n      vertices.push(thisVertices[i].clone())\n    }\n\n    return new Polygon(vertices)\n  }\n\n  /**\n   * Gets the width of this polygon.\n   *\n   * @readonly\n   * @returns {number}\n   */\n  get width() {\n    return this.mBounds.width\n  }\n\n  /**\n   * Gets the height of this polygon.\n   *\n   * @readonly\n   * @returns {number}\n   */\n  get height() {\n    return this.mBounds.height\n  }\n\n  /**\n   * Shows whether point is within polygon area.\n   *\n   * @param {number} x Point position x.\n   * @param {number} y Point position y.\n   * @return {boolean} True if polygon contains point.\n   */\n  containsXY(x, y) {\n    return this.contains(new Vector(x, y))\n  }\n\n  /**\n   * Shows whether point is within polygon area.\n   *\n   * @param {Vector} vector Point to check.\n   * @return {boolean} True if polygon contains point.\n   */\n  contains(vector) {\n    let center = this.mCenter\n    let lines = this.mLines\n    let len = lines.length\n\n    if (center.equals(vector)) {\n      return true\n    }\n\n    let intersectionLine = new Line(vector, center.clone())\n    let intersects = 0\n    intersectionLine.scale(\n      (this.width + this.height) / intersectionLine.length()\n    )\n\n    for (let i = 0; i < len; i++) {\n      intersects += lines[i].intersects(intersectionLine) ? 1 : 0\n    }\n\n    return intersects % 2 !== 0\n  }\n\n  /**\n   * Perimeter of this polygon.\n   *\n   * @return {number} perimeter.\n   */\n  get perimeter() {\n    let thisLines = this.mLines\n    let len = thisLines.length\n    let perimeter = 0\n\n    for (let i = 0; i < len; i++) {\n      perimeter += thisLines[i].length()\n    }\n\n    return perimeter\n  }\n\n  /**\n   * Checks collision between two polygons.\n   *\n   * @param {Polygon} polygon Object to check.\n   * @return {boolean} True if polygon collides with another polygon.\n   */\n  collide(polygon) {\n    if (!this.mBounds.intersects(polygon.mBounds)) {\n      return false\n    }\n\n    let thisLines = this.mLines\n    let thisLen = thisLines.length\n    let polygonLines = polygon.mLines\n    let polygonLen = polygonLines.length\n\n    for (let i = 0; i < thisLen; i++) {\n      for (let j = 0; j < polygonLen; j++) {\n        if (thisLines[i].intersects(polygonLines[j])) {\n          return true\n        }\n      }\n    }\n\n    return false\n  }\n\n  /**\n   * Checks collision between this polygon and circle.\n   *\n   * @param {Circle} circle Object to check.\n   * @return {boolean} True if polygon collides with circle.\n   */\n  collideCircle(circle) {\n    let bounds = this.mBounds\n    let lines = this.mLines\n\n    if (\n      bounds.left > circle.right ||\n      bounds.right < circle.left ||\n      bounds.top > circle.bottom ||\n      bounds.bottom < circle.top\n    ) {\n      return false\n    }\n\n    let len = lines.length\n    for (let i = 0; i < len; i++) {\n      if (lines[i].intersectsCircle(circle)) {\n        return true\n      }\n    }\n\n    return false\n  }\n\n  /**\n   * Checks collision between this polygon and rectangle.\n   *\n   * @param {Rectangle} rectangle Object to check.\n   * @return {boolean} True if polygon collides with rectangle.\n   */\n  collideRectangle(rectangle) {\n    if (!this.mBounds.intersects(rectangle)) {\n      return false\n    }\n\n    let thisLines = this.mLines\n    let thisLen = thisLines.length\n    let rectangleLines = rectangle.lines\n    let rectangleLen = rectangleLines.length\n\n    for (let i = 0; i < thisLen; i++) {\n      for (let j = 0; j < rectangleLen; j++) {\n        if (thisLines[i].intersects(rectangleLines[j])) {\n          return true\n        }\n      }\n    }\n\n    return false\n  }\n\n  /**\n   * Checks if this polygon overlaps another.\n   *\n   * @param {Polygon} polygon Object to check.\n   * @return {boolean} True if polygon overlaps second.\n   */\n  overlap(polygon) {\n    if (\n      this.mBounds.width < polygon.mBounds.width ||\n      this.mBounds.height < polygon.mBounds.height\n    ) {\n      return false\n    }\n\n    if (!this.contains(polygon.mCenter)) {\n      return false\n    }\n\n    let thisLines = this.mLines\n    let thisLen = thisLines.length\n    let polygonLines = polygon.mLines\n    let polygonLen = polygonLines.length\n\n    for (let i = 0; i < thisLen; i++) {\n      for (let j = 0; j < polygonLen; j++) {\n        if (thisLines[i].intersects(polygonLines[j])) {\n          return false\n        }\n      }\n    }\n\n    return true\n  }\n\n  /**\n   * Checks if this polygon overlaps passed circle.\n   *\n   * @param {Circle} circle Object to check.\n   * @return {boolean} True if polygon overlaps circle.\n   */\n  overlapCircle(circle) {\n    if (!this.containsXY(circle.x, circle.y)) {\n      return false\n    }\n\n    let thisLines = this.mLines\n    let len = thisLines.length\n\n    for (let i = 0; i < len; i++) {\n      if (thisLines[i].intersectsCircle(circle)) {\n        return false\n      }\n    }\n\n    return true\n  }\n\n  /**\n   * Checks if this polygon overlaps given rectangle.\n   *\n   * @param {Rectangle} rectangle Object to check.\n   * @return {boolean} True if polygon overlaps rectangle.\n   */\n  overlapRectangle(rectangle) {\n    if (!this.contains(rectangle.center())) {\n      return false\n    }\n\n    let thisLines = this.mLines\n    let thisLen = thisLines.length\n    let rectangleLines = rectangle.lines\n    let rectangleLen = rectangleLines.length\n\n    for (let i = 0; i < thisLen; i++) {\n      for (let j = 0; j < rectangleLen; j++) {\n        if (thisLines[i].intersects(rectangleLines[j])) {\n          return false\n        }\n      }\n    }\n\n    return true\n  }\n\n  /**\n   * Calculates center, bounds, and edges of this polygon.\n   *\n   * @return {Polygon} This polygon.\n   */\n  refresh() {\n    let center = this.mCenter\n    let bounds = this.mBounds\n    let vertices = this.mVertices\n    let lines = (this.mLines = [])\n    center.set(0, 0)\n\n    // bounds\n    let maxX = -Number.MAX_VALUE\n    let maxY = -Number.MAX_VALUE\n    let minX = Number.MAX_VALUE\n    let minY = Number.MAX_VALUE\n\n    for (let i = 0; i < vertices.length; i++) {\n      let vector = vertices[i]\n      center.add(vector)\n\n      // bounds\n      let { x, y } = vector\n      maxX = x > maxX ? x : maxX\n      maxY = y > maxY ? y : maxY\n      minX = x < minX ? x : minX\n      minY = y < minY ? y : minY\n\n      lines.push(new Line(vector, vertices[i + 1] || vertices[0]))\n    }\n\n    center.multiplyScalar(1 / vertices.length)\n    bounds.set(minX, minY, maxX - minX, maxY - minY)\n\n    return this\n  }\n\n  /**\n   * Calculates center of this polygon.\n   *\n   * @return {Polygon} This polygon.\n   */\n  refreshCenter() {\n    let center = this.mCenter\n    let vertices = this.mVertices\n    let len = vertices.length\n    center.set(0, 0)\n\n    for (let i = 0; i < len; i++) {\n      center.add(vertices[i])\n    }\n\n    center.multiplyScalar(1 / vertices.length)\n\n    return this\n  }\n\n  /**\n   * Calculates bounds of this polygon.\n   *\n   * @return {Polygon} This polygon.\n   */\n  refreshBounds() {\n    let bounds = this.mBounds\n    let vertices = this.mVertices\n    let maxX = -Number.MAX_VALUE\n    let maxY = -Number.MAX_VALUE\n    let minX = Number.MAX_VALUE\n    let minY = Number.MAX_VALUE\n    let len = vertices.length\n    let x\n    let y\n\n    for (let i = 0; i < len; i++) {\n      x = vertices[i].x\n      y = vertices[i].y\n      maxX = x > maxX ? x : maxX\n      maxY = y > maxY ? y : maxY\n      minX = x < minX ? x : minX\n      minY = y < minY ? y : minY\n    }\n\n    bounds.set(minX, minY, maxX - minX, maxY - minY)\n\n    return this\n  }\n\n  /**\n   * Calculates edges of this polygon.\n   *\n   * @return {Polygon} This polygon.\n   */\n  refreshLines() {\n    let vertices = this.mVertices\n    let lines = (this.mLines = [])\n\n    for (let i = 0; i < vertices.length; i += 2) {\n      lines.push(new Line(vertices[i], vertices[i + 1] || vertices[0]))\n    }\n\n    return this\n  }\n\n  /**\n   * Creates instance of Polygon.\n   *\n   * @param {string} path Numbers x y divided with space.\n   * @return {Polygon} Created polygon.\n   */\n  static fromPath(path) {\n    let vertices = []\n    let path2 = path.split(' ')\n\n    for (let i = 0; i < path2.length; i += 2) {\n      vertices.push(new Vector(Number(path2[i]), Number(path2[i + 1])))\n    }\n\n    return new Polygon(vertices)\n  }\n\n  /**\n   * Sets rotation. Rotates this polygon around it center.\n   *\n   * @param {number} rotation Angle in radians.\n   * @return {Polygon} This polygon.\n   */\n  setRotation(rotation) {\n    let center = this.mCenter\n    let vertices = this.mVertices\n    let cos = Math.cos(rotation)\n    let sin = Math.sin(rotation)\n\n    for (let i = 0, len = vertices.length; i < len; i++) {\n      let vector = vertices[i]\n      vector\n        .subtract(center)\n        .set(vector.x * cos - vector.y * sin, vector.x * sin + vector.y * cos)\n        .add(center)\n    }\n\n    return this.refresh()\n  }\n\n  /**\n   * Translates this polygon to specified position.\n   *\n   * @param {Vector} point Translation vector.\n   * @return {Polygon} This vertices.\n   */\n  setTranslation(point) {\n    let center = this.mCenter\n    let vertices = this.mVertices\n    let len = vertices.length\n    point.subtract(center)\n\n    for (let i = 0; i < len; i++) {\n      vertices[i].add(point)\n    }\n\n    return this.refresh()\n  }\n\n  /**\n   * Returns array of vertices.\n   *\n   * @returns {Array<Vector>}\n   */\n  get vertices() {\n    return this.mVertices\n  }\n\n  /**\n   * Returns center points of this polygon.\n   * @returns {Vector}\n   */\n  get center() {\n    return this.mCenter\n  }\n\n  // @ifdef DEBUG\n  /**\n   * String representation of this polygon.\n   *\n   * @ignore\n   * @param {number=} [digits=2] Number of digits after float point.\n   * @return {string} Description.\n   */\n  toString(digits = 2) {\n    let thisLines = this.mLines\n    let thisVertices = this.mVertices\n    let len = thisLines.length\n    let vertices = ''\n    let lines = ''\n\n    for (let i = 0; i < len; i++) {\n      lines += thisLines[i].toString(digits)\n    }\n\n    len = thisVertices.length\n    for (let i = 0; i < len; i++) {\n      vertices += thisVertices[i].toString(digits)\n    }\n\n    return `Polygon { vertices: ${vertices}, bounds: ${this.mBounds.toString(\n      digits\n    )}, center: ${this.mCenter.toString()}, lines: ${lines} }`\n  }\n\n  // @endif\n}\n\n/**\n * @ignore\n * @type {Polygon}\n * @nocollapse\n */\nPolygon.__cache = new Polygon()\n","/**\n * Mathematical representation of a bezier curve.\n *\n * @cat geom\n */\nexport \nclass Curve {\n  /**\n   * Creates new Curve instance.\n   */\n  constructor() {\n    /** @private @type {Array<number>} */\n    this.mPoints = []\n\n    /** @private @type {Array<Vector>} */\n    this.mLookup = null\n\n    /** @private @type {boolean} */\n    this.mBaked = false\n\n    /** @private @type {number} */\n    this.mStep = 1 / 60\n\n    /** @private @type {Array<number>} */\n    this.mEachT = []\n  }\n\n  /**\n   * Sets new points coordinates.\n   *\n   * @param  {...number} points Coordinates: startX, startY, cpStartX, cpStartY, cpEndX, cpEndY, endX/start2X, endY/start2Y, cp2StartX, cp2StartX... 8 or 14 or 20...\n   * @return {Curve} This curve.\n   */\n  set(...points) {\n    this.mPoints = this.__initPoints(points)\n    this.__refreshEachT()\n\n    if (this.mBaked) this.__refreshCache()\n\n    return this\n  }\n\n  /**\n   * Enables or disables interpolation from cache (lookup).\n   * Returns true or false depending on baked is enabled or not.\n   *\n   * @return {boolean}\n   */\n  get baked() {\n    return this.mBaked\n  }\n\n  /**\n   * @ignore\n   * @param  {boolean} label\n   */\n  set baked(label) {\n    this.mBaked = label\n\n    if (!this.mLookup && this.mPoints) {\n      this.__refreshCache()\n    }\n  }\n\n  /**\n   * Wides points array. Sets first point for next bezier same as last of previous.\n   *\n   * @ignore\n   * @private\n   * @param  {Array<number>} points Array of points coordinates.\n   * @return {Array<number>} Points coordinates array.\n   */\n  __initPoints(points) {\n    let res = []\n\n    for (let i = 6; i < points.length; i += 6) {\n      res = res.concat(points.slice(i - 6, i + 2))\n    }\n\n    return res\n  }\n\n  /**\n   * Refresh cache (lookup) for fast interpolations.\n   *\n   * @ignore\n   * @private\n   * @return {Curve} This curve.\n   */\n  __refreshCache() {\n    let lookup = (this.mLookup = [])\n    let getFullLength = this.getFullLength()\n    let points = this.mPoints\n    let pointsLen = points.length\n\n    for (let i = 0; i < pointsLen; i += 8) {\n      let length = Curve.getLength(...points.slice(i, i + 8))\n      let step = (this.mStep * getFullLength) / length\n\n      for (let t = step; t < 1; t += step)\n        lookup.push(Curve.lerp(t, ...points.slice(i, i + 8)))\n    }\n\n    return this\n  }\n\n  /**\n   * Refresh local interpolation kof for each bezier in curve.\n   *\n   * @ignore\n   * @private\n   * @return {Curve} This curve.\n   */\n  __refreshEachT() {\n    let points = this.mPoints\n    let eachT = (this.mEachT = [])\n    let pointsLen = points.length\n    let eachLength = []\n\n    for (let i = 0; i < pointsLen; i += 8)\n      eachLength.push(Curve.getLength(...points.slice(i, i + 8)))\n\n    let length = this.getFullLength()\n    let s = 0\n    for (let i = 0; i < pointsLen; i += 8) {\n      s += eachLength[i / 8]\n      eachT.push(s / length)\n    }\n\n    return this\n  }\n\n  /**\n   * Interpolates single bezier on t position.\n   *\n   * @param  {number} t Interpolation position (0...1).\n   * @param  {number} startX\n   * @param  {number} startY\n   * @param  {number} cpStartX\n   * @param  {number} cpStartY\n   * @param  {number} cpEndX\n   * @param  {number} cpEndY\n   * @param  {number} endX\n   * @param  {number} endY\n   * @param  {Vector=} outVector\n   * @return {Vector} Position on bezier.\n   */\n  static lerp(\n    t,\n    startX,\n    startY,\n    cpStartX,\n    cpStartY,\n    cpEndX,\n    cpEndY,\n    endX,\n    endY,\n    outVector\n  ) {\n    let u = 1 - t\n    let tt = t * t\n    let uu = u * u\n    let uuu = uu * u\n    let ttt = tt * t\n\n    let p = outVector || new Vector()\n    p.set(startX, startY)\n    p.x *= uuu\n    p.y *= uuu\n\n    // first\n    p.x += 3 * uu * t * cpStartX\n    p.y += 3 * uu * t * cpStartY\n\n    // second\n    p.x += 3 * u * tt * cpEndX\n    p.y += 3 * u * tt * cpEndY\n\n    // third\n    p.x += ttt * endX\n    p.y += ttt * endY\n\n    return p\n  }\n\n  /**\n   * Interpolates across whole curve.\n   *\n   * @param  {number} t Interpolation position (0...1).\n   * @param  {Vector=} outVector Vector to be returned.\n   * @return {Vector} Position on curve.\n   */\n  interpolate(t, outVector) {\n    let res = outVector || new Vector()\n    let lookup = this.mLookup\n\n    if (this.mBaked) {\n      let i = Math.ceil((lookup.length - 1) * t)\n      let p = lookup[i]\n      res.copyFrom(p)\n\n      return res\n    }\n\n    // not backed\n    let { mEachT, mPoints } = this\n    let i = 0\n\n    while (mEachT[i] < t) i++\n\n    let minT = mEachT[i - 1] || 0\n    let maxT = mEachT[i]\n    let bezier = mPoints.slice(i * 8, i * 8 + 8)\n\n    return Curve.lerp((t - minT) / (maxT - minT), ...bezier, res)\n  }\n\n  /**\n   * Returns single bezier length.\n   *\n   * @param  {...number} points Coordinates: startX, startY, cpStartX, cpStartY, cpEndX, cpEndY, endX, endY\n   * @return {number} Length.\n   */\n  static getLength(...points) {\n    let p0 = new Vector(points[0], points[1])\n    let p1 = new Vector(points[2], points[3])\n    let p2 = new Vector(points[4], points[5])\n    let p3 = new Vector(points[6], points[7])\n\n    return (\n      (p3.distance(p0) + p0.distance(p1) + p1.distance(p2) + p2.distance(p3)) /\n      2\n    )\n  }\n\n  /**\n   * Returns this curve length.\n   *\n   * @return {number} Length.\n   */\n  getFullLength() {\n    let points = this.mPoints\n    let mPointsLen = points.length\n    let res = 0\n\n    for (let i = 0; i < mPointsLen; i += 8)\n      res += Curve.getLength(...points.slice(i, i + 8))\n\n    return res\n  }\n}\n\n/**\n * @ignore\n * @type {Curve}\n * @nocollapse\n */\nCurve.__cache = new Curve()\n","/**\n * The type of the message.\n * @cat core\n * @static\n * @constant\n * @enum {string}\n */\nexport \nconst MessageType = {\n  DIRECT: 'direct',\n  BUBBLE: 'bubble',\n}\n","/**\n * The type of the binding.\n * @cat core\n * @static\n * @constant\n * @enum {string}\n */\nexport \nconst BindingType = {\n  REGULAR: 'regular',\n  OVERHEARD: 'overheard',\n}\n","/**\n * Message holds all information about dispatched event. This is a pooled object.\n *\n * @cat core\n */\nexport \nclass Message {\n  constructor() {\n    /** @type {MessageDispatcher} The `MessageDispatcher` object, which posted this message. */\n    this.sender = null\n\n    /** @type {string} The name of message. */\n    this.name = ''\n\n    /** @type {Object} `GameObject` which receives this message. */\n    this.target = null\n\n    /** @type {Object} The point from which sending is begun. */\n    this.origin = null\n\n    /** @type {boolean} Specifies if invocation of this message was canceled. */\n    this.canceled = false\n\n    /** @type {MessageType} Message type. See `MessageType` enum. */\n    this.type = MessageType.DIRECT\n  }\n\n  /**\n   * Cancels message invocation.\n   *\n   * @return {void}\n   */\n  cancel() {\n    this.canceled = true\n  }\n\n  // @ifdef DEBUG\n  /**\n   * Generates message string representation.\n   *\n   * @return {string}\n   */\n  toString() {\n    let name = ''\n\n    let isGameObject = this.sender instanceof GameObject\n    if (isGameObject === true)\n      name = /** @type {GameObject}*/ (this.sender).name\n\n    return `MESSAGE: { name: '${this.name}', sender: '${name}', target: '${\n      this.target.name\n    }', path: '${this.path}' }`\n  }\n  // @endif\n\n  /**\n   * @ignore\n   * @returns {Message}\n   */\n  __reset() {\n    this.sender = null\n    this.name = ''\n    this.target = null\n    this.canceled = false\n    this.type = MessageType.DIRECT\n    return this\n  }\n}\n\n/**\n * Pool for messages.\n *\n * @type {ObjectPool}\n * @nocollapse\n *\n */\nMessage.pool = new ObjectPool(Message)\n\n/** @const @public @type {string} */\nMessage.PROGRESS = 'progress'\n\n/** @const @public @type {string} */\nMessage.COMPLETE = 'complete'\n\n/** @const @public @type {string} */\nMessage.ERROR = 'error'\n\n/** @const @public @type {string} */\nMessage.CHANGE = 'change'\n\n/** @const @public @type {string} */\nMessage.READY = 'ready'\n\n/** @const @public @type {string} */\nMessage.UPDATE = 'update'\n\n/** @const @public @type {string} */\nMessage.RESIZE = 'resize'\n","/**\n * A bridge between callback and context.\n *\n * @cat core\n */\nexport \nclass MessageBinding {\n  /**\n   * @param {MessageDispatcher} owner                The owner of this binding.\n   * @param {string} name                            Name of the message.\n   * @param {Function} callback                      Callback function.\n   * @param {boolean} isOnce                         Indicates whenever this binding should be auto destroyed after first execution.\n   * @param {*=} [context=null]                      Optional context (usually this).\n   * @param {BindingType} [type=BindingType.REGULAR] Type of the binding.\n   * @param {?string} [pathPattern=null]             Glob pattern to filter sender by name.\n   */\n  constructor(\n    owner,\n    name,\n    callback,\n    isOnce,\n    context = null,\n    type = BindingType.REGULAR,\n    pathPattern = null\n  ) {\n    /** @ignore @type {MessageDispatcher} */\n    this.owner = owner\n\n    /** @ignore @type {string} */\n    this.name = name\n\n    /** @ignore @type {Function} */\n    this.callback = callback\n\n    /** @ignore @type {boolean} */\n    this.isOnce = isOnce\n\n    /** @ignore @type {*} */\n    this.context = context\n\n    /** @ignore @type {?string} */\n    this.pathPattern = pathPattern\n\n    /** @ignore @type {Glob|null} */\n    this.glob = pathPattern == null ? null : new Glob(pathPattern)\n\n    /** @ignore @type {BindingType} */\n    this.type = type\n  }\n\n  /**\n   * Destroys this binding.\n   */\n  off() {\n    this.owner.__off(this)\n  }\n\n  /**\n   * @ignore\n   * @returns {MessageBinding}\n   */\n  __reset() {\n    this.owner = null\n    this.pathPattern = null\n    return this\n  }\n}\n","/**\n * The MessageDispatcher class is the base class for all classes that posts messages.\n *\n * Global messages will not be dispatched on non GameObject objects.\n *\n * @cat core\n */\nexport \nclass MessageDispatcher {\n  /**\n   * Creates new MessageDispatcher instance\n   * @param {boolean} [checkForStage=false]\n   */\n  constructor(checkForStage = false) {\n    this.mBindings = null\n    this.checkForStage = checkForStage\n  }\n\n  /**\n   * Adds listener by given name and callback.\n   *\n   * @public\n   * @param {string} name       Message name.\n   * @param {Function} callback Function to be called on message send.\n   * @param {*} [context=null]  Object to be used as `this` in callback function.\n   * @return {MessageBinding}\n   */\n  on(name, callback, context) {\n    return this.__on(name, callback, false, context)\n  }\n\n  /**\n   * Removes all bindings by given message name.\n   *\n   * @public\n   * @param {...string} names One or more message name.\n   * @returns {void}\n   */\n  off(...names) {\n    for (let i = 0; i < names.length; i++) {\n      const name = names[i]\n\n      let earIndex = name.indexOf('@')\n      if (earIndex !== -1) {\n        Debug.error('Removing overheard bindings is not allowed.')\n        return\n      }\n\n      if (\n        this.mBindings !== null &&\n        this.mBindings.hasOwnProperty(name) === true\n      ) {\n        let bindings = this.mBindings[name].slice()\n\n        for (let i = 0; i < bindings.length; i++) this.__off(bindings[i])\n      }\n    }\n  }\n\n  /**\n   * Adds listener by given name and callback. Binding will be automatically removed after first execution.\n   *\n   * @public\n   * @param {string} name       Message name.\n   * @param {Function} callback Function to be called on message send.\n   * @param {*} [context=null]  Object to be used as `this` in callback function.\n   * @return {MessageBinding}\n   */\n  once(name, callback, context) {\n    return this.__on(name, callback, true, context)\n  }\n\n  /**\n   * Posts message with a given params.\n   *\n   * Adding `~` character to the begging of the name will bubble message to the top of the tree.\n   *\n   * @public\n   * @param {string} name  The name of a message\n   * @param {...*} params  A list of params to send\n   * @return {void}\n   */\n  post(name, ...params) {\n    let message = this.__draftMessage(name)\n\n    if (message.type === MessageType.DIRECT)\n      this.__invoke(this, message, ...params)\n    else if (message.type === MessageType.BUBBLE)\n      this.__postBubbles(this, message, true, ...params)\n\n    if (message.canceled === false)\n      this.__invokeOverheard(this, message, ...params)\n\n    Message.pool.release(message)\n  }\n\n  /**\n   * Returns parent MessageDispatcher.\n   *\n   * @readonly\n   * @return {MessageDispatcher|null}\n   */\n  get parent() {\n    return null\n  }\n\n  /**\n   * Returns the stage Game Object to which this belongs to or null if not added onto stage.\n   *\n   * @readonly\n   * @return {Stage|null}\n   */\n  get stage() {\n    return null\n  }\n\n  /**\n   * Returns string representing a url like path to this object in the display\n   * tree.\n   *\n   * @readonly\n   * @return {string|null}\n   */\n  get path() {\n    return null\n  }\n\n  /**\n   * @private\n   * @ignore\n   * @param {string} name\n   * @param {Function} callback\n   * @param {boolean} [isOnce=false]\n   * @param {*} [context=null]\n   * @return {MessageBinding}\n   */\n  __on(name, callback, isOnce = false, context = null) {\n    Debug.assert(name !== null, 'name cannot be null.')\n    Debug.assert(name.trim().length > 0, 'name cannot be null.')\n    Debug.assert(\n      !(name.indexOf('~') === 0),\n      'Using `~` is not tot allowed here.'\n    )\n    Debug.assert(callback !== null, 'callback cannot be null.')\n\n    let earIndex = name.indexOf('@')\n    if (earIndex !== -1) {\n      let messageName = name.substring(0, earIndex)\n      let pathPattern = name.substring(earIndex + 1)\n      let global = MessageDispatcher.mOverheardHandlers\n\n      if (global.hasOwnProperty(messageName) === false) global[messageName] = []\n\n      let bindings = global[messageName]\n      let binding = new MessageBinding(\n        this,\n        messageName,\n        callback,\n        isOnce,\n        context,\n        BindingType.OVERHEARD,\n        pathPattern\n      )\n      bindings.push(binding)\n      return binding\n    }\n\n    if (this.mBindings === null) this.mBindings = {}\n\n    if (this.mBindings.hasOwnProperty(name) === false) this.mBindings[name] = []\n\n    let binding = new MessageBinding(\n      this,\n      name,\n      callback,\n      isOnce,\n      context,\n      BindingType.REGULAR\n    )\n    this.mBindings[name].push(binding)\n\n    return binding\n  }\n\n  /**\n   * @ignore\n   * @param {MessageBinding} binding\n   */\n  __off(binding) {\n    if (binding.type === BindingType.REGULAR) {\n      if (this.mBindings === null) return\n\n      if (this.mBindings.hasOwnProperty(binding.name) === false) return\n\n      let bindings = this.mBindings[binding.name]\n      const ix = bindings.indexOf(binding)\n      if (ix === -1) return\n\n      bindings.splice(ix, 1)\n    } else if (binding.type === BindingType.OVERHEARD) {\n      let global = MessageDispatcher.mOverheardHandlers\n      if (global.hasOwnProperty(binding.name) === false) return\n\n      let bindings = global[binding.name]\n\n      const ix = bindings.indexOf(binding)\n      if (ix === -1) return\n\n      bindings.splice(ix, 1)\n    }\n  }\n\n  /**\n   * @private\n   * @ignore\n   * @param {MessageDispatcher} sender\n   * @param {Message} message\n   * @param {...*} params\n   * @return {void}\n   */\n  __invoke(sender, message, ...params) {\n    if (message.canceled === true) return\n\n    if (this.mBindings === null) return\n\n    if (\n      this.checkForStage === true &&\n      this !== Black.stage &&\n      this.stage === null\n    )\n      return\n\n    let bindings = this.mBindings[message.name]\n\n    if (bindings === undefined || bindings.length === 0) return\n\n    let cloned = bindings.slice(0)\n\n    for (let i = 0; i < cloned.length; i++) {\n      message.target = this\n\n      let binding = cloned[i]\n\n      if (\n        this.checkForStage === true &&\n        binding.owner.stage === Black.stage &&\n        binding.owner.stage === null\n      )\n        continue\n\n      binding.callback.call(binding.context, message, ...params)\n\n      if (binding.isOnce === true) this.__off(binding)\n\n      if (message.canceled === true) return\n    }\n  }\n\n  /**\n   * @private\n   * @ignore\n   * @param {MessageDispatcher}  sender\n   * @param {Message}  message\n   * @param {...*} params\n   * @return {void}\n   */\n  __invokeOverheard(sender, message, ...params) {\n    if (message.canceled === true) return\n\n    let bindings = MessageDispatcher.mOverheardHandlers[message.name]\n\n    if (bindings === undefined || bindings.length === 0) return\n\n    let cloned = bindings.slice(0)\n\n    for (let i = 0; i < cloned.length; i++) {\n      let binding = cloned[i]\n\n      if (\n        this.checkForStage === true &&\n        binding.owner.stage === Black.stage &&\n        binding.owner.stage === null\n      )\n        continue\n\n      if (!this.__checkPath(sender.path, binding)) continue\n\n      message.target = this\n      binding.callback.call(binding.context, message, ...params)\n\n      if (binding.isOnce === true) this.__off(binding)\n\n      if (message.canceled === true) return\n    }\n  }\n\n  /**\n   * Message will always reach the stage even if some of the middle nodes were removed during process of invocation.\n   *\n   * @private\n   * @ignore\n   * @param {*}  sender\n   * @param {Message}  message\n   * @param {boolean}  toTop\n   * @param {...*} params\n   * @return {void}\n   */\n  __postBubbles(sender, message, toTop, ...params) {\n    message.origin = this\n\n    let list = [this]\n\n    let current = this\n    while (current.parent !== null) {\n      list.push(current.parent)\n      current = current.parent\n    }\n\n    for (let i = 0; i < list.length; i++) {\n      let dispatcher = list[i]\n      dispatcher.__invoke(sender, message, ...params)\n\n      if (message.canceled === true) return\n    }\n  }\n\n  /**\n   * @private\n   * @ignore\n   *\n   * @param {string} name\n   * @returns {Message}\n   */\n  __draftMessage(name) {\n    const message = Message.pool.get()\n    message.__reset()\n\n    message.sender = this\n\n    if (name.charAt(0) === '~') {\n      message.name = name.substr(1)\n      message.type = MessageType.BUBBLE\n    } else {\n      message.name = name\n    }\n\n    return message\n  }\n\n  /**\n   * @ignore\n   * @private\n   * @param {string|null} path\n   * @param {MessageBinding} binding\n   * @returns {boolean}\n   */\n  __checkPath(path, binding) {\n    if (path === null || binding.pathPattern === null) return false\n\n    if (path === binding.pathPattern) return true\n\n    if (binding.pathPattern.indexOf('*') === -1)\n      return path === binding.pathPattern\n\n    return binding.glob.test(path)\n  }\n}\n\n/**\n * @private\n * @type {Object.<string, Array>}\n */\nMessageDispatcher.mOverheardHandlers = {}\n","/**\n * Font measurement tools.\n *\n * @cat display.text\n */\n\nexport \nclass FontMetrics {\n  /**\n   * Creates new instance of FontMetrics. Do not use constructor directly instead use {@link FontMetrics#get} method.\n   *\n   * @ignore\n   * @private\n   * @param {TextStyle} style Default text info with 24 font size.\n   */\n  constructor(style) {\n    if (FontMetrics.__CONTEXT === null) {\n      FontMetrics.__CANVAS = /** @type {HTMLCanvasElement} */ (document.createElement(\n        'canvas'\n      ))\n      FontMetrics.__CONTEXT = FontMetrics.__CANVAS.getContext('2d')\n\n      FontMetrics.__CANVAS.width = 10\n      FontMetrics.__CANVAS.height = 200\n    }\n\n    style.size = 24\n\n    /** @private */\n    this.mCanvas = FontMetrics.__CANVAS\n\n    /** @private */\n    this.mCtx = FontMetrics.__CONTEXT\n\n    /** @private @type {TextStyle} */\n    this.mStyle = style\n\n    const drawY = Math.floor(FontMetrics.__CANVAS.height * 0.7766)\n    this.mCtx.clearRect(0, 0, this.mCanvas.width, this.mCanvas.height)\n    this.mCtx.font = `${style.weight} ${style.size}px ${style.family}`\n    this.mCtx.fillText('x', 0, drawY, 1)\n\n    let data = this.mCtx.getImageData(0, 0, 1, this.mCanvas.height).data\n\n    const xHeight = this.__getBottom(data) - this.__getTop(data)\n\n    for (let i = 32; i <= 126; i++) {\n      this.mCtx.fillText(String.fromCharCode(i), 0, drawY, 1)\n    }\n\n    data = this.mCtx.getImageData(0, 0, 1, this.mCanvas.height).data\n\n    const top = this.__getTop(data)\n    const bottom = this.__getBottom(data)\n    const baseLine = drawY - top\n    const height = bottom - top\n\n    /**\n     * The line upon which most letters \"sit\" and below which descender extend.\n     * @public\n     * @type {number}\n     */\n    this.baseline = baseLine\n\n    /**\n     * The maximum y position for the lowest glyph in the font.\n     * @public\n     * @type {number}\n     */\n    this.bottom = height\n\n    /**\n     * The recommended distance above the mean line (top of lower case characters) for singled spaced text.\n     * @public\n     * @type {number}\n     */\n    this.ascent = baseLine - xHeight\n\n    /**\n     * The recommended distance below the baseline for singled spaced text.\n     * @public\n     * @type {number}\n     */\n    this.descent = height - baseLine\n\n    /**\n     * The distance between the baseline and the mean line of lower-case letters, i.e height of `x` character.\n     * @public\n     * @type {number}\n     */\n    this.xHeight = xHeight\n\n    /**\n     * The height of a capital letter above the baseline.\n     * @public\n     * @type {number}\n     */\n    this.capHeight = baseLine\n  }\n\n  /**\n   * `capHeight` normalized.\n   *\n   * @readonly\n   * @public\n   * @returns {number}\n   */\n  get capHeightNormalized() {\n    return this.capHeight / this.mStyle.size\n  }\n\n  /**\n   * `xHeight` normalized.\n   *\n   * @readonly\n   * @public\n   * @returns {number}\n   */\n  get xHeightNormalized() {\n    return this.xHeight / this.mStyle.size\n  }\n\n  /**\n   * `ascent` normalized.\n   *\n   * @readonly\n   * @public\n   * @returns {number}\n   */\n  get ascentNormalized() {\n    return this.ascent / this.mStyle.size\n  }\n\n  /**\n   * `descent` normalized.\n   *\n   * @readonly\n   * @public\n   * @returns {number}\n   */\n  get descentNormalized() {\n    return this.descent / this.mStyle.size\n  }\n\n  /**\n   * `baseline` normalized.\n   *\n   * @readonly\n   * @public\n   * @returns {number}\n   */\n  get baselineNormalized() {\n    return this.baseline / this.mStyle.size\n  }\n\n  /**\n   * `bottom` normalized.\n   *\n   * @readonly\n   * @public\n   * @returns {number}\n   */\n  get bottomNormalized() {\n    return this.bottom / this.mStyle.size\n  }\n\n  /**\n   * @ignore\n   * @private\n   * @param {Uint8ClampedArray} data\n   * @returns {number}\n   */\n  __getTop(data) {\n    for (let i = 3, n = data.length; i < n; i += 4) {\n      if (data[i] > 0) {\n        return (i - 3) / 4\n      }\n    }\n\n    return data.length / 4\n  }\n\n  /**\n   * @ignore\n   * @private\n   * @param {Uint8ClampedArray} data\n   * @returns {number}\n   */\n  __getBottom(data) {\n    for (let i = data.length - 1; i > 0; i -= 4) {\n      if (data[i] > 0) {\n        return (i + 1) / 4\n      }\n    }\n\n    return 0\n  }\n\n  /**\n   * Use this method instead of constructor.\n   *\n   * @static\n   * @param {string} fontName Name of font.\n   * @returns {FontMetrics}\n   */\n  static get(fontName) {\n    let cache = FontMetrics.CACHE[fontName]\n\n    if (cache == null) {\n      let style = new TextStyle(fontName, 0, 24)\n      cache = new FontMetrics(style)\n      FontMetrics.CACHE[fontName] = cache\n    }\n\n    return cache\n  }\n}\n\n/** @ignore @static @private */\nFontMetrics.CACHE = {}\n\n/** @ignore @static @private */\nFontMetrics.__CONTEXT = null\n\n/** @ignore @static @private @type {HTMLCanvasElement}*/\nFontMetrics.__CANVAS = null\n\n/** @ignore @static @private */\nFontMetrics.CHAR_CAPITAL_HEIGHT = 's'\n\n/** @ignore @static @private */\nFontMetrics.CHAR_BASELINE = 'a'\n\n/** @ignore @static @private */\nFontMetrics.CHAR_XHEIGHT = 'x'\n\n/** @ignore @static @private */\nFontMetrics.CHAR_DESCENT = 'p'\n\n/** @ignore @static @private */\nFontMetrics.CHAR_ASCENT = 'h'\n","/**\n * Object representing text measurement result.\n *\n * @cat display.text\n */\nexport \nclass TextMetricsData {\n  constructor() {\n    /**\n     * Array of TextSegmentMetricsData objects containing style, bounds and other metrics information for each segment,\n     * @type {Array<TextSegmentMetricsData>}\n     */\n    this.segments = [] // TextPartMetricsData\n\n    /**\n     * The sum bounds, including all segments.\n     * @type {Rectangle}\n     */\n    this.bounds = new Rectangle()\n\n    /**\n     * Bounds plus stroke size.\n     * @type {Rectangle}\n     */\n    this.strokeBounds = null\n\n    /**\n     * Bounds of text shadow.\n     * @type {Rectangle}\n     */\n    this.shadowBounds = null\n\n    /**\n     * Array if widths for each line.\n     * @type {Array<number>}\n     */\n    this.lineWidth = []\n  }\n}\n\n/**\n * Object representing text segment measurement result.\n *\n * @cat display.text\n */\nexport \nclass TextSegmentMetricsData {\n  constructor(text, style, lineIndex, bounds) {\n    /**\n     * Text value for this segment.\n     * @type {string}\n     */\n    this.text = text\n\n    /**\n     * The style of this segment.\n     * @type {TextStyle}\n     */\n    this.style = style\n\n    /**\n     * The line index for this segment.\n     * @type {number}\n     */\n    this.lineIndex = lineIndex\n\n    /**\n     * The bounds of this segment.\n     * @type {Rectangle}\n     */\n    this.bounds = bounds\n  }\n}\n\n/**\n * Provides native text measurement tools\n *\n * @cat display.text\n * @static\n */\nexport \nclass TextMetricsEx {\n  constructor() {\n    throw new Error('Singleton')\n  }\n\n  /**\n   * Measures the area of provided text. In case style is not defined the default style will be used. Text is vertically\n   * aligned by its baseline.\n   *\n   * @static\n   * @param {string} text                            The text to measure.\n   * @param {number} lineHeight                      The height of the line.\n   * @param {...TextStyle} styles The TextStyle object representing text properties and formatting.\n   *\n   * @returns {TextMetricsData} Object representing bounds for each rich text part.\n   */\n  static measure(text, lineHeight, ...styles) {\n    let parts = []\n\n    const regex = /(~{([^}]+)}|^)(.+?(?=~{.+}|$|^))|(\\n)/gm\n\n    let m\n    let currTag = 'def'\n    let lineIx = 0\n\n    while ((m = regex.exec(text)) !== null) {\n      if (m[4]) lineIx++\n\n      if (m[2]) currTag = m[2]\n\n      if (m[3])\n        parts.push({\n          tag: currTag,\n          text: m[3],\n          style: styles.filter(x => x.name === currTag)[0],\n          lineIndex: lineIx,\n        })\n    }\n\n    let data = new TextMetricsData()\n    let defaultStyle =\n      styles.filter(x => x.name === 'def')[0] || TextStyle.default\n    let lineHeightPx = defaultStyle.size * lineHeight\n    let sumBounds = new Rectangle()\n    let sumStrokeBounds = new Rectangle()\n    let sumShadowBounds = null\n\n    let lastLineIndex = -1\n    let currentX = 0\n    let currentY = 0\n    let lastBounds = null\n\n    let defaultFontMetrics = FontMetrics.get(defaultStyle.family)\n    let defaultBaseline =\n      defaultFontMetrics.baselineNormalized * defaultStyle.size\n\n    for (let i = 0; i < parts.length; i++) {\n      let part = parts[i]\n      let style = part.style\n      let bounds = TextMetricsEx.__measure(part.text, style)\n      let baseline =\n        FontMetrics.get(style.family).baselineNormalized * style.size\n\n      if (lastLineIndex !== part.lineIndex) {\n        data.lineWidth[part.lineIndex] = 0\n        currentX = 0\n      }\n\n      currentY = lineHeightPx * part.lineIndex + defaultBaseline - baseline\n\n      bounds.x = currentX + 2\n      bounds.y = currentY + 2\n\n      currentX += bounds.width\n\n      lastLineIndex = part.lineIndex\n\n      part.bounds = bounds\n      data.lineWidth[part.lineIndex] += bounds.width\n\n      sumBounds.union(bounds)\n      sumStrokeBounds.union(\n        bounds.clone().inflate(style.strokeThickness, style.strokeThickness)\n      )\n\n      if (style.dropShadow === true) {\n        let shadowBounds = bounds.clone()\n        shadowBounds.inflate(style.shadowBlur, style.shadowBlur)\n        shadowBounds.x += style.shadowDistanceX\n        shadowBounds.y += style.shadowDistanceY\n        sumShadowBounds = sumShadowBounds || shadowBounds\n        sumShadowBounds.union(shadowBounds)\n      }\n\n      data.segments.push(\n        new TextSegmentMetricsData(\n          part.text,\n          style,\n          part.lineIndex,\n          part.bounds\n        )\n      )\n    }\n\n    data.bounds = sumBounds\n    data.strokeBounds = sumStrokeBounds\n    data.shadowBounds = sumShadowBounds || new Rectangle()\n\n    return data\n  }\n\n  /**\n   * Measures the area of provided text. Multiline is not supported.\n   *\n   * @static\n   * @param {string} text         The text to measure.\n   * @param {TextStyle} style     The TextStyle object representing text properties and formatting.\n   * @param {?Rectangle} [outBounds=null] Out param into which bounds of the text will be stored.\n   * @returns {Rectangle} Bounds of the text;\n   */\n  static __measure(text, style, outBounds = null) {\n    Debug.assert(style != null, 'Style cannot be null')\n\n    outBounds = outBounds || new Rectangle()\n    outBounds.zero()\n\n    let span = TextMetricsEx.__span\n\n    if (TextMetricsEx.__span === null) {\n      TextMetricsEx.__span = /** @type {HTMLElement} */ (document.createElement(\n        'span'\n      ))\n      span = /** @type {HTMLElement} */ (TextMetricsEx.__span)\n      span.id = 'font'\n      span.style.position = 'absolute'\n      span.style.width = 'auto'\n      span.style.height = 'auto'\n      span.style.top = '0px'\n      span.style.left = '0px'\n      span.style.display = 'inline-block'\n      span.style.border = '1px solid green'\n      span.style.color = '#00ff00'\n      span.style.verticalAlign = 'baseline'\n      span.style.whiteSpace = 'nowrap' //pre\n      span.style.lineHeight = 'normal'\n      span.style.top = '-9999px'\n      span.style.left = '-9999px'\n      document.body.appendChild(span)\n    }\n\n    span.style.fontFamily = style.family\n    span.style.fontSize = `${style.size}px`\n    span.style.fontWeight = style.weight\n    span.style.fontStyle = style.style\n\n    let fontMetrics = FontMetrics.get(style.family)\n    span.innerHTML = text.replace(/ /g, '&nbsp')\n\n    outBounds.set(\n      0,\n      fontMetrics.baselineNormalized * style.size,\n      span.offsetWidth + 2,\n      fontMetrics.bottomNormalized * style.size + 2\n    )\n    return outBounds\n  }\n\n  /**\n   * Measures the area of provided text\n   *\n   * @static\n   * @param {string} text\n   * @param {BitmapFontData} data\n   * @param {number} lineHeight\n   * @param {Rectangle} outBounds\n   * @returns {Rectangle}\n   */\n  static measureBitmap(text, data, lineHeight, outBounds) {\n    outBounds = outBounds || new Rectangle()\n\n    let prevCharCode = -1\n    let cx = 0\n    let cy = 0\n\n    let maxHeight = 0\n    let maxWidth = 0\n\n    for (let i = 0; i < text.length; i++) {\n      let charCode = text.charCodeAt(i)\n\n      if (/(?:\\r\\n|\\r|\\n)/.test(text.charAt(i))) {\n        cx = 0\n        cy += data.lineHeight * lineHeight\n        prevCharCode = -1\n        continue\n      }\n\n      let charData = data.chars[charCode]\n\n      if (charData == null) continue\n\n      if (prevCharCode >= 0 && charData.kerning[prevCharCode])\n        cx += charData.kerning[prevCharCode]\n\n      cx += charData.xAdvance\n\n      maxWidth = Math.max(maxWidth, cx + charData.xOffset)\n      maxHeight = Math.max(maxHeight, cy + charData.height + charData.yOffset)\n\n      prevCharCode = charCode\n    }\n\n    return outBounds.set(0, 0, maxWidth, maxHeight)\n  }\n}\n\n/**\n * @ignore\n * @private\n * @static\n * @type {HTMLElement|null}\n */\nTextMetricsEx.__span = null\n\n/**\n * @ignore\n * @private\n * @static\n */\nTextMetricsEx.NEWLINE_REGEX = /\\r?\\n/\n","/**\n * Provides time related methods.\n *\n * @cat core\n * @static\n */\nexport \nclass Time {\n  constructor() {}\n\n  /**\n   * Time since start in seconds.\n   *\n   * @static\n   * @returns {number}\n   */\n  static get now() {\n    return Time.mTime\n  }\n\n  /**\n   * Time since last frame.\n   *\n   * @static\n   * @returns {number}\n   */\n  static get dt() {\n    return Time.mDeltaTime * Time.mScale\n  }\n\n  /**\n   * Time since last update.\n   *\n   * @static\n   * @returns {number}\n   */\n  static get alpha() {\n    return Time.mAlphaTime\n  }\n\n  /**\n   * Time since last frame.\n   *\n   * @static\n   * @returns {number}\n   */\n  static get delta() {\n    return Time.mDeltaTime * Time.mScale\n  }\n\n  /**\n   * Gets/Sets timescale for engine\n   *\n   * @returns {number}\n   */\n  static get scale() {\n    return Time.mScale\n  }\n\n  /**\n   * @ignore\n   * @param {number} value\n   */\n  static set scale(value) {\n    Debug.assert(value >= 0, 'Time.scale must be >= 0.')\n\n    Time.mScale = value\n  }\n}\n\n/** @ignore @type {number} */\nTime.mTime = 0\n\n/** @ignore @type {number} */\nTime.mActualTime = 0\n\n/** @ignore @type {number} */\nTime.mDeltaTimeMs = 1000 / 60\n\n/** @ignore @type {number} */\nTime.mDeltaTime = (1000 / 60) * 0.001\n\n/** @ignore @type {number} */\nTime.mScale = 1\n\n/** @ignore @type {number} */\nTime.mAlphaTime = 0\n\n/** @ignore @type {number} */\nTime.mRenderOffset = 0\n","/**\n * Base class for custom systems. System is used to listen scene changes.\n *\n * @cat core\n * @extends MessageDispatcher\n */\nexport \nclass System extends MessageDispatcher {\n  constructor() {\n    super()\n  }\n\n  /**\n   * onUpdate\n   *\n   * @protected\n   * @return {void}\n   */\n  onUpdate() {}\n\n  /**\n   * onPostUpdate\n   *\n   * @protected\n   * @return {void}\n   */\n  onPostUpdate() {}\n\n  /**\n   * onRender\n   *\n   * @protected\n   * @return {void}\n   */\n  onRender() {}\n\n  /**\n   * onChildrenAdded\n   *\n   * @protected\n   * @param {GameObject} gameObject GameObject instance.\n   * @return {void}\n   */\n  onChildrenAdded(gameObject) {}\n\n  /**\n   * onChildrenRemoved\n   *\n   * @protected\n   * @param {GameObject} gameObject GameObject instance.\n   * @return {void}\n   */\n  onChildrenRemoved(gameObject) {}\n\n  /**\n   * onChildrenRemoved\n   *\n   * @protected\n   * @param {GameObject} gameObject GameObject instance.\n   * @return {void}\n   */\n  onChildrenChanged(gameObject) {}\n\n  /**\n   * onComponentAdded\n   *\n   * @protected\n   * @param {GameObject} child GameObject instance.\n   * @param {Component} component Component instance added to game object.\n   * @return {void}\n   */\n  onComponentAdded(child, component) {}\n\n  /**\n   * onComponentRemoved\n   *\n   * @protected\n   * @param {GameObject} child GameObject instance.\n   * @param {Component} component Component instance removed from game object.\n   * @return {void}\n   */\n  onComponentRemoved(child, component) {}\n}\n","/**\n * Manages viewport, handles DOM container resize events and updates internal\n * data. When firing `resize` event, stage bounds will be not up to date. Listen\n * for stage's `resize` message instead.\n *\n * @cat core\n * @fires Viewport#resize\n * @extends MessageDispatcher\n */\nexport \nclass Viewport extends MessageDispatcher {\n  /**\n   * constructor\n   * @param {HTMLElement} containerElement The native HTML element.\n   * @return {void}\n   */\n  constructor(containerElement) {\n    super()\n\n    /** @private @type {HTMLElement} */\n    this.mContainerElement = containerElement\n\n    let style = this.mContainerElement.style\n    style.userSelect = 'none'\n    style.touchAction = 'none'\n    style.cursor = 'auto'\n    style.WebkitTapHighlightColor = 'rgba(0, 0, 0, 0)'\n\n    const size = this.mContainerElement.getBoundingClientRect()\n\n    /** @private @type {Rectangle} */\n    this.mSize = new Rectangle(size.left, size.top, size.width, size.height)\n\n    this.isTransparent = true\n    this.backgroundColor = 0x222222\n\n    this.mChecksLeftSeconds = 0\n\n    window.addEventListener('resize', () => this.__onResize())\n  }\n\n  /**\n   * @private\n   * @ignore\n   */\n  __update() {\n    if (this.mChecksLeftSeconds <= 0) return\n\n    this.__onResize()\n\n    this.mChecksLeftSeconds -= Time.delta\n  }\n\n  /**\n   * @private\n   * @ignore\n   */\n  __onResize() {\n    const size = this.mContainerElement.getBoundingClientRect()\n    const newSize = Rectangle.pool\n      .get()\n      .set(size.left, size.top, size.width, size.height)\n\n    if (this.mSize.equals(newSize) === true) return\n\n    this.mSize.copyFrom(newSize)\n\n    /**\n     * Posted every time viewport size has changed.\n     * @event Viewport#resize\n     */\n    this.post(Message.RESIZE, this.mSize)\n\n    this.mChecksLeftSeconds = 1\n    Rectangle.pool.release(newSize)\n  }\n\n  /**\n   * Returns the size of a viewport.\n   *\n   * @return {Rectangle}\n   */\n  get size() {\n    return this.mSize\n  }\n\n  /**\n   * nativeDOM - Returns the HTML container element the engine runs in.\n   *\n   * @return {Element}\n   */\n  get nativeDOM() {\n    return this.mContainerElement\n  }\n\n  // TODO: dispose, remove resize event\n}\n","/**\n * A base class for custom components.\n *\n * @cat core\n * @unrestricted\n * @extends MessageDispatcher\n */\nexport \nclass Component extends MessageDispatcher {\n  /**\n   * Creates new Component instance.\n   */\n  constructor() {\n    super(true)\n\n    /** @private @type {number} */\n    this.mId = ++Component.ID\n\n    /** @private @type {GameObject|null} */\n    this.mGameObject = null\n\n    /** @private @type {boolean} */\n    this.mAdded = false\n  }\n\n  /**\n   * Called when attached to GameObject.\n   *\n   * @protected\n   * @param  {GameObject} gameObject The owner of this component.\n   * @return {void}\n   */\n  onAdded(gameObject) {}\n\n  /**\n   * Called when detached from GameObject.\n   *\n   * @protected\n   * @param  {GameObject} gameObject The owner of this component.\n   * @return {void}\n   */\n  onRemoved(gameObject) {}\n\n  /**\n   * Called at every update.\n   *\n   * @protected\n   * @return {void}\n   */\n  onUpdate() {}\n\n  /**\n   * Called after all updates have been executed but before DisplayObject's onRender. GameObject itself does not have onRender method so Component#onRender will not be called on GameObjects.\n   * This method can be used to interpolate/extrapolate values when low `Black#ups` value is used.\n   *\n   * @protected\n   * @return {void}\n   */\n  onRender() {}\n\n  /**\n   * Detaches this Component from its parent GameObject.\n   *\n   * @returns {void}\n   */\n  removeFromParent() {\n    if (this.mGameObject === null) return\n\n    this.mGameObject.removeComponent(this)\n  }\n\n  /**\n   * Returns owner of this component.\n   *\n   * @readonly\n   * @returns {GameObject}\n   */\n  get gameObject() {\n    return this.mGameObject\n  }\n\n  /**\n   * Returns this Component owner GameObject.\n   * @readonly\n   * @return {GameObject|null}\n   */\n  get parent() {\n    return this.mGameObject\n  }\n\n  /**\n   * Returns the stage Game Object to which this component belongs to or null if not on the stage.\n   *\n   * @override\n   * @readonly\n   * @return {Stage|null}\n   */\n  get stage() {\n    if (this.mGameObject === null) return null\n\n    return this.mGameObject.stage\n  }\n\n  /**\n   * Returns string representing a url like path to this object in the display tree.\n   *\n   * @override\n   * @readonly\n   * @return {string|null}\n   */\n  get path() {\n    if (this.mGameObject !== null)\n      return this.mGameObject.path + '#' + this.constructor.name\n\n    return this.constructor.name\n  }\n}\n\n/**\n * @ignore\n * @type {number}\n * @nocollapse\n */\nComponent.ID = 0\n","/**\n * Building block in Black Engine.\n *\n * @cat core\n * @export\n * @unrestricted\n * @extends MessageDispatcher\n */\nexport \nclass GameObject extends MessageDispatcher {\n  /**\n   * Creates new instance of GameObject.\n   */\n  constructor() {\n    super(true)\n\n    /** @private @type {number} */\n    this.mId = ++GameObject.ID\n\n    /** @private @type {string|null} */\n    this.mName = null\n\n    /** @private @type {Array<Component>} */\n    this.mComponents = []\n\n    /** @protected @type {Array<GameObject>} */\n    this.mChildren = []\n\n    /** @private @type {number} */\n    this.mX = 0\n\n    /** @private @type {number} */\n    this.mY = 0\n\n    /** @private @type {number} */\n    this.mScaleX = 1\n\n    /** @private @type {number} */\n    this.mScaleY = 1\n\n    /** @protected @type {number} */\n    this.mPivotX = 0\n\n    /** @protected @type {number} */\n    this.mPivotY = 0\n\n    /** @protected @type {number} */\n    this.mSkewX = 0\n\n    /** @protected @type {number} */\n    this.mSkewY = 0\n\n    /** @protected @type {number|null} */\n    this.mAnchorX = null\n\n    /** @protected @type {number|null} */\n    this.mAnchorY = null\n\n    /** @protected @type {number} */\n    this.mPivotOffsetX = 0\n\n    /** @protected @type {number} */\n    this.mPivotOffsetY = 0\n\n    /** @protected @type {boolean} */\n    this.mAnchorChanged = false\n\n    /** @private @type {number} */\n    this.mRotation = 0\n\n    /** @protected @type {Rectangle} */\n    this.mBoundsCache = new Rectangle()\n\n    /** @private @type {Matrix} */\n    this.mLocalTransform = new Matrix()\n\n    /** @private @type {Matrix} */\n    this.mWorldTransform = new Matrix()\n\n    /** @private @type {Matrix} */\n    this.mWorldTransformInverted = new Matrix()\n\n    /** @private @type {DirtyFlag} */\n    this.mDirty = DirtyFlag.DIRTY\n\n    /** @protected @type {GameObject} */\n    this.mParent = null\n\n    /** @private @type {string|null} */\n    this.mTag = null\n\n    /** @private @type {boolean} */\n    this.mAdded = false\n\n    /** @private @type {number} */\n    this.mNumChildrenRemoved = 0\n\n    /** @private @type {number} */\n    this.mNumComponentsRemoved = 0\n\n    /** @private @type {number} */\n    this.mDirtyFrameNum = 0\n\n    /** @private @type {boolean} */\n    this.mSuspendDirty = false\n\n    // cache all colliders for fast access\n    /** @private @type {Array<Collider>} */\n    this.mCollidersCache = []\n\n    /** @private @type {boolean} */\n    this.mChildOrComponentBeenAdded = false\n\n    /** @private @type {Array<GameObject>} */\n    this.mChildrenClone = null\n\n    /** @private @type {Array<Component>} */\n    this.mComponentClone = null\n  }\n\n  make(values) {\n    // can be helpful if there are many children\n    this.mSuspendDirty = true\n\n    for (let property in values) {\n      if (values.hasOwnProperty(property)) {\n        this[property] = values[property]\n      }\n    }\n\n    this.mSuspendDirty = false\n    this.setTransformDirty()\n\n    return this\n  }\n\n  /**\n   * Returns unique object id.\n   *\n   * @returns {number}\n   */\n  get id() {\n    return this.mId\n  }\n\n  /**\n   * Returns true if object was clean for at least 1 update.\n   *\n   * Note: Make sure to apply all changes to this game object before checking for static.\n   *\n   * @param {boolean} [includeChildren=true]\n   * @returns {boolean}\n   */\n  checkStatic(includeChildren = true) {\n    if (includeChildren === false) return this.mDirtyFrameNum < Black.frameNum\n\n    let isDynamic = false\n    GameObject.forEach(this, x => {\n      if (x.mDirtyFrameNum >= Black.frameNum) {\n        isDynamic = true\n        return true\n      }\n    })\n\n    return !isDynamic\n  }\n\n  /**\n   * This method called each time object added to stage.\n   *\n   * @return {void}\n   */\n  onAdded() {}\n\n  /**\n   * Called when object is removed from stage.\n   *\n   * @return {void}\n   */\n  onRemoved() {}\n\n  /**\n   * Sugar method for adding child `GameObjects` or `Components` in a simple manner.\n   *\n   * @param {...(GameObject|Component)} gameObjectsAndOrComponents A `GameObject` or `Component` to add.\n   * @return {GameObject} This game object\n   */\n  add(...gameObjectsAndOrComponents) {\n    for (let i = 0; i < gameObjectsAndOrComponents.length; i++) {\n      let gooc = gameObjectsAndOrComponents[i]\n\n      if (gooc instanceof GameObject)\n        this.addChild(/** @type {!GameObject} */ (gooc))\n      else this.addComponent(/** @type {!Component} */ (gooc))\n    }\n\n    return this\n  }\n\n  /**\n   * Adds a child `GameObject` instance to this `GameObject` instance. The child is added to the top of all other\n   * children in this GameObject instance.\n   *\n   * @param  {GameObject} child The GameObject instance to add as a child of this GameObject instance.\n   * @return {GameObject}\n   */\n  addChild(child) {\n    return this.addChildAt(child, this.mChildren.length)\n  }\n\n  /**\n   * Adds a child `GameObject` instance to this `GameObject` instance. The child is added to the top of all other\n   * children in this GameObject instance.\n   *\n   * @param  {GameObject} child The GameObject instance to add as a child of this GameObject instance.\n   * @param  {number=} [index=0] The index position to which the child is added.\n   * @return {GameObject} The GameObject instance that you pass in the child parameter.\n   */\n  addChildAt(child, index = 0) {\n    Debug.assert(child instanceof GameObject, 'Type error.')\n\n    let numChildren = this.mChildren.length\n\n    if (index < 0 || index > numChildren)\n      throw new Error('Child index is out of bounds.')\n\n    if (child.mParent === this) return this.setChildIndex(child, index)\n\n    // this operation should be atomic. since __setParent can throw exception.\n    this.mChildren.splice(index, 0, child)\n\n    child.removeFromParent()\n    child.__setParent(this)\n\n    if (this.root instanceof Stage) Black.instance.onChildrenAdded(child)\n\n    this.mChildOrComponentBeenAdded = true\n\n    return child\n  }\n\n  /**\n   * @private\n   * @ignore\n   * @param {GameObject} value\n   * @return {boolean}\n   */\n  __setParent(value) {\n    let p = value\n\n    while (p !== null && p !== this) p = p.mParent\n\n    if (p === this) throw new Error('Object cannot be a child to itself.')\n\n    this.mParent = value\n    this.setTransformDirty()\n    return true\n  }\n\n  /**\n   * Sets the index (layer) of the specified `GameObject` to the specified index (layer).\n   *\n   * @param {GameObject} child The `GameObject` instance to change index for.\n   * @param {number} index Desired index.\n   * @returns {GameObject} The `GameObject` instance that you pass in the child parameter.\n   */\n  setChildIndex(child, index) {\n    let ix = this.mChildren.indexOf(child)\n\n    if (ix < 0)\n      throw new Error('Given child element was not found in children list.')\n\n    if (ix === index) return child\n\n    // NOTE: systems needs to know when trees changes\n    this.mChildren.splice(ix, 1)\n    this.mChildren.splice(index, 0, child)\n\n    if (this.stage !== null) Black.instance.onChildrenChanged(child)\n\n    this.setTransformDirty()\n\n    return child\n  }\n\n  /**\n   * Removes this `GameObject` instance from its parent.\n   *\n   * @return {void}\n   */\n  removeFromParent() {\n    if (this.mParent !== null) this.mParent.removeChild(this)\n\n    this.setTransformDirty()\n  }\n\n  /**\n   * Removes specified child `GameObject` instance from children.\n   *\n   * @param {GameObject} child `GameObject` instance to remove.\n   * @return {GameObject} The `GameObject` instance that you pass in the child parameter.\n   */\n  removeChild(child) {\n    let ix = this.mChildren.indexOf(child)\n\n    if (ix < 0) return null\n\n    return this.removeChildAt(ix)\n  }\n\n  /**\n   * Finds children by name.\n   *\n   * @param {string} name Name of the child object to find.\n   * @return {GameObject|null} GameObject instance or null if not found.\n   */\n  getChildByName(name) {\n    for (let i = 0; i < this.mChildren.length; i++) {\n      if (this.mChildren[i].name === name) return this.mChildren[i]\n    }\n\n    return null\n  }\n\n  /**\n   * Removes `GameObjects` instance from specified index.\n   *\n   * @param {number} index Index of child.\n   * @return {GameObject} The removed `GameObject` instance.\n   */\n  removeChildAt(index) {\n    if (index < 0 || index > this.numChildren)\n      throw new Error('Child index is out of bounds.')\n\n    let hadRoot = this.stage !== null\n\n    let child = this.mChildren[index]\n    child.__setParent(null)\n\n    this.mChildren.splice(index, 1)\n\n    if (hadRoot) Black.instance.onChildrenRemoved(child)\n\n    this.setTransformDirty()\n    this.mNumChildrenRemoved++\n\n    return child\n  }\n\n  /**\n   * Returns `GameObject` at specified index.\n   *\n   * @param {number} index The index of child `GameObject`.\n   * @return {GameObject} The `GameObject` at specified index.\n   */\n  getChildAt(index) {\n    return this.mChildren[index]\n  }\n\n  /**\n   * Adds `Component` instance to the end of the list.\n   *\n   * @param  {Component} component `Component` instance or instances.\n   * @return {Component} The `Component` instance you pass in the instances parameter.\n   * @throws {Error}\n   */\n  addComponent(component) {\n    Debug.assert(component instanceof Component, 'Type error.')\n\n    let instance = component\n\n    if (instance.gameObject)\n      throw new Error(\n        'Component cannot be added to two game objects at the same time.'\n      )\n\n    this.mComponents.push(instance)\n    instance.mGameObject = this\n\n    if (instance instanceof Collider) this.mCollidersCache.push(instance)\n\n    if (this.stage !== null || Black.stage === this) {\n      Black.instance.onComponentAdded(this, instance)\n    }\n\n    this.mChildOrComponentBeenAdded = true\n\n    return instance\n  }\n\n  /**\n   * Remove specified component.\n   *\n   * @param {Component} instance The `Component` instance.\n   * @return {Component|null}\n   */\n  removeComponent(instance) {\n    if (!instance) return null\n\n    Debug.assert(instance instanceof Component, 'Type error.')\n\n    let index = this.mComponents.indexOf(instance)\n    if (index > -1) this.mComponents.splice(index, 1)\n\n    // detach game object after or before?\n    instance.mGameObject = null\n\n    if (instance instanceof Collider) {\n      let index = this.mCollidersCache.indexOf(instance)\n      if (index > -1) this.mCollidersCache.splice(index, 1)\n    }\n\n    if (this.stage !== null || Black.stage === this) {\n      Black.instance.onComponentRemoved(this, instance)\n    }\n\n    this.mNumComponentsRemoved++\n\n    return instance\n  }\n\n  /**\n   * Get component by type.\n   *\n   * @param {Function} typeName The component type.\n   * @return {Component|null} The `Component` instance or null if not found.\n   */\n  getComponent(typeName) {\n    for (let i = 0; i < this.mComponents.length; i++) {\n      let c = this.mComponents[i]\n      if (c instanceof typeName) return c\n    }\n\n    return null\n  }\n\n  /**\n   * Returns number of component's of this GameObject.\n   *\n   * @return {number}\n   */\n  get numComponents() {\n    return this.mComponents.length\n  }\n\n  /**\n   * Retrieves `Component` at given index.\n   *\n   * @param {number} index Index of component.\n   * @return {Component|null}\n   */\n  getComponentAt(index) {\n    if (index >= 0 && index < this.mComponents.length)\n      return this.mComponents[index]\n\n    return null\n  }\n\n  /**\n   * Returns local transformation `Matrix`\n   *\n   * @readonly\n   * @return {Matrix}\n   */\n  get localTransformation() {\n    if (this.mDirty & DirtyFlag.LOCAL) {\n      this.mDirty ^= DirtyFlag.LOCAL\n\n      if (this.mSkewX === 0.0 && this.mSkewY === 0.0) {\n        if (this.mRotation === 0) {\n          return this.mLocalTransform.set(\n            this.mScaleX,\n            0,\n            0,\n            this.mScaleY,\n            this.mX - this.mPivotX * this.mScaleX,\n            this.mY - this.mPivotY * this.mScaleY\n          )\n        } else {\n          let cos = Math.cos(this.mRotation)\n          let sin = Math.sin(this.mRotation)\n          let a = this.mScaleX * cos\n          let b = this.mScaleX * sin\n          let c = this.mScaleY * -sin\n          let d = this.mScaleY * cos\n          let tx = this.mX - this.mPivotX * a - this.mPivotY * c\n          let ty = this.mY - this.mPivotX * b - this.mPivotY * d\n          return this.mLocalTransform.set(a, b, c, d, tx, ty)\n        }\n      } else {\n        this.mLocalTransform.identity()\n        this.mLocalTransform.scale(this.mScaleX, this.mScaleY)\n        this.mLocalTransform.skew(this.mSkewX, this.mSkewY)\n        this.mLocalTransform.rotate(this.mRotation)\n\n        let a = this.mLocalTransform.data[0]\n        let b = this.mLocalTransform.data[1]\n        let c = this.mLocalTransform.data[2]\n        let d = this.mLocalTransform.data[3]\n        let tx = this.mX\n        let ty = this.mY\n\n        if (this.mPivotX !== 0.0 || this.mPivotY !== 0.0) {\n          tx = this.mX - a * this.mPivotX - c * this.mPivotY\n          ty = this.mY - b * this.mPivotX - d * this.mPivotY\n        }\n\n        this.mLocalTransform.data[4] = tx\n        this.mLocalTransform.data[5] = ty\n      }\n    }\n\n    return this.mLocalTransform\n  }\n\n  /**\n   * Gets/Sets cloned Matrix object which represents object orientation in world space.\n   *\n   * @return {Matrix}\n   */\n  get worldTransformation() {\n    if (\n      this.mDirty & DirtyFlag.ANCHOR &&\n      (this.mAnchorX !== null || this.mAnchorY !== null)\n    ) {\n      this.mDirty ^= DirtyFlag.ANCHOR\n\n      this.__updatePivots(this)\n\n      this.setDirty(\n        /** @type {DirtyFlag} */ (DirtyFlag.LOCAL | DirtyFlag.WIRB),\n        true\n      )\n    }\n\n    if (this.mDirty & DirtyFlag.WORLD) {\n      this.mDirty ^= DirtyFlag.WORLD\n\n      if (this.mParent !== null)\n        this.mParent.worldTransformation\n          .copyTo(this.mWorldTransform)\n          .append(this.localTransformation)\n      else this.localTransformation.copyTo(this.mWorldTransform)\n    }\n    return this.mWorldTransform\n  }\n\n  /**\n   * @ignore\n   * @param {Matrix} value\n   * @return {void}\n   */\n  set localTransformation(value) {\n    const PI_Q = Math.PI / 4.0\n\n    let a = value.data[0]\n    let b = value.data[1]\n    let c = value.data[2]\n    let d = value.data[3]\n    let tx = value.data[4]\n    let ty = value.data[5]\n\n    this.mPivotX = this.mPivotX = 0\n    this.mX = tx\n    this.mY = ty\n\n    let skewX = Math.atan(-c / d)\n    let skewY = Math.atan(b / a)\n\n    if (skewX != skewX) skewX = 0.0\n    if (skewY != skewY) skewY = 0.0\n\n    this.mScaleY =\n      skewX > -PI_Q && skewX < PI_Q ? d / Math.cos(skewX) : -c / Math.sin(skewX)\n    this.mScaleX =\n      skewY > -PI_Q && skewY < PI_Q ? a / Math.cos(skewY) : b / Math.sin(skewY)\n\n    if (MathEx.equals(skewX, skewY)) {\n      this.mRotation = skewX\n      this.mSkewX = this.mSkewY = 0\n    } else {\n      this.mRotation = 0\n      this.mSkewX = skewX\n      this.mSkewY = skewY\n    }\n\n    this.setTransformDirty()\n  }\n\n  /**\n   * Returns cloned and inverted Matrix object which represents object orientation in world space\n   *\n   * @readonly\n   * @return {Matrix}\n   */\n  get worldTransformationInverted() {\n    if (this.mDirty & DirtyFlag.WORLD_INV) {\n      this.mDirty ^= DirtyFlag.WORLD_INV\n\n      this.worldTransformation.copyTo(this.mWorldTransformInverted).invert()\n    }\n\n    return this.mWorldTransformInverted\n  }\n\n  /**\n   * @ignore\n   * @private\n   * @return {void}\n   */\n  __update() {\n    this.onUpdate()\n\n    if (this.mChildOrComponentBeenAdded === false) return\n\n    if (this.mComponents.length > 0) {\n      this.mComponentClone = this.mComponents.slice()\n\n      for (let k = 0; k < this.mComponentClone.length; k++) {\n        if (this.mAdded === false) break\n\n        let c = this.mComponentClone[k]\n\n        if (c.mAdded === false) break\n\n        c.onUpdate()\n      }\n    }\n\n    if (this.mChildren.length > 0) {\n      this.mChildrenClone = this.mChildren.slice()\n\n      for (let i = 0; i < this.mChildrenClone.length; i++) {\n        let child = this.mChildrenClone[i]\n\n        if (child.mAdded === true) child.__update()\n      }\n    }\n  }\n\n  /**\n   * Called at every engine update. The execution order of onFixedUpdate, onUpdate and onPostUpdate is\n   * going from top to bottom of the display list.\n   *\n   * @protected\n   * @return {void}\n   */\n  onUpdate() {}\n\n  /**\n   * Called every time `GameObject` has to be rendered. Doesn't render itself. Collects render data to be processed by\n   * video driver after.\n   *\n   * NOTE: Adding, removing or changing children elements inside onRender method can lead to unexpected behavior.\n   *\n   * @protected\n   * @param {VideoNullDriver} driver Current registered video driver.\n   * @param {Renderer} parentRenderer Renderer of parent `GameObject` if there is one.\n   * @param {boolean=} [isBackBufferActive=false] Specifies if render to backBuffer.\n   * @return {Renderer}\n   */\n  onCollectRenderables(driver, parentRenderer, isBackBufferActive = false) {\n    return null\n  }\n\n  /**\n   * Override this method if you need to specify GameObject size. Should be always be a local coordinates.\n   *\n   * @protected\n   * @param {Rectangle=} [outRect=undefined] Rectangle to be returned.\n   * @return {Rectangle} bounds in local space without taking care about transformation matrix\n   */\n  onGetLocalBounds(outRect = undefined) {\n    outRect = outRect || new Rectangle()\n    return outRect.set(0, 0, 0, 0)\n  }\n\n  /**\n   * Returns world bounds of this object and all children if specified (true by default).\n   *\n   * `object.getBounds()` - relative to parent (default).<br>\n   * `object.getBounds(object)` - local bounds.<br>\n   * `object.getBounds(object.parent)` - relative to parent.<br>\n   * `object.getBounds(objectB)` - relative to objectB space.<br>\n   *\n   * @param {GameObject} [space=null] The `GameObject` relative to.\n   * @param {boolean} [includeChildren=true] Specifies if include children in calculations.\n   * @param {Rectangle=} [outRect=null] Rectangle to be returned.\n   * @return {Rectangle} Returns bounds of the object with/without all children.\n   */\n  getBounds(space = null, includeChildren = true, outRect = undefined) {\n    outRect = outRect || new Rectangle()\n\n    this.onGetLocalBounds(outRect)\n\n    if (space == null) space = this.mParent\n\n    if (space == this) {\n      // local\n    } else if (space == this.mParent) {\n      if (includeChildren === false) {\n        let matrix = Matrix.pool.get()\n        matrix.copyFrom(this.localTransformation)\n        matrix.transformRect(outRect, outRect)\n        Matrix.pool.release(matrix)\n      } else if (includeChildren === true && this.mDirty & DirtyFlag.BOUNDS) {\n        let matrix = Matrix.pool.get()\n        matrix.copyFrom(this.localTransformation)\n        matrix.transformRect(outRect, outRect)\n        Matrix.pool.release(matrix)\n      } else {\n        outRect.copyFrom(this.mBoundsCache)\n        return outRect\n      }\n    } else {\n      let matrix = Matrix.pool.get()\n      matrix.copyFrom(this.worldTransformation)\n      matrix.prepend(space.worldTransformationInverted)\n      matrix.transformRect(outRect, outRect)\n      Matrix.pool.release(matrix)\n    }\n\n    if (includeChildren === true) {\n      let childBounds = Rectangle.pool.get()\n\n      for (let i = 0; i < this.mChildren.length; i++) {\n        childBounds.zero()\n\n        this.mChildren[i].getBounds(space, includeChildren, childBounds)\n        outRect.union(childBounds)\n      }\n\n      Rectangle.pool.release(childBounds)\n\n      if (space == this.mParent && this.mDirty & DirtyFlag.BOUNDS) {\n        this.mBoundsCache.copyFrom(outRect)\n        this.mDirty ^= DirtyFlag.BOUNDS\n      }\n    }\n\n    return outRect\n  }\n\n  /**\n   * Returns stage relative bounds of this object excluding it's children;\n   *\n   * @param {Rectangle=} [outRect=null] Rectangle to be store resulting bounds in.\n   * @returns {Rectangle}\n   */\n  getStageBounds(outRect = undefined) {\n    outRect = outRect || new Rectangle()\n\n    this.onGetLocalBounds(outRect)\n\n    let matrix = Matrix.pool.get()\n    matrix.copyFrom(this.worldTransformation)\n    matrix.prepend(this.stage.worldTransformationInverted) // 120ms\n    matrix.transformRect(outRect, outRect) // 250ms\n    Matrix.pool.release(matrix)\n\n    return outRect\n  }\n\n  /**\n   * Evaluates whether the game object or one of its children intersects with the given point\n   *\n   * @param {Vector} localPoint Coordinates vector.\n   * @return {GameObject|null}\n   */\n  hitTest(localPoint) {\n    let c = /** @type {InputComponent}*/ (this.getComponent(InputComponent))\n    let touchable = c !== null && c.touchable\n    let insideMask = this.onHitTestMask(localPoint)\n\n    if (touchable === false || insideMask === false) return null\n\n    let target = null\n    let numChildren = this.mChildren.length\n\n    for (let i = numChildren - 1; i >= 0; --i) {\n      let child = this.mChildren[i]\n\n      target = child.hitTest(localPoint)\n\n      if (target !== null) return target\n    }\n\n    if (this.onHitTest(localPoint) === true) return this\n\n    return null\n  }\n\n  /**\n   * @ignore\n   * @protected\n   * @param {Vector} localPoint\n   * @return {boolean}\n   */\n  onHitTest(localPoint) {\n    let contains = false\n\n    // BEGINOF: WTF\n    let tmpVector = /** @type {Vector}*/ (Vector.pool.get())\n    this.worldTransformationInverted.transformVector(localPoint, tmpVector)\n    // ENDOF: WTF\n\n    if (this.mCollidersCache.length > 0) {\n      for (let i = 0; i < this.mCollidersCache.length; i++) {\n        let collider = this.mCollidersCache[i]\n\n        contains = collider.containsPoint(tmpVector)\n        if (contains === true) return true\n      }\n    } else {\n      contains = this.localBounds.containsXY(tmpVector.x, tmpVector.y)\n    }\n\n    Vector.pool.release(tmpVector)\n    return contains\n  }\n\n  /**\n   * @ignore\n   * @protected\n   * @param {Vector} localPoint\n   * @return {boolean}\n   */\n  onHitTestMask(localPoint) {\n    return true\n  }\n\n  /**\n   * Returns local bounds of this object (without children).\n   */\n  get localBounds() {\n    return this.getBounds(this, false)\n  }\n\n  /**\n   * Returns parent-relative bounds (including children).\n   */\n  get bounds() {\n    return this.getBounds(this.mParent, true)\n  }\n\n  /**\n   * Sets the object transform in one line.\n   *\n   * @param {number} [x=0]       Cord X.\n   * @param {number} [y=0]       Cord Y.\n   * @param {number} [r=0]       Rotation.\n   * @param {number} [scaleX=1]  Scale X.\n   * @param {number} [scaleY=1]  Scale Y.\n   * @param {number} [anchorX=0] Anchor X.\n   * @param {number} [anchorY=0] Anchor Y.\n   * @param {boolean} [includeChildren=true] Include children when adjusting pivot?\n   *\n   * @return {GameObject} This.\n   */\n  setTransform(\n    x = 0,\n    y = 0,\n    r = 0,\n    scaleX = 1,\n    scaleY = 1,\n    anchorX = 0,\n    anchorY = 0,\n    includeChildren = true\n  ) {\n    this.mX = x\n    this.mY = y\n    this.mRotation = r\n    this.mScaleX = scaleX\n    this.mScaleY = scaleY\n    this.mAnchorX = anchorX\n    this.mAnchorY = anchorY\n\n    this.setTransformDirty()\n    return this\n  }\n\n  /**\n   * Calculates GameObject's position relative to another GameObject.\n   *\n   * @param {GameObject} gameObject Coordinates vector.\n   * @param {Vector|null} [outVector=null] Vector to be returned.\n   * @return {Vector}\n   */\n  relativeTo(gameObject, outVector = null) {\n    outVector = outVector || new Vector()\n    outVector.set(this.x, this.y)\n\n    if (this.parent == null || gameObject == null) return outVector\n\n    this.parent.localToGlobal(outVector, outVector)\n    gameObject.globalToLocal(outVector, outVector)\n    return outVector\n  }\n\n  /**\n   * Calculate global position of the object.\n   *\n   * @param {Vector} localPoint Coordinates vector.\n   * @param {Vector|null} [outVector=null] Vector to be returned.\n   * @return {Vector}\n   */\n  localToGlobal(localPoint, outVector = null) {\n    return this.worldTransformation.transformVector(localPoint, outVector)\n  }\n\n  /**\n   * Calculate local position of the object\n   *\n   * @param {Vector} globalPoint Coordinates vector.\n   * @param {Vector|null} [outVector=null] Vector to be returned.\n   * @return {Vector}\n   */\n  globalToLocal(globalPoint, outVector = null) {\n    return this.worldTransformationInverted.transformVector(\n      globalPoint,\n      outVector\n    )\n  }\n  /**\n   * Gets a count of children elements.\n   *\n   * @return {number}\n   */\n  get numChildren() {\n    return this.mChildren.length\n  }\n\n  /**\n   * Gets/Sets the name of this GameObject instance.\n   *\n   * @export\n   * @return {string|null}\n   */\n  get name() {\n    return this.mName\n  }\n\n  /**\n   * @export\n   * @ignore\n   * @param {string|null} value\n   * @return {void}\n   */\n  set name(value) {\n    this.mName = value\n  }\n\n  /**\n   * Gets/Sets the x coordinate of the GameObject instance relative to the local coordinates of the parent GameObject.\n   * @export\n   * @return {number}\n   */\n  get x() {\n    return this.mX\n  }\n\n  /**\n   * @export\n   * @ignore\n   * @param {number} value\n   * @return {void}\n   */\n  set x(value) {\n    if (this.mX == value) return\n\n    Debug.assert(!isNaN(value), 'Value cannot be NaN')\n\n    this.mX = value\n    this.setTransformDirty()\n  }\n\n  /**\n   * Gets/Sets the y coordinate of the GameObject instance relative to the local coordinates of the parent GameObject.\n   *\n   * @export\n   * @return {number}\n   */\n  get y() {\n    return this.mY\n  }\n\n  /**\n   * @export\n   * @ignore\n   * @param {number} value\n   * @return {void}\n   */\n  set y(value) {\n    if (this.mY == value) return\n\n    Debug.assert(!isNaN(value), 'Value cannot be NaN')\n\n    this.mY = value\n    this.setTransformDirty()\n  }\n\n  /**\n   * Gets/Sets the x coordinate of the object's origin in its local space in pixels.\n   *\n   * @export\n   * @return {number}\n   */\n  get pivotOffsetX() {\n    return this.mPivotOffsetX\n  }\n\n  /**\n   * @export\n   * @ignore\n   * @param {number} value\n   * @return {void}\n   */\n  set pivotOffsetX(value) {\n    if (this.mPivotOffsetX === value) return\n\n    Debug.assert(!isNaN(value), 'Value cannot be NaN')\n\n    this.mPivotOffsetX = value\n\n    this.__updatePivots(this)\n    this.setTransformDirty()\n  }\n\n  /**\n   * Gets/Sets the y coordinate of the object's origin in its local space in pixels.\n   *\n   * @export\n   * @return {number}\n   */\n  get pivotOffsetY() {\n    return this.mPivotOffsetY\n  }\n\n  /**\n   * @export\n   * @ignore\n   * @param {number} value\n   * @return {void}\n   */\n  set pivotOffsetY(value) {\n    if (this.mPivotOffsetY === value) return\n\n    Debug.assert(!isNaN(value), 'Value cannot be NaN')\n\n    this.mPivotOffsetY = value\n\n    this.__updatePivots(this)\n    this.setTransformDirty()\n  }\n\n  /**\n   * Gets/Sets the x-coordinate of the object's origin in its local space in percent.\n   *\n   * @export\n   * @ignore\n   * @param {number|null} value\n   * @return {void}\n   */\n  set anchorX(value) {\n    if (this.mAnchorX === value) return\n\n    Debug.assert(value !== null && !isNaN(value), 'Value cannot be NaN')\n\n    this.mAnchorX = value\n    this.mAnchorChanged = true\n\n    this.setTransformDirty()\n  }\n\n  /**\n   * Gets/Sets the y-coordinate of the object's origin in its local space in percent.\n   *\n   * @export\n   * @ignore\n   * @param {number|null} value\n   * @return {void}\n   */\n  set anchorY(value) {\n    if (this.mAnchorY === value) return\n\n    Debug.assert(value !== null && !isNaN(value), 'Value cannot be NaN')\n\n    this.mAnchorY = value\n    this.mAnchorChanged = true\n\n    this.setTransformDirty()\n  }\n\n  /**\n   * Returns current anchor-x value in range from 0 to 1.\n   *\n   * @export\n   * @returns {number|null}\n   */\n  get anchorX() {\n    return this.mAnchorX\n  }\n\n  /**\n   * Returns current anchor-y value in range from 0 to 1.\n   *\n   * @export\n   * @returns {number|null}\n   */\n  get anchorY() {\n    return this.mAnchorY\n  }\n\n  /**\n   * Returns current pivot-x value in range from 0 to 1.\n   *\n   * @returns {number}\n   */\n  get pivotX() {\n    return this.mPivotX\n  }\n\n  /**\n   * Returns current pivot-y value in range from 0 to 1.\n   *\n   * @returns {number}\n   */\n  get pivotY() {\n    return this.mPivotY\n  }\n\n  /**\n   * Sets the origin point relatively to its bounds. For example, setting x and y value to 0.5 will set origin to the\n   * center of the object.\n   *\n   * @param {number}  [ax=0.5]               Align along x-axis.\n   * @param {number}  [ay=0.5]               Align along y-axis.\n   *\n   * @return {GameObject} This.\n   */\n  alignAnchor(ax = 0.5, ay = 0.5) {\n    Debug.isNumber(ax, ay)\n\n    this.mAnchorX = ax\n    this.mAnchorY = ay\n\n    return this\n  }\n\n  /**\n   * Sets anchor point to given position. See `alignPivotOffset`.\n   *\n   * @deprecated\n   *\n   * @param {number}  [ax=0.5]               Align along x-axis.\n   * @param {number}  [ay=0.5]               Align along y-axis.\n   * @return {GameObject} This.\n   */\n  alignPivot(ax = 0.5, ay = 0.5) {\n    return this.alignPivotOffset(ax, ay)\n  }\n\n  /**\n   * Sets the origin point offset from current anchor value. For example, setting anchor-x value to 0.5 and pivotOffsetX\n   * to 10 will center object by x-axis and will shift object to the left by 10 pixels from half of the width.\n   *\n   * @param {number}  [ax=0.5]               Align along x-axis.\n   * @param {number}  [ay=0.5]               Align along y-axis.\n   * @param {boolean} [includeChildren=true] Include children elements when calculating bounds?\n   *\n   * @return {GameObject} This.\n   */\n  alignPivotOffset(ax = 0.5, ay = 0.5, includeChildren = true) {\n    Debug.isNumber(ax, ay)\n\n    this.getBounds(this, includeChildren, Rectangle.__cache.zero())\n\n    this.mPivotOffsetX = Rectangle.__cache.width * ax\n    this.mPivotOffsetY = Rectangle.__cache.height * ay\n\n    this.mPivotX =\n      this.mAnchorX === null\n        ? this.mPivotOffsetX + Rectangle.__cache.x\n        : this.mPivotOffsetX +\n          Rectangle.__cache.width * this.mAnchorX +\n          Rectangle.__cache.x\n    this.mPivotY =\n      this.mAnchorY === null\n        ? this.mPivotOffsetY + Rectangle.__cache.y\n        : this.mPivotOffsetY +\n          Rectangle.__cache.height * this.mAnchorY +\n          Rectangle.__cache.y\n\n    this.setTransformDirty()\n\n    return this\n  }\n\n  /**\n   * Gets/Sets the scale factor of this object along x-axis.\n   *\n   * @export\n   * @return {number}\n   */\n  get scaleX() {\n    return this.mScaleX\n  }\n\n  /**\n   * @export\n   * @ignore\n   * @param {number} value\n   *\n   * @return {void}\n   */\n  set scaleX(value) {\n    if (this.mScaleX == value) return\n\n    Debug.assert(!isNaN(value), 'Value cannot be NaN')\n\n    this.mScaleX = value\n    this.setTransformDirty()\n  }\n\n  /**\n   * Gets/Sets the scale factor of this object along y-axis.\n   *\n   * @export\n   *\n   * @return {number}\n   */\n  get scaleY() {\n    return this.mScaleY\n  }\n\n  /**\n   * @export\n   * @ignore\n   * @param {number} value\n   * @return {void}\n   */\n  set scaleY(value) {\n    if (this.mScaleY == value) return\n\n    Debug.assert(!isNaN(value), 'Value cannot be NaN')\n\n    this.mScaleY = value\n    this.setTransformDirty()\n  }\n\n  /**\n   * Gets/sets both `scaleX` and `scaleY`. Getter will return `scaleX` value;\n   * @export\n   * @returns {number}\n   */\n  get scale() {\n    return this.scaleX\n  }\n\n  /**\n   * @export\n   * @ignore\n   * @param {number} value\n   *\n   * @returns {void}\n   */\n  set scale(value) {\n    if (this.mScaleX == value) return\n\n    Debug.assert(!isNaN(value), 'Value cannot be NaN')\n\n    this.mScaleX = this.mScaleY = value\n    this.setTransformDirty()\n  }\n\n  /**\n   * Gets/sets horizontal skew angle in radians.\n   * @export\n   * @returns {number}\n   */\n  get skewX() {\n    return this.mSkewX\n  }\n\n  /**\n   * @export\n   * @ignore\n   * @param {number} value\n   *\n   * @returns {void}\n   */\n  set skewX(value) {\n    if (this.mSkewX == value) return\n\n    Debug.assert(!isNaN(value), 'Value cannot be NaN')\n\n    this.mSkewX = value\n    this.setTransformDirty()\n  }\n\n  /**\n   * Gets/sets vertical skew angle in radians.\n   * @export\n   * @returns {number}\n   */\n  get skewY() {\n    return this.mSkewY\n  }\n\n  /**\n   * @export\n   * @ignore\n   * @param {number} value\n   *\n   * @returns {void}\n   */\n  set skewY(value) {\n    if (this.mSkewY == value) return\n\n    Debug.assert(!isNaN(value), 'Value cannot be NaN')\n\n    this.mSkewY = value\n    this.setTransformDirty()\n  }\n\n  /**\n   * Gets/Sets rotation in radians.\n   *\n   * @export\n   *\n   * @return {number}\n   */\n  get rotation() {\n    return this.mRotation\n  }\n\n  /**\n   * @export\n   * @ignore\n   * @param {number} value\n   * @return {void}\n   */\n  set rotation(value) {\n    if (this.mRotation == value) return\n\n    Debug.assert(!isNaN(value), 'Value cannot be NaN')\n\n    this.mRotation = value\n    this.setTransformDirty()\n  }\n\n  /**\n   * Returns this GameObject parent GameObject or null.\n   * @readonly\n   * @return {GameObject|null}\n   */\n  get parent() {\n    return this.mParent\n  }\n\n  /**\n   * Returns top most parent object or this if there is no parents.\n   *\n   * @readonly\n   * @return {GameObject}\n   */\n  get root() {\n    let current = this\n\n    while (current.mParent != null) current = current.mParent\n\n    return current\n  }\n\n  /**\n   * Returns the stage Game Object to which this game object belongs to or null if not added on stage.\n   *\n   * @override\n   * @readonly\n   * @return {Stage|null}\n   */\n  get stage() {\n    return this.mAdded === true ? Black.stage : null\n  }\n\n  /**\n   * Gets/sets the width of this object.\n   *\n   * @return {number}\n   */\n  get width() {\n    return this.getBounds(this.mParent).width\n  }\n\n  /**\n   * @ignore\n   * @param {number} value\n   * @return {void}\n   */\n  set width(value) {\n    Debug.assert(!isNaN(value), 'Value cannot be NaN')\n\n    this.scaleX = 1\n    const currentWidth = this.width\n\n    if (currentWidth != 0.0) this.scaleX = value / currentWidth\n  }\n\n  /**\n   * Gets/sets the height of this object.\n   *\n   * @return {number}\n   */\n  get height() {\n    return this.getBounds(this.mParent).height\n  }\n\n  /**\n   * @ignore\n   * @param {number} value\n   * @return {void}\n   */\n  set height(value) {\n    Debug.assert(!isNaN(value), 'Value cannot be NaN')\n\n    this.scaleY = 1\n    const currentHeight = this.height\n\n    if (currentHeight != 0) this.scaleY = value / currentHeight\n  }\n\n  /**\n   * Returns width of this GameObject in local space without including children\n   * elements.\n   *\n   * @readonly\n   * @return {number}\n   */\n  get localWidth() {\n    return this.getBounds(this, false).width\n  }\n\n  /**\n   * Returns height of this GameObject in local space without including children\n   * elements.\n   *\n   * @readonly\n   * @return {number}\n   */\n  get localHeight() {\n    return this.getBounds(this, false).height\n  }\n\n  // TODO: precache\n  /**\n   * Returns string representing a url like path to this object in the display\n   * tree.\n   *\n   * @override\n   * @readonly\n   * @return {string|null}\n   */\n  get path() {\n    if (this.mParent !== null) return this.mParent.path + '/' + this.mName\n\n    return this.mName\n  }\n\n  /**\n   * Gets/Sets tag of this GameObject.\n   *\n   * @return {string|null}\n   */\n  get tag() {\n    return this.mTag\n  }\n\n  /**\n   * @ignore\n   * @param {string|null} value\n   * @return {void}\n   */\n  set tag(value) {\n    if (this.mTag === value) return\n\n    /** @type {string|null} */\n    let old = this.mTag\n    this.mTag = value\n\n    if (this.mAdded) Black.instance.onTagUpdated(this, old, value)\n  }\n\n  /**\n   * Starts coroutine.\n   *\n   * @param {Function} gen  Generator function.\n   * @param {*=} [ctx=null] Context for Generator function.\n   * @return {*}\n   */\n  spawn(gen, ctx = null) {\n    let iter = gen.apply(ctx == null ? this : ctx)\n\n    function step(it) {\n      if (it.done) return\n\n      if (typeof it.value === 'function') it.value(x => step(iter.next(x)))\n      else step(iter.next(it.value))\n    }\n\n    step(iter.next())\n    return iter\n  }\n\n  /**\n   * Waits for given amount of seconds before processing.\n   *\n   * @param {number} [seconds=1] Duration\n   * @return {function(?):?}\n   */\n  wait(seconds = 1) {\n    return cb =>\n      setTimeout(\n        cb.bind(this, /** @type {number} */ (seconds * 1000)),\n        /** @type {number} */ (seconds * 1000)\n      )\n  }\n\n  /**\n   * Waits for a specific message.\n   *\n   * @param {string} message The name of the message to wait for.\n   * @return {function(?):?}\n   */\n  waitMessage(message) {\n    return cb => this.once(message, cb.bind(this))\n  }\n\n  /**\n   * Marks this GameObject and/or its children elements as dirty.\n   *\n   * @param {DirtyFlag} flag The flag or flag bit mask.\n   * @param {boolean} [includeChildren=true] Specifies if the flag needed for all children.\n   * @return {void}\n   */\n  setDirty(flag, includeChildren = true) {\n    if (includeChildren) {\n      GameObject.forEach(this, x => {\n        x.mDirty |= flag\n        x.mDirtyFrameNum = Black.frameNum\n      })\n    } else {\n      this.mDirty |= flag\n      this.mDirtyFrameNum = Black.frameNum\n    }\n\n    Renderer.__dirty = true\n  }\n\n  /**\n   * @private\n   * @ignore\n   * @param {GameObject} go\n   */\n  __updatePivots(go) {\n    go.getBounds(go, true, Rectangle.__cache.zero())\n\n    go.mPivotX =\n      go.mAnchorX === null\n        ? go.mPivotOffsetX + Rectangle.__cache.x\n        : go.mPivotOffsetX +\n          Rectangle.__cache.width * go.mAnchorX +\n          Rectangle.__cache.x\n    go.mPivotY =\n      go.mAnchorY === null\n        ? go.mPivotOffsetY + Rectangle.__cache.y\n        : go.mPivotOffsetY +\n          Rectangle.__cache.height * go.mAnchorY +\n          Rectangle.__cache.y\n  }\n\n  /**\n   * Marks the GameObject's parent as dirty.\n   *\n   * @param {DirtyFlag} flag The flag or flag bit mask.\n   * @return {void}\n   */\n  setParentDirty(flag) {\n    let current = this\n    while (current != null) {\n      current.mDirty |= flag\n      current.mDirtyFrameNum = Black.frameNum\n      current = current.mParent\n    }\n\n    Renderer.__dirty = true\n  }\n\n  /**\n   * Marks this GameObject as Local dirty and all children elements as World dirty.\n   *\n   * @returns {void}\n   */\n  setTransformDirty() {\n    if (this.mSuspendDirty === true) return\n\n    this.setDirty(\n      /** @type {DirtyFlag} */ (DirtyFlag.LOCAL | DirtyFlag.BOUNDS),\n      false\n    )\n    this.setDirty(DirtyFlag.WIRB, true)\n\n    this.setParentDirty(\n      /** @type {DirtyFlag} */ (DirtyFlag.BOUNDS | DirtyFlag.ANCHOR)\n    )\n  }\n\n  /**\n   * Marks this GameObject with Render dirty flag if it is not suspended for dirty.\n   *\n   * @returns {void}\n   */\n  setRenderDirty() {\n    if (this.mSuspendDirty === true) return\n\n    this.setDirty(DirtyFlag.RENDER, true)\n  }\n\n  /**\n   * @ignore\n   * @param {boolean} value\n   * @return {void}\n   */\n  set touchable(value) {\n    let c = /** @type {InputComponent}*/ (this.getComponent(InputComponent))\n\n    if (value === true) {\n      if (c === null) this.addComponent(new InputComponent())\n      else c.touchable = true\n    } else {\n      if (c !== null) this.removeComponent(c)\n    }\n  }\n\n  /**\n   * Gets/Sets whether the object will listen for user input messages.\n   *\n   * @return {boolean}\n   */\n  get touchable() {\n    let c = /** @type {InputComponent} */ (this.getComponent(InputComponent))\n    return c !== null && c.touchable === true\n  }\n\n  // TODO: rename method\n  /**\n   * @ignore\n   *\n   * @param {Array<number>} points\n   * @param {Matrix} worldTransformation\n   * @param {Rectangle=} outRect\n   * @return {Rectangle}\n   */\n  static getBoundsWithPoints(points, worldTransformation, outRect) {\n    outRect = outRect || new Rectangle()\n\n    let minX = Number.MAX_VALUE\n    let maxX = -Number.MAX_VALUE\n    let minY = Number.MAX_VALUE\n    let maxY = -Number.MAX_VALUE\n    let xx = 0\n    let yy = 0\n    let tmpVector = new Vector()\n\n    for (let i = 0; i < points.length; i += 2) {\n      worldTransformation.transformXY(points[i], points[i + 1], tmpVector)\n\n      if (minX > tmpVector.x) minX = tmpVector.x\n\n      if (maxX < tmpVector.x) maxX = tmpVector.x\n\n      if (minY > tmpVector.y) minY = tmpVector.y\n\n      if (maxY < tmpVector.y) maxY = tmpVector.y\n    }\n\n    outRect.set(minX, minY, maxX - minX, maxY - minY)\n    return outRect\n  }\n\n  /**\n   * Returns whenever a given GameObject intersects with a point.\n   *\n   * @param {GameObject} gameObject GameObject to test.\n   * @param {Vector} point A point to test.\n   * @return {boolean} True if intersects.\n   */\n  static intersects(gameObject, point) {\n    let tmpVector = new Vector()\n    let inv = gameObject.worldTransformationInverted\n\n    inv.transformVector(point, tmpVector)\n\n    return gameObject.localBounds.containsXY(tmpVector.x, tmpVector.y)\n  }\n\n  /**\n   * Returns a point where intersection were made in local space.\n   *\n   * @param {GameObject} gameObject GameObject to test intersection with.\n   * @param {Vector} point The point to test.\n   * @param {Vector=} outVector If passed point of intersection will be stored in it.\n   * @return {boolean} True if intersects.\n   */\n  static intersectsAt(gameObject, point, outVector = undefined) {\n    outVector = outVector || new Vector()\n\n    Vector.__cache.set()\n\n    gameObject.worldTransformationInverted.transformVector(\n      point,\n      Vector.__cache\n    )\n    let contains = gameObject.localBounds.containsXY(\n      Vector.__cache.x,\n      Vector.__cache.y\n    )\n\n    if (contains === false) return false\n\n    outVector.x = Vector.__cache.x - gameObject.localBounds.x\n    outVector.y = Vector.__cache.y - gameObject.localBounds.y\n    return true\n  }\n\n  /**\n   * Checks if GameObject or any of its children elements intersects the given point.\n   *\n   * @param {GameObject} gameObject GameObject to test.\n   * @param {Vector} point Point to test.\n   * @return {GameObject|null} Intersecting object or null.\n   */\n  static intersectsWith(gameObject, point) {\n    let obj = null\n    for (let i = gameObject.numChildren - 1; i >= 0; --i) {\n      let child = gameObject.mChildren[i]\n\n      obj = GameObject.intersectsWith(child, point)\n      if (obj != null) return obj\n\n      let inside = GameObject.intersects(child, point)\n      if (inside) {\n        obj = child\n        break\n      }\n    }\n\n    if (obj === null && GameObject.intersects(gameObject, point))\n      return gameObject\n\n    return null\n  }\n\n  /**\n   * Returns all GameObject with given tag.\n   *\n   * @param {string} tag Tag to find.\n   * @returns {Array<GameObject>|null} Array of GameObject or null if not found.\n   */\n  static findWithTag(tag) {\n    if (Black.instance.mTagCache.hasOwnProperty(tag) === false) return null\n\n    return Black.instance.mTagCache[tag]\n  }\n\n  /**\n   * Returns a list of Components.\n   *\n   * @param {GameObject} gameObject GameObject to start search from.\n   * @param {function (new:Component)} type Type of Component.\n   * @return {Array<Component>} Array of Component or empty array.\n   */\n  static findComponents(gameObject, type) {\n    Debug.assert(gameObject !== null, 'gameObject cannot be null.')\n    Debug.assert(type !== null, 'type cannot be null.')\n\n    /** @type {Array<Component>} */\n    let list = []\n\n    /** @type {function(GameObject, function(new:Component)):void} */\n    let f = function(gameObject, type) {\n      for (let i = 0; i < gameObject.mComponents.length; i++) {\n        let c = gameObject.mComponents[i]\n        if (c instanceof type) list.push(c)\n      }\n\n      for (let i = 0; i < gameObject.mChildren.length; i++)\n        f(gameObject.mChildren[i], type)\n    }\n\n    f(gameObject, type)\n\n    return list\n  }\n\n  /**\n   * Runs action across all GameObjects.\n   *\n   * @param {GameObject} gameObject GameObject to start iteration from.\n   * @param {function(GameObject)} action The function to be executed on every GameObject.\n   * @return {void}\n   */\n  static forEach(gameObject, action) {\n    if (gameObject == null) gameObject = Black.stage\n\n    let r = action(gameObject)\n    if (r == true) return\n\n    for (let i = 0; i < gameObject.mChildren.length; i++) {\n      r = GameObject.forEach(gameObject.mChildren[i], action)\n      if (r == true) return\n    }\n  }\n\n  /**\n   * Finds object by its name. If node is not passed the root will be taken as\n   * starting point.\n   *\n   * @param {string} name      Name to search.\n   * @param {GameObject=} node Starting GameObject.\n   *\n   * @return {GameObject} GameObject or null.\n   */\n  static find(name, node) {\n    if (node == null) node = Black.stage\n\n    if (node.name === name) return node\n\n    for (let i = 0; i < node.numChildren; i++) {\n      let r = GameObject.find(name, node.getChildAt(i))\n      if (r != null) return r\n    }\n\n    return null\n  }\n\n  /**\n   * Finds object by its id property. If node is not passed the root will be taken as\n   * starting point.\n   *\n   * @param {number} id         Id to search.\n   * @param {GameObject=} node  Starting GameObject or null.\n   *\n   * @return {GameObject} GameObject or null.\n   */\n  static findById(id, node) {\n    if (node == null) node = Black.stage\n\n    if (node.id === id) return node\n\n    for (let i = 0; i < node.numChildren; i++) {\n      let r = GameObject.findById(id, node.getChildAt(i))\n      if (r !== null) return r\n    }\n\n    return null\n  }\n}\n\n/**\n * @private\n * @type {number}\n * @nocollapse\n */\nGameObject.ID = 0\n\n/**\n * @cat core\n * @enum {number}\n */\nexport \nconst DirtyFlag = {\n  CLEAN: 0, // Object is 100% cached\n  LOCAL: 1, // Local transformation is dirty\n  WORLD: 2, // World transformation is dirty\n  WORLD_INV: 4, // Inverted world transformation is dirty\n  RENDER: 8, // Object needs to be rendered\n  RENDER_CACHE: 16, // In case object renders to bitmap internally, bitmap needs to be updated\n  ANCHOR: 32, //\n  BOUNDS: 64, // Parent-relative bounds needs update\n  DIRTY: 0xffffff, // Everything is dirty, you, me, everything!\n  WIRB: 78,\n}\n","/**\n * Stage scale mode\n * @cat display\n * @static\n * @constant\n * @enum {string}\n */\nexport \nconst StageScaleMode = {\n  /** The stage size will be the same no matter what DPI is */\n  NORMAL: 'normal',\n  /** The stage size will be affected by dpi */\n  NO_SCALE: 'noScale',\n  /** The stage size tries to stay inside requested size. default is 960x640 */\n  FIXED: 'fixed',\n  /** The stage size will be equal to requested size, position will be centered */\n  CONTAIN: 'contain',\n  /** The stage size will be equal to requested size, position will be centered, and cover the viewport */\n  COVER: 'cover',\n}\n","/**\n * Stage Orientation\n * @cat display\n * @enum {string}\n * @static\n * @constant\n */\nexport \nconst StageOrientation = {\n  /** Automatically detects orientation and switches width and height depending on device orientation. */\n  UNIVERSAL: 'universal',\n  LANDSCAPE: 'landscape',\n  PORTRAIT: 'portrait',\n}\n","/**\n * The root container for all renderable objects\n *\n * @cat display\n * @fires Stage#resize\n * @extends GameObject\n */\n\nexport \nclass Stage extends GameObject {\n  constructor() {\n    super()\n\n    /** @private @type {string} */\n    this.mName = 'stage'\n\n    /** @private @type {StageScaleMode} */\n    this.mScaleMode = StageScaleMode.NORMAL\n\n    /** @private @type {number} */\n    this.mWidth = 960\n    /** @private @type {number} */\n    this.mHeight = 640\n\n    /** @private @type {number} */\n    this.mStageWidth = 0\n    /** @private @type {number} */\n    this.mStageHeight = 0\n    /** @private @type {number} */\n    this.mStageScaleFactor = 0\n\n    /** @private @type {number} */\n    this.mCacheWidth = 0\n\n    /** @private @type {number} */\n    this.mCacheHeight = 0\n\n    /** @private @type {number} */\n    this.mDPR = Device.getDevicePixelRatio()\n\n    /** @private @type {StageOrientation} */\n    this.mOrientation = StageOrientation.UNIVERSAL\n\n    /** @private @type {boolean} */\n    this.mOrientationLock = true\n\n    this.mAdded = true\n\n    if (Black.instance.hasSystem(Input)) this.addComponent(new InputComponent())\n  }\n\n  /**\n   * Gets/Sets stage orientation.\n   *\n   * @returns {StageOrientation}\n   */\n  get orientation() {\n    return this.mOrientation\n  }\n\n  /**\n   * @ignore\n   * @param {StageOrientation} value\n   * @returns {void}\n   */\n  set orientation(value) {\n    this.mOrientation = value\n    this.__refresh()\n  }\n\n  /**\n   * Sets stage size by given width and height.\n   *\n   * @param {number} width New stage width.\n   * @param {number} height New stage height.\n   * @returns {void}\n   */\n  setSize(width, height) {\n    this.mWidth = width\n    this.mHeight = height\n\n    this.__refresh()\n  }\n\n  /**\n   * @inheritDoc\n   */\n  onUpdate() {\n    const { size } = Black.instance.viewport\n\n    if (this.mCacheWidth !== size.width || this.mCacheHeight !== size.height) {\n      this.mCacheWidth = size.width\n      this.mCacheHeight = size.height\n\n      this.__refresh()\n    }\n  }\n\n  /**\n   * @private\n   * @ignore\n   * @returns {void}\n   */\n  __refresh() {\n    const size = Black.instance.viewport.size.clone()\n\n    if (\n      this.mOrientationLock &&\n      ((this.mOrientation === StageOrientation.LANDSCAPE &&\n        Device.isPortrait) ||\n        (this.mOrientation === StageOrientation.PORTRAIT && Device.isLandscape))\n    )\n      [size.width, size.height] = [size.height, size.width]\n\n    const windowWidth = size.width\n    const windowHeight = size.height\n\n    if (this.mScaleMode === StageScaleMode.FIXED) {\n      const scaleFactor = Math.min(\n        windowWidth / this.mWidth,\n        windowHeight / this.mHeight\n      )\n      this.mStageWidth = this.mWidth\n      this.mStageHeight = this.mHeight\n      this.mScaleX = this.mScaleY = this.mStageScaleFactor = scaleFactor\n    } else if (this.mScaleMode === StageScaleMode.NORMAL) {\n      this.mStageWidth = size.width\n      this.mStageHeight = size.height\n      this.mScaleX = this.mScaleY = this.mStageScaleFactor = 1\n    } else if (this.mScaleMode === StageScaleMode.CONTAIN) {\n      const scaleFactor = Math.min(\n        windowWidth / this.mWidth,\n        windowHeight / this.mHeight\n      )\n      const width = this.mWidth * scaleFactor\n      const height = this.mHeight * scaleFactor\n      this.mX = (windowWidth - width) / 2\n      this.mY = (windowHeight - height) / 2\n      this.mStageWidth = this.mWidth\n      this.mStageHeight = this.mHeight\n      this.mScaleX = this.mScaleY = this.mStageScaleFactor = scaleFactor\n    } else if (this.mScaleMode === StageScaleMode.COVER) {\n      const scaleFactor = Math.max(\n        windowWidth / this.mWidth,\n        windowHeight / this.mHeight\n      )\n      const width = this.mWidth * scaleFactor\n      const height = this.mHeight * scaleFactor\n      this.mX = (windowWidth - width) / 2\n      this.mY = (windowHeight - height) / 2\n      this.mStageWidth = this.mWidth\n      this.mStageHeight = this.mHeight\n      this.mScaleX = this.mScaleY = this.mStageScaleFactor = scaleFactor\n    } else if (this.mScaleMode === StageScaleMode.NO_SCALE) {\n      this.mStageWidth = size.width * this.mDPR\n      this.mStageHeight = size.height * this.mDPR\n\n      this.mScaleX = this.mScaleY = this.mStageScaleFactor = 1 / this.mDPR\n    } else {\n      Debug.error('Not supported stage scale mode.')\n    }\n\n    this.mStageWidth = Math.round(this.mStageWidth)\n    this.mStageHeight = Math.round(this.mStageHeight)\n    this.mX = Math.round(this.mX)\n    this.mY = Math.round(this.mY)\n\n    // TODO: i don't like this line\n    // TODO: me neither\n    // TODO: but its setting Renderer.__dirty which is good\n    // TODO: replace with priority message?\n    Black.driver.__onResize(null, null)\n\n    this.setTransformDirty()\n\n    /**\n     * Posts every time stage size is changed.\n     * @event Stage#resize\n     */\n    this.post(Message.RESIZE)\n  }\n\n  /**\n   * Gets/Sets stage scale mode.\n   *\n   * @return {StageScaleMode}\n   */\n  get scaleMode() {\n    return this.mScaleMode\n  }\n\n  /**\n   * @ignore\n   * @param {StageScaleMode} value\n   * @returns {void}\n   */\n  set scaleMode(value) {\n    this.mScaleMode = value\n    this.__refresh()\n  }\n\n  /**\n   * Stage scale factor.\n   *\n   * @public\n   * @readonly\n   * @returns {number}\n   */\n  get scaleFactor() {\n    return this.mStageScaleFactor\n  }\n\n  /**\n   * Original stage width multiplied by device pixel ratio and stage scale factor.\n   *\n   * @public\n   * @readonly\n   * @returns {number}\n   */\n  get renderWidth() {\n    return this.mStageWidth * this.mDPR * this.mStageScaleFactor\n  }\n\n  /**\n   * Original stage height multiplied by device pixel ratio and stage scale factor.\n   *\n   * @public\n   * @readonly\n   * @returns {number}\n   */\n  get renderHeight() {\n    return this.mStageHeight * this.mDPR * this.mStageScaleFactor\n  }\n\n  /**\n   * Gets stage center coordinate along X-axis.\n   *\n   * @public\n   * @readonly\n   * @returns {number}\n   */\n  get centerX() {\n    return this.mStageWidth * 0.5\n  }\n\n  /**\n   * Gets stage center coordinate along Y-axis.\n   *\n   * @public\n   * @readonly\n   * @returns {number}\n   */\n  get centerY() {\n    return this.mStageHeight * 0.5\n  }\n\n  /**\n   * Gets/sets whenever stage orientation should be locked. If false and orientation is not universal stage will remain same size in both orientation.\n   * @returns {boolean}\n   */\n  get orientationLock() {\n    return this.mOrientationLock\n  }\n\n  /**\n   * @ignore\n   * @param {boolean} value\n   * @returns {void}\n   */\n  set orientationLock(value) {\n    this.mOrientationLock = value\n    this.__refresh()\n  }\n\n  /**\n   * @inheritDoc\n   */\n  getBounds(space = undefined, includeChildren = true, outRect = undefined) {\n    outRect = outRect || new Rectangle()\n    return outRect.set(\n      -this.mX / this.mStageScaleFactor,\n      -this.mY / this.mStageScaleFactor,\n      this.mStageWidth + (2 * this.mX) / this.mStageScaleFactor,\n      this.mStageHeight + (2 * this.mY) / this.mStageScaleFactor\n    )\n  }\n\n  /**\n   * @inheritDoc\n   */\n  onGetLocalBounds(outRect = undefined) {\n    outRect = outRect || new Rectangle()\n    return outRect.set(0, 0, this.mStageWidth, this.mStageHeight)\n  }\n\n  /**\n   * @inheritDoc\n   */\n  get localTransformation() {\n    this.mLocalTransform.set(this.mScaleX, 0, 0, this.mScaleY, this.mX, this.mY)\n\n    if (this.mOrientationLock === false) return this.mLocalTransform\n\n    if (\n      (this.mOrientation === StageOrientation.LANDSCAPE && Device.isPortrait) ||\n      (this.mOrientation === StageOrientation.PORTRAIT && Device.isLandscape)\n    ) {\n      let x\n      let y\n      if (\n        this.mScaleMode === StageScaleMode.LETTERBOX ||\n        this.mScaleMode === StageScaleMode.COVER\n      ) {\n        x =\n          Black.instance.viewport.size.width * 0.5 -\n          this.mStageHeight * 0.5 * this.mStageScaleFactor\n        y =\n          Black.instance.viewport.size.height * 0.5 +\n          this.mStageWidth * 0.5 * this.mStageScaleFactor\n      } else {\n        x = 0\n        y = Black.instance.viewport.size.height\n      }\n\n      this.mLocalTransform.rotate(-Math.PI / 2)\n      this.mLocalTransform.setTranslation(x, y)\n    }\n\n    return this.mLocalTransform\n  }\n\n  removeFromParent() {\n    Debug.error('Not allowed.')\n  }\n\n  set scaleX(value) {\n    Debug.error('Not allowed.')\n  }\n  get scaleX() {\n    return 1\n  }\n\n  set scaleY(value) {\n    Debug.error('Not allowed.')\n  }\n  get scaleY() {\n    return 1\n  }\n\n  set pivotOffsetX(value) {\n    Debug.error('Not allowed.')\n  }\n  get pivotOffsetX() {\n    return 0\n  }\n\n  set pivotOffsetY(value) {\n    Debug.error('Not allowed.')\n  }\n  get pivotOffsetY() {\n    return 0\n  }\n\n  set anchorX(value) {\n    Debug.error('Not allowed.')\n  }\n  get anchorX() {\n    return 0\n  }\n\n  set anchorY(value) {\n    Debug.error('Not allowed.')\n  }\n  get anchorY() {\n    return 0\n  }\n\n  set x(value) {\n    Debug.error('Not allowed.')\n  }\n  get x() {\n    return this.mX / this.mStageScaleFactor\n  } // GG ES6\n\n  set y(value) {\n    Debug.error('Not allowed.')\n  }\n  get y() {\n    return this.mY / this.mStageScaleFactor\n  } // GG ES6\n\n  set rotation(value) {\n    Debug.error('Not allowed.')\n  }\n  get rotation() {\n    return 0\n  } // GG ES6\n\n  set width(value) {\n    Debug.error('Not allowed.')\n  }\n  get width() {\n    return this.mStageWidth\n  }\n\n  set height(value) {\n    Debug.error('Not allowed.')\n  }\n  get height() {\n    return this.mStageHeight\n  }\n\n  set name(value) {\n    Debug.error('Not allowed.')\n  }\n  get name() {\n    return this.mName\n  }\n}\n","/**\n * Base class for collider component.\n *\n * @cat colliders\n * @extends Component\n */\n\nexport \nclass Collider extends Component {\n  /**\n   * Creates new instance for Collider.\n   *\n   * @ignore\n   */\n  constructor() {\n    super()\n\n    /**\n     * Dirty flag.\n     * @private @type {boolean}\n     */\n    this.mChanged = true\n\n    /**\n     * Global in stage coordinates center.\n     * @private @type {Vector}\n     */\n    this.mCenter = new Vector()\n\n    /**\n     * Global in stage coordinates min x and y vertex.\n     * @private @type {Vector}\n     */\n    this.mMin = new Vector()\n\n    /**\n     * Global in stage coordinates max x and y vertex.\n     * @private @type {Vector} */\n    this.mMax = new Vector()\n  }\n\n  /**\n   * Checks if given global coordinates are located within collider's area.\n   *\n   * @public\n   * @param {Vector} point Global coordinates.\n   * @returns {boolean}\n   */\n  containsPoint(point) {\n    Debug.error('Abstract method.')\n    return false\n  }\n\n  /**\n   * Updates min, max, center of this collider, to prepare to collision test\n   *\n   * @public\n   * @param {Matrix} transform Game object world transformation with zero position.\n   * @param {Vector} position  Rigid body position.\n   */\n  refresh(transform, position) {}\n}\n","/**\n * Collider with rectangle shape.\n *\n * @cat colliders\n * @extends Collider\n */\n\nexport \nclass BoxCollider extends Collider {\n  /**\n   * Creates instance of BoxCollider.\n   *\n   * @param {number} x      X-coordinate.\n   * @param {number} y      Y-coordinate.\n   * @param {number} width  Rectangle width.\n   * @param {number} height Rectangle height.\n   */\n  constructor(x, y, width, height) {\n    super()\n\n    const normals = []\n    const vertices = []\n\n    for (let i = 0; i < 4; i++) {\n      normals.push(new Vector())\n      vertices.push(new Vector())\n    }\n\n    /**\n     * Local to gameObject.\n     * @private @type {Rectangle}\n     */\n    this.mRect = new Rectangle()\n\n    /**\n     * Local to rigid body normals.\n     * @private @type {Array<Vector>}\n     */\n    this.mNormals = normals\n\n    /**\n     * Local to rigid body vertices.\n     * @private @type {Array<Vector>} */\n    this.mVertices = vertices\n\n    /**\n     * Local to rigid body min x and y vertex.\n     * @private @type {Vector} */\n    this.mLocalMin = new Vector()\n\n    /**\n     * Local to rigid body max x and y vertex\n     * @private @type {Vector}\n     */\n    this.mLocalMax = new Vector()\n\n    /**\n     * Local to rigid body center\n     * @private @type {Vector}\n     */\n    this.mLocalCenter = new Vector()\n\n    this.set(x, y, width, height)\n  }\n\n  /**\n   * Updates this collider with a new given values.\n   *\n   * @public\n   * @param {number} x      X-coordinate.\n   * @param {number} y      Y-coordinate.\n   * @param {number} width  Rectangle width.\n   * @param {number} height Rectangle height.\n   * @returns {BoxCollider}\n   */\n  set(x, y, width, height) {\n    this.mRect.set(x, y, width, height)\n    this.mChanged = true\n    return this\n  }\n\n  /**\n   * @inheritDoc\n   */\n  refresh(transform, position) {\n    const localMin = this.mLocalMin\n    const localMax = this.mLocalMax\n    const min = this.mMin\n    const max = this.mMax\n    const localCenter = this.mLocalCenter\n    const center = this.mCenter\n\n    if (this.mChanged) {\n      const vertices = this.mVertices\n      const normals = this.mNormals\n      const rect = this.mRect\n      const vec = Vector.pool.get()\n\n      transform.transformVector(vec.set(0, -1), normals[0])\n      transform.transformVector(vec.set(1, 0), normals[1])\n      transform.transformVector(vec.set(0, 1), normals[2])\n      transform.transformVector(vec.set(-1, 0), normals[3])\n\n      for (let i = 0; i < 4; i++) {\n        normals[i].normalize()\n      }\n\n      transform.transformVector(vec.set(rect.x, rect.y), vertices[0])\n      transform.transformVector(\n        vec.set(rect.x + rect.width, rect.y),\n        vertices[1]\n      )\n      transform.transformVector(\n        vec.set(rect.x + rect.width, rect.y + rect.height),\n        vertices[2]\n      )\n      transform.transformVector(\n        vec.set(rect.x, rect.y + rect.height),\n        vertices[3]\n      )\n\n      localCenter.set(\n        (vertices[0].x + vertices[2].x) / 2,\n        (vertices[0].y + vertices[2].y) / 2\n      )\n      localMin.x = Math.min(\n        vertices[0].x,\n        vertices[1].x,\n        vertices[2].x,\n        vertices[3].x\n      )\n      localMin.y = Math.min(\n        vertices[0].y,\n        vertices[1].y,\n        vertices[2].y,\n        vertices[3].y\n      )\n      localMax.x = Math.max(\n        vertices[0].x,\n        vertices[1].x,\n        vertices[2].x,\n        vertices[3].x\n      )\n      localMax.y = Math.max(\n        vertices[0].y,\n        vertices[1].y,\n        vertices[2].y,\n        vertices[3].y\n      )\n\n      Vector.pool.release(vec)\n    }\n\n    min.x = localMin.x + position.x\n    min.y = localMin.y + position.y\n    max.x = localMax.x + position.x\n    max.y = localMax.y + position.y\n\n    center.x = localCenter.x + position.x\n    center.y = localCenter.y + position.y\n  }\n\n  /**\n   * Checks if given global coordinates are located within collider's area.\n   *\n   * @public\n   * @param {Vector} point Global coordinates.\n   *\n   * @return {boolean}\n   */\n  containsPoint(point) {\n    return this.mRect.containsXY(point.x, point.y)\n  }\n\n  // /**\n  //  * Draw this\n  //  *\n  //  * @public\n  //  * @param {Graphics} graphics   Drawing place\n  //  * @param {Vector} bodyPosition This parent global position\n  //  *\n  //  * @return {void}\n  //  */\n  // debug(graphics, bodyPosition) {\n  //   const vertices = this.mVertices;\n  //\n  //   graphics.beginPath();\n  //   graphics.moveTo(bodyPosition.x + vertices[0].x, bodyPosition.y + vertices[0].y);\n  //   graphics.lineTo(bodyPosition.x + vertices[1].x, bodyPosition.y + vertices[1].y);\n  //   graphics.lineTo(bodyPosition.x + vertices[2].x, bodyPosition.y + vertices[2].y);\n  //   graphics.lineTo(bodyPosition.x + vertices[3].x, bodyPosition.y + vertices[3].y);\n  //   graphics.lineTo(bodyPosition.x + vertices[0].x, bodyPosition.y + vertices[0].y);\n  //   graphics.stroke();\n  // }\n}\n","/**\n * Collider with circle shape.\n *\n * @cat colliders\n * @extends Collider\n */\n\nexport \nclass CircleCollider extends Collider {\n  /**\n   * Creates new instance of CircleCollider.\n   *\n   * @param {number} x      Center coordinate within X-axis.\n   * @param {number} y      Center coordinate within Y-axis.\n   * @param {number} radius Radius of the circle.\n   */\n  constructor(x, y, radius) {\n    super()\n\n    /** @private @type {Circle} */\n    this.mCircle = new Circle(x, y, radius) // local to sprite\n\n    /**\n     * Local to rigid body center.\n     * @private @type {Vector}\n     */\n    this.mLocalCenter = new Vector()\n\n    /**\n     * Local to rigid body min x and y vertex.\n     * @private @type {Vector} */\n    this.mLocalMin = new Vector()\n\n    /**\n     * Local to rigid body max x and y vertex\n     * @private @type {Vector}\n     */\n    this.mLocalMax = new Vector()\n\n    /**\n     * Global in stage coordinates radius\n     * @private @type {number}\n     */\n    this.mRadius = 0\n\n    this.set(x, y, radius)\n  }\n\n  /**\n   * Updates this collider with a new given values.\n   *\n   * @public\n   * @param {number} x      Center coordinate within X-axis.\n   * @param {number} y      Center coordinate within Y-axis.\n   * @param {number} radius Radius of the circle.\n   * @returns {CircleCollider}\n   */\n  set(x, y, radius) {\n    this.mCircle.set(x, y, radius)\n    this.mChanged = true\n    return this\n  }\n\n  /**\n   * @inheritDoc\n   */\n  refresh(transform, position) {\n    const localMin = this.mLocalMin\n    const localMax = this.mLocalMax\n    const min = this.mMin\n    const max = this.mMax\n    const localCenter = this.mLocalCenter\n    const center = this.mCenter\n\n    if (this.mChanged) {\n      const circle = this.mCircle\n      const scale = Math.sqrt(\n        transform.data[0] * transform.data[0] +\n          transform.data[1] * transform.data[1]\n      )\n      const radius = circle.r * scale\n\n      transform.transformXY(circle.x, circle.y, localCenter)\n      this.mRadius = radius\n\n      localMin.x = localCenter.x - radius\n      localMin.y = localCenter.y - radius\n      localMax.x = localCenter.x + radius\n      localMax.y = localCenter.y + radius\n    }\n\n    min.x = localMin.x + position.x\n    min.y = localMin.y + position.y\n    max.x = localMax.x + position.x\n    max.y = localMax.y + position.y\n\n    center.x = localCenter.x + position.x\n    center.y = localCenter.y + position.y\n  }\n\n  /**\n   * Checks if given global coordinates are located within collider's area.\n   *\n   * @public\n   * @param {Vector} point Global coordinates.\n   * @returns {boolean}\n   */\n  containsPoint(point) {\n    if (this.gameObject === null) {\n      return false\n    }\n\n    const circle = this.mCircle\n    const vec = Vector.pool.get()\n    const distance = vec.set(circle.x, circle.y).distance(point)\n    Vector.pool.release(vec)\n\n    return distance <= circle.r\n  }\n\n  // /**\n  //  * Draw this\n  //  *\n  //  * @public\n  //  * @param {Graphics} graphics Drawing place\n  //  */\n  // debug(graphics) {\n  //   graphics.beginPath();\n  //   graphics.circle(this.mCenter.x, this.mCenter.y, this.mRadius);\n  //   graphics.stroke();\n  // }\n}\n","/**\n * A base texture class.\n *\n * @cat textures\n */\nexport \nclass Texture {\n  /**\n   * Creates new instance of texture.\n   *\n   * @param {HTMLImageElement|HTMLCanvasElement|HTMLVideoElement} nativeElement The native element to get image data from.\n   * @param {Rectangle=} [region=null]                                          The area of texture to be drawn.\n   * @param {Rectangle=} [untrimmedRegion=null]                                 The original area of texture.\n   * @param {number=} [scale=1]                                                 Inverted scale factor.\n   */\n  constructor(nativeElement, region = null, untrimmedRegion = null, scale = 1) {\n    this.mId = ++Texture.__ID\n\n    /** @private @type {HTMLImageElement|HTMLCanvasElement|HTMLVideoElement} */\n    this.mNative = nativeElement\n\n    /** @private @type {boolean} */\n    this.mValid = false\n\n    /** @private @type {Rectangle} */\n    this.mRegion = new Rectangle()\n\n    /** @private @type {Rectangle} */\n    this.mUntrimmedRegion = new Rectangle()\n\n    /** @private @type {number} */\n    this.mNativeWidth = 0\n\n    /** @private @type {number} */\n    this.mNativeHeight = 0\n\n    /** @private @type {number} */\n    this.mDisplayWidth = 0\n\n    /** @private @type {number} */\n    this.mDisplayHeight = 0\n\n    /** @private @type {number} */\n    this.mRenderWidth = 0\n\n    /** @private @type {number} */\n    this.mRenderHeight = 0\n\n    /** @private @type {number} */\n    this.mScale = scale\n\n    this.set(nativeElement, region, untrimmedRegion, scale)\n  }\n\n  /**\n   * Updates this texture with new native element.\n   *\n   * @param {HTMLImageElement|HTMLCanvasElement|HTMLVideoElement} nativeElement The native element to get image data from.\n   * @param {Rectangle=} [region=null]                                          The area of texture to be drawn.\n   * @param {Rectangle=} [untrimmedRegion=null]                                 The original area of texture.\n   * @param {number=} [scale=1]                                                 Inverted scale factor.\n   */\n  set(nativeElement, region = null, untrimmedRegion = null, scale = 1) {\n    Debug.assert(nativeElement != null, 'nativeElement cannot be null')\n    Debug.assert(!isNaN(scale), 'scale cannot be NaN')\n\n    this.mScale = scale\n    this.mNative = nativeElement\n\n    this.mNativeWidth =\n      nativeElement.naturalWidth ||\n      nativeElement.videoWidth ||\n      nativeElement.width\n    this.mNativeHeight =\n      nativeElement.naturalHeight ||\n      nativeElement.videoHeight ||\n      nativeElement.height\n\n    this.mRegion =\n      region || this.mRegion.set(0, 0, this.mNativeWidth, this.mNativeHeight)\n    this.mUntrimmedRegion =\n      untrimmedRegion ||\n      this.mUntrimmedRegion.set(0, 0, this.mRegion.width, this.mRegion.height)\n\n    this.mDisplayWidth = Math.ceil(this.mUntrimmedRegion.width * this.mScale)\n    this.mDisplayHeight = Math.ceil(this.mUntrimmedRegion.height * this.mScale)\n\n    this.mRenderWidth = Math.ceil(this.mRegion.width * this.mScale)\n    this.mRenderHeight = Math.ceil(this.mRegion.height * this.mScale)\n\n    this.mValid =\n      nativeElement != null && this.mDisplayWidth > 0 && this.mDisplayHeight > 0\n  }\n\n  /**\n   * @ignore\n   * @param {string} name\n   * @returns {number}\n   */\n  static getScaleFactorFromName(name) {\n    let ixStart = name.indexOf('@')\n    if (ixStart === -1) return 1\n\n    let ixEnd = name.indexOf('x', ixStart)\n    return parseFloat(name.substring(ixStart + 1, ixEnd))\n  }\n\n  /**\n   * @ignore\n   * @param {string} name\n   * @returns {string}\n   */\n  static removeScaleFactorFromName(name) {\n    let ixStart = name.indexOf('@')\n    if (ixStart === -1) return name\n\n    let ixEnd = name.indexOf('x', ixStart)\n    return name.substring(0, ixStart) + name.substring(ixEnd + 1)\n  }\n\n  /**\n   * Creates new texture from Base64 string.\n   *\n   * @param {string} string Base64 string.\n   * @returns {Texture}\n   */\n  static fromBase64String(string) {\n    let imgElement = new Image()\n    imgElement.src = string\n    return new Texture(imgElement)\n  }\n\n  /**\n   * @ignore\n   * @param {Element} canvas\n   * @param {string} type\n   * @param {number} quality\n   * @returns {Texture}\n   */\n  static fromCanvasAsImage(canvas, type = 'image/png', quality = 1) {\n    let imgElement = new Image()\n    imgElement.src = /** @type {HTMLCanvasElement} */ (canvas).toDataURL(\n      type,\n      quality\n    )\n\n    return new Texture(imgElement)\n  }\n\n  /**\n   * @ignore\n   * @param {HTMLCanvasElement} canvas\n   * @returns {Texture|null}\n   */\n  static fromCanvas(canvas) {\n    return Black.driver.getTextureFromCanvas(canvas)\n  }\n\n  /**\n   * Original width of the texture multiplied by scale.\n   *\n   * @readonly\n   * @returns {number}\n   */\n  get width() {\n    return this.mDisplayWidth\n  }\n\n  /**\n   * Original height of the texture multiplied by scale.\n   *\n   * @readonly\n   * @returns {number}\n   */\n  get height() {\n    return this.mDisplayHeight\n  }\n\n  /**\n   * Texture scale.\n   *\n   * @readonly\n   * @returns {number}\n   */\n  get scale() {\n    return this.mScale\n  }\n\n  /**\n   * The area of the texture to be drawn.\n   *\n   * @readonly\n   * @returns {Rectangle}\n   */\n  get region() {\n    return this.mRegion\n  }\n\n  /**\n   * The original area of the texture.\n   *\n   * @readonly\n   * @returns {Rectangle}\n   */\n  get untrimmedRegion() {\n    return this.mUntrimmedRegion\n  }\n\n  /**\n   * Original width of the texture.\n   *\n   * @readonly\n   * @returns {number}\n   */\n  get nativeWidth() {\n    return this.mNativeWidth\n  }\n\n  /**\n   * Original height of the texture.\n   *\n   * @readonly\n   * @returns {number}\n   */\n  get nativeHeight() {\n    return this.mNativeHeight\n  }\n\n  /**\n   * The same as Texture.width\n   *\n   * @readonly\n   * @returns {number}\n   */\n  get displayWidth() {\n    return this.mDisplayWidth\n  }\n\n  /**\n   * The same as Texture.height\n   *\n   * @readonly\n   * @returns {number}\n   */\n  get displayHeight() {\n    return this.mDisplayHeight\n  }\n\n  /**\n   * Renderable width of the texture multiplied by scale.\n   *\n   * @readonly\n   * @returns {number}\n   */\n  get renderWidth() {\n    return this.mRenderWidth\n  }\n\n  /**\n   * Renderable height of the texture multiplied by scale.\n   *\n   * @readonly\n   * @returns {number}\n   */\n  get renderHeight() {\n    return this.mRenderHeight\n  }\n\n  /**\n   * Determines if the texture can be drawn.\n   *\n   * @readonly\n   * @returns {boolean}\n   */\n  get isValid() {\n    return this.mValid\n  }\n\n  /**\n   * Native HTML element.\n   *\n   * @readonly\n   * @returns {HTMLImageElement|HTMLCanvasElement|HTMLVideoElement}\n   */\n  get native() {\n    return this.mNative\n  }\n\n  get id() {\n    return this.mId\n  }\n}\n\n/**\n * @private\n * @type {number}\n * @nocollapse\n */\nTexture.__ID = 0\n\n/**\n * @private\n * @type {HTMLImageElement|null}\n * @nocollapse\n */\nTexture.MISSING_IMAGE_CACHE = null\n\n/**\n * @private\n * @type {number}\n * @nocollapse\n */\nTexture.MAX_SIZE = 2048\n","/**\n * A texture allowing game objects to be rendered onto it.\n *\n * @cat textures\n */\nexport \nclass CanvasRenderTexture extends Texture {\n  /**\n   * Creates new CanvasRenderTexture instance with given size and scale.\n   *\n   * @param {number} width  The width of the texture in stage space.\n   * @param {number} height The height of the texture in stage space.\n   * @param {number} scale  The scale factor of the internal texture\n   */\n  constructor(width, height, scale) {\n    const renderTarget = new RenderTargetCanvas(width * scale, height * scale)\n\n    super(renderTarget.native)\n    this.set(renderTarget.native, null, null, 1 / scale)\n\n    this.renderTarget = renderTarget\n  }\n\n  /**\n   * Updates this instance with given size and scale.\n   *\n   * @param {number} width  The width of the texture in stage space.\n   * @param {number} height The height of the texture in stage space.\n   * @param {number} scale  The scale factor of the internal texture\n   */\n  resize(width, height, scale) {\n    this.renderTarget.resize(width * scale, height * scale)\n    this.set(this.renderTarget.native, null, null, 1 / scale)\n  }\n\n  __dumpToDocument() {\n    let img = new Image()\n    img.style.position = 'fixed'\n    img.style.top = '0px'\n    img.style.left = '0px'\n    img.style.background = '#333'\n    img.style.width = '256px'\n    img.style.height = 'auto'\n    //img.style.border = '1px solid crimson';\n    img.src = /** @type {HTMLCanvasElement} */ (this.mNative).toDataURL(\n      'image/png'\n    )\n    document.body.appendChild(img)\n  }\n}\n","/**\n * A texture atlas.\n *\n * @cat textures\n * @extends Texture\n */\nexport \nclass AtlasTexture extends Texture {\n  constructor(nativeElement, jsonObject, scale = 1) {\n    super(nativeElement)\n\n    /** @private @type {Object.<string, Texture>} */\n    this.mSubTextures = {}\n\n    this.__parseJson(jsonObject, scale)\n  }\n\n  /**\n   * @ignore\n   * @private\n   * @param {{meta: *, frames: Object}} o\n   * @param {number} scale\n   * @return {void}\n   */\n  __parseJson(o, scale) {\n    const NEGATIVE_HALF_PI = -(Math.PI / 2)\n\n    for (let key in o.frames) {\n      const data = /** @type {Array<number>} */ (o.frames[key])\n      const region = new Rectangle(data[0], data[1], data[2], data[3])\n      const untrimmedRect = new Rectangle(data[4], data[5], data[6], data[7])\n\n      this.mSubTextures[key] = new Texture(\n        this.native,\n        region,\n        untrimmedRect,\n        scale\n      )\n    }\n  }\n\n  /**\n   * Returns the texture by a given name.\n   *\n   * @param {string} name The name of the texture to find.\n   * @return {Texture} The Texture or null if not found.\n   */\n  getTexture(name) {\n    /** @type {Texture} */\n    let t = this.mSubTextures[name]\n    Debug.assertWarn(t !== undefined, `Texture '${name}' was not found`)\n\n    return /** @type {Texture} */ (t)\n  }\n\n  /**\n   * Returns array of Texture by given name or wildcard mask.\n   * If `nameMask` is null then all textures will be returned.\n   * This method sorts all resulting textures using neutral sort algorith.\n   *\n   * @param {string|null} [nameMask=null] The mask to filter by.\n   * @param {Array<Texture>|null}         outTextures If passed will be overwritten by result object.\n   * @return {Array<Texture>}             The list of found textures.\n   */\n  getTextures(nameMask = null, outTextures = null) {\n    let out = outTextures || []\n    if (nameMask === null) {\n      for (let key in this.mSubTextures) out.push(this.mSubTextures[key])\n\n      return /** @type {Array<Texture>} */ (out)\n    }\n\n    let names = []\n\n    // TODO: make helper wild function\n    let re = new RegExp('^' + nameMask.split('*').join('.*') + '$')\n    for (let key in this.mSubTextures) if (re.test(key)) names.push(key)\n\n    //names.sort(AtlasTexture.__naturalComparer);\n    AtlasTexture.naturalSort(names)\n\n    for (let i = 0; i < names.length; i++) out.push(this.mSubTextures[names[i]])\n\n    return out\n  }\n\n  /**\n   * Gets dictionary of sub textures.\n   *\n   * @returns {Object} The list of sub textures.\n   */\n  get subTextures() {\n    return this.mSubTextures\n  }\n\n  /**\n   * Sorts set of data in natural order\n   *\n   * @ignore\n   * @param {Array<Object>} dataset\n   * @param {string|null} [field=null]\n   */\n  static naturalSort(dataset, field = null) {\n    dataset.sort(AtlasTexture.__naturalComparer(field))\n  }\n\n  /**\n   * @ignore\n   * @private\n   * @param {string|null} field\n   * @param {boolean} useAbs\n   * @returns {function(?, ?):number}\n   */\n  static __naturalComparer(field = null, useAbs = true) {\n    return function(a, b) {\n      const NUMBER_GROUPS = /(-?\\d*\\.?\\d+)/g\n      let aa = String(field == null ? a : a[field]).split(NUMBER_GROUPS)\n      let bb = String(field == null ? b : b[field]).split(NUMBER_GROUPS)\n      let min = Math.min(aa.length, bb.length)\n\n      for (let i = 0; i < min; i++) {\n        let x = 0\n        let y = 0\n\n        if (useAbs) {\n          x = Math.abs(parseFloat(aa[i])) || aa[i].toLowerCase()\n          y = Math.abs(parseFloat(bb[i])) || bb[i].toLowerCase()\n        } else {\n          x = parseFloat(aa[i]) || aa[i].toLowerCase()\n          y = parseFloat(bb[i]) || bb[i].toLowerCase()\n        }\n\n        if (x < y) return -1\n        else if (x > y) return 1\n      }\n\n      return 0\n    }\n  }\n}\n","/**\n * Base class for loaders.\n *\n * @cat assets.loaders\n * @extends MessageDispatcher\n */\nexport \nclass AssetLoader extends MessageDispatcher {\n  /**\n   * Creates new AssetLoader instance.\n   *\n   * @param {string} url\n   */\n  constructor(url) {\n    super()\n\n    /** @protected @type {string} */\n    this.mUrl = url\n\n    /** @protected @type {?|null} */\n    this.mData = null\n\n    /** @private @type {boolean} */\n    this.mIsLoaded = false\n\n    /** @private @type {Asset} */\n    this.mOwner = null\n  }\n\n  /**\n   * When overridden loads data. Should not be called directly.\n   *\n   * @public\n   */\n  load() {}\n\n  /**\n   * When overridden aborts loading process. Should not be called directly.\n   *\n   * @public\n   */\n  abort() {}\n\n  /**\n   * @protected\n   */\n  onLoad() {\n    this.mIsLoaded = true\n    this.post(Message.COMPLETE)\n  }\n\n  /**\n   * @protected\n   */\n  onError() {\n    this.mIsLoaded = false\n    this.post(Message.ERROR)\n  }\n\n  /**\n   * Returns native loaded data object associated with this loader.\n   *\n   * @return {?}\n   */\n  get data() {\n    return this.mData\n  }\n\n  /**\n   * Returns the Asset owning this loader.\n   *\n   * @returns {Asset}\n   */\n  get owner() {\n    return this.mOwner\n  }\n}\n","/**\n * Responsible for loading images.\n *\n * @cat assets.loaders\n * @extends AssetLoader\n */\nexport \nclass ImageAssetLoader extends AssetLoader {\n  /**\n   * Creates new ImageAssetLoader instance.\n   * @param {string} url\n   */\n  constructor(url) {\n    super(url)\n\n    /** @private @type {Image} */\n    this.mImageElement = new Image()\n    this.mImageElement.crossOrigin = 'anonymous'\n  }\n\n  /**\n   * @inheritDoc\n   */\n  load() {\n    this.mImageElement.src = this.mUrl\n    this.mImageElement.onload = () => this.onLoad()\n    this.mImageElement.onerror = () => this.onError()\n    this.mData = this.mImageElement\n  }\n\n  /**\n   * @inheritDoc\n   */\n  abort() {\n    this.mImageElement.onload = this.mImageElement.onabort = this.mImageElement.onerror = function() {}\n    this.mImageElement.src = ImageAssetLoader.ALT_URL\n  }\n}\n\nImageAssetLoader.ALT_URL =\n  'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAIAAACQd1PeAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAA5JREFUeNpiYmBgAAgwAAAMAAMjcmNcAAAAAElFTkSuQmCC'\n","/**\n * XHRAssetLoader responsible for loading data via XMLHttpRequest.\n *\n * @cat assets.loaders\n * @extends AssetLoader\n */\nexport \nclass XHRAssetLoader extends AssetLoader {\n  constructor(url) {\n    super(url)\n\n    /** @protected @type {XMLHttpRequest} */\n    this.mRequest = new XMLHttpRequest()\n\n    /** @type {string|undefined} */\n    this.mimeType = undefined\n\n    /** @type {string} */\n    this.responseType = ''\n  }\n\n  /**\n   * @inheritDoc\n   */\n  load() {\n    this.mRequest.open('GET', this.mUrl, true)\n\n    if (this.responseType != '') this.mRequest.responseType = this.responseType\n\n    if (this.mRequest.overrideMimeType != undefined && this.mimeType)\n      this.mRequest.overrideMimeType(this.mimeType)\n\n    this.mRequest.onreadystatechange = () => {\n      if (this.mRequest.readyState === 4) {\n        if (\n          this.mRequest.status === 200 ||\n          (this.mRequest.status === 0 && this.mRequest.responseText)\n        ) {\n          if (this.responseType === '' || this.responseType === 'text')\n            this.mData = this.mRequest.responseText\n          else this.mData = this.mRequest.response\n\n          this.onLoad()\n        } else this.onError()\n      }\n    }\n\n    this.mRequest.send(null)\n  }\n\n  /**\n   * @inheritDoc\n   */\n  abort() {\n    this.mRequest.abort()\n  }\n}\n","/**\n * Responsible for loading local or Google fonts.\n *\n * @cat assets.loaders\n * @extends AssetLoader\n */\nexport \nclass FontFaceAssetLoader extends AssetLoader {\n  /**\n   * Creates new FontFaceAssetLoader instance.\n   *\n   * @param {string} name     The custom name of the font\n   * @param {string} url      The path to the font\n   * @param {boolean} isLocal Pass `true` if font is local otherwise Google Fonts service is used.\n   */\n  constructor(name, url, isLocal) {\n    super(url)\n\n    /** @private @type {string} */\n    this.mName = name\n\n    /** @private @type {string} */\n    this.mTestingFontName = 'Courier New'\n\n    /** @private @type {boolean} */\n    this.mIsLocal = isLocal\n\n    /** @private @type {string} */\n    this.mTestingString = '~ GHBDTN,.#$Mlck'\n\n    /** @private @type {number} */\n    this.mCheckDelay = 50\n\n    /** @private @type {HTMLElement} */\n    this.mTestingElement = this.__getTestingElement()\n\n    /** @private @type {FontMetrics|null} */\n    this.metrics = null\n\n    /** @private @type {Element} */\n    this.mLoaderElement = this.__getLoaderElement(this.mIsLocal)\n    this.mTestingElement.style.fontFamily = this.mTestingFontName\n\n    /** @private @type {number} */\n    this.mDefaultFontWidth = this.mTestingElement.offsetWidth\n    this.mTestingElement.style.fontFamily = name + ',' + this.mTestingFontName\n\n    /** @private @type {number} */\n    this.mTimeoutHandle = -1\n  }\n\n  load() {\n    if (this.mIsLocal)\n      this.mLoaderElement.innerHTML += `\\n @font-face {font-family: ${\n        this.mName\n      }; src: url(${this.mUrl});}`\n    else this.mLoaderElement.href = this.mUrl\n\n    this.__checkLoadingStatus()\n  }\n\n  abort() {\n    clearTimeout(this.mTimeoutHandle)\n    this.mTestingElement.parentNode.removeChild(this.mTestingElement)\n  }\n\n  /**\n   * @ignore\n   * @private\n   * @return {Element}\n   */\n  __getLoaderElement(local) {\n    let loaderElement = document.createElement(local ? 'style' : 'link')\n    loaderElement.type = 'text/css'\n    loaderElement.media = 'all'\n    loaderElement.rel = 'stylesheet'\n    loaderElement.onerror = () => {\n      this.onError()\n    }\n    document.getElementsByTagName('head')[0].appendChild(loaderElement)\n    return loaderElement\n  }\n\n  /**\n   * @ignore\n   * @private\n   * @return {HTMLElement}\n   */\n  __getTestingElement() {\n    let testingElement = /** @type {HTMLElement}*/ (document.createElement(\n      'span'\n    ))\n    testingElement.style.position = 'absolute'\n    testingElement.style.top = '-9999px'\n    testingElement.style.left = '-9999px'\n    testingElement.style.visibility = 'hidden'\n    testingElement.style.fontSize = '250px'\n    testingElement.innerHTML = this.mTestingString\n    document.body.appendChild(testingElement)\n\n    return testingElement\n  }\n\n  /**\n   * @private\n   * @return {void}\n   */\n  __checkLoadingStatus() {\n    if (this.mDefaultFontWidth === this.mTestingElement.offsetWidth) {\n      this.mTimeoutHandle = setTimeout(\n        this.__checkLoadingStatus.bind(this),\n        this.mCheckDelay\n      )\n      return\n    }\n\n    this.metrics = FontMetrics.get(this.mName)\n    this.mTestingElement.parentNode.removeChild(this.mTestingElement)\n\n    this.onLoad()\n  }\n}\n","/**\n * Holds information about external assets.\n *\n * @fires Asset#error\n * @fires Asset#complete\n *\n * @cat assets\n * @extends MessageDispatcher\n */\nexport \nclass Asset extends MessageDispatcher {\n  /**\n   * Creates new Asset instance.\n   *\n   * @param  {string} name Name of asset.\n   */\n  constructor(name) {\n    super()\n\n    /** @protected @type {string} */\n    this.mName = name\n\n    /** @protected @type {Object|undefined} */\n    this.mData = null\n\n    /** @protected @type {Array<AssetLoader>} */\n    this.mLoaders = []\n\n    /** @private @type {number} */\n    this.mNumLoaded = 0\n\n    /** @private @type {boolean} */\n    this.mIsReady = false\n  }\n\n  /**\n   * Adds given loader to the list. Loader cannot be added to multiply Assets.\n   *\n   * @param {AssetLoader} loader Loader to add.\n   */\n  addLoader(loader) {\n    loader.mOwner = this\n    this.mLoaders.push(loader)\n\n    loader.on(Message.COMPLETE, this.__onLoaderComplete, this)\n    loader.on(Message.ERROR, this.__onLoaderError, this)\n  }\n\n  /**\n   * @private\n   * @param {Message} m\n   * @returns {void}\n   */\n  __onLoaderComplete(m) {\n    this.mNumLoaded++\n\n    if (this.mNumLoaded === this.mLoaders.length) {\n      for (let i = 0; i < this.mLoaders.length; i++)\n        this.mLoaders[i].off(Message.COMPLETE, Message.ERROR)\n\n      this.onAllLoaded()\n    }\n  }\n\n  /**\n   * @private\n   * @param {Message} m\n   */\n  __onLoaderError(m) {\n    this.abort()\n\n    /**\n     * Posted when error occurred during loading this asset.\n     * @event Asset#error\n     */\n    this.post(Message.ERROR)\n  }\n\n  /**\n   * @protected\n   */\n  onAllLoaded() {}\n\n  /**\n   * Aborts loading of this asset.\n   * @public\n   */\n  abort() {\n    this.mNumLoaded = 0\n\n    for (let i = 0; i < this.mLoaders.length; i++) {\n      const loader = this.mLoaders[i]\n      loader.off(Message.COMPLETE, Message.ERROR)\n      loader.abort()\n    }\n  }\n\n  /**\n   * Protected method used to notify AssetManager about completion of loading this asset.\n   *\n   * @protected\n   * @param {Object=} data\n   * @returns {void}\n   */\n  ready(data) {\n    this.mData = data\n    this.mIsReady = true\n\n    /**\n     * Posted when asset finished loading.\n     * @event Asset#complete\n     */\n    this.post(Message.COMPLETE)\n  }\n\n  /**\n   * Returns the name of this asset.\n   *\n   * @return {string}\n   */\n  get name() {\n    return this.mName\n  }\n\n  /**\n   * Returns loaded data object associated with this asset.\n   *\n   * @return {?}\n   */\n  get data() {\n    return this.mData\n  }\n\n  /**\n   * Returns `true` if this asset is loaded.\n   *\n   * @return {boolean}\n   */\n  get isReady() {\n    return this.mIsReady\n  }\n\n  /**\n   * Returns array of loaders.\n   *\n   * @returns {Array<AssetLoader>}\n   */\n  get loaders() {\n    return this.mLoaders\n  }\n}\n","/**\n * This is abstract class for custom user assets. For example CustomAsset can be used to load video or other data files.\n *\n * @fires Asset#error\n * @fires Asset#complete\n *\n * @cat assets\n * @extends Asset\n */\nexport \nclass CustomAsset extends Asset {}\n","/**\n * Single Texture file asset class responsible for loading images file and\n * converting them into Textures.\n *\n * @cat assets\n * @extends Asset\n */\nexport \nclass TextureAsset extends Asset {\n  /**\n   * Creates TextureAsset instance.\n   *\n   * @param {string} name Asset name.\n   * @param {string} url  URL to load image from.\n   */\n  constructor(name, url) {\n    super(name)\n\n    /** @type {number} */\n    this.mScale = 1 / Texture.getScaleFactorFromName(url)\n\n    /** @private @type {ImageAssetLoader} */\n    this.mImageLoader = new ImageAssetLoader(url)\n    this.addLoader(this.mImageLoader)\n  }\n\n  /**\n   * @inheritDoc\n   */\n  onAllLoaded() {\n    super.ready(new Texture(this.mImageLoader.data, null, null, this.mScale))\n  }\n}\n","/**\n * Single JSON file asset class responsible for loading json file.\n *\n * @cat assets\n * @extends Asset\n */\nexport \nclass JSONAsset extends Asset {\n  /**\n   * Creates new JSONAsset instance.\n   *\n   * @param {string} name The name of asset.\n   * @param {string} url  URL to the json file.\n   * @return {void}\n   */\n  constructor(name, url) {\n    super(name)\n\n    /** @private @type {XHRAssetLoader} */\n    this.mXHR = new XHRAssetLoader(url)\n    this.mXHR.mimeType = 'application/json'\n    this.addLoader(this.mXHR)\n  }\n\n  /**\n   * @inheritDoc\n   */\n  onAllLoaded() {\n    super.ready(\n      /** @type {!Object}*/ (JSON.parse(/** @type {string} */ (this.mXHR.data)))\n    )\n  }\n}\n","/**\n * Single JSON file asset class responsible for loading json file.\n *\n * @cat assets\n * @extends Asset\n */\nexport \nclass XMLAsset extends Asset {\n  /**\n   * Creates new JSONAsset instance.\n   *\n   * @param {string} name The name of asset.\n   * @param {string} url  URL to the json file.\n   * @return {void}\n   */\n  constructor(name, url) {\n    super(name)\n\n    /** @private @type {XHRAssetLoader} */\n    this.mXHR = new XHRAssetLoader(url)\n    this.mXHR.mimeType = 'text/xml'\n    this.addLoader(this.mXHR)\n  }\n\n  /**\n   * @inheritDoc\n   */\n  onAllLoaded() {\n    super.ready(\n      new DOMParser().parseFromString(\n        /** @type {string} */ (this.mXHR.data),\n        'text/xml'\n      )\n    )\n  }\n}\n","/**\n * Font file asset class responsible for loading local font files.\n *\n * Note: this class need a body to work properly.\n *\n * @cat assets\n * @extends Asset\n */\nexport \nclass FontAsset extends Asset {\n  /**\n   * Creates new instance of FontAsset.\n   *\n   * @param {string} name     The custom name of the font\n   * @param {string} url      The path to the font\n   * @param {boolean} isLocal Pass `true` if font is local otherwise Google Fonts service is used.\n   */\n  constructor(name, url, isLocal) {\n    super(name)\n\n    if (isLocal === false)\n      url =\n        'https://fonts.googleapis.com/css?family=' +\n        name.replace(new RegExp(' ', 'g'), '+')\n\n    // We are not doing actual loading since loading is handled by browser. Just fake it.\n    this.mLoader = new FontFaceAssetLoader(name, url, isLocal)\n    this.addLoader(this.mLoader)\n  }\n\n  /**\n   * @inheritDoc\n   */\n  onAllLoaded() {\n    super.ready()\n  }\n}\n","/**\n * Texture Atlas asset responsible for loading Image file and corresponding Json\n * file.\n *\n * @cat assets\n * @extends Asset\n */\nexport \nclass AtlasTextureAsset extends Asset {\n  /**\n   * Creates new AtlasTextureAsset instance.\n   *\n   * @param {string} name     Name of the asset.\n   * @param {string} imageUrl Image URL.\n   * @param {string} dataUrl  Json URL.\n   */\n  constructor(name, imageUrl, dataUrl) {\n    super(name)\n\n    /** @private @type {number} */\n    this.mScale = 1 / Texture.getScaleFactorFromName(imageUrl)\n\n    /** @private @type {ImageAssetLoader} */\n    this.mImageLoader = new ImageAssetLoader(imageUrl)\n\n    /** @private @type {XHRAssetLoader} */\n    this.mXHR = new XHRAssetLoader(dataUrl)\n    this.mXHR.mimeType = 'application/json'\n\n    this.addLoader(this.mImageLoader)\n    this.addLoader(this.mXHR)\n  }\n\n  /**\n   * @inheritDoc\n   */\n  onAllLoaded() {\n    super.ready(\n      new AtlasTexture(\n        this.mImageLoader.data,\n        /** @type {{meta: *, frames: Array<Object<Array<number>>>}} */ JSON.parse(\n          this.mXHR.data\n        ),\n        this.mScale\n      )\n    )\n  }\n}\n","/**\n * Bitmap Font Asset responsible for loading font image file and corresponding xml file.\n *\n * @cat assets\n * @extends Asset\n */\nexport \nclass BitmapFontAsset extends Asset {\n  /**\n   * Creates new AtlasTextureAsset instance.\n   *\n   * @param {string} name     Name of the asset.\n   * @param {string} imageUrl Image URL.\n   * @param {string} xmlUrl   XML URL.\n   */\n  constructor(name, imageUrl, xmlUrl) {\n    super(name)\n\n    /** @type {number} */\n    this.mScale = 1 / Texture.getScaleFactorFromName(imageUrl)\n\n    /** @private @type {ImageAssetLoader} */\n    this.mImageLoader = new ImageAssetLoader(imageUrl)\n\n    /** @private @type {XHRAssetLoader} */\n    this.mXHR = new XHRAssetLoader(xmlUrl)\n    this.mXHR.mimeType = 'text/xml'\n\n    this.addLoader(this.mImageLoader)\n    this.addLoader(this.mXHR)\n  }\n\n  /**\n   * @inheritDoc\n   */\n  onAllLoaded() {\n    let xml = new DOMParser().parseFromString(\n      /** @type {string} */ (this.mXHR.data),\n      'text/xml'\n    )\n    let texture = new Texture(this.mImageLoader.data, null, null, this.mScale)\n\n    super.ready(BitmapFontAsset.parse(xml, texture))\n  }\n\n  /**\n   *\n   * @param {Document} xml\n   * @param {Texture} texture\n   * @returns {BitmapFontData}\n   */\n  static parse(xml, texture) {\n    let data = new BitmapFontData()\n    data.texture = texture\n    data.xml = xml\n\n    let info = xml.getElementsByTagName('info')[0]\n    let common = xml.getElementsByTagName('common')[0]\n\n    data.name = info.getAttribute('face')\n    data.size = parseInt(info.getAttribute('size'), 10)\n    data.lineHeight = parseInt(common.getAttribute('lineHeight'), 10)\n    data.baseline = parseInt(common.getAttribute('base'), 10)\n    data.chars = {}\n\n    let letters = xml.getElementsByTagName('char')\n\n    for (let i = 0; i < letters.length; i++) {\n      let letter = letters[i]\n      let charCode = parseInt(letter.getAttribute('id'), 10)\n      let x = parseInt(letter.getAttribute('x'), 10) + texture.region.x\n      let y = parseInt(letter.getAttribute('y'), 10) + texture.region.y\n      let w = parseInt(letter.getAttribute('width'), 10)\n      let h = parseInt(letter.getAttribute('height'), 10)\n      let xo = parseInt(letter.getAttribute('xoffset'), 10)\n      let yo = parseInt(letter.getAttribute('yoffset'), 10)\n      let xa = parseInt(letter.getAttribute('xadvance'), 10)\n      let textureRect = new Rectangle(x, y, w, h)\n\n      let charData = new BitmapFontCharData()\n      charData.texture = new Texture(texture.native, textureRect)\n      charData.xOffset = xo\n      charData.yOffset = yo\n      charData.width = w\n      charData.height = h\n      charData.xAdvance = xa\n\n      data.chars[charCode] = charData\n    }\n\n    let kernings = xml.getElementsByTagName('kerning')\n\n    for (let i = 0; i < kernings.length; i++) {\n      let kerning = kernings[i]\n      let first = parseInt(kerning.getAttribute('first'), 10)\n      let second = parseInt(kerning.getAttribute('second'), 10)\n      let amount = parseInt(kerning.getAttribute('amount'), 10)\n\n      if (data.chars[second]) data.chars[second].kerning[first] = amount\n    }\n\n    return data\n  }\n}\n\nexport \nclass BitmapFontData {\n  constructor() {\n    /** @type {Texture} */\n    this.texture = null\n\n    /** @type {Document} */\n    this.xml = null\n\n    /** @type {string} */\n    this.name = ''\n\n    /** @type {number} */\n    this.size = 0\n\n    /** @type {number} */\n    this.lineHeight = 0\n\n    /** @type {Object.<number, BitmapFontCharData>} */\n    this.chars = {}\n\n    /** @type {number} */\n    this.baseline = 0\n  }\n}\n\nexport \nclass BitmapFontCharData {\n  constructor() {\n    /** @type {Texture} */\n    this.texture = null\n\n    /** @type {number} */\n    this.xOffset = 0\n\n    /** @type {number} */\n    this.yOffset = 0\n\n    /** @type {number} */\n    this.width = 0\n\n    /** @type {number} */\n    this.height = 0\n\n    /** @type {number} */\n    this.xAdvance = 0\n\n    /** @type {Object.<number, number>} */\n    this.kerning = {}\n  }\n}\n","/**\n * Sound file asset class responsible for loading audio files.\n *\n * @cat assets\n * @extends Asset\n */\nexport \nclass SoundAsset extends Asset {\n  /**\n   * Creates SoundAsset instance.\n   *\n   * @param {string} name Sound name.\n   * @param {string} url  URL to load audio from.\n   */\n  constructor(name, url) {\n    super(name)\n\n    if (Device.webAudioSupported === false) return\n\n    if (Black.instance.hasSystem(MasterAudio) === false) {\n      Debug.warn('[SoundAsset] Loading sound files without MasterAudio system.')\n      return\n    }\n\n    /** @private @type {XHRAssetLoader} */\n    this.mXHR = new XHRAssetLoader(url)\n    this.mXHR.responseType = 'arraybuffer'\n    this.addLoader(this.mXHR)\n  }\n\n  /**\n   * @inheritDoc\n   */\n  onAllLoaded() {\n    let undecodedAudio = /** @type {!ArrayBuffer} */ (this.mXHR.data)\n    MasterAudio.context.decodeAudioData(undecodedAudio, buffer => {\n      super.ready(new SoundClip(buffer))\n    })\n  }\n}\n","/**\n * Sound file asset class responsible for loading audio atlas files.\n *\n * @cat assets\n * @extends Asset\n */\nexport \nclass SoundAtlasAsset extends Asset {\n  /**\n   * Creates new SoundAtlasAsset instance.\n   *\n   * @param {string} name Sound name.\n   * @param {string} soundUrl  URL to load audio atlas from.\n   * @param {string} dataUrl  URL to load atlas data from.\n   */\n  constructor(name, soundUrl, dataUrl) {\n    super(name)\n\n    if (Device.webAudioSupported === false) return\n\n    if (Black.instance.hasSystem(MasterAudio) === false) {\n      Debug.warn('[SoundAsset] Loading sound files without MasterAudio system.')\n      return\n    }\n\n    /** @private @type {XHRAssetLoader} */\n    this.mAudioXHR = new XHRAssetLoader(soundUrl)\n    this.mAudioXHR.responseType = 'arraybuffer'\n    this.addLoader(this.mAudioXHR)\n\n    /** @private @type {XHRAssetLoader} */\n    this.mDataXHR = new XHRAssetLoader(dataUrl)\n    this.mDataXHR.mimeType = 'application/json'\n    this.mDataXHR.responseType = 'json'\n    this.addLoader(this.mDataXHR)\n  }\n\n  /**\n   * @inheritDoc\n   */\n  onAllLoaded() {\n    let undecodedAudio = /** @type {!ArrayBuffer} */ (this.mAudioXHR.data)\n    MasterAudio.context.decodeAudioData(undecodedAudio, buffer => {\n      super.ready(new SoundAtlasClip(buffer, this.mDataXHR.data))\n    })\n  }\n}\n","/**\n * Single JSON file asset class responsible for loading json file.\n *\n * @cat assets\n * @extends Asset\n */\n\nexport \nclass BVGAsset extends Asset {\n  /**\n   * Creates new JSONAsset instance.\n   *\n   * @param {string} name Name of the asset.\n   * @param {string} url  The URL of the json.\n   * @param {boolean} bakeSelf Flag to bake full BVG as texture. If false root will not be baked.\n   * @param {boolean} bakeChildren Flag to bake each node with id to textures. If false none children nodes will be baked.\n   * @param {Array<string>} namesToBake Concrete nodes ids to bake. Works only if bakeChildren is set to true.\n   *\n   * @returns {void}\n   */\n  constructor(name, url, bakeSelf, bakeChildren, namesToBake) {\n    super(name)\n\n    /** @private @type {boolean} */\n    this.mBakeSelf = bakeSelf\n\n    /** @private @type {boolean} */\n    this.mBakeChildren = bakeChildren\n\n    /** @private @type {Array<string>} */\n    this.mNamesToBake =\n      /** @type {Array<string>} */ (bakeChildren && namesToBake\n        ? namesToBake\n        : [])\n\n    /** @private @type {GraphicsData|null} */\n    this.mGraphicsData = null\n\n    /** @private @type {XHRAssetLoader} */\n    this.mXHR = new XHRAssetLoader(url)\n    this.mXHR.mimeType = 'application/json'\n    this.addLoader(this.mXHR)\n  }\n\n  /**\n   * @inheritDoc\n   */\n  onAllLoaded() {\n    const data = /** @type {!Object}*/ (JSON.parse(\n      /** @type {string} */ (this.mXHR.data)\n    ))\n    const parser = new BVGParser()\n\n    this.mGraphicsData = parser.parse(data)\n    this.mGraphicsData.name = this.name\n\n    super.ready(this.mGraphicsData)\n  }\n\n  /**\n   * Creates baked textures from this graphics data.\n   *\n   * @return {Object.<string, CanvasRenderTexture>}\n   */\n  bakeTextures() {\n    const textures = {}\n    const namesToBake = this.mNamesToBake\n\n    if (this.mBakeChildren && namesToBake.length === 0) {\n      const traverse = nodes => {\n        nodes = /** @type {Array<GraphicsData>} */ (nodes)\n\n        if (nodes.length === 0) return\n\n        for (let i = 0, l = nodes.length; i < l; i++) {\n          if (nodes[i].name)\n            namesToBake.push(/** @type {string} */ (nodes[i].name))\n\n          traverse(/** @type {Array<GraphicsData>} */ (nodes[i].mNodes))\n        }\n      }\n\n      traverse(this.mGraphicsData.mNodes)\n    }\n\n    if (this.mBakeSelf) namesToBake.unshift(this.mGraphicsData.name)\n\n    for (let i = 0, l = namesToBake.length; i < l; i++) {\n      const name = namesToBake[i]\n      const node = this.mGraphicsData.searchNode(name)\n\n      if (!node) {\n        Debug.warn(`[BVGAsset] GraphicsData node with id '${name}' not found.`)\n        continue\n      }\n\n      const graphics = new Graphics(node, name !== this.mGraphicsData.name)\n      const dpr = 1 / Black.driver.renderScaleFactor\n      const renderTexture = new CanvasRenderTexture(\n        graphics.width,\n        graphics.height,\n        1\n      )\n\n      Black.driver.render(graphics, renderTexture, new Matrix().scale(dpr, dpr))\n\n      textures[name] = renderTexture\n    }\n\n    return textures\n  }\n}\n","/**\n * Represents current state of the AssetManager.\n *\n * @cat assets\n * @static\n * @constant\n * @enum {string}\n */\nexport \nconst AssetManagerState = {\n  NONE: 'none',\n  LOADING: 'loading',\n  FINISHED: 'finished',\n}\n","/**\n * Responsible for loading assets and manages its in memory state.\n *\n * @fires Message.PROGRESS\n * @fires Message.COMPLETE\n * @fires Message.ERROR\n *\n * @cat assets\n * @extends MessageDispatcher\n */\n\nexport \nclass AssetManager extends MessageDispatcher {\n  /**\n   * Creates new AssetManager instance. AssetManager exposes static property\n   * called 'default' and many internal classes uses default instance.\n   */\n  constructor() {\n    super()\n\n    /** @private @type {string} */\n    this.mDefaultPath = ''\n\n    /** @private @type {number} */\n    this.mTotalLoaded = 0\n\n    /** @private @type {number} */\n    this.mTotalPending = 0\n\n    /** @private @type {number} */\n    this.mTotalErrors = 0\n\n    /** @private @type {boolean} */\n    this.mIsAllLoaded = false\n\n    /** @private @type {number} */\n    this.mLoadingProgress = 0\n\n    /** @private @type {Array<Asset>} */\n    this.mQueue = []\n\n    /** @private @type {Array<AssetLoader>} */\n    this.mLoadersQueue = []\n\n    /** @private @type {Object.<string, Texture>} */\n    this.mTextures = {}\n\n    /** @private @type {Object.<string, GraphicsData>} */\n    this.mGraphicsData = {}\n\n    /** @private @type {Object.<string, Texture>} */\n    this.mVectorTextures = {}\n\n    /** @private @type {Object.<string, AtlasTexture>} */\n    this.mAtlases = {}\n\n    /** @private @type {Object.<string, JSONAsset>} */\n    this.mJsons = {}\n\n    /** @private @type {Object.<string, XMLAsset>} */\n    this.mXMLs = {}\n\n    /** @private @type {Object.<string, SoundClip>} */\n    this.mSounds = {}\n\n    /** @private @type {Object.<string, SoundAtlasClip>} */\n    this.mSoundAtlases = {}\n\n    /** @private @type {Object.<string, FontAsset>} */\n    this.mFonts = {}\n\n    /** @private @type {Object.<string, BitmapFontData>} */\n    this.mBitmapFonts = {}\n\n    /** @private @type {Object.<string, CustomAsset>} */\n    this.mCustomAssets = {}\n\n    /** @private @type {AssetManagerState} */\n    this.mState = AssetManagerState.NONE\n\n    /** @private @type {Object.<string, boolean>} */\n    this.mDictionary = {}\n  }\n\n  /**\n   * Adds or changes texture to the internal list for future reuse by given name.\n   * @param {string} name\n   * @param {Texture} texture\n   */\n  addTexture(name, texture) {\n    this.mTextures[name] = texture\n  }\n\n  /**\n   * Adds single image to the loading queue.\n   *\n   * @param {string} name Name of the asset.\n   * @param {string} url  The URL of the image.\n   * @returns {void}\n   */\n  enqueueImage(name, url) {\n    this.__validateState()\n    this.__validateName(name)\n    this.mQueue.push(new TextureAsset(name, this.mDefaultPath + url))\n  }\n\n  /**\n   * Adds atlas to the loading queue.\n   *\n   * @param {string} name     Name of the asset.\n   * @param {string} imageUrl Atlas URL.\n   * @param {string} dataUrl  URL to the .json file which describes the atlas.\n   * @returns {void}\n   */\n  enqueueAtlas(name, imageUrl, dataUrl) {\n    this.__validateState()\n    this.__validateName(name)\n    this.mQueue.push(\n      new AtlasTextureAsset(\n        name,\n        this.mDefaultPath + imageUrl,\n        this.mDefaultPath + dataUrl\n      )\n    )\n  }\n\n  /**\n   * Adds bitmap font to the loading queue.\n   *\n   * @param {string} name     Name of the font.\n   * @param {string} imageUrl Image URL.\n   * @param {string} xmlUrl   URL to the .xml file which describes the font.\n   * @returns {void}\n   */\n  enqueueBitmapFont(name, imageUrl, xmlUrl) {\n    this.__validateState()\n    this.__validateName(name)\n    this.mQueue.push(\n      new BitmapFontAsset(\n        name,\n        this.mDefaultPath + imageUrl,\n        this.mDefaultPath + xmlUrl\n      )\n    )\n  }\n\n  /**\n   * Adds single xml file to the loading queue.\n   *\n   * @param {string} name Name of the asset.\n   * @param {string} url  The URL of the json.\n   * @returns {void}\n   */\n  enqueueXML(name, url) {\n    this.__validateState()\n    this.__validateName(name)\n    this.mQueue.push(new XMLAsset(name, this.mDefaultPath + url))\n  }\n\n  /**\n   * Adds single json file to the loading queue.\n   *\n   * @param {string} name Name of the asset.\n   * @param {string} url  The URL of the json.\n   * @returns {void}\n   */\n  enqueueJSON(name, url) {\n    this.__validateState()\n    this.__validateName(name)\n    this.mQueue.push(new JSONAsset(name, this.mDefaultPath + url))\n  }\n\n  /**\n   * Adds single Black Vector Graphics file to the loading queue.\n   *\n   * If baked both graphics data and baked texture will be stored inside this AssetManager.\n   *\n   * @param {string} name Name of the asset.\n   * @param {string} url  The URL of the json.\n   * @param {boolean=} [bakeSelf=false] Flag to bake full BVG as texture. If false root will not be baked.\n   * @param {boolean=} [bakeChildren=false] Flag to bake each node with id to textures. If false none children nodes will be baked.\n   * @param {Array<string>=} [namesToBake=null] Concrete nodes ids to bake. Works only if bakeChildren is set to true.\n   *\n   * @returns {void}\n   */\n  enqueueVector(\n    name,\n    url,\n    bakeSelf = false,\n    bakeChildren = false,\n    namesToBake = null\n  ) {\n    this.__validateState()\n    this.__validateName(name)\n    this.mQueue.push(\n      new BVGAsset(\n        name,\n        this.mDefaultPath + url,\n        bakeSelf,\n        bakeChildren,\n        namesToBake\n      )\n    )\n  }\n\n  /**\n   * Adds single sound to the loading queue.\n   *\n   * @param {string} name Name of the sound.\n   * @param {string} url  The URL of the sound.\n   * @returns {void}\n   */\n  enqueueSound(name, url) {\n    this.__validateState()\n    this.__validateName(name)\n    this.mQueue.push(new SoundAsset(name, this.mDefaultPath + url))\n  }\n\n  /**\n   * Adds sound atlas to the loading queue.\n   *\n   * @param {string} name Name of the sound.\n   * @param {string} soundUrl  The URL of the sound.\n   * @param {string} dataUrl  The URL of the data JSON.\n   * @returns {void}\n   */\n  enqueueSoundAtlas(name, soundUrl, dataUrl) {\n    this.__validateState()\n    this.__validateName(name)\n    this.mQueue.push(\n      new SoundAtlasAsset(\n        name,\n        this.mDefaultPath + soundUrl,\n        this.mDefaultPath + dataUrl\n      )\n    )\n  }\n\n  /**\n   * Adds local font to the loading queue.\n   *\n   * @param {string} name Name of the asset.\n   * @param {string} url  The URL to the font.\n   * @returns {void}\n   */\n  enqueueFont(name, url) {\n    this.__validateState()\n    this.__validateName(name)\n    this.mQueue.push(new FontAsset(name, this.mDefaultPath + url, true))\n  }\n\n  /**\n   * Adds Google Font to the loading queue.\n   *\n   * @param {string} name Name of the asset.\n   * @returns {void}\n   */\n  enqueueGoogleFont(name) {\n    this.__validateState()\n    this.__validateName(name)\n    this.mQueue.push(new FontAsset(name, '', false))\n  }\n\n  /**\n   * Adds custom asset to the loading queue.\n   *\n   * @param {Asset} asset\n   */\n  enqueueCustomAsset(asset) {\n    this.__validateState()\n    this.mQueue.push(asset)\n  }\n\n  /**\n   * Starts loading all enqueued assets.\n   *\n   * @fires complete\n   * @return {void}\n   */\n  loadQueue() {\n    this.__validateState()\n    this.mState = AssetManagerState.LOADING\n\n    for (let i = 0; i < this.mQueue.length; i++) {\n      let item = this.mQueue[i]\n\n      if (item.loaders.length > 0) {\n        item.on(Message.COMPLETE, this.onAssetLoaded, this)\n        item.on(Message.ERROR, this.onAssetError, this)\n        this.mLoadersQueue.push(...item.loaders)\n\n        this.mTotalPending++\n      }\n    }\n\n    // Loader will notify Asset when its ready. Asset will notify AssetManager.\n    for (let i = 0; i < this.mLoadersQueue.length; i++) {\n      let loader = this.mLoadersQueue[i]\n      loader.load()\n    }\n  }\n\n  /**\n   * @protected\n   * @ignore\n   * @param {Message} msg\n   * @return {void}\n   */\n  onAssetLoaded(msg) {\n    this.mTotalLoaded++\n    this.mLoadingProgress = this.mTotalLoaded / this.mTotalPending\n\n    let item = /** @type {Asset}*/ (msg.sender)\n    item.off(Message.COMPLETE, Message.ERROR)\n\n    if (item.constructor === TextureAsset) this.mTextures[item.name] = item.data\n    else if (item.constructor === AtlasTextureAsset)\n      this.mAtlases[item.name] = item.data\n    else if (item.constructor === JSONAsset) this.mJsons[item.name] = item.data\n    else if (item.constructor === SoundAsset)\n      this.mSounds[item.name] = item.data\n    else if (item.constructor === SoundAtlasAsset)\n      this.mSoundAtlases[item.name] = item.data\n    else if (item.constructor === FontAsset) this.mFonts[item.name] = item.data\n    else if (item.constructor === XMLAsset) this.mXMLs[item.name] = item.data\n    else if (item.constructor === BitmapFontAsset)\n      this.mBitmapFonts[item.name] = item.data\n    else if (item.constructor === BVGAsset) {\n      this.mGraphicsData[item.name] = item.data\n\n      const bakedTextures = /** @type {BVGAsset} */ (item).bakeTextures()\n\n      for (let name in bakedTextures) {\n        if (!bakedTextures.hasOwnProperty(name)) continue\n\n        name !== item.name && this.__validateName(name)\n        this.mVectorTextures[name] = bakedTextures[name]\n      }\n    } else if (item instanceof CustomAsset) {\n      this.mCustomAssets[item.name] = item.data\n    } else {\n      Debug.error(`[AssetManager] Unable to handle asset type ${item}.`)\n    }\n\n    /**\n     * Posted when loading progress is changed.\n     * @event AssetManager#progress\n     */\n    this.post(Message.PROGRESS, this.mLoadingProgress)\n\n    if (this.mTotalLoaded === this.mTotalPending) {\n      this.mQueue.splice(0, this.mQueue.length)\n      this.mLoadersQueue.splice(0, this.mLoadersQueue.length)\n      this.mState = AssetManagerState.FINISHED\n      this.mTotalLoaded = 0\n      this.mTotalErrors = 0\n      this.mIsAllLoaded = true\n      this.mDictionary = {}\n\n      /**\n       * Posted when all assets finished loading.\n       * @event AssetManager#complete\n       */\n      this.post(Message.COMPLETE)\n    }\n  }\n\n  onAssetError(msg) {\n    this.mTotalErrors++\n\n    let total = this.mTotalLoaded + this.mTotalErrors\n    this.mLoadingProgress = this.mTotalLoaded / this.mTotalPending\n\n    let item = /** @type {Asset}*/ (msg.sender)\n\n    item.off(Message.COMPLETE, Message.ERROR)\n    Debug.warn(`[AssetManager] Error loading asset '${item.name}'.`)\n\n    /**\n     * Posted when error occurred while loading assets.\n     * @event AssetManager#complete\n     */\n    this.post(Message.ERROR, item)\n\n    if (total === this.mTotalPending) {\n      this.mQueue.splice(0, this.mQueue.length)\n      this.mLoadersQueue.splice(0, this.mLoadersQueue.length)\n      this.mState = AssetManagerState.FINISHED\n      this.mTotalLoaded = 0\n      this.mTotalErrors = 0\n      this.mIsAllLoaded = true\n      this.mDictionary = {}\n      this.post(Message.COMPLETE)\n    }\n  }\n\n  /**\n   * Returns BitmapFontData object by given name.\n   *\n   * @param {string} name The name of the Asset to search.\n   * @return {BitmapFontData|null} Returns a BitmapFontData if found or null.\n   */\n  getBitmapFont(name) {\n    /** @type {BitmapFontData} */\n    let t = this.mBitmapFonts[name]\n\n    if (t != null) return t\n\n    Debug.warn(`[AssetManager] BitmapFontData '${name}' was not found.`)\n    return null\n  }\n\n  /**\n   * Returns Texture object by given name.\n   *\n   * @param {string} name The name of the Asset.\n   * @return {Texture|null} Returns a Texture if found or null.\n   */\n  getTexture(name) {\n    /** @type {Texture} */\n    let t = this.mTextures[name] || this.mVectorTextures[name]\n\n    if (t != null) return t\n\n    for (let key in this.mAtlases) {\n      t = this.mAtlases[key].subTextures[name]\n\n      if (t) return t\n    }\n\n    Debug.warn(`[AssetManager] Texture '${name}' was not found.`)\n    return null\n  }\n\n  getGraphicsData(name) {\n    /** @type {GraphicsData} */\n    let data = this.mGraphicsData[name]\n\n    if (data) return data\n\n    for (let key in this.mGraphicsData) {\n      data = this.mGraphicsData[key].searchNode(name)\n\n      if (data) {\n        return data\n      }\n    }\n\n    Debug.warn(`[AssetManager] GraphicsData '${name}' was not found.`)\n    return null\n  }\n\n  /**\n   * Returns array of Texture by given name mask.\n   * Searches across all loaded images and atlases.\n   *\n   * @param {string} nameMask The name mask.\n   * @returns {Array<Texture>|null}\n   */\n  getTextures(nameMask) {\n    let out = []\n    let names = []\n\n    let re = new RegExp('^' + nameMask.split('*').join('.*') + '$')\n\n    // collect single textures\n    for (let key in this.mTextures)\n      if (re.test(key))\n        names.push({ name: key, atlas: null, isBakedVector: false })\n\n    for (let key in this.mVectorTextures)\n      if (re.test(key))\n        names.push({ name: key, atlas: null, isBakedVector: true })\n\n    // collect textures from all atlases\n    for (let key in this.mAtlases) {\n      let atlas = this.mAtlases[key]\n\n      for (let key2 in atlas.subTextures)\n        if (re.test(key2))\n          names.push({ name: key2, atlas: atlas, isBakedVector: false })\n    }\n\n    AtlasTexture.naturalSort(names, 'name')\n\n    for (let i = 0; i < names.length; i++) {\n      let ao = names[i]\n\n      if (ao.atlas === null) {\n        if (ao.isBakedVector === true) out.push(this.mVectorTextures[ao.name])\n        else out.push(this.mTextures[ao.name])\n      } else out.push(ao.atlas.mSubTextures[ao.name])\n    }\n\n    if (out.length > 0) return out\n\n    return null\n  }\n\n  /**\n   * Returns AtlasTexture by given name.\n   *\n   * @param {string} name The name of the Asset.\n   * @return {AtlasTexture|null} Returns atlas or null.\n   */\n  getAtlas(name) {\n    if (this.mAtlases[name] != null) return this.mAtlases[name]\n\n    Debug.warn(`[AssetManager] Atlas '${name}' was not found.`)\n    return null\n  }\n\n  /**\n   * Returns `SoundClip` by given name.\n   *\n   * @param {string} name The name of the sound.\n   * @return {SoundClip} Returns sound or null.\n   */\n  getSound(name) {\n    /** @type {SoundClip} */\n    let t = this.mSounds[name]\n\n    if (t != null) return t\n\n    for (let key in this.mSoundAtlases) {\n      t = this.mSoundAtlases[key].subSounds[name]\n      if (t != null) return t\n    }\n\n    Debug.warn(`[AssetManager] Sound '${name}' was not found.`)\n    return null\n  }\n\n  /**\n   * Returns `SoundAtlasClip` by given name.\n   *\n   * @param {string} name The name of the sound.\n   * @return {SoundClip} Returns sound or null.\n   */\n  getSoundAtlas(name) {\n    return this.mSoundAtlases[name]\n  }\n\n  /**\n   * Returns Object parsed from JSON by given name.\n   *\n   * @param {string} name The name of the JSON asset.\n   * @return {Object} Returns object or null.\n   */\n  getJSON(name) {\n    return this.mJsons[name]\n  }\n\n  /**\n   * Returns Object parsed from `CutsomAsset` by given name.\n   *\n   * @param {string} name The name of the asset.\n   * @return {Object} Returns object or null.\n   */\n  getCustomAsset(name) {\n    return this.mCustomAssets[name]\n  }\n\n  __validateState() {\n    Debug.assert(\n      this.mState === AssetManagerState.NONE ||\n        this.mState === AssetManagerState.FINISHED,\n      'Illegal state.'\n    )\n  }\n\n  __validateName(name) {\n    Debug.assert(\n      this.mDictionary[name] == null,\n      'Asset with such name is already added.'\n    )\n\n    this.mDictionary[name] = true\n  }\n\n  /**\n   * Gets/Sets default path for loading. Useful when URLs getting too long.\n   * The asset path will be concatenated with defaultPath.\n   *\n   * @return {string}\n   */\n  get defaultPath() {\n    return this.mDefaultPath\n  }\n\n  /**\n   * @ignore\n   * @param {string} value\n   * @return {void}\n   */\n  set defaultPath(value) {\n    this.mDefaultPath = value\n  }\n\n  /**\n   * Returns True if all assets were loaded.\n   *\n   * @return {boolean}\n   */\n  get isAllLoaded() {\n    return this.mIsAllLoaded\n  }\n\n  /**\n   * Returns number of errors occurred during loading.\n   * @returns {number}\n   */\n  get numErrors() {\n    return this.mTotalErrors\n  }\n\n  /**\n   * Returns current state.\n   *\n   * @returns {AssetManagerState}\n   */\n  get state() {\n    return this.mState\n  }\n\n  /**\n   * Always returns 'AssetManager', can be used to overhear AssetManager's messages.\n   *\n   * @override\n   * @readonly\n   * @return {string|null}\n   */\n  get path() {\n    return 'AssetManager'\n  }\n}\n\n/**\n * Default instance. Sprite and other classes uses this instance to find textures by name.\n * @static\n * @type {AssetManager}\n */\nAssetManager.default = new AssetManager()\n","/**\n * A blend mode enum.\n * @cat drivers\n * @static\n * @constant\n * @enum {string}\n */\nexport \nconst BlendMode = {\n  /** Inherits blend mode from parent display object */\n  AUTO: 'auto',\n  NORMAL: 'normal',\n  ADD: 'add',\n  MULTIPLY: 'multiply',\n  SCREEN: 'screen',\n  OVERLAY: 'overlay',\n  DARKEN: 'darken',\n  LIGHTEN: 'lighten',\n  COLOR_DODGE: 'colorDodge',\n  COLOR_BURN: 'colorBurn',\n  HARD_LIGHT: 'hardLight',\n  SOFT_LIGHT: 'softLight',\n  DIFFERENCE: 'difference',\n  EXCLUSION: 'exclusion',\n  HUE: 'hue',\n  SATURATE: 'saturate',\n  COLOR: 'color',\n  LUMINOSITY: 'luminosity',\n  MASK: 'mask',\n  MASK_INV: 'maskInv',\n}\n\n/**\n * @export\n * @ignore\n * @static\n * @constant\n * @dict\n */\nconst CanvasBlendMode = {\n  auto: 'auto',\n  normal: 'source-over',\n  add: 'lighter',\n  multiply: 'multiply',\n  screen: 'screen',\n  overlay: 'overlay',\n  darken: 'darken',\n  lighten: 'lighten',\n  colorDodge: 'color-dodge',\n  colorBurn: 'color-burn',\n  hardLight: 'hard-light',\n  softLight: 'soft-light',\n  difference: 'difference',\n  exclusion: 'exclusion',\n  due: 'hue',\n  saturate: 'saturate',\n  color: 'color',\n  luminosity: 'luminosity',\n  mask: 'source-in',\n  maskInv: 'source-out',\n}\n","/**\n * A render unit. Base class for all renderables.\n *\n * @cat drivers\n */\nexport \nclass Renderer {\n  /**\n   * Creates new instance of Renderer.\n   */\n  constructor() {\n    /** @type {DisplayObject|null} */\n    this.gameObject = null\n\n    /** @type {Renderer|null} */\n    this.parent = null\n\n    /** @ignore @type {boolean} */\n    this.skipChildren = false\n\n    /** @ignore @type {boolean} */\n    this.skipSelf = false\n\n    /** @ignore @type {boolean} */\n    this.endPassRequired = false\n\n    /** @ignore @type {number} */\n    this.endPassRequiredAt = -1\n\n    /** @ignore @type {number} */\n    this.alpha = 1\n\n    /** @ignore @type {BlendMode} */\n    this.blendMode = BlendMode.NORMAL\n\n    /** @ignore @type {number|null} */\n    this.color = null\n  }\n\n  /**\n   * Called when this renderer needs to be rendered.\n   *\n   * @param {VideoNullDriver} driver Active video driver.\n   * @param {RenderSession} session Active session.\n   * @returns {void}\n   */\n  preRender(driver, session) {\n    this.endPassRequired =\n      this.gameObject.mClipRect !== null &&\n      this.gameObject.mClipRect.isEmpty === false\n\n    this.skipChildren = !(\n      this.gameObject.mAlpha > 0 && this.gameObject.mVisible === true\n    )\n    this.skipSelf = this.skipChildren\n  }\n\n  /**\n   * Called after `preRender` but before `GameObject#onRender`. Used to compute world alpha, color and blend mode.\n   * @param {VideoNullDriver} driver\n   * @param {RenderSession} session\n   */\n  begin(driver, session) {\n    this.alpha = this.gameObject.mAlpha * this.parent.alpha\n    this.color =\n      this.gameObject.mColor === null\n        ? this.parent.color\n        : this.gameObject.mColor\n    this.blendMode =\n      this.gameObject.mBlendMode === BlendMode.AUTO\n        ? this.parent.blendMode\n        : this.gameObject.mBlendMode\n  }\n\n  /**\n   * Called if `skipSelf` equals to false. Used to upload everything onto gpu.\n   *\n   * @param {VideoNullDriver} driver\n   * @param {RenderSession} session\n   */\n  upload(driver, session) {\n    let gameObject = /** @type {DisplayObject} */ (this.gameObject)\n    let transform = gameObject.worldTransformation\n\n    // if (session.isBackBufferActive === false) {\n    //   if (session.customTransform === null) {\n    //     transform = transform.clone(); // TODO: too much allocations\n    //     transform.data[4] -= Black.stage.mX;\n    //     transform.data[5] -= Black.stage.mY;\n    //   } else {\n    //     transform = transform.clone(); // TODO: too much allocations\n    //     transform.prepend(session.customTransform);\n    //   }\n    // }\n\n    driver.setSnapToPixels(gameObject.snapToPixels)\n    driver.setGlobalAlpha(this.alpha)\n    driver.setGlobalBlendMode(this.blendMode)\n    driver.setTransform(transform)\n\n    if (this.endPassRequired === true)\n      driver.beginClip(\n        gameObject.mClipRect,\n        gameObject.mPivotX,\n        gameObject.mPivotY\n      )\n  }\n\n  /**\n   * Called if `skipSelf` equals to false.\n   *\n   * @param {VideoNullDriver} driver Active video driver.\n   * @param {RenderSession} session\n   * @returns {void}\n   */\n  render(driver, session) {}\n\n  /**\n   * Called after all children objects got rendered.\n   *\n   * @param {VideoNullDriver} driver\n   * @param {RenderSession} session\n   */\n  end(driver, session) {\n    driver.endClip()\n\n    this.endPassRequiredAt = -1\n    this.endPassRequired = false\n  }\n\n  /**\n   * Tints given texture with a given color.\n   *\n   * @param {Texture} texture\n   * @param {number|null} color\n   * @returns {Texture}\n   */\n  static getColoredTexture(texture, color) {\n    if (color === 0xffffff || color === null) return texture\n\n    let colorString = color.toString()\n    if (Renderer.__colorCache.has(texture.id, colorString))\n      return /** @type {Texture}*/ (Renderer.__colorCache.get(\n        texture.id,\n        colorString\n      ))\n\n    let region = texture.region\n    let w = region.width\n    let h = region.height\n\n    let rt = new RenderTargetCanvas(w, h)\n    let ctx = rt.context\n\n    ctx.fillStyle = ColorHelper.hexColorToString(color)\n    ctx.fillRect(0, 0, w, h)\n\n    ctx.globalCompositeOperation = 'multiply'\n    ctx.drawImage(\n      texture.native,\n      region.x,\n      region.y,\n      region.width,\n      region.height,\n      0,\n      0,\n      region.width,\n      region.height\n    )\n\n    ctx.globalCompositeOperation = 'destination-atop'\n    ctx.drawImage(\n      texture.native,\n      region.x,\n      region.y,\n      region.width,\n      region.height,\n      0,\n      0,\n      region.width,\n      region.height\n    )\n\n    let t = new Texture(\n      rt.native,\n      null,\n      texture.untrimmedRegion.clone(),\n      texture.scale\n    )\n    Renderer.__colorCache.set(texture.id, colorString, t)\n\n    return t\n  }\n}\n\n/**\n * @ignore\n * @private\n * @static\n */\nRenderer.__colorCache = new MapMap()\n\n/**\n * Used to optimize battery-life on static scenes.\n * @private\n * @type {boolean}\n * @nocollapse\n */\nRenderer.__dirty = true\n\n/**\n * Indicates whenever engine should render the stage if nothing were changed in this frame. Default is false.\n */\nRenderer.skipUnchangedFrames = false\n","/**\n * A RenderSession object holds state of current frame renderers.\n *\n * @cat drivers\n */\nexport \nclass RenderSession {\n  /**\n   * Creates new instance of RenderSession.\n   */\n  constructor() {\n    /** @type {Array<Renderer>} */\n    this.parentRenderers = []\n\n    /** @type {Array<Renderer>} */\n    this.endPassParentRenderers = []\n\n    /** @type {boolean} */\n    this.isBackBufferActive = true\n\n    /** @type {Matrix|null} */\n    this.customTransform = null\n\n    /** @type {boolean} */\n    this.isMasking = false\n  }\n\n  /**\n   * Resets state for future reuse.\n   */\n  reset() {\n    this.parentRenderers.splice(0, this.parentRenderers.length)\n    this.endPassParentRenderers.splice(0, this.endPassParentRenderers.length)\n    this.isBackBufferActive = true\n    this.customTransform = null\n  }\n}\n","/**\n * Responsible for rendering `TextField` objects by different drivers.\n *\n * @extends Renderer\n * @cat drivers\n */\nexport \nclass TextRenderer extends Renderer {\n  /**\n   * Creates new instance of TextRenderer.\n   */\n  constructor() {\n    super()\n\n    this.texture = null\n\n    /** @private @type {Matrix} @ignore */\n    this.mTransformCache = new Matrix()\n\n    /** @private @type {Matrix|null} @ignore */\n    this.mTransform = null\n\n    /** @private @type {boolean} @ignore */\n    this.mUseTransformCache = false\n\n    /** @private @type {HTMLCanvasElement} */\n    this.mCanvas = /** @type {HTMLCanvasElement} */ (document.createElement(\n      'canvas'\n    ))\n\n    /** @private @type {CanvasRenderingContext2D} */\n    this.mContext = /** @type {CanvasRenderingContext2D} */ (this.mCanvas.getContext(\n      '2d'\n    ))\n\n    /** */\n    this.mContext.lineJoin = 'round'\n\n    /** */\n    this.mContext.miterLimit = 2\n\n    /** @private @type {TextMetricsData|null} */\n    this.mMetrics = null\n  }\n\n  /** @inheritDoc */\n  preRender(driver, session) {\n    this.endPassRequired =\n      this.gameObject.mClipRect !== null &&\n      this.gameObject.mClipRect.isEmpty === false\n\n    this.skipChildren = !(\n      this.gameObject.mAlpha > 0 && this.gameObject.mVisible === true\n    )\n    this.skipSelf = this.skipChildren === true\n  }\n\n  /** @inheritDoc */\n  upload(driver, session) {\n    let gameObject = /** @type {TextField} */ (this.gameObject)\n\n    if (gameObject.mDirty & DirtyFlag.RENDER_CACHE) {\n      gameObject.onGetLocalBounds()\n      this.mMetrics = gameObject.mMetrics\n    }\n\n    if (\n      gameObject.mDirty & DirtyFlag.RENDER_CACHE ||\n      gameObject.mDirty & DirtyFlag.RENDER\n    )\n      this.updateTransform()\n\n    this.mTransform =\n      this.mUseTransformCache === true\n        ? this.mTransformCache\n        : this.gameObject.worldTransformation\n\n    driver.setSnapToPixels(gameObject.snapToPixels)\n    driver.setTransform(this.mTransform)\n    driver.setGlobalAlpha(this.alpha)\n    driver.setGlobalBlendMode(this.blendMode)\n\n    if (this.endPassRequired === true) {\n      driver.beginClip(\n        gameObject.mClipRect,\n        gameObject.mPivotX,\n        gameObject.mPivotY\n      )\n    }\n  }\n\n  /**\n   * @ignore\n   * @private\n   * @param {TextMetricsData} metrics\n   * @param {TextSegmentMetricsData} segment\n   * @param {CanvasRenderingContext2D} ctx\n   * @param {VideoNullDriver} driver\n   * @param {FontMetrics} fontMetrics\n   * @param {boolean} isStroke\n   */\n  renderSegment(metrics, segment, ctx, driver, fontMetrics, isStroke) {\n    let gameObject = /** @type {TextField} */ (this.gameObject)\n\n    let baseline = fontMetrics.baselineNormalized * segment.style.size\n\n    if (isStroke === true) {\n      ctx.lineWidth = segment.style.strokeThickness\n      ctx.strokeStyle = ColorHelper.hexColorToString(segment.style.strokeColor)\n    } else {\n      ctx.fillStyle = ColorHelper.hexColorToString(segment.style.color)\n    }\n\n    ctx.font = `${segment.style.weight} ${segment.style.style} ${\n      segment.style.size\n    }px ${segment.style.family}`\n\n    let lx =\n      segment.bounds.x -\n      Math.min(metrics.strokeBounds.x, metrics.shadowBounds.x)\n    let ly =\n      baseline +\n      segment.bounds.y -\n      Math.min(metrics.strokeBounds.y, metrics.shadowBounds.y)\n\n    lx += gameObject.padding.x\n    ly += gameObject.padding.y\n\n    if (gameObject.align === 'center')\n      lx +=\n        metrics.bounds.width * 0.5 - metrics.lineWidth[segment.lineIndex] * 0.5\n    else if (gameObject.align === 'right')\n      lx += metrics.bounds.width - metrics.lineWidth[segment.lineIndex]\n\n    if (isStroke === true) ctx.strokeText(segment.text, lx, ly)\n    else ctx.fillText(segment.text, lx, ly)\n  }\n\n  /** @inheritDoc */\n  render(driver, session) {\n    let gameObject = /** @type {TextField} */ (this.gameObject)\n\n    if (\n      gameObject.mHighQuality === true &&\n      gameObject.mDirty & DirtyFlag.RENDER\n    ) {\n      gameObject.mDirty ^= DirtyFlag.RENDER\n      gameObject.mDirty |= DirtyFlag.RENDER_CACHE\n    }\n\n    if (gameObject.mDirty & DirtyFlag.RENDER_CACHE) {\n      gameObject.mDirty ^= DirtyFlag.RENDER_CACHE\n\n      const cvs = this.mCanvas\n      const ctx = this.mContext\n      let scale = 1\n      ctx.textBaseline = 'alphabetic'\n\n      if (gameObject.mHighQuality === true) {\n        let data = this.mTransform.data\n        let gameObjectScaleX = Math.sqrt(data[0] * data[0] + data[2] * data[2])\n        let gameObjectScaleY = Math.sqrt(data[1] * data[1] + data[3] * data[3])\n        scale =\n          Math.max(gameObjectScaleX, gameObjectScaleY) *\n          driver.renderScaleFactor\n      }\n\n      let canvasBounds = this.mMetrics.strokeBounds.clone()\n      canvasBounds.scale(scale, scale)\n      canvasBounds.union(this.mMetrics.shadowBounds)\n      canvasBounds.inflate(gameObject.padding.right, gameObject.padding.bottom)\n\n      cvs.width = canvasBounds.width\n      cvs.height = canvasBounds.height\n\n      let fontMetrics = FontMetrics.get(gameObject.mDefaultStyle.family)\n      let segments = this.mMetrics.segments\n\n      ctx.save()\n      ctx.scale(scale, scale)\n\n      for (let i = 0; i < segments.length; i++) {\n        if (segments[i].style.dropShadow) {\n          ctx.save()\n          ctx.shadowColor = ColorHelper.intToRGBA(\n            segments[i].style.shadowColor,\n            segments[i].style.shadowAlpha\n          )\n          ctx.shadowBlur = segments[i].style.shadowBlur\n          ctx.shadowOffsetX = segments[i].style.shadowDistanceX\n          ctx.shadowOffsetY = segments[i].style.shadowDistanceY\n          this.renderSegment(\n            this.mMetrics,\n            segments[i],\n            ctx,\n            driver,\n            fontMetrics,\n            false\n          )\n          ctx.restore()\n        }\n      }\n\n      for (let i = 0; i < segments.length; i++) {\n        let segment = segments[i]\n        if (segment.style.strokeThickness > 0) {\n          ctx.lineJoin = 'round'\n          ctx.miterLimit = 2\n          this.renderSegment(\n            this.mMetrics,\n            segment,\n            ctx,\n            driver,\n            fontMetrics,\n            true\n          )\n        }\n      }\n\n      for (let i = 0; i < segments.length; i++)\n        this.renderSegment(\n          this.mMetrics,\n          segments[i],\n          ctx,\n          driver,\n          fontMetrics,\n          false\n        )\n\n      ctx.restore()\n\n      // whats the max texture size?\n      if (this.texture === null)\n        this.texture = new Texture(cvs, null, null, 1 / scale)\n      else this.texture.set(cvs, null, null, 1 / scale)\n    }\n  }\n\n  /** @ignore */\n  updateTransform() {\n    let gameObject = /** @type {TextField} */ (this.gameObject)\n    let transform = gameObject.worldTransformation\n\n    let fieldXOffset = 0\n    let fieldYOffset = 0\n\n    let filterOffsetX = Math.min(\n      this.mMetrics.strokeBounds.x,\n      this.mMetrics.shadowBounds.x\n    )\n    let filterOffsetY = Math.min(\n      this.mMetrics.strokeBounds.y,\n      this.mMetrics.shadowBounds.y\n    )\n\n    const hasFilter = filterOffsetX !== 0 || filterOffsetY !== 0\n\n    if (gameObject.mAutoSize === false) {\n      if (gameObject.align === 'center')\n        fieldXOffset =\n          (gameObject.mFieldWidth - this.mMetrics.bounds.width) * 0.5\n      else if (gameObject.align === 'right')\n        fieldXOffset = gameObject.mFieldWidth - this.mMetrics.bounds.width\n\n      if (gameObject.mVerticalAlign === 'middle')\n        fieldYOffset =\n          (gameObject.mFieldHeight - this.mMetrics.bounds.height) * 0.5\n      else if (gameObject.mVerticalAlign === 'bottom')\n        fieldYOffset = gameObject.mFieldHeight - this.mMetrics.bounds.height\n    }\n\n    if (hasFilter === true || gameObject.mAutoSize === false) {\n      this.mUseTransformCache = true\n      transform.copyTo(this.mTransformCache)\n      this.mTransformCache.translate(\n        filterOffsetX + fieldXOffset - gameObject.padding.x,\n        filterOffsetY + fieldYOffset - gameObject.padding.y\n      )\n    } else if (gameObject.padding.isEmpty === false) {\n      this.mUseTransformCache = true\n      transform.copyTo(this.mTransformCache)\n      this.mTransformCache.translate(\n        -gameObject.padding.x,\n        -gameObject.padding.y\n      )\n    } else {\n      this.mUseTransformCache = false\n    }\n  }\n}\n","/**\n * Responsible for rendering `BitmapTextField` objects by different drivers.\n *\n * @extends Renderer\n * @cat drivers\n */\nexport \nclass BitmapTextRenderer extends Renderer {\n  /**\n   * Creates new instance of BitmapTextRenderer.\n   */\n  constructor() {\n    super()\n\n    /** @ignore @private @type {HTMLCanvasElement} */\n    this.mCanvas = /** @type {HTMLCanvasElement} */ (document.createElement(\n      'canvas'\n    ))\n\n    /** @ignore @private @type {CanvasRenderingContext2D} */\n    this.mContext = /** @type {CanvasRenderingContext2D} */ (this.mCanvas.getContext(\n      '2d'\n    ))\n\n    /** @ignore @type {Texture|null} */\n    this.texture = null\n  }\n\n  /**\n   * @inheritDoc\n   */\n  render(driver, session) {\n    let gameObject = /** @type {BitmapTextField} */ (this.gameObject)\n\n    if (gameObject.mText === null) return\n\n    if (gameObject.mDirty & DirtyFlag.RENDER_CACHE) {\n      const cvs = this.mCanvas\n      const ctx = this.mContext\n\n      let data = gameObject.mData\n      let text = gameObject.mText\n      let canvasBounds = gameObject.onGetLocalBounds()\n\n      // remove dirty flag only after getting bounds\n      gameObject.mDirty ^= DirtyFlag.RENDER_CACHE\n\n      let prevCharCode = -1\n      let cx = 0\n      let cy = 0\n\n      cvs.width = canvasBounds.width\n      cvs.height = canvasBounds.height\n\n      for (let i = 0; i < text.length; i++) {\n        let charCode = text.charCodeAt(i)\n\n        if (/(?:\\r\\n|\\r|\\n)/.test(text.charAt(i))) {\n          cx = 0\n          cy += data.lineHeight * gameObject.mLineHeight\n          prevCharCode = -1\n          continue\n        }\n\n        let charData = data.chars[charCode]\n\n        if (charData == null) continue\n\n        let texture = charData.texture\n\n        if (prevCharCode >= 0 && charData.kerning[prevCharCode])\n          cx += charData.kerning[prevCharCode]\n\n        const w = texture.width\n        const h = texture.height\n        const ox = texture.untrimmedRegion.x + charData.xOffset + cx\n        const oy = texture.untrimmedRegion.y + charData.yOffset + cy\n\n        ctx.drawImage(\n          texture.native,\n          texture.region.x,\n          texture.region.y,\n          w,\n          h,\n          ~~ox,\n          ~~oy,\n          w,\n          h\n        )\n\n        cx += charData.xAdvance\n        prevCharCode = charCode\n      }\n\n      if (this.texture === null) this.texture = new Texture(cvs)\n      else this.texture.set(cvs)\n    }\n  }\n}\n","/**\n * Base class for representing rendering surface.\n *\n * @cat drivers\n */\nexport \nclass RenderTarget {\n  /**\n   * Creates new instance fo RenderTarget.\n   *\n   * @param {number} width  The width of the surface.\n   * @param {number} height The height of the surface.\n   */\n  constructor(width, height) {\n    /** @private @type {number} */\n    this.mWidth = Math.ceil(width)\n\n    /** @private @type {number} */\n    this.mHeight = Math.ceil(height)\n  }\n\n  /**\n   * Resizes surface to the given size.\n   *\n   * @param {number} width The width of the surface.\n   * @param {number} height The height of the surface.\n   */\n  resize(width, height) {\n    this.mWidth = width\n    this.mHeight = height\n  }\n\n  /**\n   * Clears whole surface.\n   */\n  clear() {}\n\n  /**\n   * The width of the surface.\n   *\n   * @returns {number}\n   */\n  get width() {\n    return this.mWidth\n  }\n\n  /**\n   * @ignore\n   * @param {number} value\n   * @returns {void}\n   */\n  set width(value) {\n    this.mWidth = value\n  }\n\n  /**\n   * The height of the surface.\n   *\n   * @returns {number}\n   */\n  get height() {\n    return this.mHeight\n  }\n\n  /**\n   * @ignore\n   * @param {number} value\n   * @returns {void}\n   */\n  set height(value) {\n    this.mHeight = value\n  }\n}\n","/**\n * Responsible for rendering `Graphics` objects by different drivers.\n *\n * @extends Renderer\n * @cat drivers\n */\nexport \nclass GraphicsRenderer extends Renderer {\n  constructor() {\n    super()\n  }\n}\n","/**\n * Renders `DisplayObject` objects on canvas.\n *\n * @extends Renderer\n * @cat drivers.canvas\n */\n\nexport \nclass DisplayObjectRendererCanvas extends Renderer {\n  constructor() {\n    super()\n\n    /** @private @type {boolean} */\n    this.mCacheAsBitmapDirty = true\n\n    /** @private @type {Matrix|null} */\n    this.mCacheAsBitmapMatrixCache = null\n\n    /** @private @type {CanvasRenderTexture|null} */\n    this.mCacheTexture = null\n\n    /** @private @type {Rectangle|null} */\n    this.mCacheBounds = null\n\n    /** @private @type {boolean} */\n    this.mIsClipped = false\n\n    this.mIsCached = false\n\n    /** @private @type {Matrix|null} */\n    this.mBakeInvertedMatrix = null\n  }\n\n  /** @inheritDoc */\n  preRender(driver, session) {\n    let gameObject = /** @type {DisplayObject} */ (this.gameObject)\n\n    this.mIsClipped = gameObject.mClipRect !== null\n    this.endPassRequired = this.mIsClipped\n\n    if (gameObject.mCacheAsBitmap === true) {\n      if (gameObject.mCacheAsBitmapDynamic === false) {\n        if (this.mIsCached === false) {\n          this.mIsCached = true\n          gameObject.setTransformDirty()\n          this.__refreshBitmapCache()\n          this.mCacheAsBitmapDirty = false\n          this.endPassRequired = false\n        } else {\n          gameObject.mDirty |= DirtyFlag.RENDER\n        }\n      } else {\n        let isStatic = gameObject.checkStatic(true)\n\n        if (isStatic === true && this.mCacheAsBitmapDirty === true) {\n          gameObject.setTransformDirty()\n          this.__refreshBitmapCache()\n          this.mCacheAsBitmapDirty = false\n          this.endPassRequired = false\n        } else if (isStatic === false) {\n          this.mCacheAsBitmapDirty = true\n          gameObject.mDirty |= DirtyFlag.RENDER\n        }\n      }\n    }\n\n    this.skipChildren =\n      (gameObject.mCacheAsBitmap === true &&\n        this.mCacheAsBitmapDirty === false) ||\n      (this.mIsClipped && gameObject.mClipRect.isEmpty)\n    this.skipSelf = false\n\n    if (this.skipChildren === true) {\n      this.endPassRequired = false\n      this.skipSelf = true\n    }\n  }\n\n  /** @inheritDoc */\n  begin(driver, session) {\n    let gameObject = /** @type {DisplayObject} */ (this.gameObject)\n    if (this.skipChildren === true && session.isBackBufferActive === true) {\n      this.alpha = 1\n      this.blendMode = BlendMode.NORMAL\n      this.color = null\n      this.skipSelf =\n        gameObject.mAlpha <= 0 ||\n        gameObject.mVisible === false ||\n        (this.mIsClipped && gameObject.mClipRect.isEmpty)\n    } else {\n      this.alpha = gameObject.mAlpha * this.parent.alpha\n      this.color =\n        gameObject.mColor === null ? this.parent.color : gameObject.mColor\n      this.blendMode =\n        gameObject.mBlendMode === BlendMode.AUTO\n          ? this.parent.blendMode\n          : gameObject.mBlendMode\n\n      this.skipChildren =\n        gameObject.mAlpha <= 0 || gameObject.mVisible === false\n      this.skipSelf =\n        this.skipChildren === true ||\n        this.mIsClipped === false ||\n        (this.mIsClipped && gameObject.mClipRect.isEmpty)\n    }\n  }\n\n  /** @inheritDoc */\n  upload(driver, session) {\n    let gameObject = /** @type {DisplayObject} */ (this.gameObject)\n    let transform = gameObject.worldTransformation\n\n    if (this.skipChildren === true && this.mCacheAsBitmapMatrixCache) {\n      transform = this.mCacheAsBitmapMatrixCache\n\n      if (gameObject.mCacheAsBitmapDynamic === false) {\n        transform = new Matrix()\n          .append(this.gameObject.worldTransformation)\n          .append(this.mBakeInvertedMatrix)\n          .append(this.mCacheAsBitmapMatrixCache)\n      }\n    }\n\n    if (this.skipChildren === true || this.endPassRequired === true) {\n      driver.setSnapToPixels(gameObject.snapToPixels)\n      driver.setTransform(transform)\n      driver.setGlobalAlpha(this.alpha)\n      driver.setGlobalBlendMode(this.blendMode)\n    }\n\n    if (this.endPassRequired === true)\n      driver.beginClip(\n        gameObject.mClipRect,\n        gameObject.mPivotX,\n        gameObject.mPivotY\n      )\n  }\n\n  /** @inheritDoc */\n  render(driver, session) {\n    if (this.skipChildren === true && session.isBackBufferActive === true)\n      driver.drawTexture(this.mCacheTexture)\n  }\n\n  __refreshBitmapCache() {\n    const bounds = this.gameObject.getBounds(Black.stage, true)\n    const sf = Black.stage.scaleFactor\n    const fs = Black.driver.renderScaleFactor * sf\n\n    /** @type {Matrix} */\n    let m = Matrix.pool.get()\n    m.set(\n      1,\n      0,\n      0,\n      1,\n      ~~(-bounds.x * sf - Black.stage.mX),\n      ~~(-bounds.y * sf - Black.stage.mY)\n    )\n\n    if (this.mIsClipped === true && this.skipChildren === true) {\n      m.data[4] += this.gameObject.mPivotX * sf\n      m.data[5] += this.gameObject.mPivotY * sf\n    }\n\n    if (this.mCacheBounds === null) this.mCacheBounds = new Rectangle()\n\n    bounds.copyTo(this.mCacheBounds)\n    bounds.width *= fs\n    bounds.height *= fs\n\n    if (this.mCacheTexture === null)\n      this.mCacheTexture = new CanvasRenderTexture(\n        bounds.width,\n        bounds.height,\n        1\n      )\n    else this.mCacheTexture.resize(bounds.width, bounds.height, 1)\n\n    Black.driver.render(this.gameObject, this.mCacheTexture, m)\n    Matrix.pool.release(m)\n\n    if (this.mCacheAsBitmapMatrixCache === null)\n      this.mCacheAsBitmapMatrixCache = new Matrix()\n\n    this.mCacheAsBitmapMatrixCache.copyFrom(m)\n    this.mCacheAsBitmapMatrixCache.scale(\n      1 / Black.driver.renderScaleFactor,\n      1 / Black.driver.renderScaleFactor\n    )\n    this.mCacheAsBitmapMatrixCache.data[4] = -this.mCacheAsBitmapMatrixCache\n      .data[4]\n    this.mCacheAsBitmapMatrixCache.data[5] = -this.mCacheAsBitmapMatrixCache\n      .data[5]\n\n    this.mBakeInvertedMatrix = this.gameObject.worldTransformationInverted.clone()\n    //this.mCacheTexture.__dumpToDocument();\n  }\n}\n","/**\n * Renders `TextField` objects on canvas.\n *\n * @extends TextRenderer\n * @cat drivers.canvas\n */\nexport \nclass TextRendererCanvas extends TextRenderer {\n  /** @inheritDoc */\n  render(driver, session) {\n    super.render(driver, session)\n\n    driver.drawTexture(\n      Renderer.getColoredTexture(this.texture, this.gameObject.mColor)\n    )\n  }\n}\n","/**\n * Renders `BitmapTextField` objects on canvas.\n *\n * @extends BitmapTextRenderer\n * @cat drivers.canvas\n */\nexport \nclass BitmapTextRendererCanvas extends BitmapTextRenderer {\n  /** @inheritDoc */\n  render(driver, session) {\n    super.render(driver, session)\n\n    driver.drawTexture(\n      Renderer.getColoredTexture(this.texture, this.gameObject.mColor)\n    )\n  }\n}\n","/**\n * Renders `Particle` objects on canvas.\n *\n * @extends Renderer\n * @cat drivers.canvas\n */\nexport \nclass EmitterRendererCanvas extends Renderer {\n  /**\n   * Creates new instance of EmitterRendererCanvas.\n   */\n  constructor() {\n    super()\n\n    /**\n     * @ignore\n     * @type {boolean}\n     */\n    this.isLocal = false\n\n    /** @private @type {Matrix} */\n    this.__tmpLocal = new Matrix()\n\n    /** @private @type {Matrix} */\n    this.__tmpWorld = new Matrix()\n  }\n\n  /** @inheritDoc */\n  preRender(driver, session) {\n    let gameObject = /** @type {Emitter} */ (this.gameObject)\n\n    this.skipChildren = !(\n      gameObject.mAlpha > 0 &&\n      gameObject.mTextures.length > 0 &&\n      gameObject.mVisible === true\n    )\n    this.skipSelf = !(\n      gameObject.mTextures.length > 0 && gameObject.mParticles.length > 0\n    )\n  }\n\n  /** @inheritDoc */\n  render(driver, session) {\n    let gameObject = /** @type {Emitter} */ (this.gameObject)\n\n    driver.setSnapToPixels(gameObject.snapToPixels)\n\n    let plength = gameObject.mParticles.length\n    let localTransform = this.__tmpLocal\n    let worldTransform = this.__tmpWorld\n    localTransform.identity()\n\n    if (gameObject.sortOrder === EmitterSortOrder.FRONT_TO_BACK) {\n      for (let i = 0; i < plength; i++)\n        this.__renderParticle(\n          gameObject.mParticles[i],\n          localTransform,\n          worldTransform,\n          driver\n        )\n    } else {\n      for (let i = plength - 1; i > 0; i--)\n        this.__renderParticle(\n          gameObject.mParticles[i],\n          localTransform,\n          worldTransform,\n          driver\n        )\n    }\n  }\n\n  /**\n   * @ignore\n   * @private\n   * @param {Particle} particle\n   * @param {Matrix} localTransform\n   * @param {Matrix} worldTransform\n   * @param {VideoNullDriver} driver\n   */\n  __renderParticle(particle, localTransform, worldTransform, driver) {\n    let gameObject = /** @type {Emitter} */ (this.gameObject)\n\n    let texture = gameObject.textures[particle.textureIndex]\n    let tw = texture.displayWidth * particle.anchorX\n    let th = texture.displayHeight * particle.anchorY\n\n    if (particle.r === 0) {\n      let tx = particle.x - tw * particle.scaleX\n      let ty = particle.y - th * particle.scaleY\n      localTransform.set(particle.scaleX, 0, 0, particle.scaleY, tx, ty)\n    } else {\n      let cos = Math.cos(particle.r)\n      let sin = Math.sin(particle.r)\n      let a = particle.scaleX * cos\n      let b = particle.scaleX * sin\n      let c = particle.scaleY * -sin\n      let d = particle.scaleY * cos\n\n      let tx = particle.x - tw * a - th * c\n      let ty = particle.y - tw * b - th * d\n      localTransform.set(a, b, c, d, tx, ty)\n    }\n\n    if (gameObject.mIsLocal === true) {\n      worldTransform.identity()\n      worldTransform.copyFrom(localTransform)\n      worldTransform.prepend(gameObject.worldTransformation)\n    } else {\n      worldTransform.copyFrom(gameObject.mSpace.worldTransformation)\n      worldTransform.append(localTransform)\n    }\n\n    driver.setGlobalAlpha(gameObject.mAlpha * particle.alpha)\n    driver.setTransform(worldTransform)\n    driver.drawTexture(\n      Renderer.getColoredTexture(\n        texture,\n        particle.color === null ? gameObject.mColor : particle.color\n      )\n    )\n  }\n}\n","/**\n * Renders `Sprite` objects on canvas.\n *\n * @extends Renderer\n * @cat drivers.canvas\n */\n\nexport \nclass SpriteRendererCanvas extends Renderer {\n  constructor() {\n    super()\n\n    /** @type {CanvasPattern|null} */\n    this.pattern = null\n\n    /** @type {Texture|null} */\n    this.patternTexture = null\n\n    /** @type {CanvasRenderTexture|null} */\n    this.sliceTextureCache = null\n\n    /** @type {number|null} */\n    this.sizeWidthCache = null\n\n    /** @type {number|null} */\n    this.sizeHeightCache = null\n\n    /** @type {Texture} */\n    this.textureCache = null\n  }\n\n  /** @inheritDoc */\n  preRender(driver, session) {\n    let gameObject = /** @type {Sprite} */ (this.gameObject)\n\n    const skip = gameObject.mClipRect !== null && gameObject.mClipRect.isEmpty\n\n    this.endPassRequired =\n      gameObject.mClipRect !== null && !gameObject.mClipRect.isEmpty\n    this.skipChildren =\n      skip || gameObject.mAlpha <= 0 || gameObject.mVisible === false\n    this.skipSelf =\n      skip ||\n      gameObject.mTexture === null ||\n      gameObject.mAlpha <= 0 ||\n      gameObject.mVisible === false\n  }\n\n  renderSlice9Grid(driver, texture, grid) {\n    const dpr = driver.mDevicePixelRatio\n    let desiredWidth = texture.width * this.gameObject.mScaleX\n    let desiredHeight = texture.height * this.gameObject.mScaleY\n\n    if (\n      this.textureCache === texture &&\n      this.sizeWidthCache === desiredWidth &&\n      this.sizeHeightCache === desiredHeight\n    )\n      return this.sliceTextureCache\n\n    this.textureCache = texture\n    this.sizeWidthCache = desiredWidth\n    this.sizeHeightCache = desiredHeight\n\n    const sourceX = texture.region.x\n    const sourceY = texture.region.y\n    const sourceWidth = texture.region.width\n    const sourceHeight = texture.region.height\n\n    const destX = texture.untrimmedRegion.x * dpr\n    const destY = texture.untrimmedRegion.y * dpr\n\n    if (this.sliceTextureCache === null)\n      this.sliceTextureCache = new CanvasRenderTexture(\n        desiredWidth,\n        desiredHeight,\n        1 / texture.scale\n      )\n    else\n      this.sliceTextureCache.resize(\n        desiredWidth,\n        desiredHeight,\n        1 / texture.scale\n      )\n\n    const ctx = this.sliceTextureCache.renderTarget.context\n    const scale = Math.min(this.gameObject.scaleX, this.gameObject.scaleY)\n\n    if (scale <= 1) {\n      ctx.setTransform(scale, 0, 0, scale, 0, 0)\n      desiredWidth /= scale\n      desiredHeight /= scale\n    }\n\n    const gridLeft = grid.x / texture.scale\n    const gridTop = grid.y / texture.scale\n    const gridRight = sourceWidth - grid.right / texture.scale\n    const gridBottom = sourceHeight - grid.bottom / texture.scale\n\n    // non-scalable\n    const srcOffsetX = sourceX + sourceWidth - gridRight\n    const dstOffsetX = destX + desiredWidth / texture.scale - gridRight\n\n    const srcOffsetY = sourceY + sourceHeight - gridBottom\n    const dstOffsetY = destY + desiredHeight / texture.scale - gridBottom\n\n    // top left\n    ctx.drawImage(\n      texture.native,\n      sourceX,\n      sourceY,\n      gridLeft,\n      gridTop,\n      destX,\n      destY,\n      gridLeft,\n      gridTop\n    )\n\n    // top right\n    ctx.drawImage(\n      texture.native,\n      srcOffsetX,\n      sourceY,\n      gridRight,\n      gridTop,\n      dstOffsetX,\n      destY,\n      gridRight,\n      gridTop\n    )\n\n    // bottom right\n    ctx.drawImage(\n      texture.native,\n      srcOffsetX,\n      srcOffsetY,\n      gridRight,\n      gridBottom,\n      dstOffsetX,\n      dstOffsetY,\n      gridRight,\n      gridBottom\n    )\n\n    // bottom left\n    ctx.drawImage(\n      texture.native,\n      sourceX,\n      srcOffsetY,\n      gridLeft,\n      gridBottom,\n      destX,\n      dstOffsetY,\n      gridLeft,\n      gridBottom\n    )\n\n    // scalable\n    const srcLeftOffset = sourceX + gridLeft\n    const dstLeftOffset = destX + gridLeft\n\n    const srcTopOffset = sourceY + gridTop\n    const dstTopOffset = destY + gridTop\n\n    const srcRightOffset = sourceX + sourceWidth - gridRight\n    const dstRightOffset = destX + desiredWidth / texture.scale - gridRight\n\n    const srcBottomOffset = sourceY + sourceHeight - gridBottom\n    const dstBottomOffset = destY + desiredHeight / texture.scale - gridBottom\n\n    const srcCenterWidth = sourceWidth - gridLeft - gridRight\n    const dstCenterWidth = desiredWidth / texture.scale - gridLeft - gridRight\n\n    const srcCenterHeight = sourceHeight - gridTop - gridBottom\n    const dstCenterHeight = desiredHeight / texture.scale - gridTop - gridBottom\n\n    // top\n    ctx.drawImage(\n      texture.native,\n      srcLeftOffset,\n      sourceY,\n      srcCenterWidth,\n      gridTop,\n      dstLeftOffset,\n      destY,\n      dstCenterWidth,\n      gridTop\n    )\n\n    // right\n    ctx.drawImage(\n      texture.native,\n      srcRightOffset,\n      srcTopOffset,\n      gridRight,\n      srcCenterHeight,\n      dstRightOffset,\n      dstTopOffset,\n      gridRight,\n      dstCenterHeight\n    )\n\n    // bottom\n    ctx.drawImage(\n      texture.native,\n      srcLeftOffset,\n      srcBottomOffset,\n      srcCenterWidth,\n      gridBottom,\n      dstLeftOffset,\n      dstBottomOffset,\n      dstCenterWidth,\n      gridBottom\n    )\n\n    // left\n    ctx.drawImage(\n      texture.native,\n      sourceX,\n      srcTopOffset,\n      gridLeft,\n      srcCenterHeight,\n      destX,\n      dstTopOffset,\n      gridLeft,\n      dstCenterHeight\n    )\n\n    //center\n    ctx.drawImage(\n      texture.native,\n      srcLeftOffset,\n      srcTopOffset,\n      srcCenterWidth,\n      srcCenterHeight,\n      dstLeftOffset,\n      dstTopOffset,\n      dstCenterWidth,\n      dstCenterHeight\n    )\n\n    return this.sliceTextureCache\n  }\n\n  /** @inheritDoc */\n  render(driver, session) {\n    let ctx = /** @type {CanvasDriver}*/ (driver).mCtx\n    let gameObject = /** @type {Sprite} */ (this.gameObject)\n\n    let texture = Renderer.getColoredTexture(gameObject.mTexture, this.color)\n\n    if (gameObject.mSlice9grid !== null) {\n      const data = this.gameObject.worldTransformation.data\n      const m = Matrix.pool\n        .get()\n        .set(\n          data[0] / this.gameObject.scaleX,\n          data[1] / this.gameObject.scaleX,\n          data[2] / this.gameObject.scaleY,\n          data[3] / this.gameObject.scaleY,\n          data[4],\n          data[5]\n        )\n      driver.setTransform(m)\n      Matrix.pool.release(m)\n\n      texture = this.renderSlice9Grid(driver, texture, gameObject.mSlice9grid)\n    }\n\n    if (gameObject.mTiling === null) {\n      driver.drawTexture(texture)\n    } else {\n      // we got some tiling\n      if (this.pattern === null || this.patternTexture !== texture) {\n        const renderCanvas = new RenderTargetCanvas(\n          texture.width,\n          texture.height\n        )\n        const r = texture.region\n        const u = texture.untrimmedRegion\n        renderCanvas.context.drawImage(\n          texture.native,\n          r.x,\n          r.y,\n          r.width,\n          r.height,\n          u.x,\n          u.y,\n          r.width,\n          r.height\n        )\n\n        this.pattern = ctx.createPattern(renderCanvas.native, 'repeat')\n        this.patternTexture = texture\n      }\n\n      ctx.fillStyle = /** @type {CanvasPattern} */ (this.pattern)\n\n      let dpr = driver.renderScaleFactor\n\n      let m = gameObject.worldTransformation.clone()\n      m.scale(gameObject.tiling.scaleX * dpr, gameObject.tiling.scaleY * dpr)\n      m.translate(gameObject.tiling.wrapX / dpr, gameObject.tiling.wrapY / dpr)\n\n      driver.setTransform(m)\n\n      // draw pattern\n      ctx.fillRect(\n        -gameObject.tiling.wrapX,\n        -gameObject.tiling.wrapY,\n        gameObject.tiling.width / gameObject.tiling.scaleX,\n        gameObject.tiling.height / gameObject.tiling.scaleY\n      )\n      ctx.fillStyle = 'black'\n    }\n  }\n}\n","/**\n * Canvas rendering surface.\n *\n * @extends RenderTarget\n * @cat drivers.canvas\n */\nexport \nclass RenderTargetCanvas extends RenderTarget {\n  /**\n   * Creates new instance of RenderTargetCanvas.\n   *\n   * @param {number} width  The width of the surface.\n   * @param {number} height The height of the surface.\n   */\n  constructor(width, height) {\n    super(width, height)\n\n    /** @ignore @private @type {HTMLCanvasElement} */\n    this.mCanvas = /** @type {HTMLCanvasElement} */ (document.createElement(\n      'canvas'\n    ))\n\n    /** @ignore @private @type {CanvasRenderingContext2D} */\n    this.mCtx = /** @type {CanvasRenderingContext2D} */ (this.mCanvas.getContext(\n      '2d'\n    ))\n\n    this.resize(width, height)\n  }\n\n  /**\n   * @inheritDoc\n   */\n  resize(width, height) {\n    this.mCanvas.width = Math.ceil(width)\n    this.mCanvas.height = Math.ceil(height)\n  }\n\n  /**\n   * @inheritDoc\n   */\n  clear() {\n    this.mCtx.setTransform(1, 0, 0, 1, 0, 0)\n    this.mCtx.clearRect(0, 0, this.mCanvas.width, this.mCanvas.height)\n  }\n\n  /**\n   * @inheritDoc\n   */\n  get width() {\n    return this.mCanvas.width\n  }\n\n  /**\n   * @inheritDoc\n   */\n  set width(val) {\n    this.mCanvas.width = val\n  }\n\n  /**\n   * @inheritDoc\n   */\n  get height() {\n    return this.mCanvas.height\n  }\n\n  /**\n   * @inheritDoc\n   */\n  set height(val) {\n    this.mCanvas.height = val\n  }\n\n  /**\n   * HTML canvas element.\n   *\n   * @returns {HTMLCanvasElement}\n   */\n  get native() {\n    return this.mCanvas\n  }\n\n  /**\n   * Canvas rendering context.\n   *\n   * @returns {CanvasRenderingContext2D}\n   */\n  get context() {\n    return this.mCtx\n  }\n}\n","/**\n * Renders `Graphics` objects on canvas.\n *\n * @extends GraphicsRenderer\n * @cat drivers.canvas\n */\n\nexport \nclass GraphicsRendererCanvas extends GraphicsRenderer {\n  /**\n   * Creates new instance of GraphicsRendererCanvas.\n   */\n  constructor() {\n    super()\n  }\n\n  /** @inheritDoc */\n  render(driver, session) {\n    let gameObject = /** @type {Graphics} */ (this.gameObject)\n    this.__drawCommandBuffer(driver)\n\n    if (gameObject.mColor !== null && gameObject.mColor !== 0xffffff) {\n      driver.context.globalCompositeOperation = 'multiply'\n      this.__drawCommandBuffer(driver, gameObject.mColor)\n    }\n  }\n\n  /**\n   * Prepare context to draw.\n   *\n   * @private\n   * @param {VideoNullDriver} driver Driver to draw.\n   * @param {number|null=} [color=null] Tint.\n   *\n   * @return {void}\n   */\n  __drawCommandBuffer(driver, color = null) {\n    const gameObject = /** @type {Graphics} */ (this.gameObject)\n    const ctx = driver.context\n\n    ctx.save()\n    ctx.beginPath()\n\n    const transform = Matrix.pool.get().copyFrom(gameObject.worldTransformation)\n    transform.translate(-gameObject.mDataOffsetX, -gameObject.mDataOffsetY)\n\n    this.__renderNode(driver, color, gameObject.mGraphicsData, transform)\n\n    Matrix.pool.release(transform)\n    ctx.restore()\n  }\n\n  /**\n   * Recursively draws each node of GraphicsData.\n   *\n   * @private\n   * @param {VideoNullDriver} driver Driver to draw.\n   * @param {number|null} color Tint.\n   * @param {GraphicsData} node Commands provider.\n   * @param {Matrix} transform Graphics Data global transformation.\n   *\n   * @return {void}\n   */\n  __renderNode(driver, color, node, transform) {\n    const commands = node.mCommandQueue\n    const ctx = driver.context\n    const len = commands.length\n    const r = driver.renderScaleFactor\n    const px = node.mPivotX\n    const py = node.mPivotY\n\n    transform = transform.clone().append(node.mTransform)\n    driver.setTransform(transform)\n\n    for (let i = 0; i < len; i++) {\n      const cmd = commands[i]\n\n      switch (cmd.type) {\n        case GraphicsCommandType.LINE_STYLE: {\n          ctx.lineWidth = cmd.getNumber(0) * r\n          ctx.strokeStyle = ColorHelper.intToRGBA(\n            color === null ? cmd.getNumber(1) : /** @type {number} */ (color),\n            cmd.getNumber(2)\n          )\n          ctx.lineCap = cmd.getString(3)\n          ctx.lineJoin = cmd.getString(4)\n          ctx.miterLimit = cmd.getNumber(5)\n          break\n        }\n\n        case GraphicsCommandType.FILL_STYLE: {\n          ctx.fillStyle = ColorHelper.intToRGBA(\n            color === null ? cmd.getNumber(0) : /** @type {number} */ (color),\n            cmd.getNumber(1)\n          )\n          break\n        }\n\n        case GraphicsCommandType.FILL_GRD: {\n          const gradientInfo = /** @type {GraphicsLinearGradient} */ (cmd.getObject(\n            0\n          ))\n          let grd = gradientInfo.native\n\n          if (!grd) {\n            const dpr = Black.driver.renderScaleFactor\n            const entries = []\n\n            grd = gradientInfo.native = ctx.createLinearGradient(\n              gradientInfo.x0 * dpr,\n              gradientInfo.y0 * dpr,\n              gradientInfo.x1 * dpr,\n              gradientInfo.y1 * dpr\n            )\n\n            for (let key in gradientInfo.stops) {\n              entries.push({\n                percent: parseFloat(key),\n                color: gradientInfo.stops[key],\n              })\n            }\n\n            entries.sort((a, b) => a.percent - b.percent)\n\n            for (let i = 0, l = entries.length; i < l; i++) {\n              const entry = entries[i]\n              grd.addColorStop(entry.percent, entry.color)\n            }\n          }\n\n          ctx.fillStyle = /** @type {CanvasGradient} */ (grd)\n\n          break\n        }\n\n        case GraphicsCommandType.FILL_PATTERN: {\n          const patternInfo = /** @type {GraphicsPattern} */ (cmd.getObject(0))\n          let pattern = patternInfo.native\n\n          if (!pattern) {\n            pattern = patternInfo.native = ctx.createPattern(\n              patternInfo.image,\n              patternInfo.repetition\n            )\n          }\n\n          ctx.fillStyle = /** @type {CanvasPattern} */ (pattern)\n\n          break\n        }\n\n        case GraphicsCommandType.ARC: {\n          ctx.arc(\n            cmd.getNumber(0) * r - px,\n            cmd.getNumber(1) * r - py,\n            cmd.getNumber(2) * r,\n            cmd.getNumber(3),\n            cmd.getNumber(4),\n            cmd.getBoolean(5)\n          )\n          break\n        }\n\n        case GraphicsCommandType.RECT: {\n          ctx.rect(\n            cmd.getNumber(0) * r - px,\n            cmd.getNumber(1) * r - py,\n            cmd.getNumber(2) * r,\n            cmd.getNumber(3) * r\n          )\n          break\n        }\n\n        case GraphicsCommandType.ROUNDED_RECT: {\n          const x = cmd.getNumber(0)\n          const y = cmd.getNumber(1)\n          const width = cmd.getNumber(2)\n          const height = cmd.getNumber(3)\n          const radius = cmd.getNumber(4)\n\n          ctx.moveTo(x * r - px, (y + radius) * r - py)\n          ctx.quadraticCurveTo(\n            x * r - px,\n            y * r - py,\n            (x + radius) * r - px,\n            y * r - py\n          )\n          ctx.lineTo((x + width - radius) * r - px, y * r - py)\n          ctx.quadraticCurveTo(\n            (x + width) * r - px,\n            y * r - py,\n            (x + width) * r - px,\n            (y + radius) * r - py\n          )\n          ctx.lineTo((x + width) * r - px, (y + height - radius) * r - py)\n          ctx.quadraticCurveTo(\n            (x + width) * r - px,\n            (y + height) * r - py,\n            (x + width - radius) * r - px,\n            (y + height) * r - py\n          )\n          ctx.lineTo((x + radius) * r - px, (y + height) * r - py)\n          ctx.quadraticCurveTo(\n            x * r - px,\n            (y + height) * r - py,\n            x * r - px,\n            (y + height - radius) * r - py\n          )\n          ctx.closePath()\n          break\n        }\n\n        case GraphicsCommandType.BEZIER_CURVE_TO: {\n          ctx.bezierCurveTo(\n            cmd.getNumber(0) * r - px,\n            cmd.getNumber(1) * r - py,\n            cmd.getNumber(2) * r - px,\n            cmd.getNumber(3) * r - py,\n            cmd.getNumber(4) * r - px,\n            cmd.getNumber(5) * r - py\n          )\n          break\n        }\n        case GraphicsCommandType.QUADRATIC_CURVE_TO: {\n          ctx.quadraticCurveTo(\n            cmd.getNumber(0) * r - px,\n            cmd.getNumber(1) * r - py,\n            cmd.getNumber(2) * r - px,\n            cmd.getNumber(3) * r - py\n          )\n          break\n        }\n        case GraphicsCommandType.BEGIN_PATH: {\n          ctx.beginPath()\n          break\n        }\n        case GraphicsCommandType.CLOSE_PATH: {\n          ctx.closePath()\n          break\n        }\n        case GraphicsCommandType.FILL: {\n          ctx.fill(cmd.getBoolean(0) === true ? 'nonzero' : 'evenodd')\n          break\n        }\n\n        case GraphicsCommandType.LINE_TO: {\n          ctx.lineTo(cmd.getNumber(0) * r - px, cmd.getNumber(1) * r - py)\n          break\n        }\n\n        case GraphicsCommandType.MOVE_TO: {\n          ctx.moveTo(cmd.getNumber(0) * r - px, cmd.getNumber(1) * r - py)\n          break\n        }\n\n        case GraphicsCommandType.LINE_DASH: {\n          ctx.setLineDash(cmd.getNumber(0))\n          break\n        }\n\n        case GraphicsCommandType.STROKE: {\n          ctx.stroke()\n          break\n        }\n\n        case GraphicsCommandType.BOUNDS: {\n          break\n        }\n\n        default:\n          Debug.error(`Unsupported canvas command '${cmd.type}'.`)\n          break\n      }\n    }\n\n    for (let i = 0, l = node.mNodes.length; i < l; i++) {\n      this.__renderNode(driver, color, node.mNodes[i], transform)\n    }\n  }\n}\n","/**\n * Base class for custom video drivers. VideoDriver is used to render things onto the screen.\n *\n * @cat drivers\n */\nexport \nclass VideoNullDriver {\n  /**\n   * Creates new instance of VideoNullDriver.\n   *\n   * @param  {HTMLElement} containerElement The HTML element container for rendering.\n   * @param  {number} width                 The width of the viewport.\n   * @param  {number} height                The height of the viewport.\n   */\n  constructor(containerElement, width, height) {\n    /** @protected @type {HTMLElement} */\n    this.mContainerElement = containerElement\n\n    /** @protected @type {number} */\n    this.mClientWidth = width\n\n    /** @protected @type {number} */\n    this.mClientHeight = height\n\n    /** @protected @type {Matrix} Actual object - do not change */\n    this.mTransform = new Matrix()\n\n    /** @protected @type {Matrix} */\n    this.mIdentityMatrix = new Matrix()\n\n    /** @protected @type {RenderSession} */\n    this.mActiveSession = new RenderSession()\n\n    /** @protected @type {Array<RenderSession>} */\n    this.mSessions = []\n\n    /** @protected @type {?} */\n    this.mLastRenderTexture = null\n\n    /** @protected @type {boolean} */\n    this.mSnapToPixels = false\n\n    /** @protected @type {number} */\n    this.mDevicePixelRatio =\n      Black.instance.useHiDPR === true ? Device.getDevicePixelRatio() : 1\n\n    /** @protected @type {BlendMode|null} */\n    this.mGlobalBlendMode = BlendMode.AUTO\n\n    /** @protected @type {number} */\n    this.mGlobalAlpha = 1\n\n    /** @protected @type {Renderer} */\n    this.mStageRenderer = new Renderer()\n\n    /** @protected @type {Object.<string, function(new: Renderer)>} */\n    this.mRendererMap = {}\n\n    Black.instance.viewport.on('resize', this.__onResize, this)\n  }\n\n  /**\n   * A main render function.\n   *\n   * @public\n   * @param {GameObject} gameObject                    A GameObject instance to render onto RenderTarget.\n   * @param {CanvasRenderTexture} [renderTexture=null] Destination surface to render game object on. Will be rendered\n   *                                                   onto backbuffer if null.\n   * @param {Matrix} [customTransform=null]            An optional extra offset.\n   */\n  render(gameObject, renderTexture = null, customTransform = null) {}\n\n  /**\n   * A factory method which returns new Renderer instance based on internal GameObject to Renderer map.\n   *\n   * @param {string} type      The type of the GameObject to find renderer for.\n   * @param {GameObject} owner The owner of this renderer.\n   * @returns {Renderer} New renderer instance.\n   */\n  getRenderer(type, owner) {\n    return null\n  }\n\n  /**\n   * @ignore\n   * @private\n   * @returns {RenderSession}\n   */\n  __saveSession() {\n    let session = VideoNullDriver.sessionPool.get()\n    session.reset()\n\n    this.mSessions.push(session)\n\n    this.mActiveSession = session\n    return session\n  }\n\n  /**\n   * @ignore\n   * @private\n   */\n  __restoreSession() {\n    this.mSessions.pop()\n    this.mActiveSession = this.mSessions[this.mSessions.length - 1] || null\n  }\n\n  /**\n   * @ignore\n   * @protected\n   * @param {RenderSession} session\n   * @param {GameObject} gameObject\n   * @param {Renderer} parentRenderer\n   * @returns {void}\n   */\n  __collectParentRenderables(session, gameObject, parentRenderer) {\n    let current = gameObject\n    if (current === null) return\n\n    let parents = []\n    for (current = current.parent; current !== null; current = current.parent)\n      parents.splice(0, 0, current)\n\n    for (let i = 0; i < parents.length; i++) {\n      current = parents[i]\n\n      let renderer = current.mRenderer\n\n      if (renderer == null) continue\n\n      session.parentRenderers.push(renderer)\n      renderer.parent = parentRenderer\n      parentRenderer = renderer\n\n      renderer.preRender(this, session)\n\n      if (renderer.endPassRequired === true)\n        session.endPassParentRenderers.push(renderer)\n    }\n  }\n\n  /**\n   * Notifies renderer about new clipping.\n   *\n   * @protected\n   * @param {Rectangle} clipRect The region to clip.\n   * @param {number} px Pivot-x.\n   * @param {number} py Pivot-y.\n   */\n  beginClip(clipRect, px, py) {}\n\n  /**\n   * Notifies renderer to stop last clipping.\n   * @protected\n   */\n  endClip() {}\n\n  /**\n   * @protected\n   * @ignore\n   * @param {Message} msg\n   * @param {Rectangle} rect\n   * @returns {void}\n   */\n  __onResize(msg, rect) {\n    Renderer.__dirty = true\n\n    let w = this.mContainerElement.clientWidth\n    let h = this.mContainerElement.clientHeight\n\n    this.mClientWidth = w\n    this.mClientHeight = h\n  }\n\n  /**\n   * Initialization function.\n   *\n   * @protected\n   * @return {void}\n   */\n  start() {}\n\n  /**\n   * Called before rendering anything. Usually used to clear back-buffer.\n   *\n   * @protected\n   * @returns {void}\n   */\n  beginFrame() {\n    this.clear()\n  }\n\n  /**\n   * Called after rendering is finished.\n   *\n   * @protected\n   * @returns {void}\n   */\n  endFrame() {}\n\n  /**\n   * @ignore\n   * @param {HTMLCanvasElement} canvas\n   * @return {?Texture}\n   */\n  getTextureFromCanvas(canvas) {\n    return null\n  }\n\n  /**\n   * Sets world transformation for future use.\n   *\n   * @public\n   * @param {Matrix} m An transformation matrix to store.\n   * @returns {void}\n   */\n  setTransform(m) {\n    this.mTransform = m\n  }\n\n  /**\n   * Indicates if transform should be snapped to pixels.\n   * @param {boolean} value\n   * @returns {void}\n   */\n  setSnapToPixels(value) {\n    this.mSnapToPixels = value\n  }\n\n  /**\n   * Gets/Sets the global alpha. Used to calculate alpha relative to parent object.\n   *\n   * @protected\n   * @return {number}\n   */\n  getGlobalAlpha() {\n    return this.mGlobalAlpha\n  }\n\n  /**\n   * @ignore\n   * @param {number} value\n   * @return {void}\n   */\n  setGlobalAlpha(value) {\n    this.mGlobalAlpha = value\n  }\n\n  /**\n   * Gets/Sets global blending mode. Used to calculate blend mode relative to parent object.\n   *\n   * @return {?BlendMode}\n   */\n  getGlobalBlendMode() {\n    return this.mGlobalBlendMode\n  }\n\n  /**\n   * @ignore\n   * @param {?BlendMode} value\n   * @return {void}\n   */\n  setGlobalBlendMode(value) {\n    this.mGlobalBlendMode = value\n  }\n\n  /**\n   * Draws texture onto back-buffer. alpha, blend mode and transformation matrix must be set prior to calling this\n   * method.\n   *\n   * @public\n   * @param {Texture} texture Instance of the Texture to draw.\n   *\n   */\n  drawTexture(texture) {}\n\n  /**\n   * Draws texture onto back-buffer with given offset. alpha, blend mode and transformation matrix must be set prior to calling this\n   * method.\n   *\n   * @param {Texture} texture Instance of the Texture to draw.\n   * @param {number} ox Offset along x-axis\n   * @param {number} oy Offset along y-axis\n   */\n  drawTextureWithOffset(texture, ox, oy) {}\n\n  /**\n   * Clears back-buffer.\n   *\n   * @protected\n   * @returns {void}\n   */\n  clear() {}\n\n  /**\n   * Returns current rendering context or null.\n   * @returns {?}\n   */\n  get context() {\n    return null\n  }\n\n  /**\n   * Returns device pixel ratio or 1 in case high DPR support is disabled.\n   *\n   * @returns {number}\n   */\n  get renderScaleFactor() {\n    return this.mDevicePixelRatio\n  }\n}\n\n/**\n * Recyclable session pool. Do not recycle manually.\n *\n * @type {ObjectPool}\n * @nocollapse\n */\nVideoNullDriver.sessionPool = new ObjectPool(RenderSession)\n","/**\n * Video driver responsible for rendering game objects onto HTML canvas element.\n *\n * @extends VideoNullDriver\n * @cat drivers.canvas\n */\nexport \nclass CanvasDriver extends VideoNullDriver {\n  /**\n   * Creates new instance of CanvasDriver\n   *\n   * @param {HTMLElement} containerElement The DOM element to draw into.\n   * @param {number} width                 The width of the viewport.\n   * @param {number} height                The height of the viewport.\n   */\n  constructor(containerElement, width, height) {\n    super(containerElement, width, height)\n\n    /** @private @type {CanvasRenderingContext2D|null} */\n    this.mCtx = null\n\n    this.__createCanvas()\n\n    /** @inheritDoc */\n    this.mRendererMap = {\n      DisplayObject: DisplayObjectRendererCanvas,\n      Sprite: SpriteRendererCanvas,\n      Emitter: EmitterRendererCanvas,\n      Text: TextRendererCanvas,\n      BitmapText: BitmapTextRendererCanvas,\n      Graphics: GraphicsRendererCanvas,\n    }\n  }\n\n  getRenderer(type, owner) {\n    let renderer = new this.mRendererMap[type]()\n    renderer.gameObject = /** @type {DisplayObject} */ (owner)\n    return renderer\n  }\n\n  /**\n   * @inheritDoc\n   */\n  render(\n    gameObject,\n    renderTexture = null,\n    customTransform = null,\n    isMasking = false\n  ) {\n    let isBackBufferActive = renderTexture === null\n\n    if (\n      Renderer.skipUnchangedFrames === true &&\n      isBackBufferActive === true &&\n      Renderer.__dirty === false\n    )\n      return\n\n    let session = this.__saveSession()\n    session.isBackBufferActive = isBackBufferActive\n    session.customTransform = customTransform\n    session.isMasking = isMasking\n\n    let parentRenderer = this.mStageRenderer\n\n    // RenderTexture related\n    if (renderTexture !== null) {\n      // Swap context\n      this.mLastRenderTexture = this.mCtx\n      this.mCtx = renderTexture.renderTarget.context\n\n      // clear context cache\n      this.mGlobalAlpha = -1\n      this.mGlobalBlendMode = null\n\n      parentRenderer.alpha = 1\n      parentRenderer.blendMode = BlendMode.NORMAL\n      parentRenderer.color = null\n\n      // collect parents of given GameObject\n      this.__collectParentRenderables(session, gameObject, this.mStageRenderer)\n\n      for (let i = 0, len = session.parentRenderers.length; i !== len; i++) {\n        let renderer = session.parentRenderers[i]\n        renderer.begin(this, session)\n\n        if (renderer.skipSelf === false) renderer.upload(this, session)\n      }\n\n      if (session.parentRenderers.length > 0)\n        parentRenderer =\n          session.parentRenderers[session.parentRenderers.length - 1]\n    }\n\n    this.renderObject(gameObject, session, parentRenderer)\n\n    if (renderTexture !== null) {\n      while (session.endPassParentRenderers.length > 0)\n        session.endPassParentRenderers.pop().end(this, session)\n\n      this.mCtx = this.mLastRenderTexture\n\n      this.mGlobalAlpha = -1\n      this.mGlobalBlendMode = null\n    }\n\n    this.__restoreSession()\n  }\n\n  /**\n   * @ignore\n   * @param {GameObject} child\n   * @param {RenderSession} session\n   * @param {Renderer} parentRenderer\n   */\n  renderObject(child, session, parentRenderer) {\n    let skipChildren = false\n    let renderer = /** @type {DisplayObject} */ (child).mRenderer\n\n    if (renderer != null) {\n      renderer.parent = parentRenderer\n      renderer.preRender(this, session)\n\n      for (let i = 0; i < child.mComponents.length; i++) {\n        const comp = child.mComponents[i]\n        comp.onRender()\n      }\n      /** @type {DisplayObject} */ ;(child).onRender()\n\n      renderer.begin(this, session)\n\n      if (renderer.skipSelf === false || session.isMasking === true) {\n        renderer.upload(this, session)\n        renderer.render(this, session)\n      }\n\n      skipChildren = renderer.skipChildren\n    }\n\n    if (skipChildren === false || session.isMasking === true) {\n      for (let i = 0; i < child.mChildren.length; i++)\n        this.renderObject(\n          child.mChildren[i],\n          session,\n          renderer || parentRenderer\n        )\n    }\n\n    if (renderer != null && renderer.endPassRequired === true)\n      renderer.end(this, session)\n  }\n\n  /**\n   * @ignore\n   * @private\n   * @return {void}\n   */\n  __createCanvas() {\n    let dpr = this.mDevicePixelRatio\n\n    let cvs = /** @type {HTMLCanvasElement} */ (document.createElement(\n      'canvas'\n    ))\n    cvs.style.position = 'absolute'\n    cvs.id = 'canvas'\n\n    cvs.width = this.mClientWidth * dpr\n    cvs.height = this.mClientHeight * dpr\n    cvs.style.width = this.mClientWidth + 'px'\n    cvs.style.height = this.mClientHeight + 'px'\n\n    this.mContainerElement.appendChild(cvs)\n\n    this.mCtx = /** @type {CanvasRenderingContext2D} */ (cvs.getContext('2d'))\n  }\n\n  /**\n   * @ignore\n   * @protected\n   * @param {Message} msg\n   * @param {Rectangle} rect\n   * @returns {void}\n   */\n  __onResize(msg, rect) {\n    super.__onResize(msg, rect)\n\n    // canvas will reset state after changing size\n    this.mGlobalBlendMode = null\n    this.mGlobalAlpha = -1\n\n    let dpr = this.mDevicePixelRatio\n    this.mCtx.canvas.width = this.mClientWidth * dpr\n    this.mCtx.canvas.height = this.mClientHeight * dpr\n    this.mCtx.canvas.style.width = this.mClientWidth + 'px'\n    this.mCtx.canvas.style.height = this.mClientHeight + 'px'\n  }\n\n  /**\n   * @inheritDoc\n   */\n  drawTexture(texture) {\n    if (texture.isValid === false) return\n\n    let dpr = this.mDevicePixelRatio\n\n    let sourceX = texture.region.x\n    let sourceY = texture.region.y\n    let sourceWidth = texture.region.width\n    let sourceHeight = texture.region.height\n\n    let destX = texture.untrimmedRegion.x * dpr\n    let destY = texture.untrimmedRegion.y * dpr\n    let destWidth = texture.renderWidth * dpr\n    let destHeight = texture.renderHeight * dpr\n\n    this.mCtx.drawImage(\n      texture.native,\n      sourceX,\n      sourceY,\n      sourceWidth,\n      sourceHeight,\n      destX,\n      destY,\n      destWidth,\n      destHeight\n    )\n  }\n\n  /**\n   * @inheritDoc\n   */\n  drawTextureWithOffset(texture, ox, oy) {\n    if (texture.isValid === false) return\n\n    let dpr = this.mDevicePixelRatio\n\n    let sourceX = texture.region.x\n    let sourceY = texture.region.y\n    let sourceWidth = texture.region.width\n    let sourceHeight = texture.region.height\n\n    let destX = (ox + texture.untrimmedRegion.x) * dpr\n    let destY = (oy + texture.untrimmedRegion.y) * dpr\n    let destWidth = texture.renderWidth * dpr\n    let destHeight = texture.renderHeight * dpr\n\n    this.mCtx.drawImage(\n      texture.native,\n      sourceX,\n      sourceY,\n      sourceWidth,\n      sourceHeight,\n      destX,\n      destY,\n      destWidth,\n      destHeight\n    )\n  }\n\n  /**\n   * @inheritDoc\n   */\n  beginClip(clipRect, px, py) {\n    let dpr = this.mDevicePixelRatio\n\n    this.mCtx.save()\n    this.mCtx.beginPath()\n    this.mCtx.rect(\n      (clipRect.x + px) * dpr,\n      (clipRect.y + py) * dpr,\n      clipRect.width * dpr,\n      clipRect.height * dpr\n    )\n\n    this.mCtx.clip()\n  }\n\n  /**\n   * @inheritDoc\n   */\n  endClip() {\n    this.mCtx.restore()\n\n    this.mGlobalAlpha = -1\n    this.mGlobalBlendMode = null\n  }\n\n  /**\n   * @inheritDoc\n   */\n  setTransform(transform) {\n    let dpr = this.mDevicePixelRatio\n    let session = this.mActiveSession\n\n    if (session.isBackBufferActive === false) {\n      if (session.customTransform === null) {\n        transform = transform.clone() // TODO: too much allocations\n        transform.data[4] -= Black.stage.mX\n        transform.data[5] -= Black.stage.mY\n      } else {\n        transform = transform.clone() // TODO: too much allocations\n        transform.prepend(session.customTransform)\n      }\n    }\n\n    this.mTransform = transform\n\n    let mv = transform.value\n    Debug.isNumber(mv[0], mv[1], mv[2], mv[3], mv[4], mv[5])\n\n    if (this.mSnapToPixels === true)\n      this.mCtx.setTransform(\n        mv[0],\n        mv[1],\n        mv[2],\n        mv[3],\n        (mv[4] * dpr) | 0,\n        (mv[5] * dpr) | 0\n      )\n    else\n      this.mCtx.setTransform(\n        mv[0],\n        mv[1],\n        mv[2],\n        mv[3],\n        mv[4] * dpr,\n        mv[5] * dpr\n      )\n  }\n\n  /**\n   * @inheritDoc\n   */\n  setGlobalAlpha(value) {\n    Debug.isNumber(value)\n\n    if (value == this.mGlobalAlpha) return\n\n    this.mGlobalAlpha = value\n    this.mCtx.globalAlpha = value\n  }\n\n  /**\n   * @inheritDoc\n   */\n  setGlobalBlendMode(blendMode) {\n    if (blendMode === BlendMode.AUTO) return\n\n    blendMode = CanvasBlendMode[blendMode]\n\n    if (this.mGlobalBlendMode === blendMode) return\n\n    this.mGlobalBlendMode = blendMode\n    this.mCtx.globalCompositeOperation = blendMode\n  }\n\n  /**\n   * @inheritDoc\n   */\n  clear() {\n    if (Renderer.skipUnchangedFrames === true && Renderer.__dirty === false)\n      return\n\n    // TODO: clear only changed region\n    this.mCtx.setTransform(1, 0, 0, 1, 0, 0)\n\n    let viewport = Black.instance.viewport\n    if (viewport.isTransparent === false) {\n      this.mCtx.fillStyle = ColorHelper.hexColorToString(\n        viewport.backgroundColor\n      )\n      this.mCtx.fillRect(\n        0,\n        0,\n        viewport.size.width * this.mDevicePixelRatio,\n        viewport.size.height * this.mDevicePixelRatio\n      )\n    } else {\n      this.mCtx.clearRect(\n        0,\n        0,\n        viewport.size.width * this.mDevicePixelRatio,\n        viewport.size.height * this.mDevicePixelRatio\n      )\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n  getTextureFromCanvas(canvas) {\n    return new Texture(canvas)\n  }\n\n  /**\n   * Returns current rendering context or null.\n   * @returns {CanvasRenderingContext2D}\n   */\n  get context() {\n    return this.mCtx\n  }\n}\n","/**\n * The base class for all renderable objects. Adds `alpha` and `visible` properties to GameObject.\n *\n * @cat display\n * @extends GameObject\n */\nexport \nclass DisplayObject extends GameObject {\n  constructor() {\n    super()\n\n    /** @protected @type {number} */\n    this.mAlpha = 1\n\n    /** @protected @type {BlendMode} */\n    this.mBlendMode = BlendMode.AUTO\n\n    /** @protected @type {boolean} */\n    this.mVisible = true\n\n    /** @protected @type {Rectangle} */\n    this.mClipRect = null\n\n    /** @protected @type {Renderer|null} */\n    this.mRenderer = this.getRenderer()\n\n    /** @private @type {boolean} */\n    this.mCacheAsBitmap = false\n\n    /** @private @type {boolean} */\n    this.mCacheAsBitmapDynamic = true\n\n    /** @private @type {boolean} */\n    this.mCacheAsBitmapDirty = true\n\n    /** @private @type {Matrix|null} */\n    this.mCacheAsBitmapMatrixCache = null\n\n    /** @private @type {CanvasRenderTexture|null} */\n    this.mCache = null\n\n    /** @private @type {Rectangle|null} */\n    this.mCacheBounds = null\n\n    /** @protected @type {?number} */\n    this.mColor = null\n\n    /** @protected @type {boolean} */\n    this.mSnapToPixels = false\n  }\n\n  /**\n   * Called at the end of the loop, all renderers are already collected and this object and its children will be\n   * rendered. Should be used to interpolate between last and current state.\n   *\n   * NOTE: Adding, removing or changing children elements inside onRender method can lead to unexpected behavior.\n   *\n   * @protected\n   * @return {void}\n   */\n  onRender() {}\n\n  /**\n   * Factory method returns concrete renderer for this Game Object.\n   *\n   * @returns {Renderer}\n   */\n  getRenderer() {\n    return Black.driver.getRenderer('DisplayObject', this)\n  }\n\n  /**\n   * @inheritDoc\n   */\n  onGetLocalBounds(outRect = undefined) {\n    outRect = outRect || new Rectangle()\n\n    if (this.mClipRect !== null) {\n      this.mClipRect.copyTo(outRect)\n      return outRect\n    }\n\n    return outRect.set(0, 0, 0, 0)\n  }\n\n  /**\n   * @inheritDoc\n   */\n  getBounds(space = undefined, includeChildren = true, outRect = undefined) {\n    outRect = outRect || new Rectangle()\n\n    let localBounds = this.onGetLocalBounds()\n\n    if (space == null) space = this.mParent\n\n    if (space == this) {\n      // local\n    } else if (space == this.mParent) {\n      if (includeChildren === false || this.mClipRect !== null) {\n        let matrix = Matrix.pool.get()\n        matrix.copyFrom(this.localTransformation)\n        matrix.transformRect(localBounds, outRect)\n        Matrix.pool.release(matrix)\n      } else if (includeChildren === true && this.mDirty & DirtyFlag.BOUNDS) {\n        let matrix = Matrix.pool.get()\n        matrix.copyFrom(this.localTransformation)\n        matrix.transformRect(localBounds, outRect)\n        Matrix.pool.release(matrix)\n      } else {\n        // Return cached\n        outRect.copyFrom(this.mBoundsCache)\n        return outRect\n      }\n    } else {\n      let matrix = Matrix.pool.get()\n      matrix.copyFrom(this.worldTransformation)\n      matrix.prepend(space.worldTransformationInverted)\n      matrix.transformRect(localBounds, outRect)\n      Matrix.pool.release(matrix)\n    }\n\n    if (space !== this) {\n      if (this.mClipRect !== null) {\n        outRect.x += this.mPivotX\n        outRect.y += this.mPivotY\n      }\n    } else {\n      localBounds.copyTo(outRect)\n    }\n\n    if (this.mClipRect !== null) return outRect\n\n    if (includeChildren === true) {\n      let childBounds = Rectangle.pool.get()\n\n      for (let i = 0; i < this.mChildren.length; i++) {\n        childBounds.zero()\n\n        this.mChildren[i].getBounds(space, includeChildren, childBounds)\n        outRect.union(childBounds)\n      }\n\n      Rectangle.pool.release(childBounds)\n\n      if (space == this.mParent && this.mDirty & DirtyFlag.BOUNDS) {\n        this.mBoundsCache.copyFrom(outRect)\n        this.mDirty ^= DirtyFlag.BOUNDS\n      }\n    }\n\n    return outRect\n  }\n\n  /**\n   * @inheritDoc\n   */\n  hitTest(localPoint) {\n    let c = /** @type {InputComponent}*/ (this.getComponent(InputComponent))\n    let touchable = c !== null && c.touchable\n    let insideMask = this.onHitTestMask(localPoint)\n\n    if (this.visible === false || touchable === false || insideMask === false)\n      return null\n\n    let target = null\n    let numChildren = this.mChildren.length\n\n    for (let i = numChildren - 1; i >= 0; --i) {\n      let child = this.mChildren[i]\n\n      target = child.hitTest(localPoint)\n\n      if (target !== null) return target\n    }\n\n    if (this.onHitTest(localPoint) === true) return this\n\n    return null\n  }\n\n  /**\n   * @inheritDoc\n   */\n  onHitTestMask(localPoint) {\n    if (this.mClipRect === null) return true\n\n    let tmpVector = Vector.pool.get()\n    this.worldTransformationInverted.transformVector(localPoint, tmpVector)\n\n    let contains = this.mClipRect.containsXY(\n      tmpVector.x - this.mPivotX,\n      tmpVector.y - this.mPivotY\n    )\n    Vector.pool.release(tmpVector)\n\n    return contains\n  }\n\n  /**\n   * Gets/Sets tinting color of the object. Pass `null` to disable tinting. Tinting color will be applied to all children\n   * objects. You can override tint color for children by setting custom value or `null` to inherit color from parent.\n   * @returns {?number}\n   */\n  get color() {\n    return this.mColor\n  }\n\n  /**\n   * @ignore\n   * @param {?number} value\n   * @return {void}\n   */\n  set color(value) {\n    if (this.mColor === value) return\n\n    this.mColor = value\n    this.setRenderDirty()\n  }\n\n  /**\n   * Gets/Sets whether this container and all it's children should be baked into\n   * bitmap. Setting `cacheAsBitmap` onto Sprites, TextFields or any other\n   * inherited classes will give zero effect.\n   *\n   * @return {boolean}\n   */\n  get cacheAsBitmap() {\n    return this.mCacheAsBitmap\n  }\n\n  /**\n   * @ignore\n   * @param {boolean} value\n   * @return {void}\n   */\n  set cacheAsBitmap(value) {\n    if (value === this.mCacheAsBitmap) return\n\n    this.mCacheAsBitmap = value\n\n    if (value === false) {\n      this.mCache = null\n      this.mCacheAsBitmapDirty = true\n      this.mCacheAsBitmapMatrixCache = null\n      this.mCacheBounds = null\n\n      this.setTransformDirty()\n    }\n  }\n\n  /**\n   * Gets/sets whenever cache as bitmap should be automatically refreshed.\n   *\n   * @returns {boolean}\n   */\n  get cacheAsBitmapDynamic() {\n    return this.mCacheAsBitmapDynamic\n  }\n\n  /**\n   * @ignore\n   * @param {boolean} value\n   * @return {void}\n   */\n  set cacheAsBitmapDynamic(value) {\n    this.mCacheAsBitmapDynamic = value\n  }\n\n  /**\n   * Gets/Sets the opacity of the object.\n   * Baked objects may change behavior.\n   *\n   * @return {number}\n   */\n  get alpha() {\n    return this.mAlpha\n  }\n\n  /**\n   * @ignore\n   * @param {number} value\n   * @return {void}\n   */\n  set alpha(value) {\n    Debug.assert(!isNaN(value), 'Value cannot be NaN')\n\n    if (this.mAlpha === MathEx.clamp(value, 0, 1)) return\n\n    this.mAlpha = MathEx.clamp(value, 0, 1)\n    this.setRenderDirty()\n  }\n\n  /**\n   * Gets/Sets visibility of the object.\n   *\n   * @return {boolean}\n   */\n  get visible() {\n    return this.mVisible\n  }\n\n  /**\n   * @ignore\n   * @param {boolean} value\n   * @return {void}\n   */\n  set visible(value) {\n    if (this.mVisible === value) return\n\n    this.mVisible = value\n    this.setRenderDirty()\n  }\n\n  /**\n   * Gets/Sets blend mode for the object.\n   *\n   * @return {BlendMode}\n   */\n  get blendMode() {\n    return this.mBlendMode\n  }\n\n  /**\n   * @ignore\n   * @param {BlendMode} value\n   * @return {void}\n   */\n  set blendMode(value) {\n    if (this.mBlendMode === value) return\n\n    this.mBlendMode = value\n    this.setRenderDirty()\n  }\n\n  /**\n   * Gets/Sets clipping area for the object.\n   *\n   * @return {Rectangle}\n   */\n  get clipRect() {\n    return this.mClipRect\n  }\n\n  /**\n   * @ignore\n   * @param {Rectangle} value\n   * @return {void}\n   */\n  set clipRect(value) {\n    this.mClipRect = value\n    this.setRenderDirty()\n  }\n\n  /**\n   * Gets/sets whenever this object x and y value should be rounded.\n   * @returns {boolean}\n   */\n  get snapToPixels() {\n    return this.mSnapToPixels\n  }\n\n  /**\n   * @ignore\n   * @param {boolean} value\n   */\n  set snapToPixels(value) {\n    this.mSnapToPixels = value\n  }\n}\n","/**\n * Structure object for graphics. Stores parsed layered data, ready for render.\n * Normally you should not work with this object, and use Graphics instead.\n *\n * @cat display\n */\n\nexport \nclass GraphicsData {\n  /**\n   * Creates new instance of GraphicsData\n   */\n  constructor() {\n    /** @private @type {Array<GraphicsData>} */\n    this.mNodes = []\n\n    /** @private @type {Matrix} */\n    this.mTransform = new Matrix()\n\n    /** @private @type {Array<GraphicsCommand>} */\n    this.mCommandQueue = []\n\n    /** @private @type {number} */\n    this.mPivotX = 0\n\n    /** @private @type {number} */\n    this.mPivotY = 0\n\n    /** @private @type {number} */\n    this.mPosX = 0\n\n    /** @private @type {number} */\n    this.mPosY = 0\n\n    /** @private @type {string|null} */\n    this.mName = null\n  }\n\n  /**\n   * Calculates trimmed local bounds.\n   *\n   * @protected\n   * @param {Object} graphics Object to store bounds by reference.\n   * @param {Matrix} transform Matrix to transform children nodes, for internal use.\n   *\n   * @return {Rectangle} Calculated local bounds.\n   */\n  onGetLocalBounds(graphics, transform) {\n    let path = new GraphicsPath()\n    let len = this.mCommandQueue.length\n\n    transform = transform.clone().append(this.mTransform)\n    const m = transform.data\n    const scaleX = Math.sqrt(m[0] * m[0] + m[1] * m[1])\n    const scaleY = Math.sqrt(m[2] * m[2] + m[3] * m[3])\n\n    for (let i = 0; i < len; i++) {\n      let cmd = this.mCommandQueue[i]\n\n      switch (cmd.type) {\n        case GraphicsCommandType.BEGIN_PATH: {\n          if (path.bounds) {\n            transform.transformRect(path.bounds, path.bounds)\n            graphics.mLocalBounds = graphics.mLocalBounds\n              ? graphics.mLocalBounds.union(path.bounds)\n              : path.bounds\n          }\n\n          path = new GraphicsPath()\n          break\n        }\n        case GraphicsCommandType.BOUNDS: {\n          for (let k = 0; k < cmd.data.length; k += 2) {\n            path.points.push(cmd.getNumber(k), cmd.getNumber(k + 1))\n          }\n\n          break\n        }\n        case GraphicsCommandType.LINE_STYLE: {\n          path.lastLineWidth = cmd.getNumber(0)\n          let joints = cmd.getString(4)\n\n          if (joints === JointStyle.MITER) path.lineMul = 1\n\n          break\n        }\n        case GraphicsCommandType.FILL: {\n          if (path.points.length !== 0) {\n            let tmpBounds = Rectangle.fromPointsXY(path.points)\n            path.bounds = path.bounds ? path.bounds.union(tmpBounds) : tmpBounds\n          }\n\n          break\n        }\n        case GraphicsCommandType.STROKE: {\n          if (path.lastLineWidth > path.maxLineWidth)\n            path.maxLineWidth = path.lastLineWidth\n\n          if (path.maxLineWidth === 0) path.maxLineWidth = 1\n\n          path.maxLineWidth *= path.lineMul\n\n          if (path.points.length !== 0) {\n            let tmpBounds = Rectangle.fromPointsXY(path.points)\n\n            if (path.points.length > 1)\n              tmpBounds.inflate(\n                path.maxLineWidth * scaleX,\n                path.maxLineWidth * scaleY\n              )\n\n            path.bounds = path.bounds ? path.bounds.union(tmpBounds) : tmpBounds\n          }\n\n          break\n        }\n\n        default:\n          break\n      }\n    }\n\n    if (path.bounds) {\n      transform.transformRect(path.bounds, path.bounds)\n      graphics.mLocalBounds = graphics.mLocalBounds\n        ? graphics.mLocalBounds.union(path.bounds)\n        : path.bounds\n    }\n\n    for (let i = 0, l = this.mNodes.length; i < l; i++) {\n      this.mNodes[i].onGetLocalBounds(graphics, transform)\n    }\n\n    return graphics.mLocalBounds\n  }\n\n  /**\n   * Sets line style. Zero or less values of `lineWidth` are ignored.\n   *\n   * @public\n   * @param {number} lineWidth Line width.\n   * @param {number=} [color=0] Line color.\n   * @param {number=} [alpha=1] Line alpha.\n   * @param {CapsStyle=} [caps=CapsStyle.NONE] Line caps style.\n   * @param {JointStyle=} [joints=JointStyle.MITER] Line joints style.\n   * @param {number=} [miterLimit=3] Miter limit.\n   * @returns {void}\n   */\n  lineStyle(\n    lineWidth = 0,\n    color = 0,\n    alpha = 1,\n    caps = CapsStyle.NONE,\n    joints = JointStyle.MITER,\n    miterLimit = 3\n  ) {\n    Debug.isNumber(lineWidth, color, alpha, miterLimit)\n    if (lineWidth <= 0) return\n\n    this.__pushCommand(\n      GraphicsCommandType.LINE_STYLE,\n      lineWidth,\n      color,\n      alpha,\n      caps,\n      joints,\n      miterLimit\n    )\n  }\n\n  /**\n   * Sets fill style\n   *\n   * @public\n   * @param {number} [color=0] Fill color.\n   * @param {number=} [alpha=1] Fill alpha.\n   * @returns {void}\n   */\n  fillStyle(color = 0, alpha = 1) {\n    Debug.isNumber(color, alpha)\n    this.__pushCommand(GraphicsCommandType.FILL_STYLE, color, alpha)\n  }\n\n  /**\n   * Sets fill style to gradient.\n   *\n   * @public\n   * @param {GraphicsGradient} gradient Fill gradient.\n   *\n   * @returns {void}\n   */\n  fillGradient(gradient) {\n    if (gradient instanceof GraphicsLinearGradient) {\n      this.__pushCommand(\n        GraphicsCommandType.FILL_GRD,\n        /** @type {GraphicsLinearGradient} */ (gradient)\n      )\n    } // radial todo\n  }\n\n  /**\n   * Sets fill style to pattern.\n   *\n   * @public\n   * @param {GraphicsPattern} pattern Fill pattern.\n   *\n   * @returns {void}\n   */\n  fillPattern(pattern) {\n    this.__pushCommand(GraphicsCommandType.FILL_PATTERN, pattern)\n  }\n\n  /**\n   * Clears the graphics that were drawn and resets fill and line styles.\n   *\n   * @public\n   * @returns {void}\n   */\n  clear() {\n    this.mPosX = 0\n    this.mPosY = 0\n\n    this.mCommandQueue = []\n    this.mNodes = []\n\n    this.beginPath()\n  }\n\n  /**\n   * Moves the starting point of a path to given x and y coordinates.\n   *\n   * @public\n   * @param {number} x The x-axis of the point.\n   * @param {number} y The y-axis of the point.\n   * @returns {void}\n   */\n  moveTo(x, y) {\n    this.mPosX = x\n    this.mPosY = y\n    this.__pushCommand(GraphicsCommandType.MOVE_TO, x, y)\n  }\n\n  /**\n   * Draws a line between last point and given.\n   *\n   * @public\n   * @param {number} x The x-axis of the point.\n   * @param {number} y The y-axis of the point.\n   * @returns {void}\n   */\n  lineTo(x, y) {\n    this.mPosX = x\n    this.mPosY = y\n\n    this.__pushCommand(GraphicsCommandType.LINE_TO, x, y)\n    this.__pushCommand(GraphicsCommandType.BOUNDS, this.mPosX, this.mPosY, x, y)\n  }\n\n  /**\n   * Adds an arc to the current path.\n   *\n   * @public\n   * @param {number} x             The x-axis of the arc's center.\n   * @param {number} y             The y-axis of the arc's center.\n   * @param {number} radius        The radius of the arc.\n   * @param {number} startAngle    The starting angle in radians.\n   * @param {number} endAngle      The ending angle in radians.\n   * @param {boolean=} [anticlockwise=false] If true the arc will be drawn counter-clockwise.\n   * @returns {void}\n   */\n  arc(x, y, radius, startAngle, endAngle, anticlockwise = false) {\n    let needsMoveTo = false\n    let moveToX = 0\n    let moveToY = 0\n    let points = []\n    let diff = Math.abs(startAngle - endAngle)\n\n    if (startAngle === endAngle) return\n\n    if (diff >= MathEx.PI2) {\n      points.push(x - radius, y - radius, x + radius, y + radius)\n\n      let end = Circle.getCircumferencePoint(\n        x,\n        y,\n        radius,\n        endAngle + Math.PI * 0.5\n      )\n\n      needsMoveTo = true\n      endAngle = startAngle + MathEx.PI2\n      moveToX = end.x\n      moveToY = end.y\n    } else {\n      let start = (startAngle % MathEx.PI2) + (startAngle < 0 ? MathEx.PI2 : 0)\n      let end = endAngle\n\n      if (anticlockwise) {\n        end = start\n        start = endAngle\n      }\n\n      while (end < start) end += MathEx.PI2\n\n      const right = start === 0 || end >= MathEx.PI2\n      const left = (start <= Math.PI && end >= Math.PI) || end >= Math.PI * 3\n      const bottom =\n        (start <= Math.PI * 0.5 && end >= Math.PI * 0.5) || end >= Math.PI * 2.5\n      const top =\n        (start <= Math.PI * 1.5 && end >= Math.PI * 1.5) || end >= Math.PI * 3.5\n\n      let startCos, endCos, startSin, endSin\n\n      if (!left || !right) {\n        startCos = Math.cos(start) * radius\n        endCos = Math.cos(end) * radius\n      }\n\n      if (!top || !bottom) {\n        startSin = Math.sin(start) * radius\n        endSin = Math.sin(end) * radius\n      }\n\n      const minX = left ? -radius : Math.min(startCos, endCos)\n      const maxX = right ? radius : Math.max(startCos, endCos)\n      const minY = top ? -radius : Math.min(startSin, endSin)\n      const maxY = bottom ? radius : Math.max(startSin, endSin)\n\n      points.push(minX + x, minY + y, maxX + x, maxY + y)\n    }\n\n    this.__pushCommand(\n      GraphicsCommandType.ARC,\n      x,\n      y,\n      radius,\n      startAngle,\n      endAngle,\n      anticlockwise\n    )\n    this.__pushCommand(GraphicsCommandType.BOUNDS, ...points)\n\n    if (needsMoveTo === true)\n      this.__pushCommand(GraphicsCommandType.MOVE_TO, moveToX, moveToY)\n  }\n\n  /**\n   * Adds circle to current path.\n   *\n   * @public\n   * @param {number} x      The x-axis of the circle's center.\n   * @param {number} y      The y-axis of the circle's center.\n   * @param {number} radius The radius of the circle.\n   * @returns {void}\n   */\n  circle(x, y, radius) {\n    this.__pushCommand(GraphicsCommandType.ARC, x, y, radius, 0, MathEx.PI2)\n    this.__pushCommand(\n      GraphicsCommandType.BOUNDS,\n      x - radius,\n      y - radius,\n      x + radius,\n      y + radius\n    )\n  }\n\n  /**\n   * Creates closed rectangle like path.\n   *\n   * @public\n   * @param {number} x\n   * @param {number} y\n   * @param {number} width\n   * @param {number} height\n   *\n   * @returns {void}\n   */\n  rect(x, y, width, height) {\n    Debug.isNumber(x, y, width, height)\n\n    this.__pushCommand(GraphicsCommandType.RECT, x, y, width, height)\n    this.__pushCommand(GraphicsCommandType.BOUNDS, x, y, x + width, y + height)\n  }\n\n  /**\n   * Creates closed rounded rectangle.\n   *\n   * @public\n   * @param {number} x\n   * @param {number} y\n   * @param {number} width\n   * @param {number} height\n   * @param {number} radius\n   *\n   * @returns {void}\n   */\n  roundedRect(x, y, width, height, radius) {\n    Debug.isNumber(x, y, width, height, radius)\n\n    this.__pushCommand(\n      GraphicsCommandType.ROUNDED_RECT,\n      x,\n      y,\n      width,\n      height,\n      radius\n    )\n    this.__pushCommand(GraphicsCommandType.BOUNDS, x, y, x + width, y + height)\n  }\n\n  /**\n   * @public\n   * @param {number} cp1x\n   * @param {number} cp1y\n   * @param {number} cp2x\n   * @param {number} cp2y\n   * @param {number} x\n   * @param {number} y\n   */\n  bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y) {\n    const rangeX = this.__bezierRange(\n      this.mPosX,\n      cp1x,\n      cp2x,\n      x,\n      Vector.pool.get()\n    )\n    const rangeY = this.__bezierRange(\n      this.mPosY,\n      cp1y,\n      cp2y,\n      y,\n      Vector.pool.get()\n    )\n\n    this.mPosX = x\n    this.mPosY = y\n\n    this.__pushCommand(\n      GraphicsCommandType.BEZIER_CURVE_TO,\n      cp1x,\n      cp1y,\n      cp2x,\n      cp2y,\n      x,\n      y\n    )\n    this.__pushCommand(\n      GraphicsCommandType.BOUNDS,\n      rangeX.x,\n      rangeY.x,\n      rangeX.y,\n      rangeY.y\n    )\n\n    Vector.pool.release(rangeX)\n    Vector.pool.release(rangeY)\n  }\n\n  /**\n   * @public\n   * @param {number} cpx\n   * @param {number} cpy\n   * @param {number} x\n   * @param {number} y\n   */\n  quadraticCurveTo(cpx, cpy, x, y) {\n    const rangeX = this.__quadraticRange(this.mPosX, cpx, x, Vector.pool.get())\n    const rangeY = this.__quadraticRange(this.mPosY, cpy, y, Vector.pool.get())\n\n    this.mPosX = x\n    this.mPosY = y\n\n    this.__pushCommand(GraphicsCommandType.QUADRATIC_CURVE_TO, cpx, cpy, x, y)\n    this.__pushCommand(\n      GraphicsCommandType.BOUNDS,\n      rangeX.x,\n      rangeY.x,\n      rangeX.y,\n      rangeY.y\n    )\n\n    Vector.pool.release(rangeX)\n    Vector.pool.release(rangeY)\n  }\n\n  /**\n   * @private\n   * @param {number} p0\n   * @param {number} p1\n   * @param {number} p2\n   * @param {number} p3\n   * @param {Vector=} out\n   *\n   * @return {Vector} Out vector with set x, y as min and max bezier coordinate on passed axis\n   */\n  __bezierRange(p0, p1, p2, p3, out) {\n    out = out || new Vector()\n\n    const a = p2 - 2 * p1 + p0 - (p3 - 2 * p2 + p1)\n    const b = 2 * (p1 - p0) - 2 * (p2 - p1)\n    const c = p0 - p1\n    const discriminant = b * b - 4 * a * c\n\n    let min = Math.min(p0, p3)\n    let max = Math.max(p0, p3)\n\n    if (discriminant >= 0) {\n      const discRoot = Math.sqrt(discriminant)\n      const inv2a = 1 / (a * 2)\n      let x1 = (-b + discRoot) * inv2a\n      let x2 = (-b - discRoot) * inv2a\n      x1 = isFinite(x1) ? x1 : 0.5\n      x2 = isFinite(x2) ? x2 : 0.5\n\n      if (x1 > 0 && x1 < 1) {\n        const dot = this.__bezierDot(p0, p1, p2, p3, x1)\n        min = Math.min(dot, min)\n        max = Math.max(dot, max)\n      }\n\n      if (x2 > 0 && x2 < 1) {\n        const dot = this.__bezierDot(p0, p1, p2, p3, x2)\n        min = Math.min(dot, min)\n        max = Math.max(dot, max)\n      }\n    }\n\n    out.x = min\n    out.y = max\n\n    return out\n  }\n\n  /**\n   * @private\n   * @param {number} p0\n   * @param {number} p1\n   * @param {number} p2\n   * @param {number} p3\n   * @param {number} x\n   *\n   * @return {number}\n   */\n  __bezierDot(p0, p1, p2, p3, x) {\n    const y = 1 - x\n    return (\n      p0 * y * y * y + 3 * p1 * x * y * y + 3 * p2 * x * x * y + p3 * x * x * x\n    )\n  }\n\n  /**\n   * @private\n   * @param {number} p0\n   * @param {number} p1\n   * @param {number} p2\n   * @param {Vector=} out\n   *\n   * @return {Vector} Out vector with set x, y as min and max bezier coordinate on passed axis\n   */\n  __quadraticRange(p0, p1, p2, out) {\n    const a = p2 - p0\n    const b = p1 - p0\n    const c = b / a\n    const d = p0 + (c < 0 || c > 1 ? (b * b) / (2 * b - a) : 0)\n\n    out.x = Math.min(p0, p2, d)\n    out.y = Math.max(p0, p2, d)\n\n    return out\n  }\n\n  /**\n   * Starts new path.\n   *\n   * @public\n   * @returns {void}\n   */\n  beginPath() {\n    this.__pushCommand(GraphicsCommandType.BEGIN_PATH)\n  }\n\n  /**\n   * Closes current path.\n   *\n   * @public\n   * @returns {void}\n   */\n  closePath() {\n    this.__pushCommand(GraphicsCommandType.CLOSE_PATH)\n  }\n\n  /**\n   * Sets the line dash pattern used when stroking lines,\n   * using an array of values which specify alternating lengths of lines and gaps which describe the pattern.\n   *\n   * @public\n   * @param segments An Array of numbers which specify distances to alternately draw a line and a gap (in coordinate space units).\n   *\n   * @returns {void}\n   */\n  setLineDash(segments) {\n    this.__pushCommand(GraphicsCommandType.LINE_DASH, segments)\n  }\n\n  /**\n   * Strokes current path with the current line style..\n   *\n   * @public\n   * @returns {void}\n   */\n  stroke() {\n    this.__pushCommand(GraphicsCommandType.STROKE)\n  }\n\n  /**\n   * Fills current path with the current fill style.\n   *\n   * @public\n   * @param {boolean} isNonZero The algorithm by which to determine if a point is inside a path or outside a path, True is for \"nonzero\" and False is for \"evenodd\".\n   *\n   * @returns {void}\n   */\n  fill(isNonZero) {\n    this.__pushCommand(GraphicsCommandType.FILL, isNonZero)\n  }\n\n  /**\n   * @private\n   * @ignore\n   * @param {GraphicsCommandType} type\n   * @param {...*} data\n   */\n  __pushCommand(type, ...data) {\n    let cmd = new GraphicsCommand(type, data)\n    this.mCommandQueue.push(cmd)\n  }\n\n  searchNode(name, parent = this) {\n    if (parent.name === name) {\n      return parent\n    }\n\n    for (let i = 0, l = parent.mNodes.length; i < l; i++) {\n      const node = this.searchNode(name, parent.mNodes[i])\n\n      if (node) {\n        return node\n      }\n    }\n  }\n\n  /**\n   * Gets/Sets the name of this GraphicsData instance. Used for searching elements.\n   *\n   * @export\n   * @return {string|null}\n   */\n  get name() {\n    return this.mName\n  }\n\n  /**\n   * @export\n   * @ignore\n   * @param {string|null} value\n   * @return {void}\n   */\n  set name(value) {\n    this.mName = value\n  }\n}\n","/**\n * A basic utility class for drawing shapes.\n *\n * @cat display\n * @extends DisplayObject\n */\n\nexport \nclass Graphics extends DisplayObject {\n  /**\n   * Creates new Graphics instance.\n   *\n   * @param {GraphicsData|string|null} graphicsData The id of BVG object.\n   * @param {boolean} trim Flag to determine the passed graphicsData needs trim.\n   */\n  constructor(graphicsData = null, trim = false) {\n    super()\n\n    /** @private @type {Rectangle} */\n    this.mBounds = new Rectangle()\n\n    /**\n     * For internal usage\n     *\n     * @private @type {Rectangle|null} */\n    this.mLocalBounds = null\n\n    /** @private @type {GraphicsData|null} */\n    this.mGraphicsData = null\n\n    /** @private @type {number} */\n    this.mDataOffsetX = 0\n\n    /** @private @type {number} */\n    this.mDataOffsetY = 0\n\n    /** @private @type {boolean} */\n    this.mTrim = trim\n\n    if (graphicsData === null) {\n      this.mGraphicsData = new GraphicsData()\n    } else if (typeof graphicsData === 'string') {\n      this.mGraphicsData = AssetManager.default.getGraphicsData(graphicsData)\n    } else {\n      this.mGraphicsData = graphicsData\n    }\n\n    if (trim) {\n      this.mGraphicsData.onGetLocalBounds(this, new Matrix())\n\n      if (this.mLocalBounds) {\n        this.mDataOffsetX = this.mLocalBounds.x\n        this.mDataOffsetY = this.mLocalBounds.y\n        this.mLocalBounds = null\n      }\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n  getRenderer() {\n    return Black.driver.getRenderer('Graphics', this)\n  }\n\n  /**\n   * @inheritDoc\n   */\n  onGetLocalBounds(outRect = undefined) {\n    outRect = outRect || new Rectangle()\n\n    if (this.mClipRect !== null) {\n      this.mClipRect.copyTo(outRect)\n      return outRect\n    }\n\n    this.mGraphicsData.onGetLocalBounds(this, new Matrix())\n\n    this.mLocalBounds && outRect.copyFrom(this.mLocalBounds)\n    this.mLocalBounds = null\n\n    if (!this.mTrim) {\n      outRect.width += Math.max(0, outRect.x)\n      outRect.height += Math.max(0, outRect.y)\n      outRect.x = Math.min(0, outRect.x)\n      outRect.y = Math.min(0, outRect.y)\n    }\n\n    return outRect\n  }\n\n  /**\n   * Sets line style. Zero or less values of `lineWidth` are ignored.\n   *\n   * @public\n   * @param {number} lineWidth Line width.\n   * @param {number=} [color=0] Line color.\n   * @param {number=} [alpha=1] Line alpha.\n   * @param {CapsStyle=} [caps=CapsStyle.NONE] Line caps style.\n   * @param {JointStyle=} [joints=JointStyle.MITER] Line joints style.\n   * @param {number=} [miterLimit=3] Miter limit.\n   * @returns {void}\n   */\n  lineStyle(\n    lineWidth = 0,\n    color = 0,\n    alpha = 1,\n    caps = CapsStyle.NONE,\n    joints = JointStyle.MITER,\n    miterLimit = 3\n  ) {\n    this.mGraphicsData.lineStyle(\n      lineWidth,\n      color,\n      alpha,\n      caps,\n      joints,\n      miterLimit\n    )\n  }\n\n  /**\n   * Sets fill style\n   *\n   * @public\n   * @param {number} [color=0] Fill color.\n   * @param {number=} [alpha=1] Fill alpha.\n   * @returns {void}\n   */\n  fillStyle(color = 0, alpha = 1) {\n    this.mGraphicsData.fillStyle(color, alpha)\n  }\n\n  /**\n   * Sets fill style to gradient.\n   *\n   * @public\n   * @param {GraphicsGradient} gradient Fill gradient.\n   *\n   * @returns {void}\n   */\n  fillGradient(gradient) {\n    this.mGraphicsData.fillGradient(gradient)\n  }\n\n  /**\n   * Sets fill style to pattern.\n   *\n   * @public\n   * @param {GraphicsPattern} pattern Fill pattern.\n   *\n   * @returns {void}\n   */\n  fillPattern(pattern) {\n    this.mGraphicsData.fillPattern(pattern)\n  }\n\n  /**\n   * Clears the graphics that were drawn and resets fill and line styles.\n   *\n   * @public\n   * @returns {void}\n   */\n  clear() {\n    this.mBounds.zero()\n    this.mGraphicsData.clear()\n    this.setTransformDirty()\n  }\n\n  /**\n   * Moves the starting point of a path to given x and y coordinates.\n   *\n   * @public\n   * @param {number} x The x-axis of the point.\n   * @param {number} y The y-axis of the point.\n   * @returns {void}\n   */\n  moveTo(x, y) {\n    this.mGraphicsData.moveTo(x, y)\n  }\n\n  /**\n   * Draws a line between last point and given.\n   *\n   * @public\n   * @param {number} x The x-axis of the point.\n   * @param {number} y The y-axis of the point.\n   * @returns {void}\n   */\n  lineTo(x, y) {\n    this.mGraphicsData.lineTo(x, y)\n  }\n\n  /**\n   * Adds an arc to the current path.\n   *\n   * @public\n   * @param {number} x             The x-axis of the arc's center.\n   * @param {number} y             The y-axis of the arc's center.\n   * @param {number} radius        The radius of the arc.\n   * @param {number} startAngle    The starting angle in radians.\n   * @param {number} endAngle      The ending angle in radians.\n   * @param {boolean=} [anticlockwise=false] If true the arc will be drawn counter-clockwise.\n   * @returns {void}\n   */\n  arc(x, y, radius, startAngle, endAngle, anticlockwise = false) {\n    this.mGraphicsData.arc(x, y, radius, startAngle, endAngle, anticlockwise)\n  }\n\n  /**\n   * Adds circle to current path.\n   *\n   * @public\n   * @param {number} x      The x-axis of the circle's center.\n   * @param {number} y      The y-axis of the circle's center.\n   * @param {number} radius The radius of the circle.\n   * @returns {void}\n   */\n  circle(x, y, radius) {\n    this.mGraphicsData.circle(x, y, radius)\n  }\n\n  /**\n   * Creates closed rectangle like path.\n   *\n   * @public\n   * @param {number} x\n   * @param {number} y\n   * @param {number} width\n   * @param {number} height\n   *\n   * @returns {void}\n   */\n  rect(x, y, width, height) {\n    this.mGraphicsData.rect(x, y, width, height)\n  }\n\n  /**\n   * Creates closed rounded rectangle.\n   *\n   * @public\n   * @param {number} x\n   * @param {number} y\n   * @param {number} width\n   * @param {number} height\n   * @param {number} radius\n   *\n   * @returns {void}\n   */\n  roundedRect(x, y, width, height, radius) {\n    this.mGraphicsData.roundedRect(x, y, width, height, radius)\n  }\n\n  /**\n   * @public\n   * @param {number} cp1x\n   * @param {number} cp1y\n   * @param {number} cp2x\n   * @param {number} cp2y\n   * @param {number} x\n   * @param {number} y\n   */\n  bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y) {\n    this.mGraphicsData.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y)\n  }\n\n  /**\n   * @public\n   * @param {number} cpx\n   * @param {number} cpy\n   * @param {number} x\n   * @param {number} y\n   */\n  quadraticCurveTo(cpx, cpy, x, y) {\n    this.mGraphicsData.quadraticCurveTo(cpx, cpy, x, y)\n  }\n\n  /**\n   * Starts new path.\n   *\n   * @public\n   * @returns {void}\n   */\n  beginPath() {\n    this.mGraphicsData.beginPath()\n  }\n\n  /**\n   * Closes current path.\n   *\n   * @public\n   * @returns {void}\n   */\n  closePath() {\n    this.mGraphicsData.closePath()\n  }\n\n  /**\n   * Sets the line dash pattern used when stroking lines,\n   * using an array of values which specify alternating lengths of lines and gaps which describe the pattern.\n   *\n   * @public\n   * @param segments An Array of numbers which specify distances to alternately draw a line and a gap (in coordinate space units).\n   *\n   * @returns {void}\n   */\n  setLineDash(segments) {\n    this.mGraphicsData.setLineDash(segments)\n  }\n\n  /**\n   * Strokes current path with the current line style..\n   *\n   * @public\n   * @returns {void}\n   */\n  stroke() {\n    this.mGraphicsData.stroke()\n    this.setTransformDirty()\n  }\n\n  /**\n   * Fills current path with the current fill style.\n   *\n   * @public\n   * @param {boolean} isNonZero The algorithm by which to determine if a point is inside a path or outside a path, True is for \"nonzero\" and False is for \"evenodd\".\n   *\n   * @returns {void}\n   */\n  fill(isNonZero = true) {\n    this.mGraphicsData.fill(isNonZero)\n    this.setTransformDirty()\n  }\n\n  createLinearGradient(x, y, width, height) {\n    return new GraphicsLinearGradient(x, y, width, height)\n  }\n}\n","/**\n * Path state holder for graphics.\n *\n * @ignore\n * @cat display\n */\n\nexport \nclass GraphicsPath {\n  /**\n   * Creates new instance of GraphicsPath\n   */\n  constructor() {\n    /** @type {Rectangle|null} */\n    this.bounds = null\n\n    /** @type {Array<number>} */\n    this.points = []\n\n    /** @type {number} */\n    this.maxLineWidth = 0\n\n    /** @type {number} */\n    this.lastLineWidth = 0\n\n    /** @type {number} */\n    this.lineMul = 0.5\n  }\n}\n","/**\n * A base abstract class for graphics gradient fill.\n *\n * @ignore\n * @cat display\n */\n\nexport \nclass GraphicsGradient {\n  /**\n   * Creates new instance of GraphicsGradient\n   */\n  constructor() {\n    /** @type {Object} */\n    this.stops = {}\n\n    /** @type {CanvasGradient|null} */\n    this.native = null\n  }\n\n  /**\n   * Adds a new stop, defined by an offset and a color, to the gradient\n   *\n   * @param {number} offset A number between 0 and 1\n   * @param {string} color A CSS <color>.\n   *\n   * @return {void}\n   */\n  addColorStop(offset, color) {\n    this.stops[offset] = color\n    this.native = null\n  }\n}\n","/**\n * Linear gradient fill style for graphics.\n *\n * @ignore\n * @cat display\n */\n\nexport \nclass GraphicsLinearGradient extends GraphicsGradient {\n  /**\n   * Creates new instance of GraphicsLinearGradient\n   *\n   * @param {number} x0 The x axis of the coordinate of the start point.\n   * @param {number} y0 The y axis of the coordinate of the start point.\n   * @param {number} x1 The x axis of the coordinate of the end point.\n   * @param {number} y1 The y axis of the coordinate of the end point.\n   */\n  constructor(x0, y0, x1, y1) {\n    super()\n\n    /** @type {number} */\n    this.x0 = x0\n\n    /** @type {number} */\n    this.y0 = y0\n\n    /** @type {number} */\n    this.x1 = x1\n\n    /** @type {number} */\n    this.y1 = y1\n\n    /** @type {boolean} */\n    this.isAbsolute = false\n  }\n\n  /**\n   * @inheritDoc\n   */\n  addColorStop(percent, color) {\n    this.stops[percent] = color\n    this.native = null\n  }\n\n  /**\n   * Creates copy of this\n   *\n   * @return {GraphicsLinearGradient} New instance\n   */\n  clone() {\n    const g = new GraphicsLinearGradient(this.x0, this.y0, this.x1, this.y1)\n    g.isAbsolute = this.isAbsolute\n\n    for (let key in this.stops) {\n      g.stops[key] = this.stops[key]\n    }\n\n    return g\n  }\n}\n","/**\n * A pattern fill style class for Graphics.\n *\n * @ignore\n * @cat display\n */\n\nexport \nclass GraphicsPattern {\n  /**\n   * Creates new instance of GraphicsPattern\n   */\n  constructor(image, repetition) {\n    /** @type {HTMLImageElement | HTMLCanvasElement | HTMLVideoElement} */\n    this.image = image\n\n    /** @type {string} */\n    this.repetition = repetition\n\n    /** @type {CanvasPattern|null} */\n    this.native = null\n  }\n\n  /**\n   * Creates copy of this\n   *\n   * @return {GraphicsPattern} New instance\n   */\n  clone() {\n    return new GraphicsPattern(this.image, this.repetition)\n  }\n}\n","/**\n * A helper class for Graphics.\n *\n * @ignore\n * @cat display\n */\n\nexport \nclass GraphicsCommand {\n  /**\n   * Creates new instance of GraphicsCommand\n   *\n   * @param {GraphicsCommandType} type\n   * @param {Array<*>} data\n   */\n  constructor(type, data) {\n    /** @public @type {GraphicsCommandType} */\n    this.type = type\n\n    /** @public @type {Array<*>} */\n    this.data = data\n  }\n\n  /**\n   * Returns value at given index as a number. Used for GCC only.\n   * @param {number} ix\n   * @returns {number}\n   */\n  getNumber(ix) {\n    return /** @type {!number} */ (this.data[ix])\n  }\n\n  /**\n   * Returns value at given index as a string. Used for GCC only.\n   * @param {number} ix\n   * @returns {string}\n   */\n  getString(ix) {\n    return /** @type {!string} */ (this.data[ix])\n  }\n\n  /**\n   * Returns value at given index as a string. Used for GCC only.\n   * @param {number} ix\n   * @returns {boolean}\n   */\n  getBoolean(ix) {\n    return /** @type {!boolean} */ (this.data[ix])\n  }\n\n  /**\n   * Returns value at given index as an object. Used for GCC only.\n   * @param {number} ix\n   * @returns {Object}\n   */\n  getObject(ix) {\n    return /** @type {!Object} */ (this.data[ix])\n  }\n}\n","/**\n * Command to use in graphics\n * @cat display\n * @static\n * @constant\n * @enum {string}\n */\nexport \nconst GraphicsCommandType = {\n  LINE_STYLE: 'lineStyle',\n  FILL_STYLE: 'fillStyle',\n\n  ARC: 'arc',\n  RECT: 'rect',\n  ROUNDED_RECT: 'roundedRect',\n  BEZIER_CURVE_TO: 'bezierCurveTo',\n  QUADRATIC_CURVE_TO: 'quadraticCurveTo',\n  BEGIN_PATH: 'beginPath',\n  CLOSE_PATH: 'closePath',\n  FILL: 'fill',\n  LINE_TO: 'lineTo',\n  MOVE_TO: 'moveTo',\n  STROKE: 'stroke',\n  BOUNDS: 'bounds',\n\n  LINE_DASH: 'setLineDash',\n  FILL_GRD: 'gradientFillStyle',\n  FILL_PATTERN: 'patternFillStyle',\n}\n","/**\n * Caps style to use in drawing lines.\n * @cat display\n * @static\n * @constant\n * @enum {string}\n */\nexport \nconst CapsStyle = {\n  NONE: 'none',\n  ROUND: 'round',\n  SQUARE: 'square',\n}\n","/**\n * Joint style to use in drawing lines.\n * @cat display\n * @static\n * @constant\n * @enum {string}\n */\nexport \nconst JointStyle = {\n  BEVEL: 'bevel',\n  MITER: 'miter',\n  ROUND: 'round',\n}\n","/**\n * Fill Rule style to use on shapes fill.\n * @cat display\n * @static\n * @constant\n * @enum {string}\n */\nexport \nconst FillRule = {\n  NONE_ZERO: 'nonzero',\n  EVEN_ODD: 'evenodd',\n}\n","/**\n * Class that holds information about tiling,\n * @cat display\n */\nexport \nclass TilingInfo {\n  /**\n   * Creates new TilingInfo instance.\n   *\n   * @param {number} width  The width of destination texture.\n   * @param {number} height The height of destination texture.\n   * @param {number} scaleX Indicates how much source texture should be scaled along x-axis.\n   * @param {number} scaleY Indicates how much source texture should be scaled along y-axis.\n   * @param {number} wrapX  Indicates how many pixels needs to be wrapped around along x-axis.\n   * @param {number} wrapY  Indicates how many pixels needs to be wrapped around along y-axis.\n   */\n  constructor(\n    width = 0,\n    height = 0,\n    scaleX = 1,\n    scaleY = 1,\n    wrapX = 0,\n    wrapY = 0\n  ) {\n    /**\n     * The width of destination texture.\n     * @type {number}\n     */\n    this.width = width\n\n    /**\n     * The height of destination texture.\n     * @type {number}\n     */\n    this.height = height\n\n    /**\n     * Indicates how much source texture should be scaled along x-axis.\n     * @type {number}\n     */\n    this.scaleX = scaleX\n\n    /**\n     * Indicates how much source texture should be scaled along y-axis.\n     * @type {number}\n     */\n    this.scaleY = scaleY\n\n    /**\n     * Indicates how many pixels needs to be wrapped around along x-axis.\n     * @type {number}\n     */\n    this.wrapX = wrapX\n\n    /**\n     * Indicates how many pixels needs to be wrapped around along y-axis.\n     * @type {number}\n     */\n    this.wrapY = wrapY\n  }\n}\n","/**\n * Sprite is used to render Texture onto screen.\n *\n * @cat display\n * @extends DisplayObject\n */\nexport \nclass Sprite extends DisplayObject {\n  /**\n   * Creates a new Sprite instance.\n   *\n   * @param {Texture|string|null} texture The Texture instance or null.\n   */\n  constructor(texture = null) {\n    super()\n\n    /** @private @type {Texture|null} */\n    this.mTexture = null\n\n    /** @private @type {string|null} */\n    this.mTextureName = null\n\n    if (texture !== null && texture.constructor === String) {\n      this.mTextureName = /** @type {string} */ (texture)\n      this.mTexture = AssetManager.default.getTexture(\n        /** @type {string} */ (texture)\n      )\n    } else {\n      this.mTexture = /** @type {Texture} */ (texture)\n    }\n\n    /** @private @type {TilingInfo|null} */\n    this.mTiling = null\n\n    /** @private @type {Rectangle|null} */\n    this.mSlice9grid = null\n  }\n\n  /**\n   * @inheritDoc\n   */\n  getRenderer() {\n    return Black.driver.getRenderer('Sprite', this)\n  }\n\n  /**\n   * Returns a rectangle that completely encloses the object in local coordinate system.\n   *\n   * @protected\n   * @param {Rectangle=} outRect Rectangle to be returned.\n   * @return {Rectangle} The new Rectangle or outRect if it was passed as a param.\n   */\n  onGetLocalBounds(outRect = undefined) {\n    outRect = outRect || new Rectangle()\n\n    if (!this.mTexture) return outRect\n\n    if (this.mClipRect !== null) this.mClipRect.copyTo(outRect)\n    else if (this.tiling !== null)\n      outRect.set(0, 0, this.tiling.width, this.tiling.height)\n    else\n      outRect.set(0, 0, this.mTexture.displayWidth, this.mTexture.displayHeight)\n\n    return outRect\n  }\n\n  /**\n   * Returns the current Texture on this sprite.\n   *\n   * @return {Texture|null} The current texture set on this Sprite or null.\n   */\n  get texture() {\n    return this.mTexture\n  }\n\n  /**\n   * Sets the Texture on this sprite by name.\n   * Only AssetManager.default is used.\n   *\n   * @param {Texture|null} texture Texture to apply on.\n   * @return {void}\n   */\n  set texture(texture) {\n    if (this.mTexture === texture) return\n\n    this.mTexture = texture\n    this.setDirty(DirtyFlag.RENDER_CACHE, false)\n    this.setRenderDirty()\n  }\n\n  /**\n   * Returns the current texture name.\n   *\n   * @return {?string}\n   */\n  get textureName() {\n    return this.mTextureName\n  }\n\n  /**\n   * Sets the current texture by its name\n   *\n   * @param {?string} value\n   */\n  set textureName(value) {\n    if (this.mTextureName === value) return\n\n    this.mTextureName = value\n    this.texture = AssetManager.default.getTexture(\n      /** @type {string} */ (value)\n    )\n  }\n\n  /**\n   * Gets sets tiling information.\n   *\n   * NOTE: after changing one of TilingInfo properties make sure to call `setDirty(DirtyFlag.RENDER_CACHE)`.\n   *\n   * @returns {TilingInfo|null}\n   */\n  get tiling() {\n    return this.mTiling\n  }\n\n  /**\n   * @ignore\n   * @param {TilingInfo|null} value\n   */\n  set tiling(value) {\n    this.mTiling = value\n\n    this.setRenderDirty()\n    this.setDirty(DirtyFlag.RENDER_CACHE, false)\n  }\n\n  /**\n   * Gets/sets nine slice grid rectangle.\n   *\n   * NOTE: after changing x, y, width or height of nine slice grid attributes make sure to call `setDirty(DirtyFlag.RENDER_CACHE)` to refresh renderer.\n   *\n   * @returns {Rectangle|null}\n   */\n  get slice9grid() {\n    return this.mSlice9grid\n  }\n\n  /**\n   * @ignore\n   * @param {Rectangle|null} value\n   */\n  set slice9grid(value) {\n    this.mSlice9grid = value\n\n    this.setRenderDirty()\n    this.setDirty(DirtyFlag.RENDER_CACHE, false)\n  }\n}\n","/**\n * Holds TextField's style details.\n *\n * @cat display.text\n */\nexport \nclass TextStyle {\n  /**\n   * Creates instance of TextStyle.\n   * @param  {string=} family                                             Font name\n   * @param  {number=} [color=0x0]                                        Text color as hexadecimal number eg 0xff0000 (total red)\n   * @param  {number=} [size=14]                                          Text size\n   * @param  {TextStyle.FontStyle=} [style=TextStyle.FontStyle.NORMAL]    Text style eg italic\n   * @param  {TextStyle.FontWeight=} [weight=TextStyle.FontWeight.NORMAL] Font thickness. The value is set from 100 to 900 in increments of 100.\n   * @param  {number=} [strokeThickness=0]                                Thickness of the stroke. 0 means that no stroke\n   * @param  {number=} [strokeColor=0xffffff]                             Stroke color as hexadecimal number eg 0x00ff00 (total green)\n   */\n  constructor(\n    family = 'sans-serif',\n    color = 0x000000,\n    size = 14,\n    style = TextStyle.FontStyle.NORMAL,\n    weight = TextStyle.FontWeight.NORMAL,\n    strokeThickness = 0,\n    strokeColor = 0xffffff\n  ) {\n    /** @type {string} */\n    this.name = 'def'\n\n    /** @type {string} */\n    this.family = family\n\n    /** @type {number} */\n    this.size = size\n\n    /** @type {number} */\n    this.color = color\n\n    /** @type {TextStyle.FontStyle} */\n    this.style = style\n\n    /** @type {TextStyle.FontWeight} */\n    this.weight = weight\n\n    /** @type {number} */\n    this.strokeThickness = strokeThickness\n\n    /** @type {number} */\n    this.strokeColor = strokeColor\n\n    /** @type {boolean} */\n    this.dropShadow = false\n\n    /** @type {number} */\n    this.shadowDistanceX = 0\n\n    /** @type {number} */\n    this.shadowDistanceY = 0\n\n    /** @type {number} */\n    this.shadowColor = 0x0\n\n    /** @type {number} */\n    this.shadowAlpha = 1\n\n    /** @type {number} */\n    this.shadowBlur = 0\n  }\n\n  clone(\n    family = null,\n    color = NaN,\n    size = NaN,\n    style = null,\n    weight = null,\n    strokeThickness = NaN,\n    strokeColor = NaN\n  ) {\n    let ret = new TextStyle()\n    ret.family = family === null ? this.family : family\n    ret.size = isNaN(size) ? this.size : size\n    ret.color = isNaN(color) ? this.color : color\n    ret.style = style === null ? this.style : style\n    ret.weight = weight === null ? this.weight : weight\n    ret.strokeThickness = isNaN(strokeThickness)\n      ? this.strokeThickness\n      : strokeThickness\n    ret.strokeColor = isNaN(strokeColor) ? this.strokeColor : strokeColor\n\n    ret.dropShadow = this.dropShadow\n    ret.shadowAlpha = this.shadowAlpha\n    ret.shadowBlur = this.shadowBlur\n    ret.shadowColor = this.shadowColor\n    ret.shadowDistanceX = this.shadowDistanceX\n    ret.shadowDistanceY = this.shadowDistanceY\n\n    return ret\n  }\n}\n\n/**\n * @cat display.text\n * @static\n * @constant\n * @enum {string}\n */\nTextStyle.FontStyle = {\n  NORMAL: 'normal',\n  ITALIC: 'italic',\n}\n\n/**\n * @cat display.text\n * @static\n * @constant\n * @enum {string}\n */\nTextStyle.FontWeight = {\n  NORMAL: '400',\n  BOLD: '700',\n}\n\n/**\n * @cat display.text\n * @static\n * @constant\n * @enum {string}\n */\nTextStyle.FontAlign = {\n  NONE: 'none',\n  LEFT: 'left',\n  RIGHT: 'right',\n  CENTER: 'center',\n}\n\n/**\n * @cat display.text\n * @static\n * @constant\n * @enum {string}\n */\nTextStyle.FontVerticalAlign = {\n  TOP: 'top',\n  MIDDLE: 'middle',\n  BOTTOM: 'bottom',\n}\n\n/** @static @readonly @type {TextStyle} */\nTextStyle.default = new TextStyle(\n  'sans-serif',\n  0x0,\n  14,\n  TextStyle.FontStyle.NORMAL,\n  TextStyle.FontWeight.NORMAL,\n  0,\n  0x0\n)\n","/**\n * This class is used to create display text.\n *\n * @cat display.text\n * @fires TextField#change\n * @extends DisplayObject\n */\nexport \nclass TextField extends DisplayObject {\n  /**\n   * Creates new instance of TextField\n   *\n   * @param {string=} [text=''] Text to be displayed inside this text field\n   * @param  {string=} family                                             Font name\n   * @param  {number=} [color=0x0]                                        Text color as hexadecimal number eg 0xff0000 (total red)\n   * @param  {number=} [size=14]                                          Text size\n   * @param  {TextStyle.FontStyle=} [style=TextStyle.FontStyle.NORMAL]    Text style eg italic\n   * @param  {TextStyle.FontWeight=} [weight=TextStyle.FontWeight.NORMAL] Font thickness. The value is set from 100 to 900 in increments of 100.\n   * @param  {number=} [strokeThickness=0]                                Thickness of the stroke. 0 means that no stroke\n   * @param  {number=} [strokeColor=0xffffff]                             Stroke color as hexadecimal number eg 0x00ff00 (total green)\n   */\n  constructor(\n    text = '',\n    family = 'sans-serif',\n    color = 0x000000,\n    size = 14,\n    style = TextStyle.FontStyle.NORMAL,\n    weight = TextStyle.FontWeight.NORMAL,\n    strokeThickness = 0,\n    strokeColor = 0xffffff\n  ) {\n    super()\n\n    /** @private @type {string} */\n    this.mText = text\n\n    /** @private @type {Rectangle} */\n    this.mCacheBounds = new Rectangle()\n\n    /** @private @type {number} */\n    this.mTextWidth = 0\n\n    /** @private @type {number} */\n    this.mTextHeight = 0\n\n    /** @private @type {TextStyle} */\n    this.mDefaultStyle = new TextStyle(\n      family,\n      color,\n      size,\n      style,\n      weight,\n      strokeThickness,\n      strokeColor\n    )\n\n    /** @private @type {Object.<string,TextStyle>} */\n    this.mStyles = {}\n\n    /** @private @type {boolean} */\n    this.mAutoSize = true\n\n    /** @private @type {TextStyle.FontAlign} */\n    this.mAlign = TextStyle.FontAlign.LEFT\n\n    /** @private @type {TextStyle.FontVerticalAlign} */\n    this.mVerticalAlign = TextStyle.FontVerticalAlign.MIDDLE\n\n    /** @private @type {boolean} */\n    this.mMultiline = false\n\n    /** @private @type {number} */\n    this.mLineHeight = 1.2\n\n    /** @private @type {Rectangle} */\n    this.mTextBounds = new Rectangle()\n\n    /** @private @type {number} */\n    this.mFieldWidth = 0\n\n    /** @private @type {number} */\n    this.mFieldHeight = 0\n\n    /** @private @type {Rectangle} */\n    this.mPadding = new Rectangle(0, 0, 0, 0)\n\n    /** @private @type {TextMetricsData|null} */\n    this.mMetrics = null\n\n    /** @private @type {boolean} */\n    this.mHighQuality = false\n  }\n\n  /**\n   * @inheritDoc\n   */\n  getRenderer() {\n    return Black.driver.getRenderer('Text', this)\n  }\n\n  /**\n   * @inheritDoc\n   */\n  onGetLocalBounds(outRect = undefined) {\n    outRect = outRect || new Rectangle()\n\n    if (this.mDirty & DirtyFlag.RENDER_CACHE) {\n      let text = this.text\n      if (this.mMultiline === false) text = text.replace(/\\n/g, '')\n\n      let styles = [this.mDefaultStyle]\n\n      for (let key in /** @type {!Object} */ (this.mStyles)) {\n        styles.push(this.mStyles[key])\n      }\n\n      this.mMetrics = TextMetricsEx.measure(text, this.mLineHeight, ...styles)\n      this.mTextBounds.copyFrom(this.mMetrics.bounds)\n    }\n\n    if (this.mClipRect !== null) {\n      this.mClipRect.copyTo(outRect)\n      return outRect\n    }\n\n    if (this.mAutoSize === false) {\n      outRect.width = this.mFieldWidth\n      outRect.height = this.mFieldHeight\n    } else {\n      outRect.width = this.mTextBounds.width\n      outRect.height = this.mTextBounds.height\n    }\n\n    outRect.width += this.mPadding.right\n    outRect.height += this.mPadding.bottom\n\n    return outRect\n  }\n\n  /**\n   * Adds or updates given text style by given tag name.\n   *\n   * @param {string} name\n   * @param {TextStyle} style\n   */\n  setStyle(name, style) {\n    Debug.assert(name !== 'def', `Please use 'setDefaultStyle' instead.`)\n    style.name = name\n\n    this.mStyles[name] = style\n\n    this.setDirty(DirtyFlag.RENDER_CACHE, false)\n    this.setTransformDirty()\n  }\n\n  /**\n   * Updates default text style with a given one.\n   *\n   * @param {TextStyle} style\n   */\n  setDefaultStyle(style) {\n    this.mDefaultStyle = style\n\n    this.setDirty(DirtyFlag.RENDER_CACHE, false)\n    this.setTransformDirty()\n  }\n\n  /**\n   * Removes style by given name.\n   *\n   * @param {string} name\n   */\n  removeStyle(name) {\n    delete this.mStyles[name]\n\n    this.setDirty(DirtyFlag.RENDER_CACHE, false)\n    this.setTransformDirty()\n  }\n\n  /**\n   * Returns text style by given name or null if not found.\n   *\n   * @param {string} name\n   * @return {TextStyle}\n   */\n  getStyle(name) {\n    return this.mStyles.hasOwnProperty(name) ? this.mStyles[name] : null\n  }\n\n  /**\n   * Returns an array of all not default styles.\n   *\n   * @return {Array<TextStyle>}\n   */\n  getAllStyles() {\n    let styles = []\n    for (let s in this.mStyles) styles.push(this.mStyles[s])\n    return styles\n  }\n\n  /**\n   * Returns default text style.\n   */\n  getDefaultStyle(name) {\n    return this.mDefaultStyle\n  }\n\n  /**\n   * @ignore\n   * @param {boolean} value\n   * @return {void}\n   */\n  set multiline(value) {\n    this.mMultiline = value\n\n    this.setDirty(DirtyFlag.RENDER_CACHE, false)\n    this.setTransformDirty()\n  }\n\n  /**\n   * Get/Set multiLine value switcher.\n   *\n   * @return {boolean}\n   */\n  get multiline() {\n    return this.mMultiline\n  }\n\n  /**\n   * @ignore\n   * @param {number} value\n   * @return {void}\n   */\n  set lineHeight(value) {\n    this.mLineHeight = value\n\n    this.setDirty(DirtyFlag.RENDER_CACHE, false)\n    this.setTransformDirty()\n  }\n\n  /**\n   * Get/Set lines vertical offset. From top previous to top next line.\n   *\n   * @return {number}\n   */\n  get lineHeight() {\n    return this.mLineHeight\n  }\n\n  /**\n   * Get/Set text size.\n   *\n   * @return {number}\n   */\n  get size() {\n    return this.mDefaultStyle.size\n  }\n\n  /**\n   * @ignore\n   * @param {number} value\n   * @return {void}\n   */\n  set size(value) {\n    if (this.mDefaultStyle.size === value) return\n\n    this.mDefaultStyle.size = value\n\n    this.setDirty(DirtyFlag.RENDER_CACHE, false)\n    this.setTransformDirty()\n  }\n\n  /**\n   * Get/Set text font.\n   *\n   * @return {string}\n   */\n  get font() {\n    return this.mDefaultStyle.family\n  }\n\n  /**\n   * @ignore\n   * @param {string} value\n   * @return {void}\n   */\n  set font(value) {\n    if (this.mDefaultStyle.family === value) return\n\n    this.mDefaultStyle.family = value\n\n    this.setDirty(DirtyFlag.RENDER_CACHE, false)\n    this.setTransformDirty()\n  }\n\n  /**\n   * Specifies text color as hexadecimal number eg 0xff0000 (total red)\n   *\n   * @return {number}\n   */\n  get color() {\n    return this.mDefaultStyle.color\n  }\n\n  /**\n   * @ignore\n   * @param {number} value\n   * @return {void}\n   */\n  set color(value) {\n    if (this.mDefaultStyle.color === value) return\n\n    this.mDefaultStyle.color = value\n\n    this.setDirty(DirtyFlag.RENDER_CACHE, false)\n    this.setTransformDirty()\n  }\n\n  /**\n   * Get/Set text style.\n   *\n   * @return {TextStyle.FontStyle}\n   */\n  get fontStyle() {\n    return this.mDefaultStyle.style\n  }\n\n  /**\n   * @ignore\n   * @param {TextStyle.FontStyle} value\n   * @return {void}\n   */\n  set fontStyle(value) {\n    if (this.mDefaultStyle.style === value) return\n\n    this.mDefaultStyle.style = value\n\n    this.setDirty(DirtyFlag.RENDER_CACHE, false)\n    this.setTransformDirty()\n  }\n\n  /**\n   * Specifies the font thick. The value is set from 100 to 900 in increments of 100.\n   *\n   * @return {TextStyle.FontWeight}\n   */\n  get weight() {\n    return this.mDefaultStyle.weight\n  }\n\n  /**\n   * @ignore\n   * @param {TextStyle.FontWeight} value\n   * @return {void}\n   */\n  set weight(value) {\n    if (this.mDefaultStyle.weight === value) return\n\n    this.mDefaultStyle.weight = value\n\n    this.setDirty(DirtyFlag.RENDER_CACHE, false)\n    this.setTransformDirty()\n  }\n\n  /**\n   * Specifies the horizontal alignment of the text (left | center | right).\n   *\n   * @return {TextStyle.FontAlign}\n   */\n  get align() {\n    return this.mAlign\n  }\n\n  /**\n   * @ignore\n   * @param {TextStyle.FontAlign} value\n   * @return {void}\n   */\n  set align(value) {\n    if (this.mAlign === value) return\n\n    this.mAlign = value\n\n    this.setDirty(DirtyFlag.RENDER_CACHE, false)\n    this.setTransformDirty()\n  }\n\n  /**\n   * Specifies the vertical alignment of the text (top | middle | bottom).\n   *\n   * @return {TextStyle.FontVerticalAlign}\n   */\n  get vAlign() {\n    return this.mVerticalAlign\n  }\n\n  /**\n   * @ignore\n   * @param {TextStyle.FontVerticalAlign} value\n   * @return {void}\n   */\n  set vAlign(value) {\n    if (this.mVerticalAlign === value) return\n\n    this.mVerticalAlign = value\n\n    this.setDirty(DirtyFlag.RENDER_CACHE, false)\n    this.setTransformDirty()\n  }\n\n  /**\n   * Specifies stroke color as hexadecimal number eg 0xff0000 (total red)\n   * @return {number}\n   */\n  get strokeColor() {\n    return this.mDefaultStyle.strokeColor\n  }\n\n  /**\n   * @ignore\n   * @param {number} value\n   * @return {void}\n   */\n  set strokeColor(value) {\n    if (this.mDefaultStyle.strokeColor === value) return\n\n    this.mDefaultStyle.strokeColor = value\n    this.setDirty(\n      /** @type {DirtyFlag} */ (DirtyFlag.RENDER_CACHE | DirtyFlag.RENDER),\n      false\n    )\n  }\n\n  /**\n   * Specifies the thickness of the stroke. 0 means that no stroke.\n   * Note: if autoSize is true stroke works like filter meaning that position of the text will not be adjusted and bounds will be the same.\n   *\n   * @return {number}\n   */\n  get strokeThickness() {\n    return this.mDefaultStyle.strokeThickness\n  }\n\n  /**\n   * @ignore\n   * @param {number} value\n   * @return {void}\n   */\n  set strokeThickness(value) {\n    if (value === this.mDefaultStyle.strokeThickness) return\n\n    this.mDefaultStyle.strokeThickness = value\n    this.setDirty(\n      /** @type {DirtyFlag} */ (DirtyFlag.RENDER_CACHE | DirtyFlag.RENDER),\n      false\n    )\n  }\n\n  /**\n   * Specifies the width of the text field. If autoSize set as false\n   *\n   * @return {number}\n   */\n  get fieldWidth() {\n    return this.mFieldWidth\n  }\n\n  /**\n   * @ignore\n   * @param {number} value\n   * @return {void}\n   */\n  set fieldWidth(value) {\n    if (value === this.mFieldWidth) return\n\n    this.mFieldWidth = value\n\n    this.setDirty(DirtyFlag.RENDER_CACHE, false)\n    this.setTransformDirty()\n  }\n\n  /** Specifies the height of the text field, if autoSize set as false\n   *\n   * @return {number}\n   */\n  get fieldHeight() {\n    return this.mFieldHeight\n  }\n\n  /**\n   * @ignore\n   * @param {number} value\n   * @return {void}\n   */\n  set fieldHeight(value) {\n    if (value === this.mFieldHeight) return\n\n    this.mFieldHeight = value\n\n    this.setDirty(DirtyFlag.RENDER_CACHE, false)\n    this.setTransformDirty()\n  }\n\n  /**Text to be displayed inside this text field.\n\n   * @return {string}\n   */\n  get text() {\n    return this.mText\n  }\n\n  /**\n   * @ignore\n   * @param {string} value\n   * @return {void}\n   */\n  set text(value) {\n    if (this.mText === value) return\n\n    this.mText = value\n\n    this.setDirty(DirtyFlag.RENDER_CACHE, false)\n    this.setTransformDirty()\n\n    /**\n     * Posts every time text has been changed.\n     * @event TextField#change\n     */\n    this.post(Message.CHANGE)\n  }\n\n  /**\n   * Determines whether the size of the field will adjust to the size of the text. Note: if this set as true, you need to specify fieldHeight and fieldWidth manually\n   *\n   * @return {boolean}\n   */\n  get autoSize() {\n    return this.mAutoSize\n  }\n\n  /**\n   * @ignore\n   * @param {boolean} value\n   * @return {void}\n   */\n  set autoSize(value) {\n    if (this.mAutoSize === value) return\n\n    this.mAutoSize = value\n\n    this.setDirty(DirtyFlag.RENDER_CACHE, false)\n    this.setTransformDirty()\n  }\n\n  /**\n   * An extra padding. Also useful for bad prepared fonts.\n   *\n   * @return {Rectangle}\n   */\n  get padding() {\n    return this.mPadding\n  }\n\n  /**\n   * @ignore\n   * @param {Rectangle} value\n   * @return {void}\n   */\n  set padding(value) {\n    this.mPadding = value\n\n    this.setDirty(DirtyFlag.RENDER_CACHE, false)\n    this.setTransformDirty()\n  }\n\n  /**\n   * Gets sets whenever to drop shadow or not.\n   *\n   * @return {boolean}\n   */\n  get dropShadow() {\n    return this.mDefaultStyle.dropShadow\n  }\n\n  /**\n   * @ignore\n   * @param {boolean} value\n   * @return {void}\n   */\n  set dropShadow(value) {\n    if (value === this.mDefaultStyle.dropShadow) return\n\n    this.mDefaultStyle.dropShadow = value\n\n    this.setDirty(DirtyFlag.RENDER_CACHE, false)\n    this.setTransformDirty()\n  }\n\n  /**\n   * Gets/sets the color of the shadow.\n   *\n   * @return {number}\n   */\n  get shadowColor() {\n    return this.mDefaultStyle.shadowColor\n  }\n\n  /**\n   * @ignore\n   * @param {number} value\n   * @return {void}\n   */\n  set shadowColor(value) {\n    if (value === this.mDefaultStyle.shadowColor) return\n\n    this.mDefaultStyle.shadowColor = value\n    this.setDirty(\n      /** @type {DirtyFlag} */ (DirtyFlag.RENDER_CACHE | DirtyFlag.RENDER),\n      false\n    )\n  }\n\n  /**\n   * Gets/sets alpha component of the shadows.\n   *\n   * @return {number}\n   */\n  get shadowAlpha() {\n    return this.mDefaultStyle.shadowAlpha\n  }\n\n  /**\n   * @ignore\n   * @param {number} value\n   * @return {void}\n   */\n  set shadowAlpha(value) {\n    if (value === this.mDefaultStyle.shadowAlpha) return\n\n    this.mDefaultStyle.shadowAlpha = value\n    this.setDirty(\n      /** @type {DirtyFlag} */ (DirtyFlag.RENDER_CACHE | DirtyFlag.RENDER),\n      false\n    )\n  }\n\n  /**\n   * Gets/sets the shadow blur radius.\n   *\n   * @return {number}\n   */\n  get shadowBlur() {\n    return this.mDefaultStyle.shadowBlur\n  }\n\n  /**\n   * @ignore\n   * @param {number} value\n   * @return {void}\n   */\n  set shadowBlur(value) {\n    if (value === this.mDefaultStyle.shadowBlur) return\n\n    this.mDefaultStyle.shadowBlur = value\n    this.setDirty(\n      /** @type {DirtyFlag} */ (DirtyFlag.RENDER_CACHE | DirtyFlag.RENDER),\n      false\n    )\n  }\n\n  /**\n   * Gets/sets shadow distance on x axis.\n   *\n   * @return {number}\n   */\n  get shadowDistanceX() {\n    return this.mDefaultStyle.shadowDistanceX\n  }\n\n  /**\n   * @ignore\n   * @param {number} value\n   * @return {void}\n   */\n  set shadowDistanceX(value) {\n    if (value === this.mDefaultStyle.shadowDistanceX) return\n\n    this.mDefaultStyle.shadowDistanceX = value\n    this.setDirty(\n      /** @type {DirtyFlag} */ (DirtyFlag.RENDER_CACHE | DirtyFlag.RENDER),\n      false\n    )\n  }\n\n  /**\n   * Gets/sets shadow distance on y axis.\n   *\n   * @return {number}\n   */\n  get shadowDistanceY() {\n    return this.mDefaultStyle.shadowDistanceY\n  }\n\n  /**\n   * @ignore\n   * @param {number} value\n   * @return {void}\n   */\n  set shadowDistanceY(value) {\n    if (value === this.mDefaultStyle.shadowDistanceY) return\n\n    this.mDefaultStyle.shadowDistanceY = value\n    this.setDirty(\n      /** @type {DirtyFlag} */ (DirtyFlag.RENDER_CACHE | DirtyFlag.RENDER),\n      false\n    )\n  }\n\n  /**\n   * Gets/sets render quality of this text field. False by default.\n   * When true font will respect object's scale and device pixel ratio. The downside is it may cause font shaking when animating.\n   *\n   * @returns {boolean}\n   */\n  get highQuality() {\n    return this.mHighQuality\n  }\n\n  /**\n   * @ignore\n   * @param {boolean} value\n   * @return {void}\n   */\n  set highQuality(value) {\n    this.mHighQuality = value\n\n    this.setDirty(DirtyFlag.RENDER_CACHE, false)\n    this.setTransformDirty()\n  }\n}\n\n/**\n * @ignore\n * @private\n * @static\n */\nTextField.__cache = null\n","/**\n * This class is used to create display text.\n *\n * @cat display.text\n * @extends DisplayObject\n */\nexport \nclass BitmapTextField extends DisplayObject {\n  /**\n   * Create new instance of BitmapTextField.\n   *\n   * @param {string|BitmapFontData} font     The name of the bitmap font\n   * @param {string=} text                   Text to be displayed inside this text field\n   */\n  constructor(font, text = '') {\n    super()\n\n    if (font !== null && font.constructor === String)\n      this.mData = AssetManager.default.getBitmapFont(\n        /** @type {string} */ (font)\n      )\n    else this.mData = /** @type {BitmapFontData} */ (font)\n\n    /** @private @type {string} */\n    this.mText = text\n\n    /** @private @type {boolean} */\n    this.mAutoSize = true\n\n    /** @private @type {boolean} */\n    this.mMultiline = false\n\n    /** @private @type {number} */\n    this.mLineHeight = 1.2\n\n    /** @private @type {Rectangle} */\n    this.mBounds = new Rectangle()\n\n    /** @private @type {Rectangle} */\n    this.mTextBounds = new Rectangle()\n\n    /** @private @type {number} */\n    this.mFieldWidth = 0\n\n    /** @private @type {number} */\n    this.mFieldHeight = 0\n  }\n\n  /**\n   * @inheritDoc\n   */\n  getRenderer() {\n    return Black.driver.getRenderer('BitmapText', this)\n  }\n\n  /**\n   * @inheritDoc\n   */\n  onGetLocalBounds(outRect = undefined) {\n    outRect = outRect || new Rectangle()\n\n    if (this.mClipRect !== null) {\n      this.mClipRect.copyTo(outRect)\n      return outRect\n    }\n\n    if (this.mDirty & DirtyFlag.RENDER_CACHE) {\n      let text = this.text\n      if (this.mMultiline === false) text = text.replace(/\\n/g, '')\n\n      TextMetricsEx.measureBitmap(\n        text,\n        this.mData,\n        this.mLineHeight,\n        this.mTextBounds\n      )\n    }\n\n    if (this.mAutoSize === false) {\n      outRect.width = this.mFieldWidth\n      outRect.height = this.mFieldHeight\n    } else {\n      outRect.width = this.mTextBounds.width\n      outRect.height = this.mTextBounds.height\n    }\n\n    return outRect\n  }\n\n  /**\n   * @ignore\n   * @param {boolean} value\n   * @return {void}\n   */\n  set multiline(value) {\n    this.mMultiline = value\n    this.setDirty(DirtyFlag.RENDER_CACHE, false)\n  }\n\n  /**\n   * Get/Set multiLine value switcher.\n   *\n   * @return {boolean}\n   */\n  get multiline() {\n    return this.mMultiline\n  }\n\n  /**\n   * @ignore\n   * @param {number} value\n   * @return {void}\n   */\n  set lineHeight(value) {\n    this.mLineHeight = value\n    this.setDirty(DirtyFlag.RENDER_CACHE, false)\n  }\n\n  /**\n   * Get/Set lines vertical offset. From top previous to top next line.\n   *\n   * @return {number}\n   */\n  get lineHeight() {\n    return this.mLineHeight\n  }\n\n  /**\n   * Specifies the width of the text field. If autoSize set as false\n   *\n   * @return {number}\n   */\n  get fieldWidth() {\n    return this.mFieldWidth\n  }\n\n  /**\n   * @ignore\n   * @param {number} value\n   * @return {void}\n   */\n  set fieldWidth(value) {\n    if (value === this.mFieldWidth) return\n\n    this.mFieldWidth = value\n    this.setDirty(DirtyFlag.RENDER_CACHE, false)\n  }\n\n  /** Specifies the height of the text field, if autoSize set as false\n   *\n   * @return {number}\n   */\n  get fieldHeight() {\n    return this.mFieldHeight\n  }\n\n  /**\n   * @ignore\n   * @param {number} value\n   * @return {void}\n   */\n  set fieldHeight(value) {\n    if (value === this.mFieldHeight) return\n\n    this.mFieldHeight = value\n    this.setDirty(DirtyFlag.RENDER_CACHE, false)\n  }\n\n  /**Text to be displayed inside this text field.\n\n   * @return {string}\n   */\n  get text() {\n    return this.mText\n  }\n\n  /**\n   * @ignore\n   * @param {string} value\n   * @return {void}\n   */\n  set text(value) {\n    if (this.mText === value) return\n\n    this.mText = value\n    this.setDirty(DirtyFlag.RENDER_CACHE, false)\n  }\n\n  /**\n   * Determines whether the size of the field will adjust to the size of the text. Note: if this set as true, you need to specify fieldHeight and fieldWidth manually\n   *\n   * @return {boolean}\n   */\n  get autoSize() {\n    return this.mAutoSize\n  }\n\n  /**\n   * @ignore\n   * @param {boolean} value\n   * @return {void}\n   */\n  set autoSize(value) {\n    if (this.mAutoSize === value) return\n\n    this.mAutoSize = value\n    this.setDirty(DirtyFlag.RENDER_CACHE, false)\n  }\n}\n\n/**\n * @ignore\n * @static\n * @private\n */\nTextField.__cache = null\n","/**\n * Contains system functions.\n * @static\n * @cat system\n */\nexport \nclass Device {\n  /**\n   * Static class.\n   */\n  constructor() {\n    /**\n     * @private\n     * @type {Device}\n     */\n    Device.mInstance = this\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.mPixelRatio = 0\n\n    Device.mInstance.mPixelRatio = Device.getDevicePixelRatio()\n  }\n\n  /**\n   * Returns current OS name.\n   *\n   * @return {string}\n   */\n  static get os() {\n    let userAgent = navigator.userAgent || navigator.vendor || window.opera\n\n    if (/windows phone/i.test(userAgent)) return 'Windows Phone'\n\n    if (/android/i.test(userAgent)) return 'Android'\n\n    if (/iPad|iPhone|iPod/.test(userAgent) /* && !window.MSStream*/)\n      return 'iOS'\n\n    return 'unknown'\n  }\n\n  /**\n   * Returns True if touch screen is present.\n   *\n   * @return {boolean}\n   */\n  static get isTouch() {\n    let hasEvent = 'ontouchstart' in window\n    if (hasEvent) return true\n\n    if (navigator.maxTouchPoints > 0) return true\n\n    return false\n  }\n\n  /**\n   * Returns True if engine is running on mobile device.\n   *\n   * @return {boolean}\n   */\n  static get isMobile() {\n    return /Mobi/.test(navigator.userAgent)\n  }\n\n  /**\n   * Returns screen pixel ratio.\n   *\n   * @return {number}\n   */\n  static get pixelRatio() {\n    return Device.mInstance.mPixelRatio\n  }\n\n  /**\n   * Returns true if web audio is supported.\n   *\n   * @return {boolean}\n   */\n  static get webAudioSupported() {\n    return (\n      window['AudioContext'] != null || window['webkitAudioContext'] != null\n    )\n  }\n\n  /**\n   * Returns device pixel ratio.\n   *\n   * @static\n   * @suppress {missingProperties}\n   * @return {number} Description\n   */\n  static getDevicePixelRatio() {\n    if (\n      window.screen.systemXDPI !== undefined &&\n      window.screen.logicalXDPI !== undefined &&\n      window.screen.systemXDPI > window.screen.logicalXDPI\n    )\n      return window.screen.systemXDPI / window.screen.logicalXDPI\n    else if (window.devicePixelRatio !== undefined)\n      return window.devicePixelRatio\n\n    return 1\n  }\n\n  /**\n   * Returns true if device is in landscape orientation.\n   *\n   * @public\n   * @readonly\n   * @returns {boolean}\n   */\n  static get isLandscape() {\n    let size = Black.instance.viewport.size\n    return size.width >= size.height\n  }\n\n  /**\n   * Returns true if device is in portrait orientation.\n   *\n   * @public\n   * @readonly\n   * @returns {boolean}\n   */\n  static get isPortrait() {\n    return !Device.isLandscape\n  }\n}\n\n/**\n * @private\n * @type {Device}\n * @nocollapse\n */\nDevice.mInstance = null\n","/**\n * Base class for distribution objects.\n *\n * @cat scatters\n */\nexport \nclass Scatter {\n  /**\n   * Creates new Scatter instance.\n   */\n  constructor() {}\n\n  /**\n   * Returns random value.\n   *\n   * @return {?} Any object.\n   */\n  getValue() {\n    return this.getValueAt(Math.random())\n  }\n\n  /**\n   * Returns value at given position.\n   *\n   * @param {number} t Position to get value at.\n   * @return {?} Any object.\n   */\n  getValueAt(t) {}\n}\n","/**\n * A number scatter for defining a range in 1D space.\n *\n * @cat scatters\n * @extends Scatter\n */\nexport \nclass FloatScatter extends Scatter {\n  /**\n   * Creates new FloatScatter instance.\n   *\n   * @param {number}      min             The min value along x-axis.\n   * @param {number}      [max=undefined] The max value along x-axis.\n   * @param {?function(number):number} [ease=null]     Easing function.\n   */\n  constructor(min, max = NaN, ease = null) {\n    super()\n\n    /**\n     * A min value.\n     * @type {number}\n     */\n    this.min = min\n\n    /**\n     * A max value.\n     * @type {number}\n     */\n    this.max = isNaN(max) ? min : max\n\n    /**\n     * Optional easing function.\n     * @type {?function(number):number}\n     */\n    this.ease = ease\n\n    /**\n     * Cached last value of `getValueAt` result.\n     * @readonly\n     * @type {number}\n     */\n    this.value = 0\n  }\n\n  /**\n   * Returns value at given position within defined range.\n   *\n   * @override\n   * @param {number} t The position.\n   * @return {number} Number at given position.\n   */\n  getValueAt(t) {\n    if (this.ease !== null) t = this.ease(t)\n\n    this.value = this.min + t * (this.max - this.min)\n    return this.value\n  }\n\n  /**\n   * Creates new FloatScatter from a set of numbers.\n   *\n   * @param {...number|FloatScatter} values Set of values.\n   * @returns {FloatScatter}\n   */\n  static fromObject(...values) {\n    if (values[0] instanceof FloatScatter)\n      return /** @type {FloatScatter} */ (values[0])\n\n    return new FloatScatter(...values)\n  }\n}\n","export \nclass ColorScatter extends Scatter {\n  constructor(color1, color2 = NaN, ease = null) {\n    super()\n\n    this.color1 = color1\n    this.color2 = isNaN(color2) ? color1 : color2\n    this.ease = ease\n    this.value = color1\n  }\n\n  getValueAt(t) {\n    if (this.ease !== null) t = this.ease(t)\n\n    this.value =\n      this.color1 === this.color2\n        ? this.color1\n        : ColorHelper.lerpHSV(this.color1, this.color2, t)\n    return this.value\n  }\n\n  /**\n   * Creates new ColorScatter from a set of numbers.\n   *\n   * @param {...number|ColorScatter} values Set of values.\n   * @returns {ColorScatter}\n   */\n  static fromObject(...values) {\n    if (values[0] instanceof ColorScatter)\n      return /** @type {ColorScatter} */ (values[0])\n\n    return new ColorScatter(...values)\n  }\n}\n","/**\n * A number scatter for defining a range in 2D space.\n *\n * @cat scatters\n * @extends Scatter\n */\nexport \nclass VectorScatter extends Scatter {\n  /**\n   * Creates new VectorScatter instance.\n   *\n   * @param {number} minX The min value along x-axis.\n   * @param {number} minY The min value along y-axis.\n   * @param {number=} [maxX=NaN] The max value along x-axis.\n   * @param {number=} [maxY=NaN] The max value along y-axis.\n   */\n  constructor(minX, minY, maxX = NaN, maxY = NaN) {\n    super()\n\n    /**\n     * A min value along x-axis.\n     * @type {number}\n     */\n    this.minX = minX\n\n    /**\n     * A min value along y-axis.\n     * @type {number}\n     */\n    this.minY = minY\n\n    /**\n     * A max value along x-axis.\n     * @type {number}\n     */\n    this.maxX = isNaN(maxX) ? minX : maxX\n\n    /**\n     * A max value along y-axis.\n     * @type {number}\n     */\n    this.maxY = isNaN(maxY) ? minY : maxY\n\n    /**\n     * Cached last value of `getValueAt` result.\n     * @readonly\n     * @type {Vector}\n     */\n    this.value = new Vector()\n  }\n\n  /**\n   * Returns a random Vector object at given position within a range specified in the constructor.\n   *\n   * @override\n   * @return {Vector} Vector object with random values withing defined range.\n   */\n  getValue() {\n    this.value.x = Math.random() * (this.maxX - this.minX) + this.minX\n    this.value.y = Math.random() * (this.maxY - this.minY) + this.minY\n    return this.value\n  }\n\n  /**\n   * Returns a Vector object at given position.\n   *\n   * @override\n   * @param {number} t The position.\n   * @return {Vector} Vector object representing values in a range at given position.\n   */\n  getValueAt(t) {\n    this.value.x = this.minX + t * (this.maxX - this.minX)\n    this.value.y = this.minY + t * (this.maxY - this.minY)\n    return this.value\n  }\n\n  /**\n   * Creates new FloatScatter from a set of numbers.\n   *\n   * @param {...number|VectorScatter} values Set of values.\n   * @returns {VectorScatter}\n   */\n  static fromObject(...values) {\n    if (values[0] instanceof Scatter)\n      return /** @type {VectorScatter} */ (values[0])\n\n    return new VectorScatter(...values)\n  }\n}\n","/**\n * Sets particle's starting velocity.\n *\n * @cat scatters\n * @extends Scatter\n */\nexport \nclass VectorCurveScatter extends Scatter {\n  /**\n   * Creates new VectorCurveScatter instance.\n   *\n   * @param {...number} points Coordinates: startX, startY, cpStartX, cpStartY, cpEndX, cpEndY, endX/start2X, endY/start2Y, cp2StartX, cp2StartX... 8 or 14 or 20...\n   */\n  constructor(...points) {\n    super()\n\n    /** @private @type {Curve} */\n    this.mCurve = new Curve()\n    this.mCurve.baked = true\n    this.mCurve.set(...points)\n\n    /** @private @type {Vector} */\n    this.mCache = new Vector()\n  }\n\n  /**\n   * Returns a Vector at given position on a curve.\n   *\n   * @override\n   * @param {number} t The position.\n   * @return {Vector} Vector object representing a value on a curve at given position.\n   */\n  getValueAt(t) {\n    this.mCurve.interpolate(t, this.mCache)\n    return this.mCache\n  }\n}\n","/**\n * A number scatter for defining a range in a circular shape.\n *\n * @cat scatters\n * @extends VectorScatter\n */\nexport \nclass RadialScatter extends VectorScatter {\n  /**\n   * Creates new VectorScatter instance.\n   *\n   * @param {number} x The center of a circle along x-axis.\n   * @param {number} y The center of a circle along y-axis.\n   * @param {number} minRadius The min radius value.\n   * @param {number} [maxRadius=NaN] The max radius value.\n   */\n  constructor(x, y, minRadius, maxRadius = NaN) {\n    super(x, y, minRadius, maxRadius)\n  }\n\n  /**\n   * Returns a random Vector object at given position within a range specified in the constructor.\n   *\n   * @override\n   * @return {Vector} Vector object with random values withing defined range.\n   */\n  getValue() {\n    return this.getValueAt(Math.random())\n  }\n\n  /**\n   * Returns a Vector object at given position.\n   *\n   * @override\n   * @param {number} t The position.\n   * @return {Vector} Vector object representing values in a range at given position.\n   */\n  getValueAt(t) {\n    // pick random radius\n    const r = this.maxX + t * (this.maxY - this.maxX)\n\n    const angle = Math.random() * 2 * Math.PI // MathEx.PI2?\n    const rSq = r * r\n    const rx = this.minX + Math.sqrt(rSq) * Math.cos(angle)\n    const ry = this.minY + Math.sqrt(rSq) * Math.sin(angle)\n\n    this.value.x = rx\n    this.value.y = ry\n\n    return this.value\n  }\n}\n","/**\n * A number scatter for defining a range in 2D space on a curve.\n *\n * @cat scatters\n * @extends Scatter\n */\nexport \nclass FloatCurveScatter extends Scatter {\n  /**\n   * Creates new FloatCurveScatter instance.\n   *\n   * @param {...number} points Coordinates: startX, startY, cpStartX, cpStartY, cpEndX, cpEndY, endX/start2X, endY/start2Y, cp2StartX, cp2StartX... 8 or 14 or 20...\n   */\n  constructor(...points) {\n    super()\n\n    /** @private @type {Curve} */\n    this.mCurve = new Curve()\n    this.mCurve.baked = true\n    this.mCurve.set(...points)\n\n    /** @private @type {Vector} */\n    this.mCache = new Vector()\n  }\n\n  /**\n   * Returns a number at given position on a curve.\n   *\n   * @override\n   * @param {number} t The position.\n   * @return {number} A value on a curve at given position.\n   */\n  getValueAt(t) {\n    this.mCurve.interpolate(t, this.mCache)\n    return this.mCache.y\n  }\n}\n","/**\n * A base utility class used by particle systems. Must be extended.\n *\n * @cat particles\n */\nexport \nclass Modifier {\n  /**\n   * Creates new instance.\n   *\n   * @param {boolean} isInitializer Indicates whenever this modifier will be applied to particle during initialization stage or particle lifetime.\n   */\n  constructor(isInitializer = true) {\n    /** @private @type {boolean} */\n    this.mIsInitializer = isInitializer\n\n    /** @type {Scatter} Modifier's object to get values from.  */\n    this.scatter = null\n  }\n\n  /**\n   * Called on each Emitter's update before `Modifier.update`\n   *\n   * @protected\n   * @param {number} dt Time since last update.\n   * @return {void}\n   */\n  preUpdate(dt) {}\n\n  /**\n   * Called on each Emitter's update for each particle.\n   *\n   * @protected\n   * @param {Emitter} emitter Emitter this modifier attached to.\n   * @param {Particle} particle Instance of `Particle`.\n   * @param {number} dt Time since last update.\n   * @return {void}\n   */\n  update(emitter, particle, dt) {}\n\n  /**\n   * Called on each Emitter's update after `Modifier.update`\n   *\n   * @protected\n   * @param {number} dt Time since last update.\n   * @return {void}\n   */\n  postUpdate(dt) {}\n\n  /**\n   * Specifies if the modifier is initializer or action.\n   *\n   * @readonly\n   * @returns {boolean}\n   */\n  get isInitializer() {\n    return this.mIsInitializer\n  }\n}\n\n// Acceleration (vel += acc * dt;)\n// InitialPosition (box)\n// InitialCirclePosition\n// InitialGameObjectPosition\n// InitialPolygonPosition\n// InitialSpineBonePosition\n// RotationOverLife\n// RotationOverProperty\n// InitialSize\n// SizeOverLife\n// vector field\n// InitialVelocity\n// VelocityOverLife/Property\n","/**\n * Adds acceleration to particles along given direction.\n *\n * @cat particles.modifiers\n * @extends Modifier\n */\nexport \nclass Acceleration extends Modifier {\n  /**\n   * Creates new Acceleration instance.\n   *\n   * @param {...(number|VectorScatter)} values An VectorScatter which defines acceleration direction.\n   */\n  constructor(...values) {\n    super(false)\n\n    /** @type {VectorScatter} Modifier's object to get values from.  */\n    this.scatter = VectorScatter.fromObject(...values)\n  }\n\n  /**\n   * @inheritDoc\n   */\n  update(emitter, particle, dt) {\n    this.scatter.getValue()\n\n    particle.ax += this.scatter.value.x\n    particle.ay += this.scatter.value.y\n  }\n}\n","/**\n * Sets particle's alpha value according to its energy value.\n *\n * @cat particles.modifiers\n * @extends Modifier\n */\nexport \nclass AlphaOverLife extends Modifier {\n  /**\n   * Creates new AlphaOverLife instance.\n   *\n   * @param {...(number|FloatScatter)} values A starting and ending values of alpha property.\n   */\n  constructor(...values) {\n    super(false)\n\n    /** @type {FloatScatter} Modifier's object to get values from.  */\n    this.scatter = FloatScatter.fromObject(...values)\n  }\n\n  /**\n   * @inheritDoc\n   */\n  update(emitter, particle, dt) {\n    particle.alpha = this.scatter.getValueAt(particle.energy)\n  }\n}\n","/**\n * Sets particle's color value according to its energy value.\n *\n * @cat particles.modifiers\n * @extends Modifier\n */\nexport \nclass ColorOverLife extends Modifier {\n  /**\n   * Creates new ColorOverLife instance.\n   *\n   * @param {...(number|ColorScatter)} values A starting and ending values of color property.\n   */\n  constructor(...values) {\n    super(false)\n\n    /** @type {ColorScatter} Modifier's object to get values from.  */\n    this.scatter = ColorScatter.fromObject(...values)\n  }\n\n  /**\n   * @inheritDoc\n   */\n  update(emitter, particle, dt) {\n    particle.color = this.scatter.getValueAt(particle.energy)\n  }\n}\n","/**\n * Sets particle's scale value according to its energy value.\n *\n * @cat particles.modifiers\n * @extends Modifier\n */\nexport \nclass ScaleOverLife extends Modifier {\n  /**\n   * Creates new ScaleOverTime instance.\n   *\n   * @param {...(number|FloatScatter)} values A starting and ending values of scale property.\n   */\n  constructor(...values) {\n    super(false)\n\n    /** @type {FloatScatter} Modifier's object to get values from.  */\n    this.scatter = FloatScatter.fromObject(...values)\n  }\n\n  /**\n   * @inheritDoc\n   */\n  update(emitter, particle, dt) {\n    particle.scaleX = particle.scaleY = this.scatter.getValueAt(particle.energy)\n  }\n}\n","/**\n * Sets particle's rotation value according to its energy value.\n *\n * @cat particles.modifiers\n * @extends Modifier\n */\nexport \nclass RotationOverLife extends Modifier {\n  /**\n   * Creates new RotationOverLife instance.\n   *\n   * @param {...(number|FloatScatter)} values A starting and ending values of alpha property.\n   */\n  constructor(...values) {\n    super(false)\n\n    /** @type {FloatScatter} Modifier's object to get values from.  */\n    this.scatter = FloatScatter.fromObject(...values)\n  }\n\n  /**\n   * @inheritDoc\n   */\n  update(emitter, particle, dt) {\n    particle.r = this.scatter.getValueAt(particle.energy)\n  }\n}\n","/**\n * Sets particle's texture according to its energy value.\n *\n * @cat particles.modifiers\n * @extends Modifier\n */\nexport \nclass TextureOverLife extends Modifier {\n  /**\n   * Creates new TextureOverLife instance.\n   *\n   * @param {...(number|FloatScatter)} values A starting and ending values of textureIndex property.\n   */\n  constructor(...values) {\n    super(false)\n\n    /** @type {FloatScatter} Modifier's object to get values from.  */\n    this.scatter = FloatScatter.fromObject(...values)\n  }\n\n  /**\n   * @inheritDoc\n   */\n  update(emitter, particle, dt) {\n    particle.textureIndex = Math.round(this.scatter.getValueAt(particle.energy))\n  }\n}\n","/**\n * Changes particle alpha according to its life.\n *\n * @cat particles.modifiers\n * @extends Modifier\n */\nexport \nclass AnchorOverLife extends Modifier {\n  /**\n   * Creates new Acceleration instance.\n   *\n   * @param {...(number|VectorScatter)} values An VectorScatter which defines acceleration direction.\n   */\n  constructor(...values) {\n    super(false)\n\n    /** @type {VectorScatter} Modifier's object to get values from.  */\n    this.scatter = VectorScatter.fromObject(...values)\n  }\n\n  /**\n   * @inheritDoc\n   */\n  update(emitter, particle, dt) {\n    this.scatter.getValueAt(particle.energy)\n\n    particle.anchorX = this.scatter.value.x\n    particle.anchorY = this.scatter.value.y\n  }\n}\n","/**\n * Rotates particle along velocity vector.\n *\n * @cat particles.modifiers\n * @extends Modifier\n */\nexport \nclass Oriented extends Modifier {\n  /**\n   * Creates new instance of oriented modifier.\n   */\n  constructor(angleShift = 0) {\n    super(false)\n    this.mAngleShift = angleShift\n  }\n\n  /**\n   * @inheritDoc\n   */\n  update(emitter, particle, dt) {\n    particle.r =\n      (Math.atan2(particle.vy, particle.vx) * MathEx.RAD2DEG -\n        (90 + this.mAngleShift)) *\n      dt\n  }\n}\n","/**\n * @ignore\n * @cat particles.modifiers\n * @extends Modifier\n */\nexport \nclass VectorField extends Modifier {\n  /**\n   * Creates new instance of VectorField.\n   *\n   * @param {number} x\n   * @param {number} y\n   * @param {number} width\n   * @param {number} height\n   * @param {number=} [resolution=0.1]\n   */\n  constructor(x, y, width, height, resolution = 0.1) {\n    super(false)\n\n    this.x = x\n    this.y = y\n    this.width = width\n    this.height = height\n    this.resolution = resolution\n    this.field = []\n\n    this.widthScaled = Math.floor(this.width * this.resolution)\n    this.heightScaled = Math.floor(this.height * this.resolution)\n\n    this.reset()\n  }\n\n  /**\n   * Resets this vector field data.\n   *\n   * @returns {void}\n   */\n  reset() {\n    this.field.splice(0, this.field.length) // why?\n\n    for (let y = 0; y < this.heightScaled; y++)\n      for (let x = 0; x < this.widthScaled; x++)\n        this.field.push(new Vector(0, 0))\n  }\n\n  /**\n   * Updates field data with a given callback function.\n   *\n   * @param {Function} fn\n   * @returns {void}\n   */\n  setData(fn) {\n    for (let y = 0; y < this.heightScaled; y++) {\n      for (let x = 0; x < this.widthScaled; x++) {\n        const index = x + y * this.widthScaled\n        fn(x, y, this.field[index])\n      }\n    }\n  }\n\n  /**\n   * Returns value at given position.\n   *\n   * @param {number} x\n   * @param {number} y\n   * @returns {Vector|null}\n   */\n  getVectorAt(x, y) {\n    x = Math.floor(x * this.resolution)\n    y = Math.floor(y * this.resolution)\n    let ix = ~~(x + y * this.widthScaled)\n\n    if (ix < 0 || ix >= this.field.length) return null\n\n    return this.field[ix]\n  }\n\n  /**\n   * @inheritDoc\n   */\n  update(emitter, particle, dt) {\n    let v = this.getVectorAt(particle.x, particle.y)\n\n    if (v === null) return\n\n    particle.ax = v.x\n    particle.ay = v.y\n  }\n}\n","/**\n * Sets initial particle life value.\n *\n * @cat particles.modifiers\n * @extends Modifier\n */\nexport \nclass InitialLife extends Modifier {\n  /**\n   * Creates new InitialLife instance.\n   *\n   * @param {...(number|FloatScatter)} values Min and max values in seconds.\n   */\n  constructor(...values) {\n    super()\n\n    /** @type {FloatScatter} Modifier's object to get values from.  */\n    this.scatter = FloatScatter.fromObject(...values)\n  }\n\n  /**\n   * @inheritDoc\n   */\n  update(emitter, particle, dt) {\n    particle.life = this.scatter.getValue()\n  }\n}\n","/**\n * Sets initial particle mass value.\n *\n * @cat particles.modifiers\n * @extends Modifier\n */\nexport \nclass InitialMass extends Modifier {\n  /**\n   * Creates new InitialMass instance.\n   *\n   * @param {...(number|FloatScatter)} values Min and max values.\n   */\n  constructor(...values) {\n    super()\n\n    /** @type {FloatScatter} Modifier's object to get values from.  */\n    this.scatter = FloatScatter.fromObject(...values)\n  }\n\n  /**\n   * @inheritDoc\n   */\n  update(emitter, particle, dt) {\n    particle.mass = this.scatter.getValue()\n  }\n}\n","/**\n * Sets initial particle scale value.\n *\n * @cat particles.modifiers\n * @extends Modifier\n */\nexport \nclass InitialScale extends Modifier {\n  /**\n   * Creates new InitialScale instance.\n   *\n   * @param {...(number|FloatScatter)} values Min and max values.\n   */\n  constructor(...values) {\n    super()\n\n    /** @type {FloatScatter} Modifier's object to get values from.  */\n    this.scatter = FloatScatter.fromObject(...values)\n  }\n\n  /**\n   * @inheritDoc\n   */\n  update(emitter, particle, dt) {\n    particle.scaleX = particle.scaleY = this.scatter.getValue()\n  }\n}\n","/**\n * Sets initial particle velocity vector.\n *\n * @cat particles.modifiers\n * @extends Modifier\n */\nexport \nclass InitialVelocity extends Modifier {\n  /**\n   * Creates new InitialVelocity instance.\n   *\n   * @param {...(number|VectorScatter)} values Min and max vectors.\n   */\n  constructor(...values) {\n    super()\n\n    /** @type {VectorScatter} Modifier's object to get values from.  */\n    this.scatter = VectorScatter.fromObject(...values)\n  }\n\n  /**\n   * @inheritDoc\n   */\n  update(emitter, particle, dt) {\n    this.scatter.getValue()\n\n    particle.vx = this.scatter.value.x\n    particle.vy = this.scatter.value.y\n  }\n}\n","/**\n * Sets initial particle position.\n *\n * @cat particles.modifiers\n * @extends Modifier\n */\nexport \nclass InitialPosition extends Modifier {\n  /**\n   * Creates new InitialPosition instance.\n   *\n   * @param {...(number|VectorScatter)} values Rectangle coordinates, its width and height.\n   */\n  constructor(...values) {\n    super()\n\n    /** @type {VectorScatter} Modifier's object to get values from.  */\n    this.scatter = VectorScatter.fromObject(...values)\n  }\n\n  /**\n   * @inheritDoc\n   */\n  update(emitter, particle, dt) {\n    let v = this.scatter.getValue()\n    particle.x = v.x\n    particle.y = v.y\n  }\n}\n","/**\n * Sets initial particle rotation value.\n *\n * @cat particles.modifiers\n * @extends Modifier\n */\nexport \nclass InitialRotation extends Modifier {\n  /**\n   * Creates new InitialRotation instance.\n   *\n   * @param {...(number|FloatScatter)} values Min and max values in radians.\n   */\n  constructor(...values) {\n    super()\n\n    /** @type {FloatScatter} Modifier's object to get values from.  */\n    this.scatter = FloatScatter.fromObject(...values)\n  }\n\n  /**\n   * @inheritDoc\n   */\n  update(emitter, particle, dt) {\n    particle.r = this.scatter.getValue()\n  }\n}\n","/**\n * Sets initial particle texture.\n *\n * @cat particles.modifiers\n * @extends Modifier\n */\nexport \nclass InitialTexture extends Modifier {\n  /**\n   * Creates new InitialTexture instance.\n   *\n   * @param {...(number|FloatScatter)} values Min and max indexes from texture list.\n   */\n  constructor(...values) {\n    super()\n\n    /** @type {FloatScatter} Modifier's object to get values from.  */\n    this.scatter = FloatScatter.fromObject(...values)\n  }\n\n  /**\n   * @inheritDoc\n   */\n  update(emitter, particle, dt) {\n    particle.textureIndex = Math.round(this.scatter.getValue())\n  }\n}\n","/**\n * Sets initial particle color value.\n *\n * @cat particles.modifiers\n * @extends Modifier\n */\nexport \nclass InitialColor extends Modifier {\n  /**\n   * Creates new InitialLife instance.\n   *\n   * @param {...(number|ColorScatter)} values Two color values.\n   */\n  constructor(...values) {\n    super()\n\n    /** @type {ColorScatter} Modifier's object to get values from.  */\n    this.scatter = ColorScatter.fromObject(...values)\n  }\n\n  /**\n   * @inheritDoc\n   */\n  update(emitter, particle, dt) {\n    particle.color = this.scatter.getValue()\n  }\n}\n","/**\n * Sets initial particle scale value.\n *\n * @cat particles.modifiers\n * @extends Modifier\n */\nexport \nclass InitialAnchor extends Modifier {\n  /**\n   * Creates new InitialScale instance.\n   *\n   * @param {...(number|VectorScatter)} values\n   */\n  constructor(...values) {\n    super()\n\n    /** @type {VectorScatter} Modifier's object to get values from.  */\n    this.scatter = VectorScatter.fromObject(...values)\n  }\n\n  /**\n   * @inheritDoc\n   */\n  update(emitter, particle, dt) {\n    let v = this.scatter.getValue()\n    particle.anchorX = v.x\n    particle.anchorY = v.y\n  }\n}\n","/**\n * Represents current state of the emitter.\n * @cat particles\n * @static\n * @constant\n * @enum {number}\n */\nexport \nconst EmitterState = {\n  PENDING: 0,\n  EMITTING: 1,\n  FINISHED: 2,\n}\n","/**\n * Indicates the order in which particles will be rendered.\n * @cat particles\n * @enum {string}\n */\nexport \nconst EmitterSortOrder = {\n  FRONT_TO_BACK: 'frontToBack',\n  BACK_TO_FRONT: 'backToFront',\n}\n","/**\n * The particle!\n *\n * @cat particles\n */\nexport \nclass Particle {\n  constructor() {\n    /** @type {number} The index of a texture. */\n    this.textureIndex = 0\n\n    /** @type {number} The x scale of this particle. */\n    this.scaleX = 1\n\n    /** @type {number} The x scale of this particle. */\n    this.scaleY = 1\n\n    /** @type {number} An alpha value. */\n    this.alpha = 1\n\n    /** @type {number} The life of this particle. */\n    this.life = 1\n\n    /** @type {number} The age of this particle. */\n    this.age = 0\n\n    /** @type {number} Relation of life to age. */\n    this.energy = this.age / this.life\n\n    /** @type {number} The mass. */\n    this.mass = 0\n\n    /** @type {number} X-component. */\n    this.x = 0\n\n    /** @type {number} Y-component. */\n    this.y = 0\n\n    /** @type {number} Rotation of this particle. */\n    this.r = 0\n\n    /** @type {number} Velocity by x. */\n    this.vx = 0\n\n    /** @type {number} Velocity by y. */\n    this.vy = 0\n\n    /** @type {number} Particle x-acceleration. */\n    this.ax = 0\n\n    /** @type {number} Particle y-acceleration. */\n    this.ay = 0\n\n    /** @type {number|null} Particle tinting color. */\n    this.color = null\n\n    /** @type {number} Particle origin point along x-axis. */\n    this.anchorX = 0.5\n\n    /** @type {number} Particle origin point along y-axis. */\n    this.anchorY = 0.5\n  }\n\n  /**\n   * Resets particle to default state.\n   *\n   * @returns {void}\n   */\n  reset() {\n    this.scaleX = this.scaleY = this.alpha = this.life = 1\n    this.textureIndex = this.age = this.energy = this.mass = this.x = this.y = this.r = this.vx = this.vy = this.ax = this.ay = 0\n    this.anchorX = this.anchorY = 0.5\n  }\n\n  /**\n   * Internal update method.\n   *\n   * @param {number} dt Time since last update.\n   * @return {void}\n   */\n  update(dt) {\n    if (this.life <= 0) {\n      this.life = 0\n      return\n    }\n\n    this.x += this.vx * dt\n    this.y += this.vy * dt\n\n    if (this.mass > 0) {\n      this.ax *= 1 / this.mass\n      this.ay *= 1 / this.mass\n    }\n\n    this.vx += this.ax * dt\n    this.vy += this.ay * dt\n\n    this.ax = 0\n    this.ay = 0\n\n    this.life -= dt\n    this.age += dt\n\n    this.energy = this.age / (this.age + this.life)\n  }\n}\n","// TODO: pretty much the emitter is always dirty and caching should not be applied onto it.\n// TODO: q/a every property\n\n/**\n * Particle emitter.\n *\n * @cat particles\n * @extends DisplayObject\n */\nexport \nclass Emitter extends DisplayObject {\n  /**\n   * Creates new Emitter instance.\n   */\n  constructor() {\n    super()\n\n    /** @private @type {Array<Texture>} */\n    this.mTextures = null\n\n    /** @private @type {Array<Particle>} */\n    this.mParticles = []\n\n    /** @private @type {Array<Particle>} */\n    this.mRecycled = []\n\n    /** @private @type {Array<Modifier>} */\n    this.mInitializers = []\n\n    /** @private @type {Array<Modifier>} */\n    this.mActions = []\n\n    /** @private @type {GameObject} */\n    this.mSpace = null\n\n    /** @private @type {boolean} */\n    this.mIsLocal = true\n\n    /** @private @type {number} */\n    this.mMaxParticles = 10000\n\n    /** @private @type {FloatScatter} */\n    this.mEmitCount = new FloatScatter(10)\n\n    /** @private @type {FloatScatter} */\n    this.mEmitNumRepeats = new FloatScatter(Infinity)\n\n    /** @private @type {number} */\n    this.mEmitNumRepeatsLeft = this.mEmitNumRepeats.getValue()\n\n    /** @private @type {FloatScatter} */\n    this.mEmitDuration = new FloatScatter(1 / 60)\n\n    /** @private @type {number} */\n    this.mEmitDurationLeft = this.mEmitDuration.getValue()\n\n    /** @private @type {FloatScatter} */\n    this.mEmitInterval = new FloatScatter(1 / 60)\n\n    /** @private @type {number} */\n    this.mEmitIntervalLeft = this.mEmitInterval.getValue()\n\n    /** @private @type {FloatScatter} */\n    this.mEmitDelay = new FloatScatter(1)\n\n    /** @private @type {number} */\n    this.mEmitDelayLeft = this.mEmitDelay.getValue()\n\n    /** @private @type {number} */\n    this.mNextUpdateAt = 0\n\n    /** @private @type {EmitterState} */\n    this.mState = EmitterState.PENDING\n\n    /** @private @type {Matrix} */\n    this.__tmpLocal = new Matrix()\n\n    /** @private @type {Matrix} */\n    this.__tmpWorld = new Matrix()\n\n    /** @private @type {EmitterSortOrder} */\n    this.mSortOrder = EmitterSortOrder.FRONT_TO_BACK\n  }\n\n  /**\n   * @inheritDoc\n   */\n  getRenderer() {\n    return Black.driver.getRenderer('Emitter', this)\n  }\n\n  /**\n   * Sets the internal state to `EmitterState.PENDING`. Use this when you need to restart emitting.\n   *\n   * @returns {void}\n   */\n  resetState() {\n    this.mState = EmitterState.PENDING\n  }\n\n  /**\n   * A helper method for quick adding modifiers.\n   *\n   * @param {...(GameObject|Component|Modifier)} modifiers The list of modifiers.\n   * @returns {Emitter}\n   */\n  add(...modifiers) {\n    for (let i = 0; i < modifiers.length; i++) {\n      let ai = modifiers[i]\n\n      if (ai instanceof Modifier) this.addModifier(ai)\n      else super.add(ai)\n    }\n    return this\n  }\n\n  /**\n   * Adds Modifier to the end of the list.\n   *\n   * @param {Modifier} modifier Modifier to add.\n   * @return {Modifier}\n   */\n  addModifier(modifier) {\n    if (modifier.isInitializer) this.mInitializers.push(modifier)\n    else this.mActions.push(modifier)\n\n    return modifier\n  }\n\n  /**\n   * Updates delay, duration, interval. Use this function each time you change one of those values.\n   *\n   * @private\n   * @param {number} [dt=0]\n   * @return {void}\n   */\n  updateNextTick(dt = 0) {\n    let t = Time.now\n    let firstEmit = false\n\n    if (this.mState === EmitterState.PENDING) {\n      this.mNextUpdateAt = t + this.mEmitDelayLeft\n      this.mEmitDelayLeft -= dt\n\n      if (this.mEmitDelayLeft <= 0) {\n        this.mEmitDelayLeft = this.mEmitDelay.getValue()\n        this.mState = EmitterState.EMITTING\n        firstEmit = true\n      }\n    }\n\n    if (this.mState === EmitterState.EMITTING) {\n      if (this.mEmitDurationLeft <= 0) {\n        this.mEmitDurationLeft = this.mEmitDuration.getValue()\n\n        this.mEmitNumRepeatsLeft--\n\n        if (this.mEmitNumRepeatsLeft <= 0) {\n          this.mState = EmitterState.FINISHED\n\n          this.post(Message.COMPLETE)\n          return\n        } else {\n          this.mState = EmitterState.PENDING\n          return\n        }\n      } else {\n        // we are getting value here each update to make sure we are up to date!\n        if (firstEmit) {\n          // for a first emit we do not want to add an extra delay. emit now!\n          this.mNextUpdateAt = t\n          this.mEmitIntervalLeft = this.mEmitInterval.getValue()\n        } else {\n          this.mEmitIntervalLeft -= dt\n          this.mNextUpdateAt = t + this.mEmitIntervalLeft\n          //console.log(this.mEmitIntervalLeft);\n\n          // reset interval\n          if (this.mEmitIntervalLeft <= 0)\n            this.mEmitIntervalLeft = this.mEmitInterval.getValue()\n        }\n      }\n\n      this.mEmitDurationLeft -= dt\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n  onUpdate() {\n    let dt = Time.delta\n\n    // rate logic\n    this.updateNextTick(dt)\n\n    if (Time.now >= this.mNextUpdateAt && this.mState === EmitterState.EMITTING)\n      this.__create(this.mEmitCount.getValue())\n\n    // main update login\n    const alength = this.mActions.length\n    const plength = this.mParticles.length\n\n    for (let k = 0; k < alength; k++) this.mActions[k].preUpdate(dt)\n\n    let particle\n\n    let i = plength\n    while (i--) {\n      particle = this.mParticles[i]\n\n      for (let k = 0; k < alength; k++)\n        this.mActions[k].update(this, particle, dt)\n\n      particle.update(dt)\n\n      if (particle.life === 0) {\n        this.mRecycled.push(particle)\n        this.mParticles.splice(i, 1)\n      }\n    }\n\n    for (let k = 0; k < alength; k++) this.mActions[k].postUpdate(dt)\n\n    // set dummy dirty flag so unchanged frames can be detected\n    if (this.mVisible === true && this.mAlpha > 0)\n      this.setDirty(DirtyFlag.LOCAL, false)\n  }\n\n  /**\n   * @ignore\n   * @private\n   */\n  __create(amount) {\n    let matrix = this.worldTransformation.clone()\n    let minv = null\n\n    if (this.mIsLocal === false) {\n      minv = this.mSpace.worldTransformationInverted.clone()\n      matrix.prepend(minv)\n    }\n\n    for (let i = 0; i < amount; i++) {\n      let p = null\n\n      if (this.mRecycled.length > 0) {\n        p = this.mRecycled.pop()\n      } else {\n        if (this.mParticles.length >= this.mMaxParticles) return\n\n        p = new Particle()\n      }\n\n      p.reset()\n\n      for (let k = 0; k < this.mInitializers.length; k++)\n        this.mInitializers[k].update(this, p, 0)\n\n      if (this.mIsLocal === false) {\n        matrix.transformXY(p.x, p.y, Vector.__cache)\n        p.x = Vector.__cache.x\n        p.y = Vector.__cache.y\n      }\n\n      this.mParticles.push(p)\n    }\n  }\n\n  /**\n   * Gets current emitter state.\n   *\n   * @return {EmitterState}\n   */\n  get state() {\n    return this.mState\n  }\n\n  /**\n   * Gets/Sets The maximum number of particles can be created.\n   *\n   * @return {number}\n   */\n  get maxParticles() {\n    return this.mMaxParticles\n  }\n\n  /**\n   * @ignore\n   * @param {number} value\n   * @return {void}\n   */\n  set maxParticles(value) {\n    if (value < 0) throw new Error('Bad argument error.')\n\n    this.mMaxParticles = value\n  }\n\n  /**\n   * Gets/Sets the number of particles to be emitted per {@link Emitter#emitInterval}\n   *\n   * @return {FloatScatter}\n   */\n  get emitCount() {\n    return this.mEmitCount\n  }\n\n  /**\n   * @ignore\n   * @param {FloatScatter} value\n   * @return {void}\n   */\n  set emitCount(value) {\n    this.mEmitCount = value\n  }\n\n  /**\n   * Gets/Sets the number of \"durations\" to to repeat. Use `Infinity` to emit particles endlessly.\n   *\n   * @return {FloatScatter}\n   */\n  get emitNumRepeats() {\n    return this.mEmitNumRepeats\n  }\n\n  /**\n   * @ignore\n   * @param {FloatScatter} value\n   * @return {void}\n   */\n  set emitNumRepeats(value) {\n    this.mEmitNumRepeats = value\n    this.mEmitNumRepeatsLeft = this.mEmitNumRepeats.getValue()\n  }\n\n  /**\n   * Gets/Sets\n   *\n   * @return {FloatScatter}\n   */\n  get emitDuration() {\n    return this.mEmitDuration\n  }\n\n  /**\n   * @ignore\n   * @param {FloatScatter} value\n   * @return {void}\n   */\n  set emitDuration(value) {\n    this.mEmitDuration = value\n    this.mEmitDurationLeft = this.mEmitDuration.getValue()\n  }\n\n  /**\n   * Gets/Sets\n   *\n   * @return {FloatScatter}\n   */\n  get emitInterval() {\n    return this.mEmitInterval\n  }\n\n  /**\n   * @ignore\n   * @param {FloatScatter} value\n   * @return {void}\n   */\n  set emitInterval(value) {\n    this.mEmitInterval = value\n    this.mEmitIntervalLeft = this.mEmitInterval.getValue()\n  }\n\n  /**\n   * Gets/Sets\n   *\n   * @return {FloatScatter}\n   */\n  get emitDelay() {\n    return this.mEmitDelay\n  }\n\n  /**\n   * @ignore\n   * @param {FloatScatter} value\n   * @return {void}\n   */\n  set emitDelay(value) {\n    this.mEmitDelay = value\n    this.mEmitDelayLeft = this.mEmitDelay.getValue()\n  }\n\n  /**\n   * Gets/Sets the space where emitting simulation will happen, ignoring space transformation, so all forces are relative to global.\n   *\n   * @return {GameObject}\n   */\n  get space() {\n    return this.mSpace\n  }\n\n  /**\n   * @ignore\n   * @param {GameObject} gameObject\n   * @return {void}\n   */\n  set space(gameObject) {\n    this.mSpace = gameObject\n    this.mIsLocal = this.mSpace === null || this.mSpace === this\n    this.setRenderDirty()\n  }\n\n  /**\n   * Gets/Sets a list of textures to use.\n   *\n   * @return {Array<Texture>}\n   */\n  get textures() {\n    return this.mTextures\n  }\n\n  /**\n   * @ignore\n   * @param {Array<Texture>} value\n   * @return {void}\n   */\n  set textures(value) {\n    this.mTextures = value\n\n    Debug.assert(\n      !(this.mTextures === null || this.mTextures.length === 0),\n      'At least one texture must be provided.'\n    )\n\n    this.setRenderDirty()\n  }\n\n  /**\n   * Sets the list of textures with given string. It uses AssetManager to find textures. Wildcard supported.\n   *\n   * @param {string} value\n   * @return {void}\n   */\n  set texturesName(value) {\n    this.textures = AssetManager.default.getTextures(value)\n  }\n\n  /**\n   * Gets/Sets the order in which particles will be sorted when rendering.\n   *\n   * @return {EmitterSortOrder}\n   */\n  get sortOrder() {\n    return this.mSortOrder\n  }\n\n  /**\n   * @ignore\n   * @param {EmitterSortOrder} value\n   * @return {void}\n   */\n  set sortOrder(value) {\n    this.mSortOrder = value\n    this.setRenderDirty()\n  }\n}\n","/**\n * @readonly\n * @enum {number}\n * @cat input\n */\nexport \nconst Key = {\n  /**\n   * @type {number}\n   */\n  A: 65,\n  /**\n   * @type {number}\n   */\n  B: 66,\n  /**\n   * @type {number}\n   */\n  C: 67,\n  /**\n   * @type {number}\n   */\n  D: 68,\n  /**\n   * @type {number}\n   */\n  E: 69,\n  /**\n   * @type {number}\n   */\n  F: 70,\n  /**\n   * @type {number}\n   */\n  G: 71,\n  /**\n   * @type {number}\n   */\n  H: 72,\n  /**\n   * @type {number}\n   */\n  I: 73,\n  /**\n   * @type {number}\n   */\n  J: 74,\n  /**\n   * @type {number}\n   */\n  K: 75,\n  /**\n   * @type {number}\n   */\n  L: 76,\n  /**\n   * @type {number}\n   */\n  M: 77,\n  /**\n   * @type {number}\n   */\n  N: 78,\n  /**\n   * @type {number}\n   */\n  O: 79,\n  /**\n   * @type {number}\n   */\n  P: 80,\n  /**\n   * @type {number}\n   */\n  Q: 81,\n  /**\n   * @type {number}\n   */\n  R: 82,\n  /**\n   * @type {number}\n   */\n  S: 83,\n  /**\n   * @type {number}\n   */\n  T: 84,\n  /**\n   * @type {number}\n   */\n  U: 85,\n  /**\n   * @type {number}\n   */\n  V: 86,\n  /**\n   * @type {number}\n   */\n  W: 87,\n  /**\n   * @type {number}\n   */\n  X: 88,\n  /**\n   * @type {number}\n   */\n  Y: 89,\n  /**\n   * @type {number}\n   */\n  Z: 90,\n  /**\n   * @type {number}\n   */\n  DIGIT_0: 48,\n  /**\n   * @type {number}\n   */\n  DIGIT_1: 49,\n  /**\n   * @type {number}\n   */\n  DIGIT_2: 50,\n  /**\n   * @type {number}\n   */\n  DIGIT_3: 51,\n  /**\n   * @type {number}\n   */\n  DIGIT_4: 52,\n  /**\n   * @type {number}\n   */\n  DIGIT_5: 53,\n  /**\n   * @type {number}\n   */\n  DIGIT_6: 54,\n  /**\n   * @type {number}\n   */\n  DIGIT_7: 55,\n  /**\n   * @type {number}\n   */\n  DIGIT_8: 56,\n  /**\n   * @type {number}\n   */\n  DIGIT_9: 57,\n  /**\n   * @type {number}\n   */\n  NUMPAD_0: 96,\n  /**\n   * @type {number}\n   */\n  NUMPAD_1: 97,\n  /**\n   * @type {number}\n   */\n  NUMPAD_2: 98,\n  /**\n   * @type {number}\n   */\n  NUMPAD_3: 99,\n  /**\n   * @type {number}\n   */\n  NUMPAD_4: 100,\n  /**\n   * @type {number}\n   */\n  NUMPAD_5: 101,\n  /**\n   * @type {number}\n   */\n  NUMPAD_6: 102,\n  /**\n   * @type {number}\n   */\n  NUMPAD_7: 103,\n  /**\n   * @type {number}\n   */\n  NUMPAD_8: 104,\n  /**\n   * @type {number}\n   */\n  NUMPAD_9: 105,\n  /**\n   * @type {number}\n   */\n  NUMPAD_MULTIPLY: 106,\n  /**\n   * @type {number}\n   */\n  NUMPAD_ADD: 107,\n  /**\n   * @type {number}\n   */\n  NUMPAD_SUBTRACT: 109,\n  /**\n   * @type {number}\n   */\n  NUMPAD_DECIMAL: 110,\n  /**\n   * @type {number}\n   */\n  NUMPAD_DIVIDE: 111,\n  /**\n   * @type {number}\n   */\n  LEFT_ARROW: 37,\n  /**\n   * @type {number}\n   */\n  UP_ARROW: 38,\n  /**\n   * @type {number}\n   */\n  RIGHT_ARROW: 39,\n  /**\n   * @type {number}\n   */\n  DOWN_ARROW: 40,\n  /**\n   * @type {number}\n   */\n  BACKSPACE: 8,\n  /**\n   * @type {number}\n   */\n  TAB: 9,\n  /**\n   * @type {number}\n   */\n  ENTER: 13,\n  /**\n   * @type {number}\n   */\n  SHIFT: 16,\n  /**\n   * @type {number}\n   */\n  CTRL: 17,\n  /**\n   * @type {number}\n   */\n  ALT: 18,\n  /**\n   * @type {number}\n   */\n  F1: 112,\n  /**\n   * @type {number}\n   */\n  F2: 113,\n  /**\n   * @type {number}\n   */\n  F3: 114,\n  /**\n   * @type {number}\n   */\n  F4: 115,\n  /**\n   * @type {number}\n   */\n  F5: 116,\n  /**\n   * @type {number}\n   */\n  F6: 117,\n  /**\n   * @type {number}\n   */\n  F7: 118,\n  /**\n   * @type {number}\n   */\n  F8: 119,\n  /**\n   * @type {number}\n   */\n  F9: 120,\n  /**\n   * @type {number}\n   */\n  F10: 121,\n  /**\n   * @type {number}\n   */\n  F11: 122,\n  /**\n   * @type {number}\n   */\n  F12: 123,\n  /**\n   * @type {number}\n   */\n  PAUSE_BREAK: 19,\n  /**\n   * @type {number}\n   */\n  CAPS_LOCK: 20,\n  /**\n   * @type {number}\n   */\n  ESCAPE: 27,\n  /**\n   * @type {number}\n   */\n  PAGE_UP: 33,\n  /**\n   * @type {number}\n   */\n  PAGE_DOWN: 34,\n  /**\n   * @type {number}\n   */\n  END: 35,\n  /**\n   * @type {number}\n   */\n  HOME: 36,\n  /**\n   * @type {number}\n   */\n  INSERT: 45,\n  /**\n   * @type {number}\n   */\n  DELETE: 46,\n  /**\n   * @type {number}\n   */\n  LEFT_WINDOW: 91,\n  /**\n   * @type {number}\n   */\n  RIGHT_WINDOW: 92,\n  /**\n   * @type {number}\n   */\n  CONTEXT_MENU: 93,\n  /**\n   * @type {number}\n   */\n  NUM_LOCK: 144,\n  /**\n   * @type {number}\n   */\n  SCROLL_LOCK: 145,\n  /**\n   * @type {number}\n   */\n  SEMI_COLON: 186,\n  /**\n   * @type {number}\n   */\n  EQUAL_SIGN: 187,\n  /**\n   * @type {number}\n   */\n  COMMA: 188,\n  /**\n   * @type {number}\n   */\n  DASH: 189,\n  /**\n   * @type {number}\n   */\n  PERIOD: 190,\n  /**\n   * @type {number}\n   */\n  FORWARD_SLASH: 191,\n  /**\n   * @type {number}\n   */\n  BACKQUOTE: 192,\n  /**\n   * @type {number}\n   */\n  BRAKET_LEFT: 219,\n  /**\n   * @type {number}\n   */\n  BACK_SLASH: 220,\n  /**\n   * @type {number}\n   */\n  BRAKET_RIGHT: 221,\n  /**\n   * @type {number}\n   */\n  SINGLE_QUOTE: 222,\n  /**\n   * @type {number}\n   */\n  SPACE: 32,\n}\n","/**\n * Holds information about keyboard event.\n *\n * @cat input\n */\nexport \nclass KeyInfo {\n  /**\n   * Create new instance of KeyInfo\n   *\n   * @param {KeyboardEvent} nativeEvent Native touch event.\n   * @return {void}\n   */\n  constructor(nativeEvent) {\n    this.keyCode = nativeEvent.keyCode\n    this.code = nativeEvent.code\n    this.char = nativeEvent.key\n    this.shiftKey = nativeEvent.shiftKey\n    this.altKey = nativeEvent.altKey\n    this.ctrlKey = nativeEvent.ctrlKey\n  }\n}\n","/**\n * A input system class is responsible for mouse, touch and keyboard input events.\n * Pointer events works for a single target only.\n * Global Input messages has higher priority.\n *\n * When GameObject gets a `pointerDown` message it gets target locked. Other\n * objects will not receive `pointerMove` or `pointerUp` messages. Target locked\n * object will receive `pointerUp` message even if pointer is outside of its\n * bounds.\n *\n * Every object in the display list should be `touchable` in order to receive input messages.\n *\n * @cat input\n * @fires Input#pointerMove\n * @fires Input#pointerDown\n * @fires Input#pointerUp\n * @extends System\n */\nexport \nclass Input extends System {\n  /**\n   * Private constructor.\n   */\n  constructor() {\n    super()\n\n    Debug.assert(\n      this.constructor.instance == null,\n      'Only single instance is allowed'\n    )\n\n    Input.instance = this\n\n    /** @private @type {Vector} */\n    this.mPointerPosition = new Vector()\n\n    /** @private @type {Vector} */\n    this.mStagePosition = new Vector()\n\n    /** @private @type {Element} */\n    this.mDom = Black.instance.containerElement\n\n    /** @private @type {Array<string>} */\n    this.mEventList = null\n\n    /** @private @type {Array<string>} */\n    this.mKeyEventList = null\n\n    this.__initListeners()\n\n    /** @private @type {Array<{e: Event, x: number, y:number}>} */\n    this.mPointerQueue = []\n\n    /** @private @type {Array<KeyboardEvent>} */\n    this.mKeyQueue = []\n\n    /** @private @type {Array<number>} */\n    this.mPressedKeys = []\n\n    /** @private @type {boolean} */\n    this.mIsPointerDown = false\n\n    /** @private @type {boolean} */\n    this.mNeedUpEvent = false\n\n    // NOTE: we need guarantee that keys are not going to change theirs order when iterating.\n    /** @private @type {Map} */\n    this.mInputListeners = new Map()\n\n    /** @private @type {GameObject} */\n    this.mTarget = null\n\n    /** @private @type {Component} */\n    this.mTargetComponent = null\n\n    /** @private @type {GameObject} */\n    this.mLockedTarget = null\n\n    /** @private @type {Component} */\n    this.mLastInTargetComponent = null\n  }\n\n  /**\n   * @ignore\n   * @private\n   * @returns {void}\n   */\n  __initListeners() {\n    this.mKeyEventList = Input.mKeyEventList\n\n    if (window.PointerEvent) this.mEventList = Input.mPointerEventList\n    else if (Device.isTouch && Device.isMobile)\n      this.mEventList = Input.mTouchEventList\n    else this.mEventList = Input.mMouseEventList\n\n    for (let i = 0; i < 3; i++)\n      this.mDom.addEventListener(\n        this.mEventList[i],\n        e => this.__onPointerEvent(e),\n        false\n      )\n\n    document.addEventListener(\n      this.mEventList[Input.IX_POINTER_UP],\n      e => this.__onPointerEventDoc(e),\n      false\n    )\n\n    for (let i = 0; i < this.mKeyEventList.length; i++)\n      document.addEventListener(\n        this.mKeyEventList[i],\n        e => this.__onKeyEvent(/** @type{KeyboardEvent}*/ (e)),\n        false\n      )\n  }\n\n  /**\n   * @ignore\n   * @private\n   * @param {KeyboardEvent} e\n   * @returns {boolean}\n   */\n  __onKeyEvent(e) {\n    if (Black.instance.isPaused === true) return false\n\n    this.mKeyQueue.push(e)\n    return true\n  }\n\n  /**\n   * @ignore\n   * @private\n   * @param {Event} e\n   * @returns {void}\n   */\n  __onPointerEventDoc(e) {\n    if (Black.instance.isPaused === true) return\n\n    // dirty check\n    let over =\n      e.target == this.mDom ||\n      /** @type {Node})*/ e.target.parentElement == this.mDom\n\n    if (over === false && this.mNeedUpEvent === true) {\n      this.mNeedUpEvent = false\n      this.__pushEvent(e)\n    }\n  }\n\n  /**\n   * @ignore\n   * @private\n   * @param {Event} e\n   * @returns {boolean}\n   */\n  __onPointerEvent(e) {\n    if (Black.instance.isPaused === true) return false\n\n    e.preventDefault()\n\n    this.__pushEvent(e)\n\n    return true\n  }\n\n  /**\n   * @ignore\n   * @private\n   * @param {Event} e\n   * @returns {void}\n   */\n  __pushEvent(e) {\n    let /** @type {Vector|null} */ p = null\n    if (e.type.indexOf('touch') === 0)\n      p = this.__getTouchPos(this.mDom, /** @type {TouchEvent} */ (e))\n    else p = this.__getPointerPos(this.mDom, e)\n\n    this.mPointerQueue.push({\n      e: e,\n      x: p.x,\n      y: p.y,\n    })\n  }\n\n  /**\n   * @ignore\n   * @private\n   * @param {Element} canvas\n   * @param {Event} evt\n   * @returns {Vector}\n   */\n  __getPointerPos(canvas, evt) {\n    let rect = canvas.getBoundingClientRect()\n    let scaleX = canvas.clientWidth / rect.width\n    let scaleY = canvas.clientHeight / rect.height\n    return new Vector(\n      (evt.clientX - rect.left) * scaleX,\n      (evt.clientY - rect.top) * scaleY\n    )\n  }\n\n  /**\n   * @ignore\n   * @private\n   * @param {Element} canvas\n   * @param {TouchEvent} evt\n   * @returns {Vector}\n   */\n  __getTouchPos(canvas, evt) {\n    let rect = canvas.getBoundingClientRect()\n\n    /** @type {Touch} */\n    let touch = evt.changedTouches[0] // ios? what about android?\n    let x = touch.clientX\n    let y = touch.clientY\n\n    let scaleX = canvas.clientWidth / rect.width\n    let scaleY = canvas.clientHeight / rect.height\n    return new Vector((x - rect.left) * scaleX, (y - rect.top) * scaleY)\n  }\n\n  /**\n   * @inheritDoc\n   */\n  onUpdate() {\n    // omg, who gave you keyboard?\n    this.__updateKeyboard()\n\n    let stage = Black.stage\n\n    while (this.mPointerQueue.length > 0) {\n      let nativeEvent = this.mPointerQueue.shift()\n\n      // update to the latest position\n      this.mPointerPosition.x = nativeEvent.x\n      this.mPointerPosition.y = nativeEvent.y\n\n      this.mStagePosition.x = nativeEvent.x\n      this.mStagePosition.y = nativeEvent.y\n\n      let inv = stage.worldTransformationInverted\n      inv.transformVector(this.mStagePosition, this.mStagePosition)\n\n      let eventType =\n        Input.mInputEventsLookup[this.mEventList.indexOf(nativeEvent.e.type)]\n\n      this.__findTarget(this.mPointerPosition)\n      this.__processNativeEvent(nativeEvent, this.mPointerPosition, eventType)\n    }\n  }\n\n  /**\n   * @ignore\n   * @private\n   * @param {Vector} pos\n   */\n  __findTarget(pos) {\n    let obj = Black.stage.hitTest(pos)\n\n    if (obj === null) {\n      this.mTarget = null\n      this.mTargetComponent = null\n      return\n    }\n\n    this.mTarget = obj\n    this.mTargetComponent = obj.getComponent(InputComponent)\n  }\n\n  /**\n   * @ignore\n   * @private\n   * @param {Object} nativeEvent\n   * @param {Vector} pos\n   * @param {string} type\n   */\n  __processNativeEvent(nativeEvent, pos, type) {\n    if (type === Input.POINTER_DOWN) {\n      this.mIsPointerDown = true\n      this.mNeedUpEvent = true\n    } else if (type === Input.POINTER_UP) {\n      this.mIsPointerDown = false\n    }\n\n    this.post(type)\n\n    if (this.mTarget === null && this.mLockedTarget === null) return\n\n    let info = new PointerInfo(this.mTarget, pos.x, pos.y)\n\n    if (type === Input.POINTER_DOWN) {\n      this.mLockedTarget = this.mTarget\n    } else if (type === Input.POINTER_UP && this.mLockedTarget !== null) {\n      this.mLockedTarget.post('~pointerUp', info)\n      this.mLockedTarget = null\n      return\n    }\n\n    let sameTarget = this.mTarget === this.mLockedTarget\n\n    if (this.mLockedTarget === null) {\n      if (this.mTarget !== null) this.mTarget.post('~' + type, info)\n    } else {\n      if (sameTarget === true) this.mLockedTarget.post('~' + type, info)\n      else {\n        if (this.mLockedTarget.mParent !== null && this.mTarget !== null)\n          this.mLockedTarget.mParent.post('~' + type, info)\n      }\n    }\n  }\n\n  /**\n   * @ignore\n   * @private\n   * @returns {void}\n   */\n  __updateKeyboard() {\n    while (this.mKeyQueue.length > 0) {\n      let nativeEvent = this.mKeyQueue.shift()\n\n      let ix = this.mKeyEventList.indexOf(nativeEvent.type)\n      let pIx = this.mPressedKeys.indexOf(nativeEvent.keyCode)\n      let fnName = Input.mKeyEventsLookup[ix]\n\n      if (fnName === 'keyUp' && pIx !== -1) this.mPressedKeys.splice(pIx, 1)\n      else if (fnName === 'keyDown' && pIx === -1) {\n        this.mPressedKeys.push(nativeEvent.keyCode)\n        fnName = 'keyPress'\n      }\n\n      this.post(fnName, new KeyInfo(nativeEvent), nativeEvent)\n    }\n  }\n\n  /**\n   * Listens for global input event by given message name.\n   *\n   * @param {string} name            The name of the message to listen for.\n   * @param {Function} callback      The callback function that will be called when message received.\n   * @param {Object=} [context=null] Optional context.\n   * @returns {MessageBinding}\n   */\n  static on(name, callback, context = null) {\n    return Input.instance.on(name, callback, context)\n  }\n\n  /**\n   * Listens for one single global input event by given message name.\n   *\n   * @param {string} name            The name of the message to listen for.\n   * @param {Function} callback      The callback function that will be called when message received.\n   * @param {Object=} [context=null] Optional context.\n   * @returns {MessageBinding}\n   */\n  static once(name, callback, context = null) {\n    return Input.instance.once(name, callback, context)\n  }\n\n  /**\n   * Indicates if mouse or touch in down at this moment.\n   *\n   * @returns {boolean}\n   */\n  static get isPointerDown() {\n    return Input.instance.mIsPointerDown\n  }\n\n  /**\n   * Returns mouse or touch pointer x-component.\n   *\n   * @returns {number}\n   */\n  static get pointerX() {\n    return Input.instance.mPointerPosition.x\n  }\n\n  /**\n   * Returns mouse or touch pointer x-component.\n   *\n   * @returns {number} Description\n   */\n  static get pointerY() {\n    return Input.instance.mPointerPosition.y\n  }\n\n  /**\n   * Returns mouse or touch pointer x-component relative to stage.\n   *\n   * @returns {number}\n   */\n  static get stageX() {\n    return Input.instance.mStagePosition.x\n  }\n\n  /**\n   * Returns mouse or touch pointer x-component  relative to stage.\n   *\n   * @returns {number} Description\n   */\n  static get stageY() {\n    return Input.instance.mStagePosition.y\n  }\n\n  /**\n   * Returns mouse or touch pointer position.\n   *\n   * @returns {Vector}\n   */\n  static get pointerPosition() {\n    return Input.instance.mPointerPosition\n  }\n\n  /**\n   * Returns pointer position relative to the stage.\n   *\n   * @returns {Vector}\n   */\n  static get stagePosition() {\n    return Input.instance.mStagePosition\n  }\n\n  /**\n   * Returns list of pressed keys.\n   *\n   * @returns {Array<number>}\n   */\n  static get pressedKeys() {\n    return Input.instance.mPressedKeys\n  }\n}\n\n/**\n * @private\n * @type {string}\n * @const\n */\nInput.POINTER_DOWN = 'pointerDown'\n\n/**\n * @private\n * @type {string}\n * @const\n */\nInput.POINTER_MOVE = 'pointerMove'\n\n/**\n * @private\n * @type {string}\n * @const\n */\nInput.POINTER_UP = 'pointerUp'\n\n/**\n * Only instance of Input.\n *\n * @type {Input}\n * @static\n * @nocollapse\n */\nInput.instance = null\n\n/**\n * @private\n * @type {number}\n * @const\n */\nInput.IX_POINTER_MOVE = 0\n\n/**\n * @private\n * @type {number}\n * @const\n */\nInput.IX_POINTER_DOWN = 1\n\n/**\n * @private\n * @type {number}\n * @const\n */\nInput.IX_POINTER_UP = 2\n\n// /**\n//  * @type {number}\n//  * @const\n//  */\n// Input.IX_POINTER_IN = 3;\n//\n// /**\n//  * @type {number}\n//  * @const\n//  */\n// Input.IX_POINTER_OUT = 4;\n\n/**\n * @private\n * @type {Array<string>}\n * @const\n */\nInput.mKeyEventList = ['keydown', 'keyup']\n\n/**\n * @private\n * @type {Array<string>}\n * @const\n */\nInput.mKeyEventsLookup = ['keyDown', 'keyUp', 'keyPress']\n\n/**\n * @private\n * @type {Array<string>}\n * @const\n */\nInput.mInputEventsLookup = [\n  'pointerMove',\n  'pointerDown',\n  'pointerUp',\n  'pointerIn',\n  'pointerOut',\n]\n\n/**\n * @private\n * @type {Array<string>}\n * @const\n */\nInput.mPointerEventList = [\n  'pointermove',\n  'pointerdown',\n  'pointerup',\n  'pointerenter',\n  'pointerleave',\n]\n\n/**\n * @private\n * @type {Array<string>}\n * @const\n */\nInput.mMouseEventList = [\n  'mousemove',\n  'mousedown',\n  'mouseup',\n  'mouseenter',\n  'mouseleave',\n]\n\n/**\n * @private\n * @type {Array<string>}\n * @const\n */\nInput.mTouchEventList = [\n  'touchmove',\n  'touchstart',\n  'touchend',\n  'touchenter',\n  'touchleave',\n]\n\n/**\n * Posts when mouse down or touch down event happened.\n * @event Input#pointerDown\n */\n\n/**\n * Posts when mouse up or touch up event happened.\n * @event Input#pointerUp\n */\n\n/**\n * Posts when mouse move or touch move event happened.\n * @event Input#pointerMove\n */\n\n/**\n * Stores additional information about pointer events.\n *\n * @ignore\n * @cat input\n */\nexport \nclass PointerInfo {\n  /**\n   * Creates new PointerInfo instance. For internal use only.\n   *\n   * @param {GameObject} activeObject `GameObject` the cursor is above.\n   * @param {number} x x-coordinate\n   * @param {number} y y-coordinate\n   */\n  constructor(activeObject, x, y) {\n    /** * @private @type {GameObject} */\n    this.mActiveObject = activeObject\n\n    /** * @private @type {number} */\n    this.mX = x\n\n    /** * @private @type {number} */\n    this.mY = y\n  }\n\n  /**\n   * Returns the object under cursor right now.\n   *\n   * @readonly\n   * @returns {GameObject}\n   */\n  get activeObject() {\n    return this.mActiveObject\n  }\n\n  /**\n   * X-coordinate.\n   *\n   * @readonly\n   * @returns {number}\n   */\n  get x() {\n    return this.mX\n  }\n\n  /**\n   * Y-coordinate.\n   *\n   * @readonly\n   * @returns {number}\n   */\n  get y() {\n    return this.mY\n  }\n}\n","/**\n * This component will allow you to subscribe for some input messages.\n *\n * @cat input\n * @extends Component\n */\nexport \nclass InputComponent extends Component {\n  /**\n   * @return {void}\n   */\n  constructor() {\n    super()\n\n    /** @type {boolean} Specifies whether the component is active. */\n    this.touchable = true\n\n    /* INTERNAL */\n    /** @ignore @type {boolean} */\n    this.mPointerInDispatched = false\n  }\n}\n","/**\n * A static class with many static easing functions.\n *\n * @cat animation\n * @static\n */\nexport \nclass Ease {\n  /**\n   * linear\n   *\n   * @param {number} k Value between 0 and 1\n   * @return {number}\n   */\n  static linear(k) {\n    return k\n  }\n\n  /**\n   * quadraticIn\n   *\n   * @param {number} k Value between 0 and 1\n   * @return {number}\n   */\n  static quadraticIn(k) {\n    return k * k\n  }\n\n  /**\n   * quadraticOut\n   *\n   * @param {number} k Value between 0 and 1\n   * @return {number}\n   */\n  static quadraticOut(k) {\n    return k * (2 - k)\n  }\n\n  /**\n   * quadraticInOut\n   *\n   * @param {number} k Value between 0 and 1\n   * @return {number}\n   */\n  static quadraticInOut(k) {\n    if ((k *= 2) < 1) return 0.5 * k * k\n\n    return -0.5 * (--k * (k - 2) - 1)\n  }\n\n  /**\n   * cubicIn\n   *\n   * @param {number} k Value between 0 and 1\n   * @return {number}\n   */\n  static cubicIn(k) {\n    return k * k * k\n  }\n\n  /**\n   * cubicOut\n   *\n   * @param {number} k Value between 0 and 1\n   * @return {number}\n   */\n  static cubicOut(k) {\n    return --k * k * k + 1\n  }\n\n  /**\n   * cubicInOut\n   *\n   * @param {number} k Value between 0 and 1\n   * @return {number}\n   */\n  static cubicInOut(k) {\n    if ((k *= 2) < 1) return 0.5 * k * k * k\n\n    return 0.5 * ((k -= 2) * k * k + 2)\n  }\n\n  /**\n   * quarticIn\n   *\n   * @param {number} k Value between 0 and 1\n   * @return {number}\n   */\n  static quarticIn(k) {\n    return k * k * k * k\n  }\n\n  /**\n   * quarticOut\n   *\n   * @param {number} k Value between 0 and 1\n   * @return {number}\n   */\n  static quarticOut(k) {\n    return 1 - --k * k * k * k\n  }\n\n  /**\n   * quarticInOut\n   *\n   * @param {number} k Value between 0 and 1\n   * @return {number}\n   */\n  static quarticInOut(k) {\n    if ((k *= 2) < 1) return 0.5 * k * k * k * k\n\n    return -0.5 * ((k -= 2) * k * k * k - 2)\n  }\n\n  /**\n   * quinticIn\n   *\n   * @param {number} k Value between 0 and 1\n   * @return {number}\n   */\n  static quinticIn(k) {\n    return k * k * k * k * k\n  }\n\n  /**\n   * quinticOut\n   *\n   * @param {number} k Value between 0 and 1\n   * @return {number}\n   */\n  static quinticOut(k) {\n    return --k * k * k * k * k + 1\n  }\n\n  /**\n   * quinticInOut\n   *\n   * @param {number} k Value between 0 and 1\n   * @return {number}\n   */\n  static quinticInOut(k) {\n    if ((k *= 2) < 1) return 0.5 * k * k * k * k * k\n\n    return 0.5 * ((k -= 2) * k * k * k * k + 2)\n  }\n\n  /**\n   * sinusoidalIn\n   *\n   * @param {number} k Value between 0 and 1\n   * @return {number}\n   */\n  static sinusoidalIn(k) {\n    return 1 - Math.cos((k * Math.PI) / 2)\n  }\n\n  /**\n   * sinusoidalOut\n   *\n   * @param {number} k Value between 0 and 1\n   * @return {number}\n   */\n  static sinusoidalOut(k) {\n    return Math.sin((k * Math.PI) / 2)\n  }\n\n  /**\n   * sinusoidalInOut\n   *\n   * @param {number} k Value between 0 and 1\n   * @return {number}\n   */\n  static sinusoidalInOut(k) {\n    return 0.5 * (1 - Math.cos(Math.PI * k))\n  }\n\n  /**\n   * exponentialIn\n   *\n   * @param {number} k Value between 0 and 1\n   * @return {number}\n   */\n  static exponentialIn(k) {\n    return k === 0 ? 0 : Math.pow(1024, k - 1)\n  }\n\n  /**\n   * exponentialOut\n   *\n   * @param {number} k Value between 0 and 1\n   * @return {number}\n   */\n  static exponentialOut(k) {\n    return k === 1 ? 1 : 1 - Math.pow(2, -10 * k)\n  }\n\n  /**\n   * exponentialInOut\n   *\n   * @param {number} k Value between 0 and 1\n   * @return {number}\n   */\n  static exponentialInOut(k) {\n    if (k === 0) return 0\n\n    if (k === 1) return 1\n\n    if ((k *= 2) < 1) return 0.5 * Math.pow(1024, k - 1)\n\n    return 0.5 * (-Math.pow(2, -10 * (k - 1)) + 2)\n  }\n\n  /**\n   * circularIn\n   *\n   * @param {number} k Value between 0 and 1\n   * @return {number}\n   */\n  static circularIn(k) {\n    return 1 - Math.sqrt(1 - k * k)\n  }\n\n  /**\n   * circularOut\n   *\n   * @param {number} k Value between 0 and 1\n   * @return {number}\n   */\n  static circularOut(k) {\n    return Math.sqrt(1 - --k * k)\n  }\n\n  /**\n   * circularInOut\n   *\n   * @param {number} k Value between 0 and 1\n   * @return {number}\n   */\n  static circularInOut(k) {\n    if ((k *= 2) < 1) return -0.5 * (Math.sqrt(1 - k * k) - 1)\n\n    return 0.5 * (Math.sqrt(1 - (k -= 2) * k) + 1)\n  }\n\n  /**\n   * elasticIn\n   *\n   * @param {number} k Value between 0 and 1\n   * @return {number}\n   */\n  static elasticIn(k) {\n    if (k === 0) return 0\n\n    if (k === 1) return 1\n\n    return -Math.pow(2, 10 * (k - 1)) * Math.sin((k - 1.1) * 5 * Math.PI)\n  }\n\n  /**\n   * elasticOut\n   *\n   * @param {number} k Value between 0 and 1\n   * @return {number}\n   */\n  static elasticOut(k) {\n    if (k === 0) return 0\n\n    if (k === 1) return 1\n\n    return Math.pow(2, -10 * k) * Math.sin((k - 0.1) * 5 * Math.PI) + 1\n  }\n\n  /**\n   * elasticInOut\n   *\n   * @param {number} k Value between 0 and 1\n   * @return {number}\n   */\n  static elasticInOut(k) {\n    if (k === 0) return 0\n\n    if (k === 1) return 1\n\n    k *= 2\n\n    if (k < 1)\n      return (\n        -0.5 * Math.pow(2, 10 * (k - 1)) * Math.sin((k - 1.1) * 5 * Math.PI)\n      )\n\n    return (\n      0.5 * Math.pow(2, -10 * (k - 1)) * Math.sin((k - 1.1) * 5 * Math.PI) + 1\n    )\n  }\n\n  /**\n   * backIn\n   *\n   * @param {number} k Value between 0 and 1\n   * @return {number}\n   */\n  static backIn(k) {\n    const s = 1.70158\n    return k * k * ((s + 1) * k - s)\n  }\n\n  /**\n   * backOut\n   *\n   * @param {number} k Value between 0 and 1\n   * @return {number}\n   */\n  static backOut(k) {\n    const s = 1.70158\n    return --k * k * ((s + 1) * k + s) + 1\n  }\n\n  /**\n   * backInOut\n   *\n   * @param {number} k Value between 0 and 1\n   * @return {number}\n   */\n  static backInOut(k) {\n    const s = 1.70158 * 1.525\n\n    if ((k *= 2) < 1) return 0.5 * (k * k * ((s + 1) * k - s))\n\n    return 0.5 * ((k -= 2) * k * ((s + 1) * k + s) + 2)\n  }\n\n  /**\n   * bounceIn\n   *\n   * @param {number} k Value between 0 and 1\n   * @return {number}\n   */\n  static bounceIn(k) {\n    return 1 - Ease.bounceOut(1 - k)\n  }\n\n  /**\n   * bounceOut\n   *\n   * @param {number} k Value between 0 and 1\n   * @return {number}\n   */\n  static bounceOut(k) {\n    if (k < 1 / 2.75) return 7.5625 * k * k\n    else if (k < 2 / 2.75) return 7.5625 * (k -= 1.5 / 2.75) * k + 0.75\n    else if (k < 2.5 / 2.75) return 7.5625 * (k -= 2.25 / 2.75) * k + 0.9375\n\n    return 7.5625 * (k -= 2.625 / 2.75) * k + 0.984375\n  }\n\n  /**\n   * bounceInOut\n   *\n   * @param {number} k Value between 0 and 1\n   * @return {number}\n   */\n  static bounceInOut(k) {\n    if (k < 0.5) return Ease.bounceIn(k * 2) * 0.5\n\n    return Ease.bounceOut(k * 2 - 1) * 0.5 + 0.5\n  }\n\n  /**\n   * smoothstep\n   *\n   * @param {number} k Value between 0 and 1\n   * @return {number}\n   */\n  static smootherStep(k) {\n    return k * k * k * (k * (6.0 * k - 15.0) + 10.0)\n  }\n}\n","/**\n * Interpolation functions.\n *\n * @cat animation\n * @static\n */\nexport \nclass Interpolation {\n  /**\n   * Linear interpolation.\n   *\n   * @param {Array}  v The input array of values to interpolate between.\n   * @param {number} k The percentage of interpolation, between 0 and 1.\n   * @param {function(number, number, number):number=} lerpFunction Interpolation function.\n   * @return {number}  The interpolated value\n   */\n  static linear(v, k, lerpFunction) {\n    let m = v.length - 1\n    let f = m * k\n    let i = Math.floor(f)\n\n    lerpFunction = lerpFunction || MathEx.lerp\n\n    if (k < 0) return lerpFunction(v[0], v[1], f)\n\n    if (k > 1) return lerpFunction(v[m], v[m - 1], m - f)\n\n    return lerpFunction(v[i], v[i + 1 > m ? m : i + 1], f - i)\n  }\n\n  /**\n   * Cubic bezier interpolation.\n   *\n   * @param {Array}  v The input array of values to interpolate between.\n   * @param {number} k The percentage of interpolation, between 0 and 1.\n   * @return {number}  The interpolated value\n   */\n  static bezier(v, k) {\n    let b = 0\n    let n = v.length\n    let pow = Math.pow\n    // Bernstein basis polynomials\n    let bn = (n, i) => {\n      let fc = Interpolation.__factorial\n      return fc(n) / fc(i) / fc(n - i)\n    }\n\n    for (let i = 0; i < n; i++)\n      b += pow(1 - k, n - i) * pow(k, i) * v[i] * bn(n, i)\n\n    return b\n  }\n\n  /**\n   * Catmull Rom interpolation.\n   *\n   * @param {Array}  v The input array of values to interpolate between.\n   * @param {number} k The percentage of interpolation, between 0 and 1.\n   * @return {number}  The interpolated value\n   */\n  static catmullRom(v, k) {\n    let m = v.length - 1\n    let f = m * k\n    let i = Math.floor(f)\n\n    let fn = (p0, p1, p2, p3, t) => {\n      let v0 = (p2 - p0) * 0.5\n      let v1 = (p3 - p1) * 0.5\n      let t2 = t * t\n      let t3 = t * t2\n\n      return (\n        ((p1 - p2) * 2 + v0 + v1) * t3 +\n        ((p2 - p1) * 3 - 2 * v0 - v1) * t2 +\n        v0 * t +\n        p1\n      )\n    }\n\n    if (v[0] === v[m]) {\n      if (k < 0) i = Math.floor((f = m * (1 + k)))\n\n      return fn(v[(i - 1 + m) % m], v[i], v[(i + 1) % m], v[(i + 2) % m], f - i)\n    } else {\n      if (k < 0) return v[0] - (fn(v[0], v[0], v[1], v[1], -f) - v[0])\n      else if (k > 1)\n        return v[m] - (fn(v[m], v[m], v[m - 1], v[m - 1], f - m) - v[m])\n\n      return fn(\n        v[i ? i - 1 : 0],\n        v[i],\n        v[m < i + 1 ? m : i + 1],\n        v[m < i + 2 ? m : i + 2],\n        f - i\n      )\n    }\n  }\n}\n\n/**\n * @private\n * @param {number} n\n * @return {number}\n */\nInterpolation.__factorial = (function() {\n  let a = [1]\n\n  return function(n) {\n    if (a[n]) return a[n]\n\n    let s = n\n\n    while (--n) s *= n\n\n    a[n] = s\n    return s\n  }\n})()\n","/**\n * A tweening component.\n *\n * @fires Tween#start\n * @fires Tween#update\n * @fires Tween#loop\n * @fires Tween#complete\n *\n * @cat animation\n * @unrestricted\n * @extends Component\n */\nexport \nclass Tween extends Component {\n  /**\n   * Creates new instance of Tween Component.\n   * @param {Object}        values            The values to tween.\n   * @param {number}        [duration=0.25]   Duraction in seconds.\n   * @param {Object|null}   [properties=null] Tween properties Object.\n   * @param {Object|null}   [plugins=null]    Interpolation plugins object\n   */\n  constructor(values, duration = 0.25, properties = null, plugins = null) {\n    super()\n\n    /** @private @dict */\n    this.mValues = values\n\n    /** @private @type {number} */\n    this.mDuration = duration\n\n    /** @private @dict */\n    this.mProperties = properties\n\n    /** @private @dict */\n    this.mPlugins = plugins\n\n    /** @private @type {boolean} */\n    this.mIsPlaying = false\n\n    /** @private @type {boolean} */\n    this.mIsPaused = false\n\n    /** @private @type {number} */\n    this.mStartTime = 0\n\n    /** @private @type {number} */\n    this.mPausedTime = 0\n\n    /** @private @dict */\n    this.mValuesStart = {}\n\n    /** @private @type {number} */\n    this.mElapsed = 0\n\n    /** @private @type {function (Array, number):number} */\n    this.mInterpolation = Interpolation.linear\n\n    /** @private @type {number} */\n    this.mDelay = 0\n\n    /** @private @type {number} */\n    this.mRepeatDelay = 0\n\n    /** @private @type {number} */\n    this.mRepeats = 0\n\n    /** @private @type {boolean} */\n    this.mInitiated = false\n\n    /** @private @type {boolean} */\n    this.mStarted = false\n\n    /** @private @type {boolean} */\n    this.mReversed = false\n\n    /** @private @type {boolean} */\n    this.mYoyo = false\n\n    /** @private @type {boolean} */\n    this.mIsYoyoBack = false\n\n    /** @private @type {boolean} */\n    this.mReverseOnInit = false\n\n    /** @private @type {boolean} */\n    this.mRemoveOnComplete = true\n\n    /** @private @type {boolean} */\n    this.mPlayOnAdded = true\n\n    /** @private @type {function(number):number} */\n    this.mEase = Tween.DEFAULT_EASE\n\n    if (this.mProperties !== null) {\n      for (let f in this.mProperties) {\n        this[f] = /** @dict */ this.mProperties[f]\n      }\n    }\n  }\n\n  /**\n   * Sets/Gets active ease function.\n   *\n   * @return {function(number):number}\n   */\n  get ease() {\n    return this.mEase\n  }\n\n  /**\n   * @ignore\n   * @param {function(number):number} value The easing function.\n   * @return {void}\n   */\n  set ease(value) {\n    this.mEase = value\n  }\n\n  /**\n   * Sets/Gets the interpolation algorithm. Possible values Interpolation.linear, Interpolation.bezier, Interpolation.catmullRom or your custom function.\n   *\n   * @return {function(Array, number):number}\n   */\n  get interpolation() {\n    return this.mInterpolation\n  }\n\n  /**\n   * @ignore\n   * @param {function(Array, number):number} value The interpolation function.\n   * @return {void}\n   */\n  set interpolation(value) {\n    this.mInterpolation = value\n  }\n\n  /**\n   * Time elapsed since tween start in seconds.\n   *\n   * @readonly\n   * @return {number}\n   */\n  get elapsed() {\n    return this.mElapsed\n  }\n\n  /**\n   * Sets/Gets amount of seconds to wait before tweening.\n   *\n   * @return {number}\n   */\n  get delay() {\n    return this.mDelay\n  }\n\n  /**\n   * @ignore\n   * @param {number} value Seconds to wait.\n   * @return {void}\n   */\n  set delay(value) {\n    this.mDelay = value\n  }\n\n  /**\n   * Gets/Sets the number of times the tween will be repeated after first execution.\n   *\n   * @return {number}\n   */\n  get repeats() {\n    return this.mRepeats\n  }\n\n  /**\n   * @ignore\n   * @param {number} value Number of times.\n   * @return {void}\n   */\n  set repeats(value) {\n    this.mRepeats = value\n  }\n\n  /**\n   * Sets/Gets amount of seconds to wait between repeats.\n   *\n   * @return {number}\n   */\n  get repeatDelay() {\n    return this.mRepeatDelay\n  }\n\n  /**\n   * @ignore\n   * @param {number} value Seconds to wait.\n   * @return {void}\n   */\n  set repeatDelay(value) {\n    this.mRepeatDelay = value\n  }\n\n  /**\n   * Gets/Sets if tween should be looped over.\n   *\n   * @return {boolean}\n   */\n  get loop() {\n    return this.mRepeats === Infinity\n  }\n\n  /**\n   * @ignore\n   * @param {boolean} value\n   * @return {void}\n   */\n  set loop(value) {\n    this.mRepeats = value ? Infinity : 0\n  }\n\n  /**\n   * Enables/disables reversing between repeats.\n   *\n   * @return {boolean}\n   */\n  get yoyo() {\n    return this.mYoyo\n  }\n\n  /**\n   * @ignore\n   * @param {boolean} value\n   * @return {void}\n   */\n  set yoyo(value) {\n    this.mYoyo = value\n  }\n\n  /**\n   * Enables/disables reversed playback on start.\n   *\n   * @return {boolean}\n   */\n  get reversed() {\n    return this.mReversed\n  }\n\n  /**\n   * @ignore\n   * @param {boolean} value\n   * @return {void}\n   */\n  set reversed(value) {\n    this.mReversed = value\n  }\n\n  /**\n   * Sets/Gets whether the Tween Component should be automatically detached from owner GameObject after completion.\n   *\n   * @return {boolean}\n   */\n  get removeOnComplete() {\n    return this.mRemoveOnComplete\n  }\n\n  /**\n   * @ignore\n   * @param {boolean} value\n   * @return {void}\n   */\n  set removeOnComplete(value) {\n    this.mRemoveOnComplete = value\n  }\n\n  /**\n   * Sets/Gets whether the tween should start playing automatically when added to the root.\n   *\n   * @return {boolean}\n   */\n  get playOnAdded() {\n    return this.mPlayOnAdded\n  }\n\n  /**\n   * @ignore\n   * @param {boolean} value\n   * @return {void}\n   */\n  set playOnAdded(value) {\n    this.mPlayOnAdded = value\n  }\n\n  /**\n   * Sets/Gets optional object with custom interpolation handler function for specific target properties.\n   *\n   * @return {Object}\n   */\n  get plugins() {\n    return this.mPlugins\n  }\n\n  /**\n   * @ignore\n   * @param {Object} value\n   * @return {void}\n   */\n  set plugins(value) {\n    this.mPlugins = value\n  }\n\n  /**\n   * Gets this tween duration.\n   *\n   * @return {number}\n   */\n  get duration() {\n    return this.mDuration\n  }\n\n  /**\n   * Indicated whether the tween is playing and not paused.\n   *\n   * @return {boolean}\n   */\n  get isPlaying() {\n    return this.mIsPlaying === true && this.mIsPaused === false\n  }\n\n  /**\n   * @private\n   * @param {number} t\n   * @return {void}\n   */\n  __start(t) {\n    this.mIsPlaying = true\n    this.mStartTime = t + this.mDelay\n  }\n\n  /**\n   * Starts tweening.\n   *\n   * @return {Tween} Returns this.\n   */\n  play() {\n    if (!this.mIsPaused) {\n      this.__start(Time.now)\n    } else {\n      this.__resume()\n    }\n\n    return this\n  }\n\n  /**\n   * Stops current tween.\n   *\n   * @return {Tween} Returns this.\n   */\n  stop() {\n    if (!this.mIsPlaying) return this\n\n    this.mIsPlaying = false\n\n    return this\n  }\n\n  /**\n   * Resets current tween.\n   *\n   * @return {Tween} Returns this.\n   */\n  reset() {\n    this.mElapsed = 0\n    if (this.mIsPlaying) this.play()\n\n    return this\n  }\n\n  /**\n   * Sets the values for tweening.\n   *\n   * @param {Object} values Values to tween.\n   * @param {number} [duration=0.25] Duration in seconds.\n   * @return {Tween} Returns this.\n   */\n  to(values = {}, duration = 0.25) {\n    this.mValues = values\n    this.mDuration = duration\n    this.mInitiated = false\n    return this\n  }\n\n  /**\n   * Pauses current tween.\n   *\n   * @return {Tween} Returns this.\n   */\n  pause() {\n    if (!this.mIsPlaying) return this\n\n    this.mIsPaused = true\n    this.mPausedTime = Time.now\n\n    return this\n  }\n\n  /**\n   * @ignore\n   * @private\n   * @return {void} Description\n   */\n  __resume() {\n    if (!this.mIsPaused) return\n\n    this.mIsPaused = false\n    this.mStartTime += Time.now - this.mPausedTime\n  }\n\n  /**\n   * @inheritDoc\n   */\n  removeFromParent() {\n    if (this.mIsPlaying) this.stop()\n\n    super.removeFromParent()\n  }\n\n  /**\n   * Add specified tween object into the queue. The specified tween will be executed after completion of this tween,\n   *\n   * @return {Tween} Returns tween to chain.\n   */\n  chain(tween) {\n    if (!tween) {\n      return this\n    }\n\n    this.mRemoveOnComplete = false\n    tween.playOnAdded = false\n\n    this.on(Message.COMPLETE, () => {\n      tween.play()\n    })\n\n    return tween\n  }\n\n  /**\n   * @inheritDoc\n   */\n  onAdded(gameObject) {\n    if (this.mPlayOnAdded) {\n      this.__start(Time.now)\n    }\n  }\n\n  /**\n   * @private\n   * @param {number} t\n   * @return {void}\n   */\n  __update(t) {}\n\n  /**\n   * Updates tween values.\n   *\n   * @param {Object} values The Object to get values from.\n   * @return {void}\n   */\n  set(values) {\n    this.mValues = values\n\n    for (let f in this.mValues)\n      this.mValuesStart[f] = parseFloat(this.gameObject[f])\n  }\n\n  /**\n   * Switches end values with start values.\n   *\n   * @param {boolean} asYoyo Indicates wether easing function should be also reversed.\n   * @return {Tween} Returns this.\n   */\n  reverse(asYoyo = false) {\n    if (this.mInitiated) {\n      this.__reverse()\n    } else {\n      this.mReverseOnInit = true\n    }\n\n    if (asYoyo) this.mIsYoyoBack = !this.mIsYoyoBack\n\n    return this\n  }\n\n  /**\n   * @private\n   * @return {void}\n   */\n  __reverse() {\n    for (let f in this.mValues) {\n      ;[this.mValues[f], this.mValuesStart[f]] = [\n        this.mValuesStart[f],\n        this.mValues[f],\n      ]\n    }\n  }\n\n  onRender() {\n    if (Black.numUpdates !== 0) return\n\n    let time = Time.now\n\n    if (\n      time < this.mStartTime ||\n      this.mIsPlaying === false ||\n      this.mIsPaused === true\n    )\n      return\n\n    if (this.mStarted === false || this.mInitiated === false) return\n\n    this.mElapsed = (time - this.mStartTime) / this.mDuration\n\n    if (this.mElapsed > 1) this.mElapsed = 1\n\n    let t = this.mEase(this.mIsYoyoBack ? 1 - this.mElapsed : this.mElapsed)\n\n    for (let f in this.mValues) {\n      let start = /** @type {number} */ (this.mValuesStart[f])\n      let end = /** @type {number|Array} */ (this.mValues[f])\n\n      if (this.mPlugins !== null && this.mPlugins.hasOwnProperty(f)) {\n        let toLerp = Array.isArray(end) ? end : [start, end]\n        this.gameObject[f] = Interpolation.linear(toLerp, t, this.mPlugins[f])\n      } else if (Array.isArray(end)) {\n        this.gameObject[f] = this.mInterpolation(end, t)\n      } else {\n        this.gameObject[f] =\n          /** @type {number} */ (start +\n          /** @type {number} */ (end - start) * (this.mIsYoyoBack ? 1 - t : t))\n      }\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n  onUpdate() {\n    let t = Time.now\n\n    if (\n      t < this.mStartTime ||\n      this.mIsPlaying === false ||\n      this.mIsPaused === true\n    )\n      return\n\n    this.__collectStartingValues()\n\n    this.mElapsed = (t - this.mStartTime) / this.mDuration\n\n    if (this.mElapsed > 1) this.mElapsed = 1\n\n    let tt = this.mEase(this.mIsYoyoBack ? 1 - this.mElapsed : this.mElapsed)\n\n    for (let f in this.mValues) {\n      let start = /** @type {number} */ (this.mValuesStart[f])\n      let end = /** @type {number|Array} */ (this.mValues[f])\n\n      if (this.mPlugins !== null && this.mPlugins.hasOwnProperty(f)) {\n        let toLerp = Array.isArray(end) ? end : [start, end]\n        this.gameObject[f] = Interpolation.linear(toLerp, tt, this.mPlugins[f])\n      } else if (Array.isArray(end)) {\n        this.gameObject[f] = this.mInterpolation(end, tt)\n      } else {\n        this.gameObject[f] =\n          /** @type {number} */ (start +\n          /** @type {number} */ (end - start) *\n            (this.mIsYoyoBack ? 1 - tt : tt))\n      }\n    }\n\n    /**\n     * Posted on every tween update.\n     * Note: tween can update object values inside `onRender` method without posting `Tween#update` message.\n     * @event Tween#update\n     */\n    this.post(Message.UPDATE, this.gameObject)\n\n    if (this.mElapsed === 1) {\n      if (this.mRepeats-- > 0) {\n        if (this.mYoyo === true) {\n          this.reverse(true)\n        }\n\n        this.mStartTime = t + this.mRepeatDelay\n\n        /**\n         * Posted everytime tween is repeating.\n         * @event Tween#loop\n         */\n        this.post('loop', this.gameObject)\n      } else {\n        this.mIsPlaying = false\n\n        /**\n         * Posten when tween is finished.\n         * @event Tween#complete\n         */\n        this.post(Message.COMPLETE, this.gameObject)\n\n        if (this.mRemoveOnComplete) {\n          this.removeFromParent()\n        } else {\n          for (let f in this.mValues) {\n            this.mValuesStart[f] = this.mValues[f]\n          }\n\n          this.mStarted = false\n        }\n      }\n    }\n  }\n\n  __collectStartingValues() {\n    if (this.mStarted === false) {\n      this.mStarted = true\n\n      /**\n       * Posted when tween started.\n       * @event Tween#start\n       */\n      this.post('start', this.gameObject)\n\n      for (let f in this.mValues) {\n        if (!this.mInitiated && Array.isArray(this.mValues[f])) {\n          this.mValues[f] = [this.gameObject[f]].concat(this.mValues[f])\n        }\n        this.mValuesStart[f] = parseFloat(this.gameObject[f])\n      }\n\n      if (this.mReversed === true || this.mReverseOnInit === true)\n        this.__reverse()\n\n      this.mInitiated = true\n    }\n  }\n}\n\n/**\n * Ease to be used in all tweens, if another ease is not specified. `Ease.smootherStep`.\n *\n * @public\n * @type {function(number):number}\n * @nocollapse\n */\nTween.DEFAULT_EASE = Ease.smootherStep\n","/**\n * Holds details about sprite animation.\n *\n * @fires AnimationInfo#complete\n * @cat animation\n */\nexport \nclass AnimationInfo {\n  /**\n   * Creates an instance of Animation class\n   *\n   * @param {AnimationController}    controller  Animation controller\n   * @param {string}                 name        The name of animation\n   * @param {Array<Texture>}         frames      Array of Textures for this animation\n   * @param {number}                 [fps=14]    Frame rate\n   * @param {boolean}                [loop=true] Is animations should be looped\n   */\n  constructor(controller, name, frames, fps = 14, loop = true) {\n    Debug.assert(fps > 0, 'FPS must be greater than 0.')\n\n    /**\n     * @private\n     * @type {AnimationController}\n     */\n    this.mController = controller\n\n    /**\n     * @private\n     * @type {string}\n     */\n    this.mName = name\n\n    /**\n     * @private\n     * @type {Array<Texture>}\n     */\n    this.mFrames = frames\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.mCurrentFrame = 0\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.mNextFrameAt = 0\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.mFPS = fps\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.mFrameDuration = 1 / this.mFPS\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.mLoop = loop\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.mPaused = false\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.mElapsed = 0\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.mStopped = false\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.mCompleted = false\n  }\n\n  /**\n   * Plays animation. If Animation is completed, current frame is reset to 0.\n   * @ignore\n   * @return {Texture} Returns the current frame Texture.\n   */\n  __play() {\n    if (this.mCompleted === true) {\n      this.mCurrentFrame = 0\n      this.mElapsed = 0\n    }\n\n    this.mPaused = false\n    this.mStopped = false\n    this.mCompleted = false\n\n    this.mNextFrameAt = Time.now + this.mFrameDuration - this.mElapsed\n    this.mElapsed = 0\n\n    return this.mFrames[this.mCurrentFrame]\n  }\n\n  /**\n   * Stops animation and resets the value of current frame.\n   *\n   * @ignore\n   * @return {void}\n   */\n  __stop() {\n    this.mStopped = true\n    this.mCurrentFrame = 0\n  }\n\n  /**\n   * Pauses animation.\n   *\n   * @ignore\n   * @return {void}\n   */\n  __pause() {\n    this.mPaused = true\n    this.mElapsed = this.mNextFrameAt - Time.now\n  }\n\n  /**\n   * @ignore\n   * @return {Texture|null}\n   */\n  __update() {\n    let t = Time.now\n    let dt = Time.dt\n\n    if (\n      t < this.mNextFrameAt ||\n      this.mPaused === true ||\n      this.mStopped === true ||\n      this.mCompleted === true\n    )\n      return null\n\n    this.mCurrentFrame++\n\n    if (this.mCurrentFrame >= this.mFrames.length) {\n      if (this.mLoop === true) {\n        this.mCurrentFrame = 0\n      } else {\n        this.mCurrentFrame = this.mFrames.length - 1\n\n        /**\n         * Post messages when animation reach its end.\n         *\n         * @event AnimationInfo#complete\n         */\n        this.mController.post(Message.COMPLETE, this)\n        this.mCompleted = true\n        return null\n      }\n    }\n\n    this.mNextFrameAt = Time.now + this.mFrameDuration\n    return this.mFrames[this.mCurrentFrame]\n  }\n\n  /**\n   * Get/Set animation speed in frames per second.\n   *\n   * @return {number}\n   */\n  get fps() {\n    return this.mFPS\n  }\n\n  /**\n   * @ignore\n   * @param {number} value\n   * @return {void}\n   */\n  set fps(value) {\n    Debug.assert(value > 0, 'FPS must be greater than 0.')\n\n    this.mFPS = value\n    this.mFrameDuration = 1 / this.mFPS\n\n    // update next frame start time\n    this.mNextFrameAt += this.mNextFrameAt - Time.now\n  }\n\n  /**\n   * Get/Set if animation should be looped.\n   * @return {boolean}\n   */\n  get loop() {\n    return this.mLoop\n  }\n\n  /**\n   * @ignore\n   * @param {boolean} value\n   * @return {void}\n   */\n  set loop(value) {\n    this.mLoop = value\n  }\n\n  /**\n   * Gets array of Texture.\n   *\n   * @return {Array<Texture>}\n   */\n  get frames() {\n    return this.mFrames\n  }\n\n  /**\n   * Returns true if Animation is playing (neither stopped nor paused).\n   *\n   * @return {boolean}\n   */\n  get isPlaying() {\n    return this.mPaused === false && this.mStopped === false\n  }\n\n  /**\n   * Returns true if animation is completed.\n   *\n   * @return {boolean}\n   */\n  get isComplete() {\n    return this.mCompleted\n  }\n\n  /**\n   * Returns name of this animation.\n   *\n   * @return {string}\n   */\n  get name() {\n    return this.mName\n  }\n}\n","/**\n * A Component which allows to play sprite animations.\n *\n * @cat animation\n * @extends Component\n */\nexport \nclass AnimationController extends Component {\n  /**\n   * Creates an instance of AnimationController\n   */\n  constructor() {\n    super()\n\n    /**\n     * @private\n     * @type {Object<string, AnimationInfo>}\n     */\n    this.mAnimations = {}\n\n    /**\n     * @private\n     * @type {AnimationInfo|null}\n     */\n    this.mCurrentAnim = null\n  }\n\n  /**\n   * Returns the AnimationInfo object that exists with the specified name.\n   *\n   * @param {string} name     The name of the child to return.\n   * @returns {AnimationInfo} Animation object that exists with the specified name.\n   */\n  getByName(name) {\n    Debug.assert(name !== null, 'Animation must be set first.')\n    Debug.assert(\n      this.mAnimations.hasOwnProperty(name),\n      'Animation must be set first.'\n    )\n\n    return this.mAnimations[name]\n  }\n\n  /**\n   * Removes Animation object that exists with the specified name. If animation is playing right now it will be stopped.\n   *\n   * @param {string} name The name of the animation to remove.\n   * @returns {void}\n   */\n  remove(name) {\n    Debug.assert(name !== null, 'Animation name shall not be null.')\n    Debug.assert(\n      this.mAnimations.hasOwnProperty(name) === true,\n      'Unable to find animation.'\n    )\n\n    let anim = this.mAnimations[name]\n\n    if (this.mCurrentAnim !== null && this.mCurrentAnim === anim) {\n      this.stop()\n      delete this.mAnimations[name]\n    }\n\n    this.mCurrentAnim = null\n  }\n\n  /**\n   * Add the Animation object into the list of animations. If animation with given name already exists exception will be thrown.\n   *\n   * @param {string}          name        The name of animation to update\n   * @param {Array<Texture>}  textures    Array of Textures\n   * @param {number}          [fps=14]    Frames Per Second\n   * @param {boolean}         [loop=true] Indicated if animation should be started over at the end.\n   * @return {AnimationInfo} The newly created Animation Object.\n   */\n  add(name, textures, fps = 14, loop = true) {\n    Debug.assert(textures.length > 0, 'Animation cannot be empty.')\n    Debug.assert(fps > 0, 'FPS must be greater than 0.')\n    Debug.assert(\n      this.mAnimations.hasOwnProperty(name) == false,\n      'Animation with same name already exists'\n    )\n\n    let anim = new AnimationInfo(this, name, textures, fps, loop)\n    this.mAnimations[name] = anim\n\n    return anim\n  }\n\n  /**\n   * Plays animation that exists with the specified name.\n   *\n   * @param {string} name The name of animation to play.\n   * @return {void}\n   */\n  play(name) {\n    Debug.assert(\n      this.mAnimations.hasOwnProperty(name),\n      'Animation must be set first.'\n    )\n\n    this.mCurrentAnim = this.mAnimations[name]\n\n    let texture = this.mCurrentAnim.__play()\n\n    let sprite = /** @type {Sprite} */ (this.gameObject)\n    if (sprite === null) return\n\n    if (texture !== null) sprite.texture = texture\n  }\n\n  /**\n   * Stops active animation. If no animations are playing at the moment nothing will happen.\n   *\n   * @return {void}\n   */\n  stop() {\n    if (this.mCurrentAnim === null) return\n\n    this.mCurrentAnim.__stop()\n  }\n\n  /**\n   * Pauses active animation.\n   *\n   * @return {void}\n   */\n  pause() {\n    if (this.mCurrentAnim === null) return\n\n    this.mCurrentAnim.__pause()\n  }\n\n  /**\n   * @inheritDoc\n   */\n  onRender() {\n    if (this.mCurrentAnim === null) return\n\n    let newTexture = this.mCurrentAnim.__update()\n    if (newTexture === null) return\n\n    let sprite = /** @type {Sprite} */ (this.gameObject)\n    sprite.texture = newTexture\n  }\n\n  /**\n   * Returns current active animation.\n   *\n   * @returns {AnimationInfo|null}\n   */\n  get currentAnimation() {\n    return this.mCurrentAnim\n  }\n}\n","/**\n * The main class, which is responsible for audio support.\n *\n * @cat audio\n * @extends {System}\n */\nexport \nclass MasterAudio extends System {\n  /**\n   * Singleton\n   */\n  constructor() {\n    super()\n\n    MasterAudio.instance = this\n\n    /** @private @type {AudioContext|null} */\n    this.mContext = null\n\n    try {\n      this.mContext = new (window['AudioContext'] ||\n        window['webkitAudioContext'])()\n    } catch (error) {\n      if (this.mContext == null) {\n        Debug.warn('no audio support')\n        return\n      }\n    }\n\n    this.__unlock()\n\n    /** @private @type {SoundListener|null} */\n    this.mCurrentListener = null\n\n    /** @private @type {Object<string, SoundChannel>} */\n    this.mChannels = {}\n\n    /** @private @type {SoundChannel} */\n    this.mMasterChannel = new SoundChannel('master')\n\n    this.mMasterChannel._outputNode.connect(this.mContext.destination)\n    this.mChannels['master'] = this.mMasterChannel\n  }\n\n  /**\n   * @ignore\n   * @private\n   * @return {void}\n   */\n  __unlock() {\n    let f = () => {\n      let buffer = this.mContext.createBuffer(1, 1, 22050)\n      let unlockSource = this.mContext.createBufferSource()\n      unlockSource.buffer = buffer\n      unlockSource.connect(this.mContext.destination)\n\n      if (unlockSource.start === undefined) unlockSource.noteOn(0)\n      else unlockSource.start(0)\n\n      if (unlockSource.context.state === 'suspended')\n        unlockSource.context.resume()\n\n      document.removeEventListener('touchstart', f)\n      document.removeEventListener('click', f)\n    }\n\n    document.addEventListener('touchstart', f)\n    document.addEventListener('click', f)\n  }\n\n  /**\n   * Creates or returns the channel with specific name.\n   *\n   * @param {string} name The name of channel to create.\n   * @returns {SoundChannel}\n   */\n  static createChannel(name) {\n    if (MasterAudio.instance.mChannels[name] == null) {\n      let ch = new SoundChannel(name)\n      ch._outputNode.connect(MasterAudio.instance.mMasterChannel._inputNode)\n      MasterAudio.instance.mChannels[name] = ch\n    }\n    return MasterAudio.instance.mChannels[name]\n  }\n\n  /**\n   * Gets the channel with specific name.\n   *\n   * @param {string} name The name of channel to get.\n   * @returns {SoundChannel|null}\n   */\n  static getChannel(name) {\n    return MasterAudio.instance.mChannels[name]\n  }\n\n  /**\n   * @ignore\n   * @param {SoundInstance} snd\n   * @returns {SoundChannel}\n   */\n  static _resolveChannel(snd) {\n    for (let chName in MasterAudio.instance.mChannels)\n      MasterAudio.instance.mChannels[chName].detachSound(snd)\n    let chName = snd.channel == '' ? 'master' : snd.channel\n    let ch = MasterAudio.instance.mChannels[chName]\n    ch.attachSound(snd)\n    return ch\n  }\n\n  /**\n   * Plays sound on specific channel.\n   *\n   * @public\n   * @param {string|SoundClip} nameOrSound The name of sound or the instance of SoundInstance.\n   * @param {string=} [channel='master']       The name of channel to play on.\n   * @param {number=} [volume=1]               Volume level.\n   * @param {boolean=} [loop=false]            Defines if sound will loop.\n   * @param {number=} [pan=0]                  The panning of the sound, ranging from -1 (left) to 1 (right).\n   * @returns {SoundInstance}                  New sound instance to be played.\n   */\n  static play(\n    nameOrSound,\n    channel = 'master',\n    volume = 1,\n    loop = false,\n    pan = 0\n  ) {\n    Debug.assert(nameOrSound != null, `Param 'nameOrSound' cannot be null.`)\n\n    let sound = null\n    if (nameOrSound.constructor === String) {\n      sound = AssetManager.default.getSound(/** @type {string} */ (nameOrSound))\n    }\n\n    return sound.play(channel, volume, loop, pan)\n  }\n\n  /**\n   * Stops all sound on specific channel.\n   *\n   * @public\n   * @param {string} channelName The name of channel to stop sounds on. If empty, stops sounds on all channels.\n   * @returns {void}\n   */\n  static stopAll(channelName = '') {\n    if (channelName === '') {\n      for (let chName in MasterAudio.instance.mChannels) {\n        MasterAudio.instance.mChannels[chName].stopAll()\n      }\n    } else {\n      MasterAudio.getChannel(channelName).stopAll()\n    }\n  }\n\n  /**\n   * @ignore\n   * @param {number} value\n   * @returns {void}\n   */\n  static set masterVolume(value) {\n    MasterAudio.instance.mMasterChannel.volume = value\n  }\n\n  /**\n   * Gets/Sets volume on master channel.\n   *\n   * @public\n   * @returns {number}\n   */\n  static get masterVolume() {\n    return MasterAudio.instance.mMasterChannel.volume\n  }\n\n  /**\n   * Gets the only instance of native AudioContext.\n   *\n   * @readonly\n   * @returns {AudioContext}\n   */\n  static get context() {\n    return MasterAudio.instance.mContext\n  }\n\n  /**\n   * Gets the master channel.\n   *\n   * @readonly\n   * @returns {SoundChannel}\n   */\n  static get masterChannel() {\n    return MasterAudio.instance.mMasterChannel\n  }\n\n  /**\n   * @ignore\n   * @param {SoundListener} value\n   * @returns {void}\n   */\n  static set currentListener(value) {\n    MasterAudio.instance.mCurrentListener = value\n  }\n\n  /**\n   * Gets/Sets current listener for spatial sound effects.\n   *\n   * @public\n   * @returns {SoundListener}\n   */\n  static get currentListener() {\n    return MasterAudio.instance.mCurrentListener\n  }\n\n  /**\n   * Resets current listener to default AudioContext listener.\n   *\n   * @public\n   * @returns {void}\n   */\n  static looseListener() {\n    MasterAudio.context.listener.setPosition(0, 0, 1)\n    MasterAudio.currentListener = null\n  }\n\n  /**\n   * @ignore\n   * @returns {!GainNode}\n   */\n  static _newGainNode() {\n    if (MasterAudio.context.createGain === undefined)\n      return MasterAudio.context.createGainNode()\n\n    return MasterAudio.context.createGain()\n  }\n}\n\n/**\n * @static\n * @type {MasterAudio}\n */\nMasterAudio.instance = null\n","/**\n * The sound effect interface. Implementations can be attached to sound channel.\n *\n * @cat audio\n */\nexport \nclass SoundEffect {\n  /**\n   * Creates new instance of SoundEffect.\n   */\n  constructor() {\n    /** @ignore @protected @type {AudioNode} */\n    this.mInputNode = null\n\n    /** @ignore @protected @type {AudioNode} */\n    this.mOutputNode = null\n  }\n\n  /**\n   * @ignore\n   * @return {AudioNode}\n   */\n  get _inputNode() {\n    Debug.assert(\n      this.mInputNode != null,\n      'Input node must be specified in descendant class'\n    )\n    return this.mInputNode\n  }\n\n  /**\n   * @ignore\n   * @return {AudioNode}\n   */\n  get _outputNode() {\n    Debug.assert(\n      this.mOutputNode != null,\n      'Output node must be specified in descendant class'\n    )\n    return this.mOutputNode\n  }\n}\n","/**\n * Distortion sound effect.\n *\n * @cat audio.effects\n * @extends {SoundEffect}\n */\nexport \nclass DistortionEffect extends SoundEffect {\n  /**\n   * Creates new instance of DistortionEffect\n   *\n   * @param {number} value Level of distortion.\n   */\n  constructor(value = 0.5) {\n    super()\n\n    /** @private @type {WaveShaperNode} */\n    this.mWaveShaperNode = MasterAudio.context.createWaveShaper()\n\n    /** @inheritDoc */\n    this.mInputNode = this.mWaveShaperNode\n\n    /** @inheritDoc */\n    this.mOutputNode = this.mWaveShaperNode\n\n    /** @private @type {number} */\n    this.mSamples = 44100\n\n    /** @private @type {Float32Array} */\n    this.mCurve = new Float32Array(this.mSamples)\n\n    /** @private @type {number}*/\n    this.mValue = value\n\n    this.distortion = value\n  }\n\n  /**\n   * @ignore\n   * @public\n   * @param {number} value\n   * @returns {void}\n   */\n  set distortion(value) {\n    this.mValue = MathEx.clamp(value, 0, 1)\n    this.__makeDistortionCurve(this.mValue, this.mSamples, this.mCurve)\n    this.mWaveShaperNode.curve = this.mCurve\n  }\n\n  /**\n   * Gets/Sets level of distortion\n   *\n   * @public\n   * @returns {number}\n   */\n  get distortion() {\n    return this.mValue\n  }\n\n  // https://stackoverflow.com/a/22313408\n  /**\n   * @ignore\n   * @private\n   * @param {number} amount\n   * @param {number} n_samples\n   * @param {Float32Array} curve\n   * @returns {Float32Array}\n   */\n  __makeDistortionCurve(amount, n_samples, curve) {\n    let k = ~~(amount * 100)\n    let deg = Math.PI / 180\n    let x = 0\n    for (let i = 0; i < n_samples; ++i) {\n      x = (i * 2) / n_samples - 1\n      curve[i] = ((3 + k) * x * 20 * deg) / (Math.PI + k * Math.abs(x))\n    }\n    return curve\n  }\n\n  // tuna.js\n\n  //   makeDistortionCurve2(amount, n_samples, curve) {\n  //     amount = Math.min(amount, 0.9999);\n  //     let k = 2 * amount / (1 - amount),\n  //         i, x;\n  //     for (i = 0; i < n_samples; i++) {\n  //         x = i * 2 / n_samples - 1;\n  //         curve[i] = (1 + k) * x / (1 + k * Math.abs(x));\n  //     }\n  //   }\n\n  //   makeDistortionCurve3(amount, n_samples, curve) {\n  //     let i, x, y;\n  //     for (i = 0; i < n_samples; i++) {\n  //         x = i * 2 / n_samples - 1;\n  //         y = ((0.5 * Math.pow((x + 1.4), 2)) - 1) * y >= 0 ? 5.8 : 1.2;\n  //         curve[i] = tanh(y);\n  //     }\n  //   }\n\n  //   makeDistortionCurve4(amount, n_samples, curve) {\n  //     let i, x, y, a = 1 - amount;\n  //     for (i = 0; i < n_samples; i++) {\n  //         x = i * 2 / n_samples - 1;\n  //         y = x < 0 ? -Math.pow(Math.abs(x), a + 0.04) : Math.pow(x, a);\n  //         curve[i] = tanh(y * 2);\n  //     }\n  //   }\n\n  //   // is it working?\n  //   makeDistortionCurve5(amount, n_samples, curve) {\n  //     let i, x, y, abx, a = 1 - amount > 0.99 ? 0.99 : 1 - amount;\n  //     for (i = 0; i < n_samples; i++) {\n  //         x = i * 2 / n_samples - 1;\n  //         abx = Math.abs(x);\n  //         if (abx < a) y = abx;\n  //         else if (abx > a) y = a + (abx - a) / (1 + Math.pow((abx - a) / (1 - a), 2));\n  //         else if (abx > 1) y = abx;\n  //         curve[i] = sign(x) * y * (1 / ((a + 1) / 2));\n  //     }\n  //   }\n\n  //   makeDistortionCurve6(amount, n_samples, curve) {\n  //     let i, x;\n  //     for (i = 0; i < n_samples; i++) {\n  //         x = i * 2 / n_samples - 1;\n  //         if (x < -0.08905) {\n  //             curve[i] = (-3 / 4) * (1 - (Math.pow((1 - (Math.abs(x) - 0.032857)), 12)) + (1 / 3) * (Math.abs(x) - 0.032847)) + 0.01;\n  //         } else if (x >= -0.08905 && x < 0.320018) {\n  //             curve[i] = (-6.153 * (x * x)) + 3.9375 * x;\n  //         } else {\n  //             curve[i] = 0.630035;\n  //         }\n  //     }\n  //   }\n\n  //   // is it working?\n  //   makeDistortionCurve7(amount, n_samples, curve) {\n  //     let a = 2 + Math.round(amount * 14),\n  //     bits = Math.round(Math.pow(2, a - 1)),\n  //     i, x;\n  //     for (i = 0; i < n_samples; i++) {\n  //         x = i * 2 / n_samples - 1;\n  //         curve[i] = Math.round(x * bits) / bits;\n  //     }\n  //   }\n}\n\n// function sign(x) {\n//   if (x === 0) {\n//       return 1;\n//   } else {\n//       return Math.abs(x) / x;\n//   }\n// }\n\n// function tanh(n) {\n//   return (Math.exp(n) - Math.exp(-n)) / (Math.exp(n) + Math.exp(-n));\n// }\n","/**\n * Allows to distribute sound between left and right channel.\n *\n * @cat audio.effects\n * @extends {SoundEffect}\n */\nexport \nclass StereoPanner extends SoundEffect {\n  /**\n   * Creates new instance of StereoPan.\n   */\n  constructor() {\n    super()\n\n    /** @private @type {GainNode} */\n    this.mGainL = MasterAudio._newGainNode()\n\n    /** @private @type {GainNode} */\n    this.mGainR = MasterAudio._newGainNode()\n\n    /** @private @type {ChannelSplitterNode} */\n    this.mSplitter = MasterAudio.context.createChannelSplitter(2)\n\n    /** @private @type {ChannelMergerNode} */\n    this.mMerger = MasterAudio.context.createChannelMerger(2)\n\n    this.mSplitter.connect(\n      this.mGainL,\n      0\n    )\n    this.mSplitter.connect(\n      this.mGainR,\n      1\n    )\n    this.mGainL.connect(\n      this.mMerger,\n      0,\n      0\n    )\n    this.mGainR.connect(\n      this.mMerger,\n      0,\n      1\n    )\n\n    /** @private @type {number} */\n    this.mValue = 0\n\n    /** @inheritDoc */\n    this.mInputNode = this.mSplitter\n\n    /** @inheritDoc */\n    this.mOutputNode = this.mMerger\n  }\n\n  /**\n   * @ignore\n   * @public\n   * @param {number} value\n   * @returns {void}\n   */\n  set pan(value) {\n    this.mValue = MathEx.clamp(value, -1, 1)\n    this.mGainL.gain.setValueAtTime(1 - MathEx.clamp(this.mValue, 0, 1), 0)\n    this.mGainR.gain.setValueAtTime(1 + MathEx.clamp(this.mValue, -1, 0), 0)\n  }\n\n  /**\n   * Sets/Gets stereo panning value\n   *\n   * @public\n   * @returns {number}\n   */\n  get pan() {\n    return this.mValue\n  }\n}\n","/**\n * Equalizer.\n *\n * @cat audio.effects\n * @extends {SoundEffect}\n */\nexport \nclass SimpleEQ extends SoundEffect {\n  /**\n   * Creates new instance of equalizer.\n   *\n   * @param {...number} frequencies List of frequencies to control sound with.\n   */\n  constructor(...frequencies) {\n    super()\n\n    // default values from winamp\n    frequencies = frequencies || [\n      60,\n      170,\n      310,\n      600,\n      1000,\n      3000,\n      6000,\n      12000,\n      14000,\n      16000,\n    ]\n\n    /** @private @type {Array<BiquadFilterNode>} */\n    this.mFilters = []\n\n    for (let i = 0; i < frequencies.length; i++) {\n      this.mFilters.push(this.__createFilter(frequencies[i]))\n      if (i > 0)\n        this.mFilters[i - 1].connect(\n          /** @type {!AudioNode} */ (this.mFilters[i])\n        )\n    }\n\n    /** @inheritDoc */\n    this.mInputNode = this.mFilters[0]\n\n    /** @inheritDoc */\n    this.mOutputNode = this.mFilters[this.mFilters.length - 1]\n\n    // todo: determine correct max value\n    /** @private @type {number} */\n    this.mMaxGainLevel = 16 // 18\n\n    /** @private @type {Object.<string, Array<number>>} */\n    this.mPresets = {}\n  }\n\n  /**\n   * @ignore\n   * @private\n   * @param {number} freq\n   * @returns {BiquadFilterNode}\n   */\n  __createFilter(freq) {\n    let f = MasterAudio.context.createBiquadFilter()\n    f.type = 'peaking'\n    f.frequency.setValueAtTime(freq, 0)\n    f.Q.setValueAtTime(1, 0)\n    f.gain.setValueAtTime(0, 0)\n    return f\n  }\n\n  /**\n   * Sets level by index.\n   *\n   * @public\n   * @param {number} freqIndex Index of frequency from the list.\n   * @param {number} value     Ranging from -1 to 1.\n   * @returns {void}\n   */\n  setLevelByIndex(freqIndex, value) {\n    Debug.assert(\n      freqIndex >= 0 && freqIndex < this.mFilters.length,\n      'Frequency index is out of range'\n    )\n    if (freqIndex < 0 || freqIndex >= this.mFilters.length) return\n    value = MathEx.clamp(value, -1, 1)\n    value *= this.mMaxGainLevel\n    this.mFilters[freqIndex].gain.setValueAtTime(value, 0)\n  }\n\n  /**\n   * Sets level by frequency if there is one in the list.\n   *\n   * @public\n   * @param {number} freq  Concrete frequency value.\n   * @param {number} value Ranging from -1 to 1.\n   * @returns {void}\n   */\n  setLevelByFrequency(freq, value) {\n    for (let i = 0; i < this.mFilters.length; i++) {\n      if (this.mFilters[i].frequency.value === freq) {\n        this.setLevelByIndex(i, value)\n      }\n    }\n  }\n\n  /**\n   * Adds new preset of levels.\n   *\n   * @public\n   * @param {string} name      The name of a preset.\n   * @param {...number} values Frequency levels. Their number must be equal to frequencies number.\n   * @returns {void}\n   */\n  addPreset(name, ...values) {\n    Debug.assert(\n      values.length != this.mFilters.length,\n      'Number of preset values must be equal to frequencies number'\n    )\n    this.mPresets[name] = values\n  }\n\n  /**\n   * Saves current levels as new preset with given name.\n   *\n   * @public\n   * @param {string} name The name of a preset.\n   * @returns {void}\n   */\n  savePreset(name) {\n    this.mPresets[name] = []\n    this.mFilters.forEach(x =>\n      this.mPresets[name].push(x.frequency.value / this.mMaxGainLevel)\n    )\n  }\n\n  /**\n   * Applies previously added or saved preset.\n   *\n   * @public\n   * @param {string} name The name of a preset.\n   * @returns {void}\n   */\n  applyPreset(name) {\n    if (this.mPresets[name] !== null) {\n      for (let i = 0; i < this.mPresets[name].length; i++) {\n        this.setLevelByIndex(i, this.mPresets[name][i])\n      }\n    }\n  }\n}\n","/**\n * Reverberation sound effect.\n *\n * @cat audio.effects\n * @extends {SoundEffect}\n */\nexport \nclass ReverbEffect extends SoundEffect {\n  /**\n   * Creates instance of ReverbEffect.\n   *\n   * @param {AudioBuffer} IRBuffer Impulse Response audio buffer.\n   */\n  constructor(IRBuffer) {\n    super()\n\n    /** @inheritDoc */\n    this.mInputNode = MasterAudio._newGainNode()\n\n    /** @inheritDoc */\n    this.mOutputNode = MasterAudio._newGainNode()\n\n    /** @private @type {ConvolverNode} */\n    this.mConvolver = MasterAudio.context.createConvolver()\n\n    /** @private @type {GainNode} */\n    this.mDry = MasterAudio._newGainNode()\n\n    /** @private @type {GainNode} */\n    this.mWet = MasterAudio._newGainNode()\n\n    /** @private @type {BiquadFilterNode} */\n    this.mTone = MasterAudio.context.createBiquadFilter()\n\n    this.mConvolver.buffer = IRBuffer\n\n    this.mInputNode.connect(this.mDry)\n    this.mDry.connect(this.mOutputNode)\n\n    this.mInputNode.connect(this.mTone)\n    this.mTone.connect(this.mConvolver)\n    this.mConvolver.connect(this.mWet)\n    this.mWet.connect(this.mOutputNode)\n\n    this.mDry.gain.setValueAtTime(1, 0)\n    this.mWet.gain.setValueAtTime(0, 0)\n    this.mTone.type = 'lowpass'\n    this.mTone.frequency.setValueAtTime(350, 0)\n    this.mTone.Q.setValueAtTime(Math.SQRT1_2, 0)\n  }\n\n  /**\n   * @ignore\n   * @public\n   * @param {number} value\n   * @returns {void}\n   */\n  set wet(value) {\n    value = MathEx.clamp(value, 0, 1)\n    this.mWet.gain.setValueAtTime(value, 0)\n  }\n\n  /**\n   * @ignore\n   * @public\n   * @param {number} value\n   * @returns {void}\n   */\n  set dry(value) {\n    value = MathEx.clamp(value, 0, 1)\n    this.mDry.gain.setValueAtTime(value, 0)\n  }\n\n  /**\n   * @ignore\n   * @public\n   * @param {number} value\n   * @returns {void}\n   */\n  set tone(value) {\n    value = MathEx.clamp(value, 10, MasterAudio.context.sampleRate / 2)\n    this.mTone.frequency.setValueAtTime(value, 0)\n  }\n\n  /**\n   * Gets/Sets level of convolved sound.\n   *\n   * @public\n   * @returns {number}\n   */\n  get wet() {\n    return this.mWet.gain.value\n  }\n\n  /**\n   * Gets/Sets level of original sound with no effect.\n   *\n   * @public\n   * @returns {number}\n   */\n  get dry() {\n    return this.mDry.gain.value\n  }\n\n  /**\n   * Gets/Sets frequency effect is applied on.\n   *\n   * @public\n   * @returns {number}\n   */\n  get tone() {\n    return this.mTone.frequency.value\n  }\n}\n","/**\n * Sound states.\n * @ignore\n * @constant\n * @cat audio\n * @enum {string}\n */\nexport \nconst SoundState = {\n  NEWBORN: 'newborn',\n  PLAYING: 'playing',\n  PAUSED: 'paused',\n  STOPPED: 'stopped',\n  COMPLETED: 'completed',\n}\n","/**\n * The sound\n *\n * @cat audio\n * @extends {MessageDispatcher}\n */\nexport \nclass SoundInstance extends MessageDispatcher {\n  /**\n   * Creates instance\n   * @param {SoundClip} sound `SoundClip` instance taken from `AssetManager`.\n   */\n  constructor(sound) {\n    super()\n\n    /** @private @type {number} */\n    this.mId = ++SoundInstance.ID\n\n    /** @private @type {SoundClip} */\n    this.mSound = sound\n\n    /** @private @type {SoundState} */\n    this.mState = SoundState.NEWBORN\n\n    /** @private @type {string} */\n    this.mChannel = 'master'\n\n    /** @private @type {number} */\n    this.mVolume = 1\n\n    /** @private @type {boolean} */\n    this.mLoop = false\n\n    /** @private @type {number} */\n    this.mStartTime = 0\n\n    /** @private @type {number} */\n    this.mPausePosition = 0\n\n    /** @private @type {AudioBufferSourceNode} */\n    this.mSrc = null\n\n    /** @private @type {GainNode} */\n    this.mGainNode = MasterAudio._newGainNode()\n\n    /** @private @type {AudioNode} The node to connect audio source */\n    this.mFirstNode = this.mGainNode\n\n    /** @private @type {AudioNode} The node the source is connected to */\n    this.mPlayNode = null\n\n    /** @private @type {PannerNode} */\n    this.mSpatialPanner = null\n\n    /** @private @type {StereoPanner} */\n    this.mStereoPanner = null\n\n    /** @private @type {AnalyserNode} */\n    this.mAnalyser = null\n  }\n\n  /**\n   * Enables spatial effect if not enabled previously.\n   *\n   * @public\n   * @returns {PannerNode}\n   */\n  enableSpacePan() {\n    if (this.mSpatialPanner == null) {\n      this.mSpatialPanner = MasterAudio.context.createPanner()\n      if (this.mFirstNode) {\n        this.mSpatialPanner.connect(this.mFirstNode)\n        this.mFirstNode = this.mSpatialPanner\n      }\n      this.__reconnectSource()\n    }\n    return this.mSpatialPanner\n  }\n\n  /**\n   * Enables stereo panning effect if not enabled previously.\n   *\n   * @public\n   * @returns {StereoPanner}\n   */\n  enableStereoPan() {\n    if (this.mStereoPanner == null) {\n      this.mStereoPanner = new StereoPanner()\n      if (this.mFirstNode) {\n        this.mStereoPanner._outputNode.connect(this.mFirstNode)\n        this.mFirstNode = this.mStereoPanner._inputNode\n      }\n      this.__reconnectSource()\n    }\n    return this.mStereoPanner\n  }\n\n  /**\n   * Enables analyser node if not enabled previously.\n   *\n   * @public\n   * @returns {AnalyserNode}\n   */\n  enableAnalyser() {\n    if (this.mAnalyser == null) {\n      this.mAnalyser = MasterAudio.context.createAnalyser()\n      if (this.mFirstNode) {\n        this.mAnalyser.connect(this.mFirstNode)\n        this.mFirstNode = this.mAnalyser\n      }\n      this.__reconnectSource()\n    }\n    return this.mAnalyser\n  }\n\n  /**\n   * @ignore\n   * @private\n   * @returns {void}\n   */\n  __reconnectSource() {\n    if (\n      this.mSrc != null &&\n      this.mPlayNode != null &&\n      this.mFirstNode != null\n    ) {\n      this.mSrc.disconnect(this.mPlayNode)\n      this.mSrc.connect(this.mFirstNode)\n      this.mPlayNode = this.mFirstNode\n    }\n  }\n\n  /**\n   * @ignore\n   * @returns {SoundInstance}\n   */\n  _play() {\n    if (this.mState === SoundState.PLAYING) return this\n\n    this.mState = SoundState.PLAYING\n\n    let duration =\n      this.mSound.isSubClip && !this.mLoop\n        ? this.mSound.duration - this.mPausePosition\n        : undefined\n    this.mGainNode.gain.setValueAtTime(this.mVolume, 0)\n\n    let src = MasterAudio.context.createBufferSource()\n    src.buffer = this.mSound.native\n    src.loop = this.mLoop\n    src.onended = () => this.__onComplete()\n    this.mFirstNode && src.connect(this.mFirstNode)\n    this.mPlayNode = this.mFirstNode\n    this.mStartTime = MasterAudio.context.currentTime - this.mPausePosition\n\n    if (this.mLoop && this.mSound.isSubClip) {\n      src.loopStart = this.mSound.offset\n      src.loopEnd = this.mSound.offset + this.mSound.duration\n    }\n\n    src.start(\n      MasterAudio.context.currentTime,\n      this.mSound.offset + this.mPausePosition,\n      duration\n    )\n    MasterAudio._resolveChannel(this)\n    this.mSrc = src\n\n    return this\n  }\n\n  /**\n   * Stops playing.\n   *\n   * @public\n   * @param {number=} [duration=0] Time offset in seconds specifying when the sound will completely stop.\n   * @returns {void}\n   */\n  stop(duration = 0) {\n    if (this.mState === SoundState.PLAYING) {\n      this.mGainNode.gain.cancelScheduledValues(0)\n      this.mSrc.stop(MasterAudio.context.currentTime + duration)\n    }\n  }\n\n  /**\n   * Pauses current sound.\n   *\n   * @public\n   * @returns {void}\n   */\n  pause() {\n    if (this.mState === SoundState.PLAYING) {\n      this.stop()\n      this.mPausePosition = this.currentPosition\n      this.mState = SoundState.PAUSED\n    }\n  }\n\n  /**\n   * Resumes current sound, if it has been paused.\n   *\n   * @public\n   * @returns {void}\n   */\n  resume() {\n    if (this.mState === SoundState.PAUSED) {\n      this._play()\n    }\n  }\n\n  /**\n   * Changes the volume of sound in given time.\n   *\n   * @param {number} from            Initial volume level.\n   * @param {number} to              Target volume level.\n   * @param {number=} [duration=0]   In seconds. If '0' changes the volume instantly.\n   * @param {string} [type='linear'] Possible types: 'linear', 'exp'.\n   */\n  fade(from, to, duration = 0, type = 'linear') {\n    if (duration <= 0) {\n      this.mGainNode.gain.setValueAtTime(to, 0)\n    } else {\n      this.mGainNode.gain.setValueAtTime(from, 0)\n      if (type === 'exp')\n        this.mGainNode.gain.exponentialRampToValueAtTime(\n          Math.max(to, 0.01),\n          MasterAudio.context.currentTime + duration\n        )\n      else\n        this.mGainNode.gain.linearRampToValueAtTime(\n          to,\n          MasterAudio.context.currentTime + duration\n        )\n    }\n  }\n\n  /**\n   * @ignore\n   * @private\n   * @returns {void}\n   */\n  __onComplete() {\n    this.mSrc = null\n    if (this.mState !== SoundState.PAUSED) {\n      this.mStartTime = 0\n      this.mState = SoundState.COMPLETED\n      this.post(Message.COMPLETE)\n    }\n  }\n\n  /**\n   * Gets current position of sound in seconds.\n   *\n   * @public\n   * @readonly\n   * @returns {number}\n   */\n  get currentPosition() {\n    switch (this.mState) {\n      case SoundState.PLAYING:\n        return (\n          (MasterAudio.context.currentTime - this.mStartTime) %\n          (this.mSound.duration + 0.01)\n        )\n      case SoundState.PAUSED:\n        return this.mPausePosition\n      case SoundState.COMPLETED:\n        return this.mSound.duration\n    }\n    return 0\n  }\n\n  /**\n   * @ignore\n   * @readonly\n   * @returns {AudioNode}\n   */\n  get _outputNode() {\n    return this.mGainNode\n  }\n\n  /**\n   * Gets/Sets current channel to play by name.\n   *\n   * @public\n   * @returns {string}\n   */\n  get channel() {\n    return this.mChannel\n  }\n\n  /**\n   * @ignore\n   * @public\n   * @param {string} value\n   * @returns {void}\n   */\n  set channel(value) {\n    if (this.mChannel === value) return\n    this.mChannel = value\n    if (this.mState === SoundState.PLAYING) {\n      MasterAudio._resolveChannel(this)\n    }\n  }\n\n  /**\n   * Gets/Sets sound volume. Ranging from 0 to 1.\n   *\n   * @public\n   * @returns {number}\n   */\n  get volume() {\n    return this.mVolume\n  }\n\n  /**\n   * @ignore\n   * @public\n   * @param {number} value\n   * @returns {void}\n   */\n  set volume(value) {\n    this.mVolume = value\n    this.mGainNode.gain.setValueAtTime(this.mVolume, 0)\n  }\n\n  /**\n   * Gets/Sets whether the sound will be looped.\n   *\n   * @public\n   * @returns {boolean}\n   */\n  get loop() {\n    return this.mLoop\n  }\n\n  /**\n   * @ignore\n   * @public\n   * @param {boolean} value\n   * @returns {void}\n   */\n  set loop(value) {\n    this.mLoop = value\n  }\n\n  /**\n   * Gets/Sets pan stereo effect. Ranging from -1 (left) to 1 (right).\n   *\n   * @public\n   * @returns {number}\n   */\n  get pan() {\n    return this.mStereoPanner.pan\n  }\n\n  /**\n   * @ignore\n   * @public\n   * @param {number} value\n   * @returns {void}\n   */\n  set pan(value) {\n    if (value !== 0 && this.mStereoPanner == null) this.enableStereoPan()\n\n    if (this.mStereoPanner) this.mStereoPanner.pan = value\n  }\n\n  /**\n   * Gets whether sound is playing.\n   *\n   * @public\n   * @readonly\n   * @returns {boolean}\n   */\n  get isPlaying() {\n    return this.mState === SoundState.PLAYING\n  }\n\n  /**\n   * Gets total duration of sound clip.\n   *\n   * @public\n   * @readonly\n   * @returns {number}\n   */\n  get duration() {\n    return this.mSound.duration\n  }\n}\n\n/**\n * @ignore\n * @private\n * @static\n */\nSoundInstance.ID = 0\n","/**\n * The class which stores audio buffer and its all sounds data.\n *\n * @cat audio\n */\nexport \nclass SoundClip {\n  /**\n   * Creates new instance of SoundClip.\n   *\n   * @param {AudioBuffer} nativeBuffer     Decoded audio buffer.\n   * @param {number=} [offset=0]           Determines at which position of buffer the sound will be played.\n   * @param {number=} [duration=undefined] If undefined, gets duration value from native audio buffer.\n   * @param {boolean=} [isSubClip=false]   Specifies whether this sound clip is part of a sound atlas.\n   */\n  constructor(nativeBuffer, offset = 0, duration = NaN, isSubClip = false) {\n    /** @private @type {AudioBuffer} */\n    this.mNativeBuffer = nativeBuffer\n\n    /** @private @type {number} */\n    this.mStartOffset = offset\n\n    /** @private @type {number} */\n    this.mDuration = duration || nativeBuffer.duration\n\n    /** @private @type {boolean} */\n    this.mIsSubClip = isSubClip\n  }\n\n  /**\n   * Creates sound instance and starts to play on specific channel\n   *\n   * @public\n   * @param {string=} [channel='master'] The name of channel.\n   * @param {number=} [volume=1]         The volume level.\n   * @param {boolean=} [loop=false]      Specifies if sound will repeat infinite times.\n   * @param {number=} [pan=0]            The panning value.\n   * @returns {SoundInstance}            New sound instance to be played.\n   */\n  play(channel = 'master', volume = 1, loop = false, pan = 0) {\n    let instance = new SoundInstance(this)\n    instance.channel = channel\n    instance.volume = volume\n    instance.loop = loop\n    instance.pan = pan\n    return instance._play()\n  }\n\n  /**\n   * Creates an array of blocks filled with average amplitude gathered in certain interval\n   *\n   * @public\n   * @param {number} blockNum Number of blocks to divide data to\n   * @returns {Float32Array}\n   */\n  collectWaveData(blockNum) {\n    let channels = []\n    for (let i = 0; i < this.mNativeBuffer.numberOfChannels; i++)\n      channels[i] = this.mNativeBuffer.getChannelData(i)\n\n    const playPercent = this.mDuration / this.mNativeBuffer.duration\n    const startPercent = this.mStartOffset / this.mNativeBuffer.duration\n    const startPos = ~~(channels[0].length * startPercent)\n    const endPos = startPos + ~~(channels[0].length * playPercent)\n    const values = new Float32Array(blockNum)\n    const blockWidth = ~~((channels[0].length * playPercent) / blockNum)\n    let dataBlock = []\n\n    for (let i = startPos, c = 0; i < endPos; i++) {\n      dataBlock.push(this.__averagePeak(channels, i))\n\n      if (dataBlock.length >= blockWidth) {\n        let max = Math.max(...dataBlock)\n        let min = Math.min(...dataBlock)\n        values[c++] = (max + min) / 2\n        dataBlock = []\n      }\n    }\n\n    return values\n  }\n\n  /**\n   * @ignore\n   * @private\n   * @param {Array<Float32Array>} channels\n   * @param {number} ix\n   */\n  __averagePeak(channels, ix) {\n    let sum = 0\n    channels.forEach(ch => (sum += Math.abs(ch[ix])))\n    return sum / channels.length\n  }\n\n  /**\n   * Gets the decoded audio buffer.\n   *\n   * @public\n   * @readonly\n   * @returns {AudioBuffer}\n   */\n  get native() {\n    return this.mNativeBuffer\n  }\n\n  /**\n   * Gets the position in seconds, where the sound should start to play.\n   *\n   * @public\n   * @readonly\n   * @returns {number}\n   */\n  get offset() {\n    return this.mStartOffset\n  }\n\n  /**\n   * Gets sound clip duration.\n   *\n   * @public\n   * @readonly\n   * @returns {number}\n   */\n  get duration() {\n    return this.mDuration\n  }\n\n  /**\n   * Represents whether this sound clip is a part of sound atlas clip.\n   *\n   * @public\n   * @readonly\n   * @returns {boolean}\n   */\n  get isSubClip() {\n    return this.mIsSubClip\n  }\n}\n","/**\n * The class which stores audio buffer of sound atlas and information about sub sound clips.\n *\n * @cat audio\n * @extends SoundClip\n */\nexport \nclass SoundAtlasClip extends SoundClip {\n  /**\n   * Creates instance of SoundAtlas.\n   *\n   * @param {AudioBuffer} nativeBuffer Decoded audio buffer.\n   * @param {Object} jsonObject        Data representing sub sounds name, duration and offset.\n   */\n  constructor(nativeBuffer, jsonObject) {\n    super(nativeBuffer)\n\n    /** @private @type {Object<string, SoundClip>} */\n    this.mClips = {}\n\n    if (jsonObject !== null)\n      for (let key in jsonObject['sounds'])\n        this.addSubSound(\n          key,\n          jsonObject['sounds'][key][0],\n          jsonObject['sounds'][key][1]\n        )\n  }\n\n  /**\n   * Dynamically sets new sub sound info bypassing json.\n   *\n   * @public\n   * @param {string} name     The name of the sub sound.\n   * @param {number} offset   The offset is seconds, where sub sound will be start playing from.\n   * @param {number} duration The duration of sub sound.\n   * @returns {SoundClip}     New instance of SoundClip.\n   */\n  addSubSound(name, offset = 0, duration = NaN) {\n    this.mClips[name] = new SoundClip(this.native, offset, duration, true)\n    return this.mClips[name]\n  }\n\n  /**\n   * Removes previously added sub sound info.\n   *\n   * @public\n   * @param {string} name The name of the sub sound.\n   * @returns {void}\n   */\n  removeSubSound(name) {\n    delete this.mClips[name]\n  }\n\n  /**\n   * Directly plays sub sound by given name on specific channel.\n   *\n   * @public\n   * @param {string} name                The name of the sub sound.\n   * @param {string=} [channel='master'] The name of channel.\n   * @param {number=} [volume=1]         The volume level.\n   * @param {boolean=} [loop=false]      Specifies if sound will repeat infinite times.\n   * @param {number=} [pan=0]            The panning value.\n   * @returns {SoundInstance|null}       New sound instance to be played.\n   */\n  playSubSound(name, channel = 'master', volume = 1, loop = false, pan = 0) {\n    let clip = this.mClips[name]\n    if (clip == null) return null\n\n    let instance = new SoundInstance(clip)\n    instance.channel = channel\n    instance.volume = volume\n    instance.loop = loop\n    instance.pan = pan\n    return instance._play()\n  }\n\n  /**\n   * The dictionary of sub sounds.\n   *\n   * @public\n   * @readonly\n   * @returns {Object<string, SoundClip>}\n   */\n  get subSounds() {\n    return this.mClips\n  }\n}\n","/**\n * Sound channel\n *\n * @cat audio\n */\nexport \nclass SoundChannel {\n  /**\n   * Creates instance of SoundChannel with specific name\n   *\n   * @param {string} name The name of the channel.\n   */\n  constructor(name) {\n    /** @private @type {string} */\n    this.mName = name\n\n    /** @private @type {!GainNode} */\n    this.mGain = MasterAudio._newGainNode()\n\n    /** @private @type {Array<SoundInstance>} */\n    this.mSounds = []\n\n    /** @private @type {Array<SoundEffect>} */\n    this.mEffects = []\n  }\n\n  /**\n   * Allows the sound to be played on this channel\n   *\n   * @public\n   * @param {SoundInstance} soundInstance Concrete SoundInstance.\n   * @returns {void}\n   */\n  attachSound(soundInstance) {\n    Debug.assert(soundInstance != null, 'Sound cannot be null')\n\n    soundInstance._outputNode.connect(this._inputNode)\n    this.mSounds.push(soundInstance)\n\n    soundInstance.on(Message.COMPLETE, () => {\n      this.mSounds.splice(this.mSounds.indexOf(soundInstance), 1)\n      soundInstance._outputNode.disconnect(0)\n    })\n  }\n\n  /**\n   * Removes given sound instance from this channel\n   *\n   * @public\n   * @param {SoundInstance} soundInstance Concrete SoundInstance.\n   * @returns {void}\n   */\n  detachSound(soundInstance) {\n    Debug.assert(soundInstance != null, 'Sound cannot be null')\n\n    let ix = this.mSounds.indexOf(soundInstance)\n    if (ix > -1) {\n      this.mSounds.splice(ix, 1)\n      soundInstance._outputNode.disconnect(0)\n    }\n  }\n\n  /**\n   * Stops all sounds on this channel\n   *\n   * @public\n   * @returns {void}\n   */\n  stopAll() {\n    for (\n      let snd = this.mSounds[0];\n      this.mSounds.length;\n      snd = this.mSounds.shift()\n    ) {\n      snd.stop()\n    }\n  }\n\n  /**\n   * Adds sound effect to this channel\n   *\n   * @public\n   * @param {SoundEffect} effect SoundEffect instance.\n   * @returns {SoundEffect}\n   */\n  addEffect(effect) {\n    Debug.assert(effect != null, 'Effect cannot be null')\n\n    effect._outputNode.connect(this._inputNode)\n    this.mEffects.unshift(effect)\n    this.__reconnectSounds()\n    return effect\n  }\n\n  /**\n   * Removes sound effect from this channel\n   *\n   * @public\n   * @param {SoundEffect} effect SoundEffect instance.\n   * @returns {SoundEffect}\n   */\n  removeEffect(effect) {\n    Debug.assert(effect != null, 'Effect cannot be null')\n\n    effect._outputNode.disconnect(0)\n    this.mEffects.splice(this.mEffects.indexOf(effect), 1)\n    this.__reconnectSounds()\n    return effect\n  }\n\n  /**\n   * Removes all sound effect from this channel\n   *\n   * @public\n   * @returns {void}\n   */\n  removeAllEffects() {\n    for (; this.mEffects.length; this.mEffects.shift()) {\n      this.mEffects[0]._outputNode.disconnect(0)\n    }\n    this.__reconnectSounds()\n  }\n\n  /**\n   * @ignore\n   * @private\n   * @returns {void}\n   */\n  __reconnectSounds() {\n    this.mSounds.forEach(x => {\n      x._outputNode.disconnect(0)\n      x._outputNode.connect(this._inputNode)\n    })\n  }\n\n  /**\n   * @ignore\n   * @public\n   * @param {number} value\n   * @returns {void}\n   */\n  set volume(value) {\n    this.mGain.gain.setValueAtTime(value, 0)\n  }\n\n  /**\n   * Gets/Sets the volume for this channel\n   *\n   * @public\n   * @returns {number}\n   */\n  get volume() {\n    return this.mGain.gain.value\n  }\n\n  /**\n   * @ignore\n   * @readonly\n   * @returns {!AudioNode}\n   */\n  get _inputNode() {\n    return this.mEffects.length\n      ? /** @type {!AudioNode} */ (this.mEffects[0]._inputNode)\n      : this.mGain\n  }\n\n  /**\n   * @ignore\n   * @readonly\n   * @returns {!AudioNode}\n   */\n  get _outputNode() {\n    return this.mGain\n  }\n}\n","/**\n * The sound component.\n *\n * @cat audio\n * @extends {Component}\n */\nexport \nclass Sound extends Component {\n  /**\n   * Creates new instance of SoundComponent.\n   *\n   * @param {string} name                    The name of sound. Uses AssetManager.default only.\n   * @param {string=} [channel='master']     The name of channel, to play sound on.\n   * @param {boolean=} [spatialEffect=false] Specifies if spatial effect is enabled.\n   * @param {number=} [rolloff=100]          Determines how far from the listener the volume reduces.\n   */\n  constructor(name, channel = 'master', spatialEffect = false, rolloff = 100) {\n    super()\n\n    /** @private @type {SoundClip} */\n    this.mSoundClip = AssetManager.default.getSound(name)\n\n    /** @private @type {number} */\n    this.mRolloff = rolloff\n\n    /** @private @type {boolean} */\n    this.mPlayOnAdded = true\n\n    /** @private @type {boolean} */\n    this.mStopOnRemove = true\n\n    /** @private @type {SoundInstance} */\n    this.mSoundInstance = null\n\n    /** @private @type {MessageBinding|null}  */\n    this.mCompleteBinding = null\n\n    /** @private @type {boolean} */\n    this.mSpatialEffect = spatialEffect\n\n    /** @private @type {string} */\n    this.mChannelName = channel\n  }\n\n  /**\n   * Starts playing sound.\n   *\n   * @public\n   * @param {number=} [volume=1]         The volume level.\n   * @param {boolean=} [loop=false]      Specifies if sound repeats infinite times.\n   * @param {boolean=} [overwrite=false] If true, stops previously started sound, if there is one.\n   * @returns {SoundInstance}            Newly created sound instance or already playing sound.\n   */\n  play(volume = 1, loop = false, overwrite = false) {\n    overwrite && this.mSoundInstance && this.stop()\n    if (!this.mSoundInstance || overwrite) {\n      this.mSoundInstance = this.mSoundClip.play(\n        this.mChannelName,\n        volume,\n        loop\n      )\n      this.mCompleteBinding = this.mSoundInstance.on(\n        Message.COMPLETE,\n        this.__onSoundComplete,\n        this\n      )\n      this.spatialEffect = this.mSpatialEffect\n    }\n    return this.mSoundInstance\n  }\n\n  /**\n   * Stops current sound instance if there is playing one.\n   *\n   * @public\n   * @returns {void}\n   */\n  stop() {\n    if (this.mSoundInstance) {\n      this.mCompleteBinding.off()\n      this.mSoundInstance.stop()\n      this.mSoundInstance = null\n    }\n  }\n\n  /**\n   * @ignore\n   * @private\n   * @returns {void}\n   */\n  __onSoundComplete() {\n    this.mSoundInstance = null\n  }\n\n  /**\n   * @inheritDoc\n   */\n  onAdded(gameObject) {\n    if (this.mPlayOnAdded) {\n      this.play()\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n  onRemoved(gameObject) {\n    if (this.mStopOnRemove && this.mSoundInstance) {\n      this.mSoundInstance.stop()\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n  onUpdate() {\n    if (\n      this.mSpatialEffect &&\n      this.mSoundInstance != null &&\n      this.mSoundInstance.isPlaying === true\n    ) {\n      const stage = Black.stage\n      const pos = this.gameObject.localToGlobal(\n        stage.globalToLocal(\n          new Vector(this.gameObject.pivotX, this.gameObject.pivotY)\n        )\n      )\n      const px = ((pos.x - stage.centerX) / stage.width) * 2\n      const py = ((pos.y - stage.centerY) / stage.height) * 2\n      this.mSoundInstance.mSpatialPanner.setPosition(px, py, 0)\n    }\n  }\n\n  /**\n   * @ignore\n   * @param {boolean} value\n   * @return {void}\n   */\n  set playOnAdded(value) {\n    this.mPlayOnAdded = value\n  }\n\n  /**\n   * Gets/Sets whether the sound should start playing when added to stage. Default value is true.\n   *\n   * @return {boolean}\n   */\n  get playOnAdded() {\n    return this.mPlayOnAdded\n  }\n\n  /**\n   * @ignore\n   * @param {boolean} value\n   * @return {void}\n   */\n  set stopOnRemove(value) {\n    this.mStopOnRemove = value\n  }\n\n  /**\n   * Sets/Gets whether the sound should be stopped if the owner GameObject is being removed form the stage. Default value is true.\n   *\n   * @return {boolean}\n   */\n  get stopOnRemove() {\n    return this.mStopOnRemove\n  }\n\n  /**\n   * @ignore\n   * @param {boolean} value\n   * @return {void}\n   */\n  set spatialEffect(value) {\n    this.mSpatialEffect = value\n    if (\n      value &&\n      this.mSoundInstance != null &&\n      this.mSoundInstance.isPlaying === true\n    ) {\n      let p = this.mSoundInstance.enableSpacePan()\n      p.rolloffFactor = this.mRolloff\n      p.refDistance = 1\n      p.distanceModel = 'inverse'\n    }\n  }\n\n  /**\n   * Sets/Gets whether the sound should have spatial effect. Default value is false.\n   *\n   * @return {boolean}\n   */\n  get spatialEffect() {\n    return this.mSpatialEffect\n  }\n}\n","/**\n * The sound listener component, which controls one and only instance of AudioContext.listener.\n *\n * @cat audio\n * @extends {Component}\n */\nexport \nclass SoundListener extends Component {\n  /**\n   * Creates new instance of SoundListener.\n   */\n  constructor() {\n    super()\n  }\n\n  /**\n   * @inheritDoc\n   */\n  onRemoved(gameObject) {\n    this.loose()\n  }\n\n  /**\n   * Starts controlling only instance of AudioContext.listener.\n   */\n  listen() {\n    MasterAudio.currentListener = this\n  }\n\n  /**\n   * Stops controlling AudioContext.listener.\n   */\n  loose() {\n    MasterAudio.looseListener()\n  }\n\n  /**\n   * @inheritDoc\n   */\n  onRender() {\n    if (MasterAudio.currentListener === this) {\n      let stage = Black.stage\n      let pos = this.gameObject.localToGlobal(\n        stage.globalToLocal(\n          new Vector(this.gameObject.pivotX, this.gameObject.pivotY)\n        )\n      )\n      let px = ((pos.x - stage.centerX) / stage.width) * 2\n      let py = ((pos.y - stage.centerY) / stage.height) * 2\n      if (MasterAudio.context.listener.positionX != null) {\n        MasterAudio.context.listener.positionX.setValueAtTime(px, 0)\n        MasterAudio.context.listener.positionY.setValueAtTime(py, 0)\n        MasterAudio.context.listener.positionZ.setValueAtTime(1, 0)\n      } else {\n        MasterAudio.context.listener.setPosition(px, py, 1)\n      }\n    }\n  }\n}\n","/**\n * RigidBody is used to describe physics properties of game object colliders\n *\n * @cat physics\n * @extends Component\n */\n\nexport \nclass RigidBody extends Component {\n  /**\n   * Creates new instance of RigidBody.\n   */\n  constructor() {\n    super()\n\n    /**\n     * Default collider. Used in case no any custom colliders provided by user.\n     * @private @type {BoxCollider}\n     */\n    this.mCollider = new BoxCollider(0, 0, 0, 0)\n\n    /**\n     * For internal usage. To mark this body is in island.\n     * @private @type {boolean}\n     */\n    this.mInGroup = false\n\n    /**\n     * Flag to mark this body is in rest.\n     * @private @type {boolean}\n     */\n    this.mIsSleeping = false\n\n    /**\n     * Internal counter. How many times (updates) this body has velocity lower than `Pair.sleepThreshold`.\n     * @private @type {number}\n     */\n    this.mSleepTime = 0\n\n    /**\n     * All colliding pairs this body participates in.\n     * @private @type {Array<Pair>}\n     */\n    this.mContacts = []\n\n    /**\n     * Game object pivot. To track changes and update default collider if needed.\n     * @private @type {Vector}\n     */\n    this.mPivot = new Vector(Number.MAX_VALUE)\n\n    /**\n     * Game bounds position. To track changes and update this position, if object was moved without physics.\n     * @private @type {Vector}\n     */\n    this.mCachedPosition = new Vector()\n\n    /**\n     * All pairs this body participates in.\n     * @public @type {Array<Pair>}\n     */\n    this.mPairs = []\n\n    /**\n     * Flag to indicate immovable body.\n     * @private @type {boolean}\n     */\n    this.mIsStatic = false\n\n    /**\n     * This position in stage coordinates.\n     * @private @type {Vector}\n     */\n    this.mPosition = new Vector()\n\n    /**\n     * This velocity to integrate.\n     * @private @type {Vector}\n     */\n    this.mVelocity = new Vector()\n\n    /**\n     * Force accumulator.\n     * @private @type {Vector}\n     */\n    this.mForce = new Vector()\n\n    /**\n     * Game object transform. To track changes and update this colliders.\n     * @private @type {Matrix}\n     */\n    this.mTransform = new Matrix(Number.MAX_VALUE)\n\n    /**\n     * Cached mass\n     * @private @type {number}\n     */\n    this.mMass = 1\n\n    /**\n     * Inverted mass or zero if body is static.\n     * @ignore @type {number}\n     */\n    this.mInvMass = 1\n\n    /**\n     * Velocity damper.\n     * @public @type {number}\n     */\n    this.frictionAir = 0.01\n\n    /**\n     * Friction for collision solving.\n     * @public @type {number}\n     */\n    this.friction = 0.1\n\n    /**\n     * Bounce for collision solving.\n     * @public @type {number}\n     */\n    this.bounce = 0.1\n  }\n\n  /**\n   * Returns this cached mass.\n   *\n   * @return {number}\n   */\n  get mass() {\n    return this.mMass\n  }\n\n  /**\n   * Sets the mass of this body.\n   *\n   * @param {number} v Mass to set.\n   * @return {void}\n   */\n  set mass(v) {\n    this.mMass = v\n\n    if (v === 0 || this.mIsStatic) {\n      this.mInvMass = 0\n    } else {\n      this.mInvMass = 1 / v\n    }\n  }\n\n  /**\n   * Returns this static indicator.\n   *\n   * @return {boolean}\n   */\n  get isStatic() {\n    return this.mIsStatic\n  }\n\n  /**\n   * Sets this body movable state. Refresh inverted mass\n   *\n   * @param {boolean} v Value to set.\n   *\n   * @return {void}\n   */\n  set isStatic(v) {\n    this.mIsStatic = v\n    this.mass = this.mMass\n  }\n\n  /**\n   * Sets the global position x of this body.\n   *\n   * @param {number} v Position to set.\n   * @return {void}\n   */\n  set x(v) {\n    this.mPosition.x = v\n  }\n\n  /**\n   * Returns this position x.\n   *\n   * @return {number}\n   */\n  get x() {\n    return this.mPosition.x\n  }\n\n  /**\n   * Sets the global position y of this body.\n   *\n   * @param {number} v Position to set.\n   * @return {void}\n   */\n  set y(v) {\n    this.mPosition.y = v\n  }\n\n  /**\n   * Returns this position y.\n   *\n   * @return {number}\n   */\n  get y() {\n    return this.mPosition.y\n  }\n\n  /**\n   * Sets the force x of this body.\n   *\n   * @param {number} v Force to set.\n   * @return {void}\n   */\n  set forceX(v) {\n    this.mIsSleeping = false\n    this.mForce.x = v\n  }\n\n  /**\n   * Returns this force x.\n   *\n   * @return {number}\n   */\n  get forceX() {\n    return this.mForce.x\n  }\n\n  /**\n   * Sets the force y of this body.\n   *\n   * @param {number} v Force to set.\n   * @return {void}\n   */\n  set forceY(v) {\n    this.mIsSleeping = false\n    this.mForce.y = v\n  }\n\n  /**\n   * Returns this force y.\n   *\n   * @return {number}\n   */\n  get forceY() {\n    return this.mForce.y\n  }\n\n  /**\n   * Sets the velocity x of this body.\n   *\n   * @param {number} v Velocity to set.\n   * @return {void}\n   */\n  set velocityX(v) {\n    this.mVelocity.x = v\n  }\n\n  /**\n   * Returns this velocity x.\n   *\n   * @return {number}\n   */\n  get velocityX() {\n    return this.mVelocity.x\n  }\n\n  /**\n   * Sets the velocity y of this body.\n   *\n   * @param {number} v Velocity to set.\n   * @return {void}\n   */\n  set velocityY(v) {\n    this.mVelocity.y = v\n  }\n\n  /**\n   * Returns this velocity y.\n   *\n   * @return {number}\n   */\n  get velocityY() {\n    return this.mVelocity.y\n  }\n\n  /**\n   * Updates game object position, colliders\n   *\n   * @public\n   * @return {void}\n   */\n  update() {\n    const gameObject = this.gameObject\n    const colliders = gameObject.mCollidersCache\n    const collider = this.mCollider\n    const position = this.mPosition\n    const wt = gameObject.worldTransformation\n    const wtData = wt.data\n    const transform = this.mTransform\n\n    // Check scale x, y and rotation (skew is forbidden for arcade physics)\n    // Also for circle world scale x and y should be the same\n    if (transform.data[0] !== wtData[0] || transform.data[2] !== wtData[2]) {\n      transform.set(wtData[0], wtData[1], wtData[2], wtData[3], 0, 0)\n      collider.mChanged = true\n\n      for (let i = 0, l = colliders.length; i < l; i++) {\n        colliders[i].mChanged = true\n      }\n    }\n\n    if (gameObject !== Black.stage) {\n      const cachedPosition = this.mCachedPosition\n      const prevX = cachedPosition.x\n      const prevY = cachedPosition.y\n\n      wt.transformXY(gameObject.pivotX, gameObject.pivotY, cachedPosition)\n\n      // Update this position if game object position was changed during frame\n      position.x += cachedPosition.x - prevX\n      position.y += cachedPosition.y - prevY\n\n      gameObject.parent.globalToLocal(position, cachedPosition)\n      gameObject.x = cachedPosition.x\n      gameObject.y = cachedPosition.y\n      gameObject.worldTransformation.transformXY(\n        gameObject.pivotX,\n        gameObject.pivotY,\n        cachedPosition\n      )\n    }\n\n    // Refresh colliders\n    if (colliders.length === 0) {\n      // TODO; do we need a boundsChanged callback?\n      let bounds = gameObject.localBounds\n\n      if (gameObject instanceof DisplayObject) {\n        let disp = /** @type {DisplayObject} */ (gameObject)\n        if (disp.mClipRect !== null)\n          collider.set(0, 0, bounds.width, bounds.height)\n        else\n          collider.set(\n            -gameObject.pivotX,\n            -gameObject.pivotY,\n            bounds.width,\n            bounds.height\n          )\n      } else {\n        collider.set(\n          -gameObject.pivotX,\n          -gameObject.pivotY,\n          bounds.width,\n          bounds.height\n        )\n      }\n\n      collider.refresh(transform, position)\n    } else {\n      for (let i = 0, l = colliders.length; i < l; i++) {\n        colliders[i].refresh(transform, position)\n      }\n    }\n  }\n\n  /**\n   * Resets colliders dirty state after collision test. Sync with update\n   *\n   * @public\n   * @return {void}\n   */\n  clearFlags() {\n    const colliders = this.gameObject.mCollidersCache\n    this.mCollider.mChanged = false\n\n    for (let i = 0, l = colliders.length; i < l; i++) {\n      colliders[i].mChanged = false\n    }\n  }\n\n  // /**\n  //  * Draws all the colliders\n  //  *\n  //  * @public\n  //  * @return {void}\n  //  */\n  // debug() {\n  //   if (!this.gameObject) return;\n  //\n  //   if (RigidBody.mDebug.graphics === null) {\n  //     RigidBody.mDebug.graphics = new Graphics();\n  //   }\n  //\n  //   const debug = RigidBody.mDebug;\n  //   const graphics = debug.graphics;\n  //   const colliders = this.gameObject.mCollidersCache;\n  //\n  //   if (debug.time !== Black.instance.mLastFrameTimeMs) {\n  //     debug.time = Black.instance.mLastFrameTimeMs;\n  //     Black.stage.add(debug.graphics);\n  //\n  //     debug.graphics.clear();\n  //   }\n  //\n  //   debug.graphics.lineStyle(2, this.mIsSleeping ? 0x00ff00 : 0xff0000);\n  //\n  //   if (colliders.length === 0) {\n  //     this.mCollider.debug(graphics, this.mCachedPosition);\n  //   } else {\n  //     for (let i = 0, l = colliders.length; i < l; i++) {\n  //       colliders[i].debug(graphics, this.mCachedPosition);\n  //     }\n  //   }\n  // }\n}\n\n// /** @private @type {Object} Debug options */\n// RigidBody.mDebug = {\n//   graphics: null,\n//   time    : 0,\n// };\n","/**\n * Projection is used to calculate ranges for collision test with Separate Axis Theorem.\n *\n * @cat physics.arcade.helpers\n */\nexport \nclass Projection {\n  /**\n   * Creates new instance of Projection.\n   */\n  constructor() {\n    /** @private @type {Vector|null} Box normal */\n    this.axis = null\n\n    /** @private @type {Array<Vector>|null} Box a vertices */\n    this.verticesA = null\n\n    /** @private @type {Array<Vector>|null} Box b vertices */\n    this.verticesB = null\n\n    /** @private @type {Range} Range from project box a vertices to axis */\n    this.rangeA = new Range()\n\n    /** @private @type {Range} Range from project box b vertices to axis */\n    this.rangeB = new Range()\n\n    /** @private @type {number} body a to body b offset projected on the axis */\n    this.offset = 0\n  }\n\n  /**\n   * Setter\n   *\n   * @public\n   *\n   * @param {Array<Vector>} verticesA box a points\n   * @param {Array<Vector>} verticesB box b points\n   * @param {Vector}        axis One from box normals\n   *\n   * return {void}\n   */\n  set(verticesA, verticesB, axis) {\n    this.verticesA = verticesA\n    this.verticesB = verticesB\n    this.axis = axis\n    this.refresh()\n  }\n\n  /**\n   * Recalculates the ranges.\n   *\n   * @public\n   *\n   * return {void}\n   */\n  refresh() {\n    Projection.__project(this.verticesA, this.axis, this.rangeA)\n    Projection.__project(this.verticesB, this.axis, this.rangeB)\n  }\n\n  /**\n   * Recalculates range.\n   *\n   * @private\n   *\n   * return {void}\n   */\n  static __project(points, axis, range) {\n    let min = Number.MAX_VALUE\n    let max = -Number.MAX_VALUE\n\n    for (let i = 0, l = points.length; i < l; i++) {\n      const dot = points[i].dot(axis)\n      min = dot < min ? dot : min\n      max = dot > max ? dot : max\n    }\n\n    range.min = min\n    range.max = max\n  }\n}\n\n/**\n * Simple range helper class.\n *\n * @cat physics.arcade.helpers\n */\nclass Range {\n  /**\n   * Creates new instance of Range.\n   */\n  constructor() {\n    /**\n     * Min value.\n     * @public @type {number}\n     */\n    this.min = 0\n\n    /**\n     * Max value.\n     * @public @type {number}\n     */\n    this.max = 0\n  }\n}\n","/**\n * Pair is used for narrow test, and resolve collision within two colliders.\n *\n * @cat physics.arcade.pairs\n */\n\nexport \nclass Pair {\n  /**\n   * Creates new instance of Pair.\n   */\n  constructor() {\n    /**\n     * Collider from body a.\n     * @public @type {Collider|null}\n     */\n    this.a = null\n\n    /**\n     * Collider from body b.\n     * @public @type {Collider|null}\n     */\n    this.b = null\n\n    /**\n     * Parent of collider a.\n     * @public @type {RigidBody|null}\n     */\n    this.bodyA = null\n\n    /**\n     * Parent of collider b.\n     * @public @type {RigidBody|null}\n     */\n    this.bodyB = null\n\n    /**\n     * Flag to indicate collision state.\n     * @private @type {boolean}\n     */\n    this.mInCollision = false\n\n    /**\n     * Flag to determine one from two bodies can move. invMass !== 0 and isSleeping === false.\n     * @private @type {boolean}\n     */\n    this.mIsStatic = false\n\n    /**\n     * Cached normal impulse to apply in next iteration or frame if collision still exist.\n     * @private @type {number}\n     */\n    this.mNormalImpulse = 0\n\n    /**\n     * Cached tangent impulse to apply in next iteration or frame if collision still exist.\n     * @private @type {number}\n     */\n    this.mTangentImpulse = 0\n\n    /**\n     * Position impulse cache to use within iterations.\n     * @private @type {number}\n     */\n    this.mPositionImpulse = 0\n\n    /**\n     * This colliders cached friction.\n     * @private @type {number}\n     */\n    this.mFriction = 0\n\n    /**\n     * This colliders cached bounce factor.\n     * @private @type {number}\n     */\n    this.mBias = 0\n\n    /**\n     * This colliders cached inverse mass sum.\n     * @private @type {number}\n     */\n    this.mMass = 0\n\n    /**\n     * Offset within the colliders on preSolve to correct overlap on each iteration.\n     * @private @type {Vector}\n     */\n    this.mOffset = new Vector()\n\n    /**\n     * Normal collision direction from a to b.\n     * @private @type {Vector}\n     */\n    this.mNormal = new Vector()\n\n    /**\n     * Positive number. Penetration within colliders.\n     * @private @type {number}\n     */\n    this.mOverlap = 0\n\n    /**\n     * Flag to indicate this pair needs refresh.\n     * @private @type {boolean}\n     */\n    this.mChanged = false\n  }\n\n  /**\n   * Tests the collision state. Updates normal and overlap for solve.\n   *\n   * @public\n   *\n   * @return {boolean} This pair in collision flag\n   */\n  test() {\n    return this.mInCollision\n  }\n\n  /**\n   * Prepares the solve properties depends on bodies physics characteristics and test result.\n   *\n   * @public\n   *\n   * @return {void}\n   */\n  preSolve() {\n    const normalX = this.mNormal.x\n    const normalY = this.mNormal.y\n    const tangentX = -normalY\n    const tangentY = +normalX\n    const positionA = this.bodyA.mPosition\n    const positionB = this.bodyB.mPosition\n    const velocityA = this.bodyA.mVelocity\n    const velocityB = this.bodyB.mVelocity\n    const invMassA = this.bodyA.mInvMass\n    const invMassB = this.bodyB.mInvMass\n    const offset = this.mOffset\n\n    const impulseX =\n      this.mNormalImpulse * normalX + this.mTangentImpulse * tangentX\n    const impulseY =\n      this.mNormalImpulse * normalY + this.mTangentImpulse * tangentY\n\n    offset.x = positionB.x - positionA.x\n    offset.y = positionB.y - positionA.y\n\n    velocityA.x -= impulseX * invMassA\n    velocityA.y -= impulseY * invMassA\n\n    velocityB.x += impulseX * invMassB\n    velocityB.y += impulseY * invMassB\n\n    const relVelX = velocityB.x - velocityA.x\n    const relVelY = velocityB.y - velocityA.y\n    const relVel = relVelX * normalX + relVelY * normalY\n\n    const bounceThreshold =\n      Pair.bounceTreshhold * Pair.unitsPerMeter * Black.stage.mScaleX\n    this.mBias =\n      relVel < -bounceThreshold\n        ? -Math.max(this.bodyA.bounce, this.bodyB.bounce) * relVel\n        : 0\n    this.mMass = 1 / (invMassA + invMassB)\n    this.mFriction = Math.min(this.bodyA.friction, this.bodyB.friction)\n    this.mPositionImpulse = 0\n  }\n\n  /**\n   * Updates the bodies velocities to solve collision.\n   *\n   * @public\n   *\n   * @return {void}\n   */\n  solveVelocity() {\n    const normalX = this.mNormal.x\n    const normalY = this.mNormal.y\n    const tangentX = -normalY\n    const tangentY = +normalX\n    const velocityA = this.bodyA.mVelocity\n    const velocityB = this.bodyB.mVelocity\n    const invMassA = this.bodyA.mInvMass\n    const invMassB = this.bodyB.mInvMass\n\n    {\n      const relVelX = velocityB.x - velocityA.x\n      const relVelY = velocityB.y - velocityA.y\n      const relVel = relVelX * normalX + relVelY * normalY\n      let impulse = -(relVel - this.mBias) * this.mMass\n      const newImpulse = Math.max(this.mNormalImpulse + impulse, 0)\n      impulse = newImpulse - this.mNormalImpulse\n      this.mNormalImpulse = newImpulse\n\n      const impulseX = impulse * normalX\n      const impulseY = impulse * normalY\n\n      velocityA.x -= impulseX * invMassA\n      velocityA.y -= impulseY * invMassA\n\n      velocityB.x += impulseX * invMassB\n      velocityB.y += impulseY * invMassB\n    }\n\n    {\n      const relVelX = velocityB.x - velocityA.x\n      const relVelY = velocityB.y - velocityA.y\n      const relVel = relVelX * tangentX + relVelY * tangentY\n      let impulse = -relVel * this.mMass\n      const maxFriction = this.mFriction * this.mNormalImpulse\n      const newImpulse = MathEx.clamp(\n        this.mTangentImpulse + impulse,\n        -maxFriction,\n        maxFriction\n      )\n      impulse = newImpulse - this.mTangentImpulse\n      this.mTangentImpulse = newImpulse\n\n      const impulseX = impulse * tangentX\n      const impulseY = impulse * tangentY\n\n      velocityA.x -= impulseX * invMassA\n      velocityA.y -= impulseY * invMassA\n\n      velocityB.x += impulseX * invMassB\n      velocityB.y += impulseY * invMassB\n    }\n  }\n\n  /**\n   * Updates the bodies positions to solve collision.\n   *\n   * @public\n   *\n   * @return {void}\n   */\n  solvePosition() {\n    const normalX = this.mNormal.x\n    const normalY = this.mNormal.y\n    const invMassA = this.bodyA.mInvMass\n    const invMassB = this.bodyB.mInvMass\n    const positionA = this.bodyA.mPosition\n    const positionB = this.bodyB.mPosition\n    const offset = this.mOffset\n\n    const dx = offset.x - positionB.x + positionA.x\n    const dy = offset.y - positionB.y + positionA.y\n\n    const overlap = this.mOverlap + (dx * normalX + dy * normalY)\n    const correction = (overlap - Pair.slop) * Pair.baumgarte\n\n    if (correction <= 0) return\n\n    let normalImpulse = correction * this.mMass\n    const impulsePrev = this.mPositionImpulse\n    this.mPositionImpulse = Math.max(impulsePrev + normalImpulse, 0)\n    normalImpulse = this.mPositionImpulse - impulsePrev\n\n    const impulseX = normalImpulse * normalX\n    const impulseY = normalImpulse * normalY\n\n    positionA.x -= impulseX * invMassA\n    positionA.y -= impulseY * invMassA\n\n    positionB.x += impulseX * invMassB\n    positionB.y += impulseY * invMassB\n  }\n\n  /**\n   * Generates pair id.\n   *\n   * @public\n   * @param {Collider} a Pair collider\n   * @param {Collider} b Pair collider\n   *\n   * @return {string} Pair unique id\n   */\n  static __id(a, b) {\n    return a.mId > b.mId ? `${a.mId}&${b.mId}` : `${b.mId}&${a.mId}`\n  }\n}\n\n/**\n * Updates to start sleep if velocities is lower, than sleep threshold.\n *\n * @ignore @type {number} */\nPair.timeToSleep = 5 //\n\n/**\n * How many pixels colliders can overlap each other without resolve.\n *\n * @ignore @type {number} */\nPair.slop = 1\n\n/**\n * Position correction koefficient. Lower is softer and with less twitches.\n *\n * @ignore @type {number} */\nPair.baumgarte = 0.2\n\n/**\n * Scale koefficient to normalize physics in some local coordinates or different resolutions.\n *\n * @ignore @type {number} */\nPair.unitsPerMeter = 1\n\n/**\n * Maximum body speed to begin sleep process, if sleeping is enabled.\n *\n * @ignore @type {number} */\nPair.sleepThreshold = 0.1\n\n/**\n * Minimal relative velocity within two bodies, required for bounce effect.\n *\n * @ignore @type {number} */\nPair.bounceTreshhold = 1\n","/**\n * BoxToBoxPair is used to test collision within boxes\n *\n * @cat physics.arcade.pairs\n * @extends Pair\n */\nexport \nclass BoxToBoxPair extends Pair {\n  /**\n   * Creates new instance of BoxToBoxPair.\n   */\n  constructor() {\n    super()\n\n    /**\n     * Collider from body a.\n     * @public @type {BoxCollider|null}\n     */\n    this.a = null\n\n    /**\n     * Collider from body b.\n     * @public @type {BoxCollider|null}\n     */\n    this.b = null\n\n    const projections = []\n\n    for (let i = 0; i < 4; i++) {\n      projections.push(new Projection())\n    }\n\n    /**\n     * Projection keeps range of projected vertices. For each normal from both the colliders.\n     * @private @type {Array<Projection>}\n     */\n    this.mProjections = projections\n  }\n\n  /**\n   * Updates this pair with a new given colliders and bodies.\n   *\n   * @public\n   *\n   * @param {BoxCollider} a   Pair collider\n   * @param {BoxCollider} b   Pair collider\n   * @param {RigidBody} bodyA Pair body\n   * @param {RigidBody} bodyB Pair body\n   *\n   * @return {Pair} This\n   */\n  set(a, b, bodyA, bodyB) {\n    this.a = a\n    this.b = b\n    this.bodyA = bodyA\n    this.bodyB = bodyB\n\n    const projections = this.mProjections\n\n    for (let i = 0, j = 0; i < 4; i += 2, j += 1) {\n      projections[i].set(a.mVertices, b.mVertices, a.mNormals[j])\n      projections[i + 1].set(a.mVertices, b.mVertices, b.mNormals[j])\n    }\n\n    return this\n  }\n\n  /**\n   * Refreshes projections.\n   *\n   * @private\n   *\n   * @return {void}\n   */\n  __refreshProjectionsRanges() {\n    const projections = this.mProjections\n\n    for (let i = 0; i < 4; i++) {\n      projections[i].refresh()\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n  test() {\n    const a = this.a\n    const b = this.b\n\n    if (a.mChanged || b.mChanged) {\n      this.mChanged = true\n    }\n\n    if (\n      a.mMax.x < b.mMin.x ||\n      a.mMin.x > b.mMax.x ||\n      a.mMax.y < b.mMin.y ||\n      a.mMin.y > b.mMax.y\n    ) {\n      return (this.mInCollision = false)\n    }\n\n    const projections = this.mProjections\n    const normal = this.mNormal\n    const offsetX = this.bodyB.mPosition.x - this.bodyA.mPosition.x\n    const offsetY = this.bodyB.mPosition.y - this.bodyA.mPosition.y\n\n    if (this.mChanged) {\n      this.mChanged = false\n      this.__refreshProjectionsRanges()\n    }\n\n    this.mOverlap = Number.MAX_VALUE\n\n    for (let i = 0; i < 4; i++) {\n      const projection = projections[i]\n      projection.offset =\n        projection.axis.x * offsetX + projection.axis.y * offsetY\n      const minA = projection.rangeA.min\n      const maxA = projection.rangeA.max\n      const minB = projection.rangeB.min + projection.offset\n      const maxB = projection.rangeB.max + projection.offset\n\n      if (minA > maxB || minB > maxA) {\n        return (this.mInCollision = false)\n      }\n    }\n\n    for (let i = 0; i < 4; i++) {\n      const projection = projections[i]\n      const minA = projection.rangeA.min\n      const maxA = projection.rangeA.max\n      const minB = projection.rangeB.min + projection.offset\n      const maxB = projection.rangeB.max + projection.offset\n\n      const optionA = maxA - minB\n      const optionB = maxB - minA\n      let overlap = optionA < optionB ? optionA : -optionB\n\n      if (minA < minB && maxA < maxB) {\n        overlap = maxA - minB\n      } else if (maxA > maxB) {\n        overlap = minA - maxB\n      }\n\n      const absOverlap = Math.abs(overlap)\n\n      if (absOverlap < this.mOverlap) {\n        this.mOverlap = absOverlap\n        normal.copyFrom(projection.axis)\n        overlap < 0 && normal.multiplyScalar(-1)\n      }\n    }\n\n    return (this.mInCollision = true)\n  }\n}\n\nBoxToBoxPair.pool = new ObjectPool(BoxToBoxPair, 100)\n","/**\n * BoxToCirclePair is used to test collision within box - circle colliders.\n *\n * @cat physics.arcade.pairs\n * @extends Pair\n */\n\nexport \nclass BoxToCirclePair extends Pair {\n  /**\n   * Creates new instance of BoxToBoxPair.\n   */\n  constructor() {\n    super()\n\n    /**\n     * Collider from body a.\n     * @public @type {BoxCollider|null}\n     */\n    this.a = null\n\n    /**\n     * Collider from body a.\n     * @public @type {CircleCollider|null}\n     */\n    this.b = null\n\n    /**\n     * Cached half width of box in stage coordinates.\n     * @private @type {number}\n     */\n    this.mBoxHalfWidth = 0\n\n    /**\n     * Cached half height of box in stage coordinates,\n     * @private @type {number}\n     */\n    this.mBoxHalfHeight = 0\n\n    /**\n     * Cached cos and sin from box game object world transformation without scale, to rotate.\n     * @private @type {Vector}\n     */\n    this.mBoxRotate = new Vector()\n\n    /**\n     * Tmp point to rotate.\n     * @private @type {Vector}\n     */\n    this.mCircleCenter = new Vector()\n  }\n\n  /**\n   * Assigns colliders and bodies to this pair.\n   *\n   * @public\n   *\n   * @param {BoxCollider} a     Pair box collider\n   * @param {CircleCollider} b  Pair circle collider\n   * @param {RigidBody} bodyA   Pair body\n   * @param {RigidBody} bodyB   Pair body\n   *\n   * @return {Pair} This\n   */\n  set(a, b, bodyA, bodyB) {\n    this.a = a\n    this.b = b\n    this.bodyA = bodyA\n    this.bodyB = bodyB\n\n    return this\n  }\n\n  /**\n   * Rotates point around anchor\n   *\n   * @private\n   *\n   * @return {void}\n   */\n  __rotate(point, anchorX, anchorY, cos, sin) {\n    const x = point.x - anchorX\n    const y = point.y - anchorY\n    const tx = cos * x - sin * y\n    const ty = sin * x + cos * y\n\n    point.x = tx + anchorX\n    point.y = ty + anchorY\n  }\n\n  /**\n   * @inheritDoc\n   */\n  test() {\n    const box = this.a\n    const circle = this.b\n\n    if (box.mChanged) {\n      this.mChanged = true\n    }\n\n    if (\n      box.mMax.x < circle.mMin.x ||\n      box.mMin.x > circle.mMax.x ||\n      box.mMax.y < circle.mMin.y ||\n      box.mMin.y > circle.mMax.y\n    ) {\n      return (this.mInCollision = false)\n    }\n\n    if (this.mChanged) {\n      this.mChanged = false\n      const transformData = this.bodyA.mTransform.data\n      const scaleX = Math.sqrt(\n        transformData[0] * transformData[0] +\n          transformData[1] * transformData[1]\n      )\n      const scaleY = Math.sqrt(\n        transformData[2] * transformData[2] +\n          transformData[3] * transformData[3]\n      )\n\n      this.mBoxRotate.set(transformData[0] / scaleX, transformData[1] / scaleX)\n      this.mBoxHalfWidth = (box.mRect.width / 2) * scaleX\n      this.mBoxHalfHeight = (box.mRect.height / 2) * scaleY\n    }\n\n    const boxRotate = this.mBoxRotate\n    const normal = this.mNormal\n    const circleCenter = this.mCircleCenter.copyFrom(circle.mCenter)\n    let hw = this.mBoxHalfWidth\n    let hh = this.mBoxHalfHeight\n\n    const rotated = boxRotate.y !== 0\n\n    if (rotated) {\n      this.__rotate(\n        circleCenter,\n        box.mCenter.x,\n        box.mCenter.y,\n        boxRotate.x,\n        -boxRotate.y\n      )\n    }\n\n    const dx = circleCenter.x - box.mCenter.x\n    const dy = circleCenter.y - box.mCenter.y\n\n    if (dx === 0 && dy === 0) {\n      this.mOverlap = circle.mRadius + hw\n      normal.set(-1, 0)\n\n      return (this.mInCollision = true)\n    }\n\n    let closestX = MathEx.clamp(dx, -hw, hw)\n    let closestY = MathEx.clamp(dy, -hh, hh)\n    const inside = dx === closestX && dy === closestY\n\n    if (inside) {\n      if (Math.abs(dx) > Math.abs(dy)) {\n        closestX = closestX > 0 ? hw : -hw\n      } else {\n        closestY = closestY > 0 ? hh : -hh\n      }\n    }\n\n    const normalX = dx - closestX\n    const normalY = dy - closestY\n    const sqLength = normalX * normalX + normalY * normalY\n    const r = circle.mRadius\n\n    if (sqLength > r * r && !inside) {\n      return (this.mInCollision = false)\n    }\n\n    if (sqLength === 0) {\n      this.mOverlap = r\n      normal.set(0, 1)\n    } else {\n      const d = Math.sqrt(sqLength)\n      this.mOverlap = r - d\n      inside\n        ? normal.set(-normalX / d, -normalY / d)\n        : normal.set(normalX / d, normalY / d)\n    }\n\n    if (rotated) {\n      this.__rotate(normal, 0, 0, boxRotate.x, boxRotate.y)\n    }\n\n    return (this.mInCollision = true)\n  }\n}\n\nBoxToCirclePair.pool = new ObjectPool(BoxToCirclePair, 100)\n","/**\n * CircleToCirclePair is used to test collision within circles colliders.\n *\n * @cat physics.arcade.pairs\n * @extends Pair\n */\nexport \nclass CircleToCirclePair extends Pair {\n  /**\n   * Creates new instance of CircleToCirclePair.\n   */\n  constructor() {\n    super()\n\n    /**\n     * Collider from body a.\n     * @public @type {CircleCollider|null}\n     */\n    this.a = null\n\n    /**\n     * Collider from body b.\n     * @public @type {CircleCollider|null}\n     */\n    this.b = null\n  }\n\n  /**\n   * Setter\n   *\n   * @public\n   *\n   * @param {CircleCollider} a  Pair circle collider\n   * @param {CircleCollider} b  Pair circle collider\n   * @param {RigidBody} bodyA   Pair body\n   * @param {RigidBody} bodyB   Pair body\n   *\n   * @return {Pair} This\n   */\n  set(a, b, bodyA, bodyB) {\n    this.a = a\n    this.b = b\n    this.bodyA = bodyA\n    this.bodyB = bodyB\n\n    return this\n  }\n\n  /**\n   * @inheritDoc\n   */\n  test() {\n    const a = this.a\n    const b = this.b\n    const offsetX = b.mCenter.x - a.mCenter.x\n    const offsetY = b.mCenter.y - a.mCenter.y\n    const totalRadius = a.mRadius + b.mRadius\n\n    if (offsetX === 0 && offsetY === 0) {\n      this.mOverlap = totalRadius\n      this.mNormal.set(1, 0)\n\n      return (this.mInCollision = true)\n    }\n\n    const totalRadiusSq = totalRadius * totalRadius\n    const distanceSq = offsetX * offsetX + offsetY * offsetY\n\n    if (distanceSq > totalRadiusSq) {\n      return (this.mInCollision = false)\n    }\n\n    const dist = Math.sqrt(distanceSq)\n    this.mOverlap = totalRadius - dist\n    this.mNormal.set(offsetX / dist, offsetY / dist)\n\n    return (this.mInCollision = true)\n  }\n}\n\nCircleToCirclePair.pool = new ObjectPool(CircleToCirclePair, 100)\n","/**\n * Broad collision checker using hash algorithm.\n *\n * @cat physics.arcade.phases\n */\nexport \nclass BroadPhase {\n  /**\n   * Creates new instance of BroadPhase.\n   */\n  constructor() {}\n\n  /**\n   * Test collision in each pair. Sets inCollision flag to false if there is no collision in pair.\n   *\n   * @param {Array<Pair>} pairs All the arcade world colliders pairs.\n   * @return {void}\n   */\n  test(pairs) {}\n}\n","/**\n * Simple AABB physics engine (beta).\n *\n * @cat physics.arcade\n * @extends System\n */\n\nexport \nclass Arcade extends System {\n  /**\n   * Creates new Arcade instance.\n   */\n  constructor() {\n    super()\n\n    /**\n     * Bodies that are on stage.\n     * @private @type {Array<RigidBody>}\n     */\n    this.mBodies = []\n\n    /**\n     * Pairs to check collisions within. With colliders which bodies are on stage.\n     * @private @type {Array<Pair>}\n     */\n    this.mPairs = []\n\n    /**\n     * Pairs which are in collision per frame.\n     * @private @type {Array<Pair>}\n     */\n    this.mContacts = []\n\n    /**\n     * Broad collision test instance.\n     * @private @type {BroadPhase}\n     */\n    this.mBroadPhase = new BroadPhase()\n\n    /**\n     * Object to store pairs by their id. For quick search in collision callbacks.\n     * @private @type {Object}\n     */\n    this.mPairsHash = Object.create(null)\n\n    /**\n     * Reference to world bounds body.\n     * @private @type {RigidBody|null}\n     */\n    this.mBoundsBody = null\n\n    /** @private @type {BoxCollider} */\n    this.mBoundsLeft = new BoxCollider(0, 0, 0, 0)\n\n    /** @private @type {BoxCollider} */\n    this.mBoundsRight = new BoxCollider(0, 0, 0, 0)\n\n    /** @private @type {BoxCollider} */\n    this.mBoundsTop = new BoxCollider(0, 0, 0, 0)\n\n    /** @private @type {BoxCollider} */\n    this.mBoundsBottom = new BoxCollider(0, 0, 0, 0)\n\n    /** @private @type {Vector} */\n    this.mGravity = new Vector(0, 1000)\n\n    /**\n     * Bigger value gives better resolver result, but require more calculations.\n     * @private @type {number}\n     */\n    this.mIterations = 5\n\n    /**\n     * Switch for sleep calculations.\n     * @private @type {boolean}\n     */\n    this.mSleepEnabled = true\n\n    /**\n     * Update delta time, secs.\n     * @public @type {number}\n     */\n    this.delta = 1 / 60\n  }\n\n  /**\n   * Invokes passed callback if given colliders are in collision.\n   *\n   * Callback params:\n   * normalX - collision normal projected on x axis. In direction from colliderA to colliderB.\n   * normalY - collision normal projected on y axis. In direction from colliderA to colliderB.\n   * overlap - positive number.\n   * [args] - rest arguments.\n   *\n   * @public\n   *\n   * @param {Collider} colliderA Collider to check\n   * @param {Collider} colliderB Collider to check\n   * @param {Function} cb        Callback\n   * @param {Object} ctx         Callback context\n   * @param {...*} [args]        Rest arguments\n   *\n   * @return {void}\n   */\n  collisionInfo(colliderA, colliderB, cb, ctx, ...args) {\n    const pair = this.mPairsHash[Pair.__id(colliderA, colliderB)]\n\n    if (pair && pair.mInCollision) {\n      const sign = pair.a === colliderA ? 1 : -1\n      cb.call(\n        ctx,\n        pair.mNormal.x * sign,\n        pair.mNormal.y * sign,\n        pair.mOverlap,\n        ...args\n      )\n    }\n  }\n\n  /**\n   * If callback passed and given bodies are in collision invokes callback.\n   * If no bodyB provided result will show that bodyA is in collision with any other body if so.\n   *\n   * Note: if more than one collision occurred within bodies, callback will be invoked only with a first found.\n   *\n   * Callback params:\n   * normalX - collision normal projected on x axis. In direction from bodyA collider to bodyB collider.\n   * normalY - collision normal projected on y axis. In direction from bodyA collider to bodyB collider.\n   * overlap - positive number.\n   * [args] - rest arguments.\n   *\n   * @public\n   *\n   * @param {RigidBody} bodyA         Body to check\n   * @param {RigidBody=} [bodyB=null] Body to check\n   * @param {Function=} [cb=null]     Callback\n   * @param {Object=} [ctx=null]      Callback context\n   * @param {...*} [args]             Rest arguments\n   *\n   * @return {boolean} Indicator of bodies collision.\n   */\n  isColliding(bodyA, bodyB = null, cb = null, ctx = null, ...args) {\n    const pairs = bodyA.mPairs\n\n    if (bodyB === null) {\n      for (let i = 0, l = pairs.length; i < l; i++) {\n        if (pairs[i].mInCollision) {\n          return true\n        }\n      }\n\n      return false\n    }\n\n    for (let i = 0, l = pairs.length; i < l; i++) {\n      const pair = pairs[i]\n\n      if (pair.mInCollision === false) continue\n\n      const sign =\n        pair.bodyA === bodyA && pair.bodyB === bodyB\n          ? 1\n          : pair.bodyA === bodyB && pair.bodyB === bodyA\n          ? -1\n          : 0\n\n      if (sign === 0) continue\n\n      if (cb)\n        cb.call(\n          ctx,\n          pair.mNormal.x * sign,\n          pair.mNormal.y * sign,\n          pair.mOverlap,\n          ...args\n        )\n\n      return true\n    }\n\n    return false\n  }\n\n  /**\n   * @inheritDoc\n   */\n  onChildrenAdded(gameObject) {\n    GameObject.forEach(gameObject, object => {\n      const body = object.getComponent(RigidBody)\n\n      if (body) {\n        this.__addBody(/** @type {RigidBody} */ (body))\n      }\n    })\n  }\n\n  /**\n   * @inheritDoc\n   */\n  onChildrenRemoved(gameObject) {\n    GameObject.forEach(gameObject, object => {\n      const body = /** @type {!RigidBody} */ (object.getComponent(RigidBody))\n\n      if (body) {\n        this.__removeBody(body, gameObject)\n      }\n    })\n  }\n\n  /**\n   * @inheritDoc\n   */\n  onComponentAdded(child, component) {\n    if (component instanceof RigidBody) {\n      this.__addBody(/** @type {RigidBody} */ (component))\n    } else if (component instanceof Collider) {\n      this.__addCollider(child, /** @type {Collider} */ (component))\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n  onComponentRemoved(child, component) {\n    if (component instanceof RigidBody) {\n      this.__removeBody(/** @type {RigidBody} */ (component), child)\n    } else if (component instanceof Collider) {\n      this.__removeCollider(child, /** @type {Collider} */ (component))\n    }\n  }\n\n  /**\n   * Adds body to arcade world. Start tracking its gameObject colliders.\n   *\n   * @private\n   * @param {RigidBody} body Body to add\n   *\n   * @return {void}\n   */\n  __addBody(body) {\n    const bodies = this.mBodies\n    const colliders = body.gameObject.mCollidersCache\n    body.mPairs.length = 0\n\n    if (colliders.length === 0) {\n      this.__addPairs(body.mCollider, body)\n    } else {\n      for (let i = 0, l = colliders.length; i < l; i++) {\n        this.__addPairs(colliders[i], body)\n      }\n    }\n\n    bodies.push(body)\n  }\n\n  /**\n   * Removes body from arcade world.\n   *\n   * @private\n   * @param {RigidBody} body        Body to remove\n   * @param {GameObject} gameObject Body's game object\n   *\n   * @return {void}\n   */\n  __removeBody(body, gameObject) {\n    const bodies = this.mBodies\n    const colliders = gameObject.mCollidersCache\n\n    if (colliders.length === 0) {\n      this.__removePairs(body.mCollider)\n    } else {\n      for (let i = 0, l = colliders.length; i < l; i++) {\n        this.__removePairs(colliders[i])\n      }\n    }\n\n    body.mPairs.length = 0\n    bodies.splice(bodies.indexOf(body), 1)\n  }\n\n  /**\n   * Adds collider to arcade world.\n   *\n   * @private\n   * @param {GameObject} child  Parent of the collider\n   * @param {Collider} collider Collider to add\n   *\n   * @return {void}\n   */\n  __addCollider(child, collider) {\n    const body = /** @type {RigidBody} */ (child.getComponent(RigidBody))\n\n    if (body && this.mBodies.indexOf(body) !== -1) {\n      this.__addPairs(collider, body)\n\n      if (child.mCollidersCache.length === 1) {\n        this.__removePairs(body.mCollider)\n      }\n    }\n  }\n\n  /**\n   * Removes collider from arcade world.\n   *\n   * @private\n   * @param {GameObject} child  Parent of the collider\n   * @param {Collider} collider Collider to remove\n   *\n   * @return {void}\n   */\n  __removeCollider(child, collider) {\n    const body = /** @type {RigidBody} */ (child.getComponent(RigidBody))\n\n    if (body && this.mBodies.indexOf(body) !== -1) {\n      this.__removePairs(collider)\n\n      const pairs = body.mPairs\n\n      for (let i = pairs.length - 1; i >= 0; i--) {\n        const pair = pairs[i]\n\n        if (pair.a === collider || pair.b === collider) {\n          pairs.splice(i, 1)\n        }\n      }\n\n      if (child.mCollidersCache.length === 0) {\n        this.__addCollider(child, body.mCollider)\n      }\n    }\n  }\n\n  /**\n   * Generate pairs, passed collider with all present colliders.\n   *\n   * @private\n   * @param {Collider} collider   Collider to generate with\n   * @param {RigidBody} fromBody  The collider body\n   *\n   * @return {void}\n   */\n  __addPairs(collider, fromBody) {\n    const bodies = this.mBodies\n    collider.mChanged = true\n\n    for (let i = 0, iLen = bodies.length; i < iLen; i++) {\n      const body = bodies[i]\n      const colliders = body.gameObject.mCollidersCache\n\n      if (body === fromBody) continue\n\n      if (colliders.length === 0) {\n        this.__addPair(collider, body.mCollider, fromBody, body)\n      } else {\n        for (let j = 0, jLen = colliders.length; j < jLen; j++) {\n          this.__addPair(collider, colliders[j], fromBody, body)\n        }\n      }\n    }\n  }\n\n  /**\n   * Creates pair and adds it to world.\n   *\n   * @private\n   * @param {Collider} a      Pair collider\n   * @param {Collider} b      Pair collider\n   * @param {RigidBody} bodyA Pair body\n   * @param {RigidBody} bodyB Pair body\n   *\n   * @return {void}\n   */\n  __addPair(a, b, bodyA, bodyB) {\n    const isBoxA = a.constructor === BoxCollider\n    const isBoxB = b.constructor === BoxCollider\n    let pair\n\n    if (isBoxA && isBoxB) {\n      pair = BoxToBoxPair.pool.get()\n    } else if (!isBoxA && !isBoxB) {\n      pair = CircleToCirclePair.pool.get()\n    } else {\n      pair = BoxToCirclePair.pool.get()\n\n      if (isBoxB) {\n        const body = bodyA\n        const collider = a\n        a = b\n        bodyA = bodyB\n        b = collider\n        bodyB = body\n      }\n    }\n\n    pair.mChanged = true\n    pair.set(a, b, bodyA, bodyB)\n    pair.mInCollision = false\n    this.mPairs.push(pair)\n\n    this.mPairsHash[Pair.__id(a, b)] = pair\n    bodyA.mPairs.push(pair)\n    bodyB.mPairs.push(pair)\n  }\n\n  /**\n   * Removes all pairs with given collider.\n   *\n   * @private\n   * @param {Collider} collider Pairs collider\n   *\n   * @return {void}\n   */\n  __removePairs(collider) {\n    const pairs = this.mPairs\n    const pairsHash = this.mPairsHash\n\n    for (let i = pairs.length - 1; i >= 0; i--) {\n      const pair = pairs[i]\n\n      if (pair.a === collider || pair.b === collider) {\n        pairs.splice(i, 1)\n\n        if (pair instanceof BoxToBoxPair) BoxToBoxPair.pool.release(pair)\n        else if (pair instanceof BoxToCirclePair)\n          BoxToCirclePair.pool.release(pair)\n        else if (pair instanceof CircleToCirclePair)\n          CircleToCirclePair.pool.release(pair)\n\n        //pair.constructor.pool.release(pair);\n\n        delete pairsHash[Pair.__id(pair.a, pair.b)]\n\n        pair.bodyA.mPairs.splice(pair.bodyA.mPairs.indexOf(pair), 1)\n        pair.bodyB.mPairs.splice(pair.bodyB.mPairs.indexOf(pair), 1)\n      }\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n  onPostUpdate() {\n    const dt = this.delta\n    const contacts = this.mContacts\n    const bodies = this.mBodies\n    const pairs = this.mPairs\n    contacts.length = 0\n\n    // refresh body colliders if scale, rotation changed\n    for (let i = 0, l = bodies.length; i < l; i++) {\n      const body = bodies[i]\n      body.update()\n      body.mContacts.length = 0\n      body.mInGroup = false\n    }\n\n    // reset each pair to defaults\n    // so phases will know, if pair in collision is true, then it needs more precise check\n    for (let i = 0, l = pairs.length; i < l; i++) {\n      const pair = pairs[i]\n\n      pair.mIsStatic =\n        (pair.bodyA.mIsSleeping || pair.bodyA.mInvMass === 0) &&\n        (pair.bodyB.mIsSleeping || pair.bodyB.mInvMass === 0)\n\n      if (pair.mIsStatic === false) {\n        pair.mInCollision = true\n      }\n    }\n\n    // update pairs in collision flag todo\n    // this.mBroadPhase.test(pairs);\n\n    // narrow collision test\n    for (let i = 0, l = pairs.length; i < l; i++) {\n      const pair = pairs[i]\n\n      if (pair.mInCollision && pair.mIsStatic === false) {\n        pair.test()\n      }\n    }\n\n    for (let i = 0, l = pairs.length; i < l; i++) {\n      const pair = pairs[i]\n\n      if (pair.mInCollision) {\n        pair.mIsStatic === false && contacts.push(pair)\n        pair.bodyA.mContacts.push(pair)\n        pair.bodyB.mContacts.push(pair)\n      } else {\n        pair.mNormalImpulse = 0\n        pair.mTangentImpulse = 0\n      }\n    }\n\n    this.__solve(dt)\n\n    if (!this.mSleepEnabled) return\n\n    const group = []\n    const stack = []\n\n    for (let i = 0, l = bodies.length; i < l; i++) {\n      const body = bodies[i]\n      body.clearFlags() // clear colliders dirty flags\n\n      if (body.mInGroup || body.mIsSleeping || body.mInvMass === 0) continue\n\n      group.length = 0\n      stack.length = 0\n\n      stack.push(body)\n\n      while (stack.length !== 0) {\n        const body = stack.pop()\n        const contacts = body.mContacts\n\n        group.push(body)\n        body.mInGroup = true\n\n        for (let i = 0, l = contacts.length; i < l; i++) {\n          const contact = contacts[i]\n          const other = contact.bodyA === body ? contact.bodyB : contact.bodyA\n\n          if (other.mInGroup || other.mInvMass === 0) continue\n\n          stack.push(other)\n        }\n      }\n\n      let isSleeping = true\n      const sleepThreshold =\n        Pair.sleepThreshold * Pair.unitsPerMeter * Black.stage.mScaleX\n\n      for (let i = 0, l = group.length; i < l; i++) {\n        const body = group[i]\n        const velocity = body.mVelocity\n        body.mSleepTime =\n          velocity.x * velocity.x + velocity.y * velocity.y < sleepThreshold\n            ? body.mSleepTime + 1\n            : 0\n        isSleeping = isSleeping && body.mSleepTime > Pair.timeToSleep\n      }\n\n      for (let i = 0, l = group.length; i < l; i++) {\n        group[i].mIsSleeping = isSleeping\n      }\n    }\n  }\n\n  /**\n   * Solve contacts.\n   *\n   * @private\n   * @param {number} dt Time from last update, ms.\n   *\n   * @return {void}\n   */\n  __solve(dt) {\n    const iterations = this.mIterations\n    const contacts = this.mContacts\n    const bodies = this.mBodies\n    const gravity = this.mGravity\n\n    for (let i = 0, l = bodies.length; i < l; i++) {\n      const body = bodies[i]\n\n      if (body.mInvMass === 0 || body.mIsSleeping) continue\n\n      const force = body.mForce\n      const velocity = body.mVelocity\n      const invMass = body.mInvMass\n      const damping = 1 - body.frictionAir\n\n      velocity.x = (velocity.x + (force.x * invMass + gravity.x) * dt) * damping\n      velocity.y = (velocity.y + (force.y * invMass + gravity.y) * dt) * damping\n    }\n\n    for (let i = 0, l = contacts.length; i < l; i++) {\n      contacts[i].preSolve()\n    }\n\n    for (let i = 0; i < iterations; i++) {\n      for (let j = 0, l = contacts.length; j < l; j++) {\n        contacts[j].solveVelocity()\n      }\n    }\n\n    const unitsPerMeterDt = Black.stage.mScaleX * Pair.unitsPerMeter * dt\n\n    for (let i = 0, l = bodies.length; i < l; i++) {\n      const body = bodies[i]\n      body.mForce.set(0, 0)\n\n      if (body.mInvMass === 0 || body.mIsSleeping) continue\n\n      const position = body.mPosition\n      const velocity = body.mVelocity\n\n      position.x += velocity.x * unitsPerMeterDt\n      position.y += velocity.y * unitsPerMeterDt\n    }\n\n    for (let i = 0; i < iterations; i++) {\n      for (let j = 0, l = contacts.length; j < l; j++) {\n        contacts[j].solvePosition()\n      }\n    }\n  }\n\n  /**\n   * Sets bounds to default values.\n   * Should be called on start and on resize.\n   *\n   * @private\n   * @return {void}\n   */\n  __setBounds() {\n    const bounds = Black.stage.bounds\n    const thickness = Number.MAX_SAFE_INTEGER\n\n    this.mBoundsLeft.set(-thickness, 0, thickness, bounds.height)\n    this.mBoundsRight.set(bounds.width, 0, thickness, bounds.height)\n    this.mBoundsTop.set(\n      -thickness,\n      -thickness,\n      bounds.width + thickness * 2,\n      thickness\n    )\n    this.mBoundsBottom.set(\n      -thickness,\n      bounds.height,\n      bounds.width + thickness * 2,\n      thickness\n    )\n  }\n\n  /**\n   * Enabled or disables world colliding bounds.\n   *\n   * @public\n   * @param {boolean} v Value to set\n   *\n   * @return {void}\n   */\n  set boundsEnabled(v) {\n    if (v) {\n      if (!this.mBoundsBody) {\n        this.mBoundsBody = new RigidBody()\n        this.mBoundsBody.isStatic = true\n\n        Black.stage.addComponent(this.mBoundsLeft)\n        Black.stage.addComponent(this.mBoundsRight)\n        Black.stage.addComponent(this.mBoundsTop)\n        Black.stage.addComponent(this.mBoundsBottom)\n\n        this.__setBounds()\n      }\n\n      Black.stage.addComponent(this.mBoundsBody)\n    } else {\n      Black.stage.removeComponent(this.mBoundsBody)\n    }\n  }\n\n  /**\n   * Sets the gravity x.\n   *\n   * @param {number} v Value to set.\n   * @return {void}\n   */\n  set gravityX(v) {\n    this.mGravity.x = v\n  }\n\n  /**\n   * Returns this gravity x.\n   *\n   * @return {number}\n   */\n  get gravityX() {\n    return this.mGravity.x\n  }\n\n  /**\n   * Sets the gravity y.\n   *\n   * @param {number} v Value to set.\n   * @return {void}\n   */\n  set gravityY(v) {\n    this.mGravity.y = v\n  }\n\n  /**\n   * Returns this gravity y.\n   *\n   * @return {number}\n   */\n  get gravityY() {\n    return this.mGravity.y\n  }\n\n  /**\n   * Sets the count of solving iterations.\n   *\n   * @param {number} v Value to set.\n   * @return {void}\n   */\n  set iterations(v) {\n    this.mIterations = v\n  }\n\n  /**\n   * Returns this count of solving iterations.\n   *\n   * @return {number}\n   */\n  get iterations() {\n    return this.mIterations\n  }\n\n  /**\n   * Sets the sleep allowed flag.\n   *\n   * @param {boolean} v Value to set.\n   * @return {void}\n   */\n  set sleepEnabled(v) {\n    this.mSleepEnabled = v\n  }\n\n  /**\n   * Returns this sleepAllowed flag.\n   *\n   * @return {boolean}\n   */\n  get sleepEnabled() {\n    return this.mSleepEnabled\n  }\n}\n","export \nclass ParserBase {\n  constructor() {\n    /**\n     * Input data to parse\n     * @public @type {Object}\n     */\n    this.data = null\n  }\n\n  /**\n   *\n   * @param {Object} data\n   *\n   * @return {Object} Parsed data\n   */\n  parse(data) {\n    this.data = data\n\n    return null\n  }\n}\n","const pathCmds = {\n  MOVETO: 'M',\n  MOVETO_REL: 'm',\n  LINETO: 'L',\n  LINETO_REL: 'l',\n  VLINE: 'V',\n  VLINE_REL: 'v',\n  HLINE: 'H',\n  HLINE_REL: 'h',\n  CURVE: 'C',\n  CURVE_REL: 'c',\n  SCURVE: 'S',\n  SCURVE_REL: 's',\n  QCURVE: 'Q',\n  QCURVE_REL: 'q',\n  SQCURVE: 'T',\n  SQCURVE_REL: 't',\n  ARC: 'A',\n  ARC_REL: 'a',\n  CLOSE_PATH: 'Z',\n}\n\nconst shapeCmds = {\n  RECT: 'r',\n  CIRCLE: 'c',\n  ELLIPSE: 'e',\n  LINE: 'l',\n  POLYLINE: 's',\n  PATH: 'p',\n  POLYGON: 'g',\n  CLIPPING: 'm',\n}\n\n/**\n * Black Vector Graphics parser.\n * Creates GraphicsData for Graphics from BVG format.\n *\n * @cat parsers\n * @extends ParserBase\n */\n\nexport \nclass BVGParser extends ParserBase {\n  /**\n   * Creates new instance of BVGParser\n   */\n  constructor() {\n    super()\n\n    /** @type {Object} */\n    this._defs = {}\n  }\n\n  /**\n   * @inheritDoc\n   *\n   * @return {GraphicsData} Data for Graphics renderer\n   */\n  parse(data) {\n    super.parse(data)\n\n    const styles = this.__parseStyles(data['styles'])\n\n    this._defs = {}\n    this.__parseDefs(data['defs'], this._defs)\n\n    return this.__traverse(data, styles, new GraphicsData(), new BVGStyle())\n  }\n\n  /**\n   * Recursively goes through children nodes and builds final GraphicsData.\n   *\n   * @private\n   * @param {Object} node BVG node.\n   * @param {Array<BVGStyle>} styles Parsed BVG styles.\n   * @param {GraphicsData} parent Parent node.\n   * @param {BVGStyle} parentStyle Style for inheritance.\n   *\n   * @returns {GraphicsData} Parsed data root.\n   */\n  __traverse(node, styles, parent, parentStyle) {\n    const defs = this._defs\n    const graphicsData = new GraphicsData()\n    let style = parentStyle.clone()\n    parent.mNodes.push(graphicsData)\n\n    if (node['id']) graphicsData.name = node['id']\n\n    let t = node['t']\n    if (t) {\n      const x = t[0] || 0\n      const y = t[1] || 0\n      const sx = t[2] || 1\n      const sy = t[3] || 1\n      const px = t[5] || 0\n      const py = t[6] || 0\n\n      graphicsData.mTransform.rotate(t[4] || 0)\n      graphicsData.mTransform.scale(sx, sy)\n      graphicsData.mTransform.skew(t[7] || 0, t[8] || 0)\n\n      graphicsData.mTransform.data[4] = x + px / sx\n      graphicsData.mTransform.data[5] = y + py / sy\n\n      graphicsData.mPivotX = px\n      graphicsData.mPivotY = py\n    }\n\n    if (node['cmds']) {\n      const cmds = node['cmds']\n        .split('$')\n        .filter(v => v)\n        .reverse()\n      const lastRect = new Rectangle()\n      let prevName = ''\n\n      while (cmds.length > 0) {\n        const cmd = cmds.pop()\n        const name = cmd[0]\n        const args = cmd\n          .slice(1)\n          .split(',')\n          .map(v => Number(v))\n\n        graphicsData.beginPath()\n\n        if (prevName !== 'S' && name !== 'S') {\n          graphicsData.fillStyle(0x000000, 1)\n          graphicsData.lineStyle(\n            1,\n            0x000000,\n            1,\n            CapsStyle.NONE,\n            JointStyle.MITER,\n            4\n          )\n        }\n\n        prevName = name\n\n        switch (name) {\n          case 'S':\n            const newStyle = styles[args[0]]\n            style = parentStyle.clone()\n            style.merge(newStyle)\n            style.compute()\n\n            break\n          case shapeCmds.PATH:\n            this.__drawPath(cmd, graphicsData)\n            break\n          case shapeCmds.RECT: {\n            const x = args[0]\n            const y = args[1]\n            const width = args[2]\n            const height = args[3]\n            const rx = (args[4] === undefined ? args[5] : args[4]) || 0\n            const ry = (args[5] === undefined ? args[4] : args[5]) || 0\n\n            lastRect.set(x, y, width, height)\n\n            if (rx !== 0 && ry !== 0) {\n              graphicsData.moveTo(x, y + ry)\n              graphicsData.quadraticCurveTo(x, y, x + rx, y)\n              graphicsData.lineTo(x + width - rx, y)\n              graphicsData.quadraticCurveTo(x + width, y, x + width, y + ry)\n              graphicsData.lineTo(x + width, y + height - ry)\n              graphicsData.quadraticCurveTo(\n                x + width,\n                y + height,\n                x + width - rx,\n                y + height\n              )\n              graphicsData.lineTo(x + rx, y + height)\n              graphicsData.quadraticCurveTo(x, y + height, x, y + height - ry)\n              graphicsData.closePath()\n            } else {\n              graphicsData.rect(args[0], args[1], args[2], args[3])\n            }\n\n            break\n          }\n          case shapeCmds.CIRCLE:\n            const d = args[2] * 2\n            lastRect.set(0, 0, d, d)\n            graphicsData.circle(args[0], args[1], args[2])\n            break\n          case shapeCmds.ELLIPSE:\n            const x = args[0]\n            const y = args[1]\n            const rx = args[2]\n            const ry = args[3]\n\n            let a = /** @type {!Array<!Array<number>>} */ (this.__arcToBezier(\n              x - rx,\n              y,\n              rx,\n              ry,\n              0,\n              0,\n              0,\n              x + rx,\n              y\n            ))\n            let b = /** @type {!Array<!Array<number>>} */ (this.__arcToBezier(\n              x + rx,\n              y,\n              rx,\n              ry,\n              0,\n              0,\n              0,\n              x - rx,\n              y\n            ))\n\n            const curves = [...a, ...b]\n\n            graphicsData.moveTo(x - rx, y)\n\n            for (let i = 0, l = curves.length; i < l; i++) {\n              const c = curves[i]\n              graphicsData.bezierCurveTo(c[2], c[3], c[4], c[5], c[6], c[7])\n            }\n\n            // graphics.moveTo(x, y);\n            break\n          case shapeCmds.LINE:\n            const x1 = args[0]\n            const y1 = args[1]\n            const x2 = args[2]\n            const y2 = args[3]\n\n            graphicsData.moveTo(x1, y1)\n            graphicsData.lineTo(x2, y2)\n            break\n          case shapeCmds.POLYLINE:\n          case shapeCmds.POLYGON:\n            const points = cmd\n              .slice(1)\n              .split(',')\n              .map(v => Number(v))\n            graphicsData.moveTo(points[0], points[1])\n\n            for (let i = 2, l = points.length; i < l; i += 2) {\n              graphicsData.lineTo(points[i], points[i + 1])\n            }\n\n            name === shapeCmds.POLYGON && graphicsData.closePath()\n            break\n          default:\n            break\n        }\n\n        if (style.needsFill && name !== 'S') {\n          if (this.__isRef(style.F)) {\n            const def = defs[style.F.slice(1)].clone()\n\n            if (def instanceof GraphicsPattern) {\n              graphicsData.fillPattern(def)\n            } else if (def instanceof GraphicsLinearGradient) {\n              if (def.isAbsolute) {\n                //\n              } else {\n                def.x0 *= lastRect.width // todo other units (Now for percents only)\n                def.x1 *= lastRect.width\n                def.y0 *= lastRect.height\n                def.y1 *= lastRect.height\n              }\n\n              for (let key in def.stops) {\n                def.stops[key] = ColorHelper.intToRGBA(\n                  parseInt(def.stops[key].slice(1), 16),\n                  style.fillAlpha\n                )\n              }\n\n              graphicsData.fillGradient(def)\n            }\n          } else {\n            graphicsData.fillStyle(style.fillColor, style.fillAlpha)\n          }\n\n          graphicsData.fill(style.fillRule === FillRule.NONE_ZERO)\n        }\n\n        if (style.needsStroke) {\n          graphicsData.lineStyle(\n            style.lineWidth,\n            style.lineColor,\n            style.lineAlpha,\n            style.lineCap,\n            style.lineJoin,\n            style.miterLimit\n          )\n\n          graphicsData.setLineDash(style.lineDash)\n          graphicsData.stroke()\n        }\n      }\n    }\n\n    if (node['nodes']) {\n      node['nodes'].forEach(c => {\n        this.__traverse(c, styles, graphicsData, style)\n      })\n    }\n\n    return graphicsData\n  }\n\n  /**\n   * Determines whether color string is url to defs or simple color.\n   *\n   * @private\n   * @param {string} value Color or url.\n   *\n   * @return {boolean}\n   */\n  __isRef(value) {\n    return value.indexOf('$') === 0\n  }\n\n  /**\n   * Parses raw defs to this defs object.\n   *\n   * @private\n   * @param {Object} defs Raw defs.\n   * @param {Object} res  Reference to this defs.\n   *\n   * @returns {Object} res Parsed data.\n   */\n  __parseDefs(defs, res) {\n    if (!defs) {\n      return res\n    }\n\n    for (let id in defs) {\n      if (!defs.hasOwnProperty(id)) continue\n\n      const def = defs[id]\n\n      if (typeof def === 'string') {\n        const cmd = def.charAt(0)\n\n        switch (cmd) {\n          case 'R': // Linear Gradient\n            const pairs = def.slice(1).split(' ')\n            const v = pairs[0].split(',').map(v => parseFloat(v))\n            const gradientInfo = new GraphicsLinearGradient(\n              v[0],\n              v[1],\n              v[2],\n              v[3]\n            )\n            gradientInfo.isAbsolute = v[4] === 0\n            res[id] = gradientInfo\n\n            for (let i = 1, l = pairs.length; i < l; i++) {\n              const pair = pairs[i]\n              const values = pair.split(',')\n              const color = '#' + values[1]\n\n              gradientInfo.addColorStop(parseFloat(values[0]), color)\n            }\n        }\n      } else {\n        // Pattern\n        const styles = this.__parseStyles(def.s)\n        const gData = this.__traverse(\n          def,\n          styles,\n          new GraphicsData(),\n          new BVGStyle()\n        )\n        const graphics = new Graphics(gData)\n        const renderTexture = new CanvasRenderTexture(\n          graphics.width,\n          graphics.height,\n          Black.driver.renderScaleFactor\n        )\n        Black.driver.render(graphics, renderTexture, new Matrix())\n\n        res[id] = new GraphicsPattern(renderTexture.native, def.r)\n      }\n    }\n\n    return res\n  }\n\n  /**\n   * BVG styles parser.\n   *\n   * @private\n   *\n   * @returns {Array<BVGStyle>} Parsed data styles.\n   */\n  __parseStyles(styles) {\n    if (!styles) return []\n\n    return styles.map(s => {\n      const style = {}\n      const props = s.split(' ')\n\n      props.forEach(p => {\n        const cmd = p[0]\n        style[cmd] = p.slice(1)\n      })\n\n      return style\n    })\n  }\n\n  /**\n   * BVG path data parser.\n   *\n   * @private\n   * @params {string} data Path data attribute value\n   * @params {GraphicsData} graphicsData Graphics data to store parsed values to.\n   *\n   * @return {void}\n   */\n  __drawPath(data, graphicsData) {\n    const values = []\n\n    data.split(',').map(item => {\n      while (item.length !== 0) {\n        const arg = parseFloat(item)\n\n        if (isNaN(arg)) {\n          values.push(item.charAt(0))\n          item = item.slice(1)\n        } else {\n          values.push(arg)\n\n          for (let i = 1; true; i++) {\n            if (parseFloat(item.slice(0, i)) === arg) {\n              item = item.slice(i)\n              break\n            }\n          }\n        }\n      }\n    })\n\n    values.reverse()\n\n    // Context position\n    let x = 0\n    let y = 0\n\n    // Path start position, to return on close path\n    let mx = 0\n    let my = 0\n\n    // Bezier curve control point 1 position, to draw next smoothed bezier curve\n    let bcx = 0\n    let bcy = 0\n\n    // Quadratic curve control point 1 position, to draw next smoothed quadratic curve\n    let qcx = 0\n    let qcy = 0\n\n    // Store last command\n    let prevValue = ''\n\n    // 0 for absolute path and x, y for relative\n    let relX = 0\n    let relY = 0\n\n    while (values.length !== 0) {\n      const last = values[values.length - 1]\n      const v = last === last.toString() ? values.pop() : prevValue\n      prevValue = v\n      relX = relY = 0\n\n      if (v === v.toLowerCase()) {\n        relX = x\n        relY = y\n      }\n\n      switch (v) {\n        case pathCmds.MOVETO:\n        case pathCmds.MOVETO_REL:\n          x = values.pop() + relX\n          y = values.pop() + relY\n          graphicsData.moveTo(x, y)\n          mx = x\n          my = y\n          break\n        case pathCmds.LINETO:\n        case pathCmds.LINETO_REL:\n          x = values.pop() + relX\n          y = values.pop() + relY\n          graphicsData.lineTo(x, y)\n          break\n        case pathCmds.VLINE:\n        case pathCmds.VLINE_REL:\n          y = values.pop() + relY\n          graphicsData.lineTo(x, y)\n          break\n        case pathCmds.HLINE:\n        case pathCmds.HLINE_REL:\n          x = values.pop() + relX\n          graphicsData.lineTo(x, y)\n          break\n        case pathCmds.CURVE:\n        case pathCmds.CURVE_REL: {\n          const cp1x = values.pop() + relX\n          const cp1y = values.pop() + relY\n          const cp2x = values.pop() + relX\n          const cp2y = values.pop() + relY\n          x = values.pop() + relX\n          y = values.pop() + relY\n          graphicsData.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y)\n          bcx = x * 2 - cp2x\n          bcy = y * 2 - cp2y\n          break\n        }\n        case pathCmds.SCURVE:\n        case pathCmds.SCURVE_REL: {\n          const cp2x = values.pop() + relX\n          const cp2y = values.pop() + relY\n          x = values.pop() + relX\n          y = values.pop() + relY\n          graphicsData.bezierCurveTo(bcx, bcy, cp2x, cp2y, x, y)\n          bcx = x * 2 - cp2x\n          bcy = y * 2 - cp2y\n          break\n        }\n        case pathCmds.QCURVE:\n        case pathCmds.QCURVE_REL: {\n          const cpx = values.pop() + relX\n          const cpy = values.pop() + relY\n          x = values.pop() + relX\n          y = values.pop() + relY\n          graphicsData.quadraticCurveTo(cpx, cpy, x, y)\n          qcx = x * 2 - cpx\n          qcy = y * 2 - cpy\n          break\n        }\n        case pathCmds.SQCURVE:\n        case pathCmds.SQCURVE_REL: {\n          x = values.pop() + relX\n          y = values.pop() + relY\n          graphicsData.quadraticCurveTo(qcx, qcy, x, y)\n          qcx = x * 2 - qcx\n          qcy = y * 2 - qcy\n          break\n        }\n        case pathCmds.ARC:\n        case pathCmds.ARC_REL: {\n          const px = x\n          const py = y\n          const rx = values.pop()\n          const ry = values.pop()\n          const xAxisRotation = values.pop()\n          const largeArcFlag = values.pop()\n          const sweepFlag = values.pop()\n          x = values.pop() + relX\n          y = values.pop() + relY\n\n          const curves = this.__arcToBezier(\n            px,\n            py,\n            rx,\n            ry,\n            xAxisRotation,\n            largeArcFlag,\n            sweepFlag,\n            x,\n            y\n          )\n\n          if (!curves) break\n\n          for (let i = 0, l = curves.length; i < l; i++) {\n            const c = curves[i]\n            graphicsData.bezierCurveTo(c[2], c[3], c[4], c[5], c[6], c[7])\n          }\n\n          break\n        }\n        case pathCmds.CLOSE_PATH:\n          graphicsData.closePath()\n          x = mx\n          y = my\n          break\n      }\n\n      if (\n        v !== pathCmds.CURVE &&\n        v !== pathCmds.CURVE_REL &&\n        v !== pathCmds.SCURVE &&\n        v !== pathCmds.SCURVE_REL\n      ) {\n        bcx = x\n        bcy = y\n      }\n\n      if (\n        v !== pathCmds.QCURVE &&\n        v !== pathCmds.QCURVE_REL &&\n        v !== pathCmds.SQCURVE &&\n        v !== pathCmds.SQCURVE_REL\n      ) {\n        qcx = x\n        qcy = y\n      }\n    }\n  }\n\n  // ARC TO BEZIER START\n  /**\n   * Approximate curve corner. Single bezier shouldn't be longer than 90 degrees.\n   *\n   * @private\n   * @params {number} theta Start angle.\n   * @params {number} deltaTheta Angle from start to end.\n   *\n   * @returns {Array<number>} Center.\n   */\n  __approxUnitArc(theta, deltaTheta) {\n    const alpha = (4 / 3) * Math.tan(deltaTheta / 4)\n    const x1 = Math.cos(theta)\n    const y1 = Math.sin(theta)\n    const x2 = Math.cos(theta + deltaTheta)\n    const y2 = Math.sin(theta + deltaTheta)\n\n    return [\n      x1,\n      y1,\n      x1 - y1 * alpha,\n      y1 + x1 * alpha,\n      x2 + y2 * alpha,\n      y2 - x2 * alpha,\n      x2,\n      y2,\n    ]\n  }\n\n  __vectorAngle(ux, uy, vx, vy) {\n    const sign = ux * vy - uy * vx < 0 ? -1 : 1\n    const dot = MathEx.clamp(ux * vx + uy * vy, -1, 1)\n\n    return sign * Math.acos(dot)\n  }\n\n  /**\n   * Find arc center.\n   *\n   * @private\n   * @params {number} x1 Context current position x.\n   * @params {number} y1 Context current position y.\n   * @params {number} x2 Context target (next) position x.\n   * @params {number} y2 Context target (next) position y.\n   * @params {number} fa Flag to determine which arc to draw.\n   * @params {number} fs Another flag to determine which arc to draw.\n   * @params {number} rx Arc radius x.\n   * @params {number} ry Arc radius y.\n   * @params {number} sinPhi Sin of x axis rotation.\n   * @params {number} cosPhi Cos of x axis rotation.\n   *\n   * @returns {Array<number>} Center.\n   */\n  __getArcCenter(x1, y1, x2, y2, fa, fs, rx, ry, sinPhi, cosPhi) {\n    const x1p = (cosPhi * (x1 - x2)) / 2 + (sinPhi * (y1 - y2)) / 2\n    const y1p = (-sinPhi * (x1 - x2)) / 2 + (cosPhi * (y1 - y2)) / 2\n\n    const rxSq = rx * rx\n    const rySq = ry * ry\n    const x1pSq = x1p * x1p\n    const y1pSq = y1p * y1p\n\n    let radical = Math.max(0, rxSq * rySq - rxSq * y1pSq - rySq * x1pSq)\n    radical /= rxSq * y1pSq + rySq * x1pSq\n    radical = Math.sqrt(radical) * (fa === fs ? -1 : 1)\n\n    const cxp = ((radical * rx) / ry) * y1p\n    const cyp = ((radical * -ry) / rx) * x1p\n\n    const cx = cosPhi * cxp - sinPhi * cyp + (x1 + x2) / 2\n    const cy = sinPhi * cxp + cosPhi * cyp + (y1 + y2) / 2\n\n    const v1x = (x1p - cxp) / rx\n    const v1y = (y1p - cyp) / ry\n    const v2x = (-x1p - cxp) / rx\n    const v2y = (-y1p - cyp) / ry\n\n    const theta = this.__vectorAngle(1, 0, v1x, v1y)\n    let deltaTheta = this.__vectorAngle(v1x, v1y, v2x, v2y)\n\n    if (fs === 0 && deltaTheta > 0) {\n      deltaTheta -= Math.PI * 2\n    }\n\n    if (fs === 1 && deltaTheta < 0) {\n      deltaTheta += Math.PI * 2\n    }\n\n    return [cx, cy, theta, deltaTheta]\n  }\n\n  /**\n   * BVG path data parser.\n   *\n   * @private\n   * @params {number} px Context current position x.\n   * @params {number} py Context current position y.\n   * @params {number} rx Arc radius x.\n   * @params {number} ry Arc radius y.\n   * @params {number} xAxisRotation Rotation in degrees.\n   * @params {number} largeFlag Flag to determine which arc to draw.\n   * @params {number} sweepFlag Another flag to determine which arc to draw.\n   * @params {number} x Context target (next) position x.\n   * @params {number} y Context target (next) position y.\n   *\n   * @returns {Array<Array<number>>|undefined} Array of bezier curves attributes.\n   */\n  __arcToBezier(px, py, rx, ry, xAxisRotation, largeFlag, sweepFlag, x, y) {\n    const sinPhi = Math.sin((xAxisRotation * Math.PI) / 180)\n    const cosPhi = Math.cos((xAxisRotation * Math.PI) / 180)\n\n    const x1p = (cosPhi * (px - x)) / 2 + (sinPhi * (py - y)) / 2\n    const y1p = (-sinPhi * (px - x)) / 2 + (cosPhi * (py - y)) / 2\n\n    if ((x1p === 0 && y1p === 0) || rx === 0 || ry === 0) return\n\n    rx = Math.abs(rx)\n    ry = Math.abs(ry)\n\n    const lambda = (x1p * x1p) / (rx * rx) + (y1p * y1p) / (ry * ry)\n\n    if (lambda > 1) {\n      const lambdaRt = Math.sqrt(lambda)\n      rx *= lambdaRt\n      ry *= lambdaRt\n    }\n\n    const center = this.__getArcCenter(\n      px,\n      py,\n      x,\n      y,\n      largeFlag,\n      sweepFlag,\n      rx,\n      ry,\n      sinPhi,\n      cosPhi\n    )\n    const curves = []\n    let theta = center[2]\n    let deltaTheta = center[3]\n\n    const segments = Math.max(\n      Math.ceil(Math.abs(deltaTheta) / (Math.PI * 0.5)),\n      1\n    )\n    deltaTheta /= segments\n\n    for (let i = 0; i < segments; i++) {\n      curves.push(this.__approxUnitArc(theta, deltaTheta))\n      theta += deltaTheta\n    }\n\n    return curves.map(function(curve) {\n      for (let i = 0; i < curve.length; i += 2) {\n        const x = curve[i] * rx\n        const y = curve[i + 1] * ry\n        const xp = cosPhi * x - sinPhi * y\n        const yp = sinPhi * x + cosPhi * y\n\n        curve[i] = xp + center[0]\n        curve[i + 1] = yp + center[1]\n      }\n\n      return curve\n    })\n  }\n}\n","/**\n * Black Vector Graphics style\n * Helper class for BVG style parse\n *\n * @cat parsers\n */\n\nexport \nclass BVGStyle {\n  /**\n   * Creates new instance of BVGStyle.\n   */\n  constructor() {\n    /**\n     * Stroke color\n     *\n     * @private @export @type {string} */\n    this.L = '-'\n\n    /**\n     * Stroke alpha.\n     *\n     * @private @export @type {number} */\n    this.l = 1\n\n    /**\n     * Line width.\n     *\n     * @private @export @type {number} */\n    this.w = 1\n\n    /**\n     * Fill color.\n     *\n     * @private @export @type {string}*/\n    this.F = '0'\n\n    /**\n     * Fill alpha.\n     *\n     * @private @export @type {number} */\n    this.f = 1\n\n    /**\n     * Fill rule.\n     * {nonzero: 1, evenodd: 0}\n     *\n     * @private @export @type {number} */\n    this.r = 1\n\n    /**\n     * Line cap.\n     * {butt: 'b', round: 'r', square: 's'}\n     *\n     * @private @export @type {string} */\n    this.c = 'b'\n\n    /**\n     * Line join.\n     * {miter: 'm', round: 'r', bevel: 'b'}\n     *\n     * @private @export @type {string} */\n    this.j = 'm'\n\n    /**\n     * Miter limit.\n     *\n     * @private @export @type {number} */\n    this.m = 4\n\n    /**\n     * Global alpha.\n     *\n     * @private @export @type {number} */\n    this.a = 1\n\n    /**\n     * Line dash.\n     *\n     * @private @export @type {string} */\n    this.d = ''\n\n    /**\n     * Fill necessity flag.\n     *\n     * @public @type {boolean} */\n    this.needsFill = true\n\n    /**\n     * Stroke necessity flag.\n     *\n     * @public @type {boolean} */\n    this.needsStroke = false\n\n    /** @public @type {number} */\n    this.fillColor = 0\n\n    /** @public @type {number} */\n    this.fillAlpha = 1\n\n    /** @public @type {number} */\n    this.lineColor = 0\n\n    /** @public @type {number} */\n    this.lineAlpha = 1\n\n    /** @public @type {number} */\n    this.lineWidth = 1\n\n    /** @public @type {CapsStyle} */\n    this.lineCap = CapsStyle.NONE\n\n    /** @public @type {JointStyle} */\n    this.lineJoin = JointStyle.MITER\n\n    /** @public @type {number} */\n    this.miterLimit = this.m\n\n    /** @public @type {FillRule} */\n    this.fillRule = FillRule.NONE_ZERO\n\n    /**\n     * Line dash segments length, unit.\n     *\n     * @public @type {Array<number>} */\n    this.lineDash = []\n  }\n\n  /**\n   * Merge parent style to this.\n   *\n   * @public\n   * @param {BVGStyle} style Parent style\n   *\n   * @returns {void}\n   */\n  merge(style) {\n    if (style.F) this.F = style.F\n\n    if (style.L) this.L = style.L\n\n    if (style.w) this.w = style.w\n\n    if (style.l) this.l *= style.l\n\n    if (style.f) this.f *= style.f\n\n    if (style.r) this.r = style.r\n\n    if (style.c) this.c = style.c\n\n    if (style.j) this.j = style.j\n\n    if (style.m) this.m = style.m\n\n    if (style.a) this.a = style.a\n\n    if (style.d) this.d = style.d\n  }\n\n  /**\n   * Update readable properties to use this style.\n   *\n   * @public\n   *\n   * @returns {void}\n   */\n  compute() {\n    this.needsFill = this.F !== '-'\n\n    if (this.needsFill) this.fillColor = parseInt(this.F, 16)\n\n    this.lineWidth = +this.w\n    this.needsStroke = this.L !== '-' && this.lineWidth > 0\n\n    if (this.needsStroke) this.lineColor = parseInt(this.L, 16)\n\n    const alpha = Number(this.a)\n    this.lineAlpha = Number(this.l) * alpha\n    this.fillAlpha = Number(this.f) * alpha\n\n    this.lineCap = {\n      b: CapsStyle.NONE,\n      r: CapsStyle.ROUND,\n      s: CapsStyle.SQUARE,\n    }[this.c]\n    this.lineJoin = {\n      m: JointStyle.MITER,\n      r: JointStyle.ROUND,\n      b: JointStyle.BEVEL,\n    }[this.j]\n    this.miterLimit = Number(this.m)\n    this.fillRule = { 1: FillRule.NONE_ZERO, 0: FillRule.EVEN_ODD }[this.r]\n    this.lineDash = this.d.split(',').map(v => Number(v))\n  }\n\n  /**\n   * Create copy of this style.\n   *\n   * @public\n   *\n   * @returns {BVGStyle} Created style.\n   */\n  clone() {\n    let s = new BVGStyle()\n    s.L = this.L\n    s.l = this.l\n    s.w = this.w\n    s.F = this.F\n    s.f = this.f\n    s.r = this.r\n    s.c = this.c\n    s.j = this.j\n    s.m = this.m\n    s.a = this.a\n\n    return s\n  }\n}\n","/**\n * @private\n * @ignore\n * @extends MessageDispatcher\n * @cat core\n */\nexport \nclass SplashScreen extends MessageDispatcher {\n  constructor() {\n    super(false)\n  }\n\n  show() {\n    // @ifndef HIDE_SPLASH_SCREEN\n    let duration = SplashScreen.duration * 0.001\n    let css = `#logo,#splash-screen{position:relative;box-sizing:border-box}#logo-inner,#logo-name{margin-left:auto;margin-right:auto}#splash-screen{z-index:999;top:0;left:0;width:100%;height:100%;display:block;background:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAQAAAAECAYAAACp8Z5+AAAAIklEQVQYV2OUkpL6/+zZMwYpKSkGEM3IwMDwnwEJMBJUAQCLUhABUGRZzwAAAABJRU5ErkJggg==);opacity:1;animation:hide 0s ease-in ${duration}s forwards}@keyframes hide{to{opacity:0}}#logo{top:20%;left:50%;animation:fadein ${duration}s linear forwards}@keyframes fadein{0%{opacity:0}100%,40%{opacity:1}}#logo-name{width:100%;margin-top:108px}`\n\n    let style = document.createElement('style')\n    style.type = 'text/css'\n    style.innerHTML = css\n    document.getElementsByTagName('head')[0].appendChild(style)\n\n    let container = /** @type {HTMLElement} */ (document.getElementById(\n      Black.instance.containerElementId\n    ))\n    let oldOverflow = container.style.overflow\n    container.style.overflow = 'hidden'\n\n    let splash = document.createElement('div')\n    splash.id = 'splash-screen'\n    container.appendChild(splash)\n\n    let logo = document.createElement('div')\n    logo.id = 'logo'\n    splash.appendChild(logo)\n\n    let logoInner = document.createElement('div')\n    logoInner.id = 'logo-inner'\n    logoInner.innerHTML = SplashScreen.SVG_LOGO\n    logo.appendChild(logoInner)\n\n    let logoName = document.createElement('div')\n    logoName.id = 'logo-name'\n    logoName.innerHTML = SplashScreen.SVG_TEXT\n    logo.appendChild(logoName)\n\n    let refresh = () => {\n      let mw = splash.offsetWidth\n      let mh = splash.offsetHeight\n\n      let size = this.calculateAspectRatioFit(mw, mh, mw * 0.5, mh * 0.5)\n\n      logo.style.width = `${size.width}px`\n      logo.style.height = `${size.height}px`\n      logo.style.marginLeft = `${-size.width * 0.5}px`\n\n      logoInner.style.width = `${Math.min(size.width, size.height)}px`\n      logoInner.style.height = `${Math.min(size.width, size.height)}px`\n\n      logoName.style.width = `${Math.min(size.width, size.height) * 0.9}px`\n      logoName.style.height = `${Math.min(size.width, size.height)}px`\n      logoName.style.marginTop = `${12}px`\n    }\n\n    refresh()\n\n    let cw = container.offsetWidth\n    let ch = container.offsetHeight\n\n    let handle = setInterval(x => {\n      if (cw !== container.offsetWidth || ch !== container.offsetHeight) {\n        cw = container.offsetWidth\n        ch = container.offsetHeight\n        refresh()\n      }\n    }, 1000 / 60)\n\n    setTimeout(() => {\n      clearTimeout(handle)\n\n      style.parentNode.removeChild(style)\n      splash.parentNode.removeChild(splash)\n\n      container.style.overflow = oldOverflow\n\n      /**\n       * Posts when splash screen is hidden.\n       * @event SplashScreen#complete\n       */\n      this.post(Message.COMPLETE)\n    }, SplashScreen.duration)\n    // @endif\n\n    // @ifdef HIDE_SPLASH_SCREEN\n    this.post(Message.COMPLETE)\n    // @endif\n  }\n\n  // @ifndef SPLASH_SCREEN\n  calculateAspectRatioFit(srcWidth, srcHeight, maxWidth, maxHeight) {\n    let ratio = Math.min(maxWidth / srcWidth, maxHeight / srcHeight)\n    return { width: srcWidth * ratio, height: srcHeight * ratio }\n  }\n  // @endif\n}\n\nSplashScreen.duration = 4200\nSplashScreen.enabled = true\n\n// @ifndef HIDE_SPLASH_SCREEN\nSplashScreen.SVG_LOGO = `<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 241.8 220.2\"><defs><style>.b{fill:#f5f5f5}.c{fill:url(#a)}</style><pattern id=\"a\" width=\"17.6\" height=\"14.87\" patternUnits=\"userSpaceOnUse\" viewBox=\"0 0 17.6 14.9\"><path fill=\"none\" d=\"M0 0h17.6v14.87H0z\"/><path class=\"b\" d=\"M0 13.4v1.5h1.5A1.5 1.5 0 0 1 0 13.4z\"/><path class=\"b\" d=\"M8.8 0a1.5 1.5 0 0 1 1.5 1.5 1.5 1.5 0 1 1-3 0A1.5 1.5 0 0 1 8.8 0H0v13.4a1.5 1.5 0 0 1 1.5-1.5A1.5 1.5 0 0 1 3 13.4a1.5 1.5 0 0 1-1.5 1.5h4.3a1.5 1.5 0 0 1-1.5-1.5 1.5 1.5 0 0 1 1.5-1.5 1.4 1.4 0 0 1 1.5 1.5 1.5 1.5 0 0 1-1.5 1.5h6a1.5 1.5 0 0 1-1.5-1.5 1.5 1.5 0 0 1 3 0 1.5 1.5 0 0 1-1.5 1.5h5.8V0zm6.6.7a1.5 1.5 0 0 1 1.5 1.5 1.5 1.5 0 0 1-1.5 1.5 1.4 1.4 0 0 1-1.5-1.5A1.5 1.5 0 0 1 15.4.7zM.4 2.2A1.5 1.5 0 0 1 1.9.7a1.5 1.5 0 0 1 1.5 1.5 1.5 1.5 0 0 1-1.5 1.5A1.5 1.5 0 0 1 .4 2.2zm1.7 5.7A1.5 1.5 0 0 1 .6 6.4a1.5 1.5 0 0 1 1.5-1.5 1.5 1.5 0 0 1 0 3zm2 3.8a1.5 1.5 0 0 1-1.5-1.5 1.5 1.5 0 0 1 1.5-1.5 1.5 1.5 0 0 1 1.5 1.5 1.5 1.5 0 0 1-1.5 1.5zm.2-8a1.5 1.5 0 0 1 1.5-1.5 1.5 1.5 0 0 1 1.5 1.5 1.4 1.4 0 0 1-1.5 1.5 1.5 1.5 0 0 1-1.5-1.5zm2.2 3.5a1.5 1.5 0 1 1 3 0 1.5 1.5 0 0 1-3 0zm2.2 5.3a1.5 1.5 0 1 1 1.5-1.5 1.5 1.5 0 0 1-1.5 1.5zm1.4-8a1.5 1.5 0 0 1 3 0 1.5 1.5 0 1 1-3 0zm2.5 5.7a1.5 1.5 0 0 1-1.5-1.5 1.5 1.5 0 0 1 1.5-1.5 1.4 1.4 0 0 1 1.5 1.5 1.5 1.5 0 0 1-1.5 1.5zm3 3.5a1.5 1.5 0 0 1-1.5-1.5 1.5 1.5 0 0 1 1.5-1.5 1.5 1.5 0 0 1 1.5 1.5 1.4 1.4 0 0 1-1.5 1.5zm0-5.5a1.5 1.5 0 0 1-1.5-1.5 1.5 1.5 0 0 1 1.5-1.5 1.5 1.5 0 0 1 1.5 1.5 1.4 1.4 0 0 1-1.5 1.5z\"/></pattern></defs><path class=\"c\" d=\"M25.8 105.2c12.1 8.8 29.7 6.7 59.8 6.8-7.9-7.3-9.1-18.7-7.1-27.3-6.6 7.3-5.1 19.3-12.8 19.4-3.4.1-6.9-4.7-8.3-10.8-5.3 9.4-12 10.7-14.7-4.5-2.3 2-3.9 8.2-9.5 6.2S26.8 81.8 30 71.3A28.3 28.3 0 0 1 14.6 61c-1.4 20.8.5 36.4 11.2 44.2zM51.9 39.9c29.7-3.6 54-22.8 69.5-26.3-.1 0-40.7-.3-72.3 1.9 6.2 3.5 10.5 16.3 2.8 24.4zM170.4 34.2c5.6-2 32.1-9.5 54.4-2.7-3-13.7-22.9-17-71.8-17.8a32.2 32.2 0 0 1 17.4 20.5zM211.3 109.3c-12.2 2.1-12.8-8.8-32.9-8.9-15.5 0-35.2 13.2-36.1 13.7h49.3c19.1 0 32.5-.6 35.5-7.3s-2.7-12.3-10.7-15.6c5.3 5.6 4.1 16.5-5.1 18.1zM66 189.2c-5.9 5-26 17.8-43.6 6.3 3.6 8.4 13.6 12.7 45.1 12-1.6-2.4-5.3-10.4-1.5-18.3zM32 161.5c7.3 7.8 18.1 2.6 33.7-6.2 10.5-6 27.5-9.9 40.6-1.1 3.7-8.7 5.4-10.9 6.7-10.6s.7 2.7 5.6 7c.4-1 3.8-7.9 3.8-12l-59.9-.8c-1.5 6.6-9.9 19-23.9 17.4-2.4-.3-2.5-11.6 2.4-16.9a36.7 36.7 0 0 0-7.4.9c-4.4 5.1-7 16.4-1.6 22.3zM150.9 148.1c23.6-.5 26 19.9 41.1 21 10.9.9 13.6-16.8 35.7-11.8-1.3-11.1-7.7-16.2-22.2-17.4 3 10.3-6.6 28.5-19.3 21.5a1.5 1.5 0 0 1-.8-1.1c-.9-11 2.8-15.8 7.5-20.7l-55.7-.7a18.5 18.5 0 0 1 3.7 12.4 20.7 20.7 0 0 1 10-3.2zM162 195.9c-3.9 3.6-3.8 9.5-2.5 12.5h4.1c0-14.8 17-12.8 21.2-.8 22.7-1.5 30.9-3.2 36-8.7s6.4-15.3 6.8-27.1c-2.6 3-9.8 14.7-10.9 16.4-17.8 26.3-39.9-5.9-54.7 7.7z\"/><path class=\"b\" d=\"M150 42.6c-.2 10.4-9.8 13.6-9.4-.7-16.2 1.9-14.5 8.5-13.7 9.5 4.4 5.6 29 4.5 27.3-4.3a5.7 5.7 0 0 0-4.2-4.5z\"/><path class=\"b\" d=\"M162.2 46.4c-1.7-15.7-17.2-18.2-28.4-15.6s-22.3 12.7-15.6 25.4 46.2 10.3 44-9.8zm-37.8 6.7c-5.4-9.7 10.6-13.4 13.2-13.8 7.5-1.3 18.2-1.2 19.6 7.6 2 13.2-28.8 13.3-32.8 6.2zM184.7 68.8c-1.1 0-1.1 3.3-5.4 12.5.3 0 5.8 0 8.6.2-.7-9.1-2.1-12.7-3.2-12.7zM162.5 82.9l7-1.1c-2.5-4.6-5.8-8.6-7 1.1zM153.1 74.5a55.8 55.8 0 0 0-7.8 2c6.4 9.4 7.4 2.2 7.8-2zM134.8 94.6c.4-.2 4.9-3.1 6.9-4.1-1.9-2-8.1-9.9-6.9 4.1zM190.9 81.8a58.3 58.3 0 0 1 9 1.5 77.7 77.7 0 0 0 .4-8.8c-1.7-.3-7.2-1.2-10.3-1.5a52 52 0 0 1 .9 8.8z\"/><path class=\"b\" d=\"M216.5 76.2a39.1 39.1 0 0 1-5.6 10.4c13 3 25.3 10.8 18.1 23.1-3.8 6.6-16.4 7.5-37.4 7.5l-55.4-.2a32.3 32.3 0 0 1-18.8 1.1c-6.8 1.5-18.2 3.7-28.2-3.1-30.8-.4-49.7 3.2-64.9-7.1C6.4 95.7 11.6 60.3 12 56.8c-6.4-12.5-.8-29.4 2.3-34.1S29.4 7.5 44.4 13c.2-.1 27.5-2.4 76-2.4 74.4 0 105.2.8 107.6 22.3 6 2.4 13.2 13 6.2 21 4.8 9.4.1 19.1-9.7 21.5a37.4 37.4 0 0 1 10.7 5.7c1.4-2.5 8.5-19.8 4.8-41.9-4.5-27.1-17.9-33.2-35.4-34.9C157.9 0 88.5.2 81.7.1 38.1-.3 18.2-.5 8.1 22.2-3.1 47.6-2.6 91.7 9.1 108c7.7 10.7 19.1 15.3 37.9 15.3 34.5 0 141.3 1.4 165.3 1.8 11-.3 27.9-3.4 29.3-19.7s-6.8-25.2-25.1-29.2z\"/><path class=\"b\" d=\"M202.7 88.6c1.3-.2 6.5-2 10.7-12.6-3-.2-6.3-.5-10.1-1.1.8 11.4-3 14-.6 13.7z\"/><path class=\"b\" d=\"M231.9 56c-7.6 5.5-18.2 1.8-19.8-3.4-2.6-8.6 4.4-10.9 6.7-10.6 7.7.8 7 6.1 4 8.1a1.5 1.5 0 0 1-1.9-2.4c1.8-1.3 0-2.8-2.1-2.7s-5.4 1-3.8 6.7 17.1 7.3 18.9-4.4c1-6.8-5.8-16.4-32.5-15.4a108.5 108.5 0 0 0-30.4 5.2c1.2 8.3-1.9 15.7-8.5 20.1-5.3 11.2-41.6 17.9-48.4-2.7-7.5.8-13.1 10-13.9 14.9a1.4 1.4 0 0 1-1.6 1.2c-6.5-.7-16.7 3.6-17.9 20-1.3 18.3 14.9 29.2 31.7 25.4a21.7 21.7 0 0 1-5-3.5c-5.7-.2-13.7-1.1-17.4-12.1-.6-1.7 2.1-3.2 2.9-.9 2.5 7.8 8.3 9.6 11.8 10a23.3 23.3 0 0 1-4.4-13.3c-.1-2.5 3-2 3-.2-.1 12.3 14.5 29.4 42 13 33.9-20.2 50.8-8.1 55.8-5 1.4.9 9.2 5.2 13.7.1 1.8-2 4.1-10.3-6.4-14.9-4.2 3.7-11.5 3.3-8.9-3-32.1-5.7-50.2 2.7-61.8 10.2s-16.4.3-17-2.5c-1.8-8.4 16.6-26.2 60.2-24.6 1.3-3.9 5.3-5.7 8.1.6 7.4.6 18 3.2 28.9 3.2s18.2-5.3 14-17.1z\"/><path class=\"b\" d=\"M176 81.3l3.8-9.1a107.7 107.7 0 0 0-23.6 1.6c-1.1 15.7-9.6 10.9-13.8 3.6-27.3 10.6-19.1 22.7-10.5 18.6-1.6-15.7 6-15 12.5-7a77.4 77.4 0 0 1 15.1-5.4c1.4-15.6 10-9.6 13.3-2.1zM65.8 101.1c5.2-.4 1.4-10.4 17-26.2 13.1-13.2-7.9-26.6-17.9-13s-4.4 39.6.9 39.2z\"/><path class=\"b\" d=\"M49.8 63.9c-4.7 6.2-6.6 20.2-2.4 30.6 2.9 7 6.9-1.5 9.3-5.4-1.2-8.8 0-20.5 5.2-28.1-5.6-3.5-10.1.3-12.1 2.9zM32.3 74.3c-2.4 10.4-.6 17.3 2.6 18.1s4.7-5.4 7.3-7.6c-.6-7.7.9-15.8 4.2-21.2-8.7-3.1-12.8 5.3-14.1 10.7z\"/><path class=\"b\" d=\"M12.2 39.9c-1.8 22.1 15.2 28 18.9 28.5 1.7-3.6 6.8-11.4 17.2-7.3 5.5-6.4 12-4.8 15.5-2.5C73.9 48.2 92 53.8 89.6 69.3a16.6 16.6 0 0 1 7.9-1.7c1.7-5.9 7.7-14.9 15.9-16.1a18.6 18.6 0 0 1 5.1-15.2c-4 1.6-20.6 10.6-28.1 12.3-1.4.3-2.4-2.4-.3-3 9.3-2.5 26.9-13.5 42.8-17.6 19.5-5.2 34.5 6.7 32.1 22.8 10.1-14.5-5.4-34.6-20.7-36.4-33.4-4.1-53.3 26.5-98.8 28.9-7 .4-11.9-2-13.7-6s-.9-9 3.7-10.6c2.1-.7 3.5 2.3 1.1 2.8s-4.9 9.2 4.8 10.7c12.7 2 14.5-14.3 7.3-21.2s-34-9.4-36.5 20.9zM108.8 156a30.1 30.1 0 0 1 6.8 8.2 45.5 45.5 0 0 1 2-10.6 17.4 17.4 0 0 1-5-5.7 47.5 47.5 0 0 0-3.8 8.1zM40.3 152.4c7.2.6 18.4-6.1 19.7-17.7-20.3-.3-20.5 13-19.7 17.7zM105.5 182.8c-9.5-20.1-30.2-13.6-46.7-2.2-14.8 10.3-29.4 7.7-35.8.1a31.5 31.5 0 0 1-4.6-32.4C5 168 14.6 187.8 24.8 193.5c18.7 10.5 37.8-5 41.6-8.5 12.4-11.2 28.8-11.8 33.4 2.2 4 12.2-7.6 21.6-15.9 18.1-10.7-4.4-6.4-13.5-3.1-15.1a7.4 7.4 0 0 1 8.7 1.9c1.2 1.3-.5 3.6-2.1 2.1s-3.5-2.1-5.1-1.3-4.3 7.6 2.6 9.6c8.9 2.6 14.7-7.1 12-14.4-3.9-10.7-15.2-8.9-19.9-6.6-14.5 7.2-12.8 30 6 30.7 23.2.9 27-19.8 22.5-29.4zM188.4 159.2c11.6 4.5 18.7-15.8 11.7-23.9-4.2 7.6-13.1 10.2-11.7 23.9z\"/><path class=\"b\" d=\"M191.9 172.1c-15.6-.4-20.8-23.1-41.9-20.9-24 2.5-24.8 45.6-13.1 57.6h3.1c-4.1-9.4-6.7-28.1 7.8-38.2 1.7-1.1 3.6 1.3 1.7 2.5-13.6 9.4-10.2 27.6-6.2 35.7h3.5c-4.2-8.4-3.6-21.3 2.4-27.3 18.5-18.3 44.9 16.4 57.1-.5 8-11.1 12.7-17.8 26.8-16.9a13.3 13.3 0 0 0-7-4c-19.7-4.1-20.7 12.4-34.2 12z\"/><path class=\"b\" d=\"M208.6 182.8c-13.7 18.8-40.7-15.8-57.2.7-5.4 5.4-5.6 18-1.2 25.1h6.1c-2-5.6.6-12.1 3.8-14.9 17.6-15 37.6 17.6 54.2-7.3 1-1.5 8.3-14.5 13.9-19.3-10.5.6-14.4 8.6-19.6 15.7z\"/><path class=\"b\" d=\"M238.8 151.3c-4-14.1-13.7-23-25.3-23.2-.3 0-120-1.8-163.5-1.8-40.8 0-44.9 21.4-47.3 34.2-3.8 20.4 3.9 40.1 8.9 46.1 9.4 11.4 25.3 13.6 48 13.6l128.4-.3c35.9 0 44.8-12.6 48.4-23.6 4.7-14 5.7-33.3 2.4-45zm-1.3 15.2c-1.5 1.5-3.3-.7-6.8 2.3.1 26.5-6.3 35.4-19 38.4-16.1 3.8-43.4 4.7-112.7 4.4-5.8 3.8-19.8 6.6-29-1.2-23.1.7-48.8.4-51.7-18.1-4.9-4.8-12.3-15.9-8.2-33.2 5.2-21.3 22.1-24.3 34.6-23.9 4.2-2.6 10-3.9 17-3.4 2 .2 1.4 2.5 1.3 3l59.3.8c.1-2-.9-2.5.1-3.9s8.9 1.7 11.8 4.1l61.1 1c4.2-4.3 3.6-10 9.2 0 12.4.9 25 4.3 26.3 21.8 3.7 1.8 8.1 6.4 6.7 7.9z\"/><path class=\"b\" d=\"M166.6 208.3l15.1-.6c-3.8-8.4-15.4-10.2-15.1.6zM113.3 166.2c-11.1-19.9-33.8-15.2-46.1-8.3-16.4 9.1-28.6 15.1-37.4 5.6-5.7-6.1-4.3-16.7-.5-23.4-12.8 6.6-13.3 28.1-4 38.6 5.7 6.5 18.5 8.7 31.8-.5 16.2-11.4 36.6-18.1 48.8-1.1 5.5 7.7 6.4 22.9-3 31.6h7.1c8-7 11.2-28.4 3.3-42.5z\"/><path class=\"b\" d=\"M137.7 153.6c1.7-13.2-7.4-17.4-12.4-18.8 1.6 11.6-8 17-6.8 36 4.6 13.7 2 29.9-4.4 38h19c-8.6-12.6-10-41.8 4.6-55.2z\"/></svg>`\nSplashScreen.SVG_TEXT = `<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 228.9 29\"><defs><style>.a{fill:#f5f5f5}</style></defs><path class=\"a\" d=\"M9.7 19a3.7 3.7 0 0 1 2.9 1.4 6 6 0 0 1 .9 3.6 4.6 4.6 0 0 1-1.4 3.8c-.9.7-2.5 1-4.7 1L0 28.7V10.1l6.6-.2a9.4 9.4 0 0 1 4.9 1c.9.7 1.4 2 1.4 3.9a5.1 5.1 0 0 1-.7 3A3.3 3.3 0 0 1 9.7 19zm-6.4-1.1h3.4a3.3 3.3 0 0 0 2.3-.6 2.5 2.5 0 0 0 .7-2.1 2.9 2.9 0 0 0-.7-2.1 5.1 5.1 0 0 0-2.6-.5H3.3zm0 8.3h3.5a3.9 3.9 0 0 0 2.6-.6c.5-.3.7-1.1.7-2.2a3 3 0 0 0-.7-2.4 3.8 3.8 0 0 0-2.7-.7H3.3zM22.9 10.1v14.3a2.1 2.1 0 0 0 .3 1.2 2.3 2.3 0 0 0 1.3.3h6.4l.2 2.6c-1.8.2-4.3.2-7.4.2s-4.2-1.2-4.2-3.8V10.1zM46.2 23.4h-6.9l-1.5 5.3h-3.5L39.9 11a1.2 1.2 0 0 1 1.2-.9h3.3a1.2 1.2 0 0 1 1.2.9l5.6 17.7h-3.5zm-.8-2.7l-1.9-6.4c-.2-1-.4-1.5-.4-1.6h-.7l-.4 1.6-1.9 6.4zM68.2 25.8l.3 2.5a18.5 18.5 0 0 1-5.7.7c-2.8 0-4.7-.7-5.8-2.1s-1.7-4-1.7-7.5.5-6 1.7-7.4 3-2.2 5.8-2.2a19.8 19.8 0 0 1 5.3.6l-.3 2.6a39.4 39.4 0 0 0-5-.2c-1.5 0-2.6.4-3.1 1.4s-.9 2.7-.9 5.2.3 4.3.9 5.2a3.2 3.2 0 0 0 3.1 1.5 37.5 37.5 0 0 0 5.4-.3zM79.1 20.3h-1.8a11.1 11.1 0 0 1 .2 1.9v6.5h-3.4V10.1h3.4v5.5a12.5 12.5 0 0 1-.2 2.1h1.8l5.1-7.6h3.7l-5 7.5a4.3 4.3 0 0 1-1.3 1.4 4.5 4.5 0 0 1 1.5 1.6l5.1 8h-3.7zM100 21.4l-3.8-1.2a5.1 5.1 0 0 1-2.8-2 5.9 5.9 0 0 1-.9-3.4c0-2 .5-3.4 1.4-4s2.6-1 5-1a24 24 0 0 1 5.8.6l-.2 2.4H99a4.7 4.7 0 0 0-2.5.4c-.4.2-.6.8-.6 1.7a2.5 2.5 0 0 0 .4 1.7 3.8 3.8 0 0 0 1.7.8l3.5 1.1a5.3 5.3 0 0 1 3 2 5.9 5.9 0 0 1 .9 3.4c0 2.1-.5 3.4-1.5 4.2s-2.7 1-5.1 1a30.8 30.8 0 0 1-6.1-.6L93 26l5.8.2a4.4 4.4 0 0 0 2.5-.5 2.2 2.2 0 0 0 .6-1.8 2.2 2.2 0 0 0-.4-1.6 3.5 3.5 0 0 0-1.5-.9zM126 10.1h3.5a1.2 1.2 0 0 1 1.3 1.4l.8 17.2h-3.3l-.7-15.8h-.5l-3.2 12.3a1.3 1.3 0 0 1-1.4 1.1H120a1.4 1.4 0 0 1-1.5-1.1l-3.2-12.3h-.5l-.6 15.8h-3.3l.7-17.2c.1-.9.5-1.4 1.4-1.4h3.5a1.2 1.2 0 0 1 1.3 1.2l2.7 10 .5 2.6h.4a26.1 26.1 0 0 1 .6-2.6l2.6-10a1.4 1.4 0 0 1 1.4-1.2zM141.4 28.7H138V10.1h3.4zM161.5 13h-5.7v15.7h-3.4V13h-5.7v-2.9h14.8zM180.9 10.1v18.6h-3.4v-8.5h-7.3v8.5h-3.4V10.1h3.4v7.3h7.3v-7.3zM196 13.1l-.2-2.6a24.4 24.4 0 0 1 5.9-.7 8.9 8.9 0 0 1 4.5.9 3.5 3.5 0 0 1 1.5 3.3 6.4 6.4 0 0 1-.7 3.1 13.3 13.3 0 0 1-2.4 3.3l-4.9 5.3 2.8-.2h5.8v3.2h-12.7v-2a2 2 0 0 1 .5-1.4l4.9-5.4c2.2-2.4 3.3-4.2 3.3-5.6a1.3 1.3 0 0 0-.7-1.3 5.7 5.7 0 0 0-2.2-.3 52.9 52.9 0 0 0-5.4.4zM214.3 28.7V10.1l7-.2c2.8 0 4.8.7 5.9 2.1s1.7 3.8 1.7 7.4-.6 6.1-1.7 7.5-3.1 2-5.9 2-4.5 0-7-.2zm3.4-16v13.4h3.6a3.6 3.6 0 0 0 3.2-1.4 12.6 12.6 0 0 0 .8-5.3c0-2.5-.3-4.3-.9-5.3a3.3 3.3 0 0 0-3.1-1.4h-3.6zM.1 8.1v-8h2.7a2.9 2.9 0 0 1 2.1.5 3 3 0 0 1 .5 2 2.9 2.9 0 0 1-.5 1.9 2.5 2.5 0 0 1-1.9.6H1.2v3zm1.1-4h1.6a1.6 1.6 0 0 0 1.1-.3 2.1 2.1 0 0 0 .3-1.2 2.3 2.3 0 0 0-.3-1.3A1.6 1.6 0 0 0 2.8 1H1.2zM9.7 0a3 3 0 0 1 2.5.9 5.2 5.2 0 0 1 .7 3.2 5 5 0 0 1-.7 3.2 3 3 0 0 1-2.5.9 2.8 2.8 0 0 1-2.4-.9 5 5 0 0 1-.7-3.2A5.2 5.2 0 0 1 7.3.9 2.8 2.8 0 0 1 9.7 0zm1.6 1.7A1.7 1.7 0 0 0 9.7 1a1.6 1.6 0 0 0-1.5.7 4.5 4.5 0 0 0-.4 2.4 4.5 4.5 0 0 0 .4 2.4 1.6 1.6 0 0 0 1.5.7 1.7 1.7 0 0 0 1.6-.7 4.5 4.5 0 0 0 .4-2.4 4.5 4.5 0 0 0-.4-2.4zM24.2.1l-1.6 7.6a.4.4 0 0 1-.4.4h-1.3a.4.4 0 0 1-.4-.4l-1.2-5.8a3.4 3.4 0 0 1-.1-.9h-.3l-.2.9-1.1 5.8V8h-1.7c-.3 0-.4-.1-.5-.4L13.9.1h1.2l1.2 6.1a5.1 5.1 0 0 0 .1 1h.3c0-.3.1-.7.1-1L18 .5a.4.4 0 0 1 .4-.4h1.3a.2.2 0 0 1 .2.2.2.2 0 0 1 .2.2l1.1 5.7c.1.3.1.6.2 1h.3v-.5a1.1 1.1 0 0 0 .1-.5L22.9.1zM30.3 7.1V8H27a1.6 1.6 0 0 1-1.2-.4 1.2 1.2 0 0 1-.4-1v-5a1.4 1.4 0 0 1 .4-1.1A2.1 2.1 0 0 1 27 .1h3.4V1h-3.2l-.5.2a.7.7 0 0 0-.1.5v1.7h3.3v1h-3.3v2a1.1 1.1 0 0 0 .1.6h3.6zM37.6 8.1h-1.2l-.7-2.5a1.1 1.1 0 0 0-1-.8h-1.6v3.3h-1.2v-8h2.8a3.4 3.4 0 0 1 2 .5 2.4 2.4 0 0 1 .6 1.8 2.8 2.8 0 0 1-.3 1.4 2 2 0 0 1-1.2.6 1.4 1.4 0 0 1 1 1.2zm-4.5-4.3h1.6a1.6 1.6 0 0 0 1.1-.3 1.4 1.4 0 0 0 .3-1.1 1.6 1.6 0 0 0-.3-1.1 1.6 1.6 0 0 0-1.1-.3h-1.6zM43.9 7.1V8h-3.3a1.6 1.6 0 0 1-1.2-.4 1.2 1.2 0 0 1-.4-1v-5a1.4 1.4 0 0 1 .4-1.1 2.1 2.1 0 0 1 1.2-.4H44V1h-3.2a.6.6 0 0 0-.5.2.8.8 0 0 0-.2.5v1.7h3.4v1h-3.4v2a1.1 1.1 0 0 0 .2.6h3.6zM45.5 8.1v-8h2.9a3 3 0 0 1 2.4.9 5.2 5.2 0 0 1 .7 3.2 5.2 5.2 0 0 1-.7 3.2 3 3 0 0 1-2.4.9zm1.1-7v6h1.8a1.6 1.6 0 0 0 1.5-.7 5.7 5.7 0 0 0 .4-2.4 6.5 6.5 0 0 0-.4-2.4 1.8 1.8 0 0 0-1.5-.6h-1.8zM59.6 3.9a1.5 1.5 0 0 1 1.3.6 2.8 2.8 0 0 1 .3 1.5 2.2 2.2 0 0 1-.5 1.6 3.4 3.4 0 0 1-2 .5h-3v-8h2.6a3.7 3.7 0 0 1 2.1.4 1.8 1.8 0 0 1 .6 1.6 2.3 2.3 0 0 1-.3 1.3 1.4 1.4 0 0 1-1.1.5zm-2.8-.4h1.6a2.9 2.9 0 0 0 1.2-.2 1.3 1.3 0 0 0 .3-1c0-.5-.1-.9-.4-1a1.7 1.7 0 0 0-1.2-.3h-1.5zm0 3.7h1.7a1.7 1.7 0 0 0 1.2-.3c.3-.1.4-.5.4-1a1.7 1.7 0 0 0-.4-1.2 1.9 1.9 0 0 0-1.3-.3h-1.6zM65.6 5.3v2.8h-1.1V5.3L61.8.1h1.3l1.6 3.3a4.2 4.2 0 0 0 .3.9h.1a8.5 8.5 0 0 1 .3-.9L67 .1h1.2z\"/></svg>`\n// @endif\n","/**\n * Timer component.\n *\n * @cat timers\n *\n * @fires Timer#complete\n * @fires Timer#tick\n *\n * @extends Component\n */\nexport \nclass Timer extends Component {\n  constructor(interval = 1, ticksCount = 1, startOnAdded = true) {\n    super()\n\n    Debug.assert(interval > 0, 'the interval value must be greater than 0')\n    Debug.assert(ticksCount > 0, 'the ticksCount value must be greater than 0')\n\n    /** @private @type {boolean} */\n    this.mStartOnAdded = startOnAdded\n\n    /** @private @type {number} */\n    this.mInterval = interval\n\n    /** @private @type {number} */\n    this.mTicksCount = ticksCount\n\n    /** @private @type {boolean} */\n    this.mIsRunning = false\n\n    /** @private @type {number} */\n    this.mTick = 0\n\n    /** @private @type {number} */\n    this.mElapsedSeconds = 0\n\n    /** @private @type {number} */\n    this.mTotalElapsedSeconds = 0\n  }\n\n  /**\n   * @inheritDoc\n   */\n  onAdded() {\n    if (this.mStartOnAdded) this.start()\n  }\n\n  /**\n   * @inheritDoc\n   */\n  onUpdate() {\n    if (this.mIsRunning === false) return\n\n    this.mElapsedSeconds += Time.delta\n    this.mTotalElapsedSeconds += Time.delta\n\n    if (this.mElapsedSeconds >= this.mInterval) {\n      this.mElapsedSeconds = 0\n\n      const ticksPerUpdate = Math.max(1, ~~(Time.delta / this.mInterval))\n      for (let i = 0; i < ticksPerUpdate; i++) {\n        this.mTick++\n\n        /**\n         * Posted on every timer tick.\n         * @event Timer#tick\n         */\n        this.post('tick', this.mTick)\n\n        if (this.mTick >= this.mTicksCount) {\n          this.mIsRunning = false\n\n          /**\n           * Posted on timer complete.\n           * @event Timer#complete\n           */\n          this.post('complete')\n          return\n        }\n      }\n    }\n  }\n\n  /**\n   * Start timer.\n   *\n   * @return {Timer} Returns this.\n   */\n  start() {\n    this.mIsRunning = true\n    return this\n  }\n\n  /**\n   * Stop and reset timer.\n   *\n   * @return {Timer} Returns this.\n   */\n  stop() {\n    this.mIsRunning = false\n    this.reset()\n    return this\n  }\n\n  /**\n   * Pauses the timer.\n   *\n   * @return {Timer} Returns this.\n   */\n  pause() {\n    this.mIsRunning = false\n    return this\n  }\n\n  /**\n   * Reset timer.\n   *\n   * sets ticks elapsedSeconds and totalElapsedSeconds to 0\n   * @return {Timer} Returns this.\n   */\n  reset() {\n    this.mTick = 0\n    this.mElapsedSeconds = 0\n    this.mTotalElapsedSeconds = 0\n    return this\n  }\n\n  /** How many ticks left.\n   *\n   * @return {number} Returns this.\n   */\n  get ticksLeft() {\n    return this.mTicksCount - this.mTick\n  }\n\n  /** current tick index.\n   *\n   * @return {number} Returns this.\n   */\n  get currentTick() {\n    return this.mTick\n  }\n\n  /**\n   * elapsed seconds from previous tick.\n   *\n   * @return {number}\n   */\n  get elapsedSeconds() {\n    return this.mElapsedSeconds\n  }\n\n  /** how many seconds left to the next tick.\n   *\n   * @return {number} Returns this.\n   */\n  get secondsToNextTick() {\n    return this.mInterval - this.mElapsedSeconds\n  }\n\n  /** If the timer is running, returns true, otherwise false.\n   *\n   * @return {boolean} Returns this.\n   */\n  get isRunning() {\n    return this.mIsRunning === true\n  }\n\n  /** If the number of ticks is less than the specified number, returns false, otherwise true.\n   *\n   * @return {boolean} Returns this.\n   */\n  get isComplete() {\n    return this.mTick >= this.mTicksCount\n  }\n\n  /**\n   * Sets/Get the number of timer ticks.\n   *\n   * @return {number}\n   */\n  get ticksCount() {\n    return this.mTicksCount\n  }\n\n  /**\n   * @ignore\n   * @param {number} value\n   * @return {void}\n   */\n  set ticksCount(value) {\n    Debug.assert(value > 0, 'the ticksCount value must be greater than 0')\n    this.mTicksCount = value\n  }\n\n  /**\n   * Sets/Get the timer interval in seconds.\n   *\n   * @return {number}\n   */\n  get interval() {\n    return this.mInterval\n  }\n\n  /**\n   * @ignore\n   * @param {number} value\n   * @return {void}\n   */\n  set interval(value) {\n    Debug.assert(value > 0, 'the interval value must be greater than 0')\n    this.mInterval = value\n  }\n\n  /**\n   * total elapsed seconds.\n   *\n   * @return {number}\n   */\n  get totalElapsedSeconds() {\n    return this.mTotalElapsedSeconds\n  }\n\n  /**\n   * Sets/Gets whether the timer should start automatically when added to the root.\n   *\n   * @return {boolean}\n   */\n  get startOnAdded() {\n    return this.mStartOnAdded\n  }\n\n  /**\n   * @ignore\n   * @param {boolean} value\n   * @return {void}\n   */\n  set startOnAdded(value) {\n    this.mStartOnAdded = value\n  }\n}\n","/**\n * The Black class represents the core of the Black Engine.\n *\n * @fires Black#paused\n * @fires Black#unpaused\n * @fires Black#ready\n * @fires Black#looped\n *\n * @export\n * @extends MessageDispatcher\n */\nexport \nclass Black extends MessageDispatcher {\n  /**\n   * Creates a new Black instance.\n   *\n   * First parameter has to be a id of the HTML div element the game will be rendered to.\n   * Second parameter has to be `GameObject` class which will be the root object of your application.\n   * Third parameter has to be a class name of `VideoNullDriver` subclass eg `CanvasDriver`.\n   * Fourth parameter is optional array of System to use,\n   *\n   * @example\n   * // Creates new Black instance with MyGame as a root class, CanvasDriver as renderer and Arcade physics as a system.\n   * new Black('game-container', MyGame, CanvasDriver, [Arcade]);\n   *\n   * @param {string}                                                       containerElementId The id of an DOM element.\n   * @param {function(new: GameObject)}                                    gameClass          Type name of an GameObject to start execution from.\n   * @param {function(new: VideoNullDriver, HTMLElement, number, number)}  videoDriverClass   Type name of an VideoDriver (VideoNullDriver, DOMDriver or CanvasDriver)\n   * @param {Array<function(new: System)>  }                               systemClasses      The list of systems to be initialized with Black engine.\n   */\n  constructor(\n    containerElementId,\n    gameClass,\n    videoDriverClass,\n    systemClasses = null\n  ) {\n    super()\n\n    Black.instance = this\n\n    console.log(\n      '%c                         >>> BLACK <<<                         ',\n      'background: #000; color: #fff;'\n    )\n\n    /** @private @type {string} */\n    this.mContainerElementId = containerElementId\n\n    /** @private @type {HTMLElement} */\n    this.mContainerElement = /** @type {!HTMLElement} */ (document.getElementById(\n      this.mContainerElementId\n    ))\n\n    if (!this.mContainerElement)\n      throw new Error('Container element was not found')\n\n    /** @private @type {function(new: VideoNullDriver, HTMLElement, number, number)} */\n    this.mVideoDriverClass = videoDriverClass\n\n    /** @private @type {Array<function(new: System)>} */\n    this.mSystemClasses = systemClasses\n\n    /** @private @type {number} */\n    this.mStageWidth = this.mContainerElement.clientWidth\n\n    /** @private @type {number} */\n    this.mStageHeight = this.mContainerElement.clientHeight\n\n    /** @private @type {number} */\n    this.mLastUpdateTime = 0\n\n    /** @private @type {number} */\n    this.mLastRenderTime = 0\n\n    /** @private @type {Array<System>} */\n    this.mSystems = []\n\n    /** @private @type {GameObject|null} */\n    this.mGameObject = null\n\n    /** @private @type {boolean} */\n    this.mIsRunning = false\n\n    /** @private @type {boolean} */\n    this.mIsStarted = false\n\n    /** @private @type {boolean} */\n    this.mIsPanic = false\n\n    /** @private @type {number} */\n    this.mRAFHandle = -1 // not sure\n\n    /** @private @type {Viewport} */\n    this.mViewport = null\n\n    /** @private @type {VideoNullDriver} */\n    this.mVideo = null\n\n    /** @private @type {boolean} */\n    this.mPaused = false\n\n    /** @private @type {boolean} */\n    this.mUnpausing = false\n\n    /** @private @type {boolean} */\n    this.mPauseOnHide = true\n\n    /** @private @type {boolean} */\n    this.mPauseOnBlur = true\n\n    /** @private @type {Object<string, Array>} */\n    this.mTagCache = {}\n\n    /** @private @type {function(new: GameObject)} */\n    this.mGameClass = gameClass\n\n    /** @private @type {GameObject|null} */\n    this.mGame = null\n\n    /** @private @type {Stage} */\n    this.mStage = null\n\n    /** @private @type {boolean} */\n    this.mWasStopped = false\n\n    /** @private @type {SplashScreen} */\n    this.mSplashScreen = new SplashScreen()\n\n    /** @private @type {Array<number>} */\n    this.mFrameTimes = []\n\n    /** @private @type {boolean} */\n    this.mUseHiDPR = Device.isMobile\n\n    this.__bootViewport()\n\n    this.__update = this.__update.bind(this)\n  }\n\n  /**\n   * Pauses all engine update logic. Note: RAF is not going to be paused and will work in background.\n   *\n   * @return {void}\n   */\n  pause() {\n    this.mPaused = true\n\n    /**\n     * Posted after engine entered paused state.\n     *\n     * @event Black#paused\n     */\n    this.post('paused')\n  }\n\n  /**\n   * Resumes update execution.\n   *\n   * @return {void}\n   */\n  resume() {\n    if (this.mPaused === true) this.mUnpausing = true\n  }\n\n  __setUnpaused() {\n    this.mPaused = false\n\n    /**\n     * Posted after engine is unpaused.\n     *\n     * @event Black#unpaused\n     */\n    this.post('unpaused')\n  }\n\n  /**\n   * @private\n   * @returns {void}\n   */\n  __bootViewport() {\n    this.mViewport = new Viewport(this.mContainerElement)\n  }\n\n  /**\n   * @private\n   * @returns {void}\n   */\n  __bootSystems() {\n    if (this.mSystemClasses === null) return\n\n    for (let i = 0; i < this.mSystemClasses.length; i++)\n      this.__addSystem(new this.mSystemClasses[i]())\n  }\n\n  /**\n   * @private\n   * @returns {void}\n   */\n  __bootStage() {\n    this.mStage = new Stage()\n\n    window.onblur = event => this.__onVisibilityChange(event)\n    window.onfocus = event => this.__onVisibilityChange(event)\n    window.onpagehide = event => this.__onVisibilityChange(event)\n    window.onpageshow = event => this.__onVisibilityChange(event)\n\n    if (document.hidden && this.mPauseOnHide === true) this.pause()\n  }\n\n  /**\n   * @private\n   * @returns {void}\n   */\n  __onVisibilityChange(event) {\n    let type = event.type\n    if (type === 'blur' && this.mPauseOnBlur === true) this.pause()\n    else if (type === 'pagehide' && this.mPauseOnHide === true) this.pause()\n    else if (type === 'focus' || type === 'pageshow') {\n      if (document.hidden === false) this.resume()\n    }\n  }\n\n  /**\n   * Returns true if system exists.\n   *\n   * @param {Function} systemTypeName\n   */\n  hasSystem(systemTypeName) {\n    for (let i = 0; i < this.mSystems.length; i++) {\n      let c = this.mSystems[i]\n      if (c instanceof systemTypeName) return true\n    }\n\n    return false\n  }\n\n  /**\n   * @private\n   * @param  {System} system The System object you want to add.\n   * @return {System}\n   */\n  __addSystem(system) {\n    this.mSystems.push(system)\n    return system\n  }\n\n  /**\n   * Gets system by type.\n   *\n   * @param {Function} typeName The system type.\n   * @return {System|null} The `System` instance or null if not found.\n   */\n  getSystem(typeName) {\n    for (let i = 0; i < this.mSystems.length; i++) {\n      let s = this.mSystems[i]\n      if (s instanceof typeName) return s\n    }\n\n    return null\n  }\n\n  /**\n   * @private\n   * @returns {void}\n   */\n  __bootVideo() {\n    this.mVideo = new this.mVideoDriverClass(\n      this.mContainerElement,\n      this.mStageWidth,\n      this.mStageHeight\n    )\n  }\n\n  /**\n   * Boots up the engine!\n   *\n   * @return {void}\n   */\n  start() {\n    if (this.mWasStopped === true) {\n      Debug.error('Black engine cannot be re-started.')\n      return\n    }\n\n    Black.instance = this\n\n    if (this.mIsStarted === true) return\n\n    this.__bootSystems()\n    this.__bootStage()\n    this.__bootVideo()\n\n    this.mStage.__refresh()\n\n    /**\n     * Posted when all systems, stage and driver ready to be used.\n     *\n     * @event Black#ready\n     */\n    this.post(Message.READY)\n\n    this.mGameObject = new this.mGameClass()\n    this.mStage.addChild(this.mGameObject)\n\n    const self = this\n\n    this.mIsStarted = true\n    this.mVideo.start()\n\n    this.mRAFHandle = window.requestAnimationFrame(function(timestamp) {\n      // TODO: do first update here\n      self.mIsRunning = true\n\n      // show splash screen\n      if (SplashScreen.enabled === true) self.mSplashScreen.show()\n\n      self.mLastUpdateTime = timestamp\n      self.mLastRenderTime = self.mLastUpdateTime\n\n      // Start the main loop.\n      self.__update(timestamp, true)\n    })\n  }\n\n  /**\n   * Stops any executions, destroys resources and scene.\n   *\n   * @return {void}\n   */\n  stop() {\n    this.mIsStarted = false\n    this.mIsRunning = false\n    window.cancelAnimationFrame(this.mRAFHandle)\n\n    console.log(\n      '%c                        <<< BYE BYE >>>                        ',\n      'background: #000; color: #fff;'\n    )\n  }\n\n  /**\n   * @private\n   * @param {number} timestamp\n   * @param {boolean} forceUpdate\n   * @return {void}\n   */\n  __update(timestamp, forceUpdate) {\n    // Calculate FPS\n    if (this.mPaused === true && this.mUnpausing === true) {\n      this.mUnpausing = false\n\n      this.mLastUpdateTime = timestamp\n      this.mLastRenderTime = this.mLastUpdateTime\n\n      this.__setUnpaused()\n    }\n\n    this.mRAFHandle = window.requestAnimationFrame(\n      /** @type {function(number)} */ (this.__update)\n    )\n\n    if (this.mPaused === true) return\n\n    let numTicks = Math.floor(\n      (timestamp - this.mLastUpdateTime) / Time.mDeltaTimeMs\n    )\n\n    if (forceUpdate === true) numTicks = 1\n\n    if (numTicks > Black.maxUpdatesPerFrame) {\n      /**\n       * Posted when engine is not able to achieve desired amount of updates per second.\n       *\n       * Usually happens when user switches to another tab in browser or update logic is too heavy to be executed\n       * withing one update loop. Lowering `Black.ups` value can help if update is heavy.\n       * Increasing `Black.maxUpdatesPerFrame` can lead to dead lock.\n       *\n       * @event Black#looped\n       */\n      this.post('looped', numTicks)\n      Debug.warn(`Unable to catch up ${numTicks} update(s).`)\n\n      numTicks = Black.maxUpdatesPerFrame\n    }\n\n    Black.numUpdates = numTicks\n    for (let i = 0; i < numTicks; i++) {\n      Time.mActualTime += Time.delta\n      Time.mTime = Time.mActualTime\n      this.__internalUpdate()\n      this.__internalSystemPostUpdate()\n    }\n\n    for (let l = timestamp - Time.mDeltaTimeMs; this.mLastUpdateTime < l; )\n      this.mLastUpdateTime += Time.mDeltaTimeMs\n\n    if (numTicks === 0)\n      Time.mAlphaTime = (timestamp - this.mLastUpdateTime) / Time.mDeltaTimeMs\n    else Time.mAlphaTime = 0\n\n    Time.mTime =\n      Time.mActualTime +\n      (timestamp - this.mLastUpdateTime) * 0.001 * Time.mScale\n\n    this.__internalSystemRender()\n    this.mVideo.beginFrame()\n    this.mVideo.render(this.mStage)\n    this.mVideo.endFrame()\n\n    Black.__frameNum++\n\n    this.mIsPanic = false\n    Renderer.__dirty = false\n\n    this.mLastRenderTime = timestamp\n  }\n\n  /**\n   * @private\n   * @return {void}\n   */\n  __internalUpdate() {\n    this.mViewport.__update()\n\n    for (let i = 0; i < this.mSystems.length; i++) this.mSystems[i].onUpdate()\n\n    this.mStage.__update()\n  }\n\n  /**\n   * @private\n   * @return {void}\n   */\n  __internalSystemPostUpdate() {\n    for (let i = 0; i < this.mSystems.length; i++)\n      this.mSystems[i].onPostUpdate()\n  }\n\n  /**\n   * @private\n   * @return {void}\n   */\n  __internalSystemRender() {\n    for (let i = 0; i < this.mSystems.length; i++) this.mSystems[i].onRender()\n  }\n\n  /**\n   * Called when tag changed for specific `GameObject`.\n   *\n   * @protected\n   * @param {GameObject} child   A game object fired the event.\n   * @param {string|null} oldTag Old tag.\n   * @param {string|null} newTag New tag.\n   * @return {void}\n   */\n  onTagUpdated(child, oldTag, newTag) {\n    if (oldTag !== null) {\n      let arr = this.mTagCache[oldTag]\n      arr.splice(arr.indexOf(child), 1)\n\n      if (arr.length === 0) delete this.mTagCache[oldTag]\n    }\n\n    if (newTag !== null) {\n      if (this.mTagCache.hasOwnProperty(newTag) === false)\n        this.mTagCache[newTag] = []\n\n      this.mTagCache[newTag].push(child)\n    }\n  }\n\n  /**\n   * Called when specific game object is added to display list.\n   *\n   * @protected\n   * @param  {GameObject} child Instance of GameObject.\n   * @return {void}\n   */\n  onChildrenAdded(child) {\n    Renderer.__dirty = true\n\n    for (let i = 0; i < this.mSystems.length; i++)\n      this.mSystems[i].onChildrenAdded(child)\n\n    GameObject.forEach(child, x => {\n      if (x.mAdded === true) return\n\n      this.onTagUpdated(x, null, x.mTag)\n\n      x.mAdded = true\n      x.onAdded()\n\n      for (let i = 0; i < x.mComponents.length; i++) {\n        let c = x.mComponents[i]\n\n        if (c.mAdded === true) continue\n\n        c.mAdded = true\n        c.onAdded(x)\n      }\n    })\n  }\n\n  /**\n   * Called when specific game object is changed its index in display list.\n   *\n   * @protected\n   * @param {GameObject} child Instance of GameObject.\n   * @return {void}\n   */\n  onChildrenChanged(child) {\n    Renderer.__dirty = true\n\n    for (let i = 0; i < this.mSystems.length; i++)\n      this.mSystems[i].onChildrenChanged(child)\n  }\n\n  /**\n   * Called when specific game object is added to display list.\n   *\n   * @protected\n   * @param  {GameObject} child Instance of GameObject.\n   * @return {void}\n   */\n  onChildrenRemoved(child) {\n    Renderer.__dirty = true\n\n    for (let i = 0; i < this.mSystems.length; i++)\n      this.mSystems[i].onChildrenRemoved(child)\n\n    let forEach = (gameObject, action) => {\n      let cloned = gameObject.mChildren.slice()\n      action(gameObject)\n\n      for (let i = 0; i < cloned.length; i++) {\n        GameObject.forEach(cloned[i], action)\n      }\n    }\n\n    GameObject.forEach(child, x => {\n      if (x.mAdded === true) {\n        this.onTagUpdated(x, null, x.mTag)\n\n        x.mAdded = false\n        x.onRemoved()\n\n        for (let i = 0; i < x.mComponents.length; i++) {\n          let c = x.mComponents[i]\n\n          if (c.mAdded === false) continue\n\n          c.mAdded = false\n          c.onRemoved(x)\n        }\n      }\n    })\n  }\n\n  /**\n   * Called when specific component is added to GameObject instance.\n   *\n   * @protected\n   * @param  {GameObject} child Instance of GameObject.\n   * @param  {Component} component Instance of Component added to game object.\n   * @return {void}\n   */\n  onComponentAdded(child, component) {\n    Renderer.__dirty = true\n\n    for (let i = 0; i < this.mSystems.length; i++)\n      this.mSystems[i].onComponentAdded(child, component)\n\n    if (component.mAdded === true) return\n\n    component.mAdded = true\n    component.onAdded(child)\n  }\n\n  /**\n   * Called when specific component is removed from its owner.\n   *\n   * @protected\n   * @param  {GameObject} child Instance of GameObject.\n   * @param  {Component} component Instance of Component removed from game object.\n   * @return {void}\n   */\n  onComponentRemoved(child, component) {\n    Renderer.__dirty = true\n\n    for (let i = 0; i < this.mSystems.length; i++)\n      this.mSystems[i].onComponentRemoved(child, component)\n\n    if (component.mAdded === false) return\n\n    component.mAdded = false\n    component.onRemoved(child)\n  }\n\n  /**\n   * Gets/Sets the number of updates should be done per second.\n   *\n   * @return {number}\n   */\n  get ups() {\n    return Time.mDeltaTimeMs * 0.001\n  }\n\n  /**\n   * @ignore\n   * @param {number} value\n   * @return {void}\n   */\n  set ups(value) {\n    Debug.isNumber(value)\n    Debug.assert(value > 0)\n\n    Time.mDeltaTimeMs = 1000 / value\n    Time.mDeltaTime = Time.mDeltaTimeMs * 0.001\n  }\n\n  /**\n   * Returns the current viewport instance. Used to get size of a game screen, or listen for resize messages.\n   *\n   * @return {Viewport}\n   */\n  get viewport() {\n    return this.mViewport\n  }\n\n  /**\n   * Returns the DOM element the engine runs in.\n   *\n   * @return {Element}\n   */\n  get containerElement() {\n    return this.mContainerElement\n  }\n\n  /**\n   * Gets/Sets if engine should be automatically paused when window is hidden.\n   *\n   * @return {boolean}\n   */\n  get pauseOnHide() {\n    return this.mPauseOnHide\n  }\n\n  /**\n   * @ignore\n   * @param {boolean} value\n   * @return {void}\n   */\n  set pauseOnHide(value) {\n    this.mPauseOnHide = value\n  }\n\n  /**\n   * Gets/Sets if engine should be automatically paused when container element is blurred.\n   *\n   * @return {boolean}\n   */\n  get pauseOnBlur() {\n    return this.mPauseOnBlur\n  }\n\n  /**\n   * @ignore\n   * @param {boolean} value\n   * @return {void}\n   */\n  set pauseOnBlur(value) {\n    this.mPauseOnBlur = value\n  }\n\n  /**\n   * Returns True if engine is paused.\n   *\n   * @readonly\n   * @returns {boolean}\n   */\n  get isPaused() {\n    return this.mPaused\n  }\n\n  /**\n   * Returns current stage.\n   *\n   * @readonly\n   * @returns {Stage}\n   */\n  get stage() {\n    return this.mStage\n  }\n\n  /**\n   * Returns HTML container element id.\n   * @returns {string}\n   */\n  get containerElementId() {\n    return this.mContainerElementId\n  }\n\n  /**\n   * Returns currently active splash screen. Splash screen posts Message.COMPLETE message on hide.\n   *\n   * @returns {SplashScreen}\n   */\n  get splashScreen() {\n    return this.mSplashScreen\n  }\n\n  /**\n   * Gets/sets whenever driver should be created with high DPR support.\n   * NOTE: Cannot be changed at runtime.\n   *\n   * @returns {boolean}\n   */\n  get useHiDPR() {\n    return this.mUseHiDPR\n  }\n\n  /**\n   * @ignore\n   * @param {boolean} value\n   * @returns {void}\n   */\n  set useHiDPR(value) {\n    this.mUseHiDPR = value\n  }\n\n  /**\n   * `Black.magic`! Got it? Got it?!?! Same as `Math.random()` but much cooler.\n   *\n   * @readonly\n   * @returns {number}\n   */\n  static get magic() {\n    return Math.random()\n  }\n\n  /**\n   * Returns current video driver.\n   *\n   * @readonly\n   * @returns {VideoNullDriver}\n   */\n  static get driver() {\n    return Black.instance.mVideo\n  }\n\n  /**\n   * Returns current stage.\n   *\n   * @readonly\n   * @returns {Stage}\n   */\n  static get stage() {\n    return Black.instance.mStage\n  }\n\n  /**\n   * Returns number of frame since engine start.\n   *\n   * @readonly\n   * @returns {number}\n   */\n  static get frameNum() {\n    return Black.__frameNum\n  }\n}\n\n/**\n * @ignore\n * @type {number}\n * @private\n */\nBlack.__frameNum = 0\n\n/**\n * Reference to the current Black instance.\n * @type {Black}\n * @static\n */\nBlack.instance = null\n\n/**\n * Indicates how many updates will be done during this frame.\n *\n * @type {number}\n */\nBlack.numUpdates = 0\n\n/**\n * Limit for number of updates to be done per one RAF.\n * @public\n */\nBlack.maxUpdatesPerFrame = 60\n"]}